   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "objdef.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .comm bSyncSetByUser,1,1
  20              	 .comm sCycleDiag,2,4
  21              	 .comm sSyncManOutPar,68,4
  22              	 .comm sSyncManInPar,68,4
  23              	 .global sErrorSettings
  24              	 .section .data.sErrorSettings,"aw",%progbits
  25              	 .align 2
  28              	sErrorSettings:
  29 0000 0200     	 .short 2
  30 0002 0000     	 .space 2
  31 0004 01000000 	 .word 1
  32 0008 0400     	 .short 4
  33 000a 0000     	 .space 2
  34              	 .global aSubindexDesc
  35              	 .section .data.aSubindexDesc,"aw",%progbits
  36              	 .align 2
  39              	aSubindexDesc:
  40 0000 53756249 	 .ascii "SubIndex 000\000"
  40      6E646578 
  40      20303030 
  40      00
  41              	 .global cBitMask
  42 000d 000000   	 .section .rodata.cBitMask,"a",%progbits
  43              	 .align 2
  46              	cBitMask:
  47 0000 0000     	 .short 0
  48 0002 0100     	 .short 1
  49 0004 0300     	 .short 3
  50 0006 0700     	 .short 7
  51 0008 0F00     	 .short 15
  52 000a 1F00     	 .short 31
  53 000c 3F00     	 .short 63
  54 000e 7F00     	 .short 127
  55 0010 FF00     	 .short 255
  56 0012 FF01     	 .short 511
  57 0014 FF03     	 .short 1023
  58 0016 FF07     	 .short 2047
  59 0018 FF0F     	 .short 4095
  60 001a FF1F     	 .short 8191
  61 001c FF3F     	 .short 16383
  62 001e FF7F     	 .short 32767
  63              	 .section .text.OBJ_GetObjectHandle,"ax",%progbits
  64              	 .align 2
  65              	 .global OBJ_GetObjectHandle
  66              	 .thumb
  67              	 .thumb_func
  69              	OBJ_GetObjectHandle:
  70              	.LFB175:
  71              	 .file 1 "../SSC/Src/objdef.c"
   1:../SSC/Src/objdef.c **** /*
   2:../SSC/Src/objdef.c **** * This source file is part of the EtherCAT Slave Stack Code licensed by Beckhoff Automation GmbH & 
   3:../SSC/Src/objdef.c **** * The corresponding license agreement applies. This hint shall not be removed.
   4:../SSC/Src/objdef.c **** * https://www.beckhoff.com/media/downloads/slave-stack-code/ethercat_ssc_license.pdf
   5:../SSC/Src/objdef.c **** */
   6:../SSC/Src/objdef.c **** 
   7:../SSC/Src/objdef.c **** /**
   8:../SSC/Src/objdef.c **** \addtogroup CoE CAN Application Profile over EtherCAT
   9:../SSC/Src/objdef.c **** @{
  10:../SSC/Src/objdef.c **** */
  11:../SSC/Src/objdef.c **** 
  12:../SSC/Src/objdef.c **** /**
  13:../SSC/Src/objdef.c **** \file objdef.c
  14:../SSC/Src/objdef.c **** \author EthercatSSC@beckhoff.com
  15:../SSC/Src/objdef.c **** \brief Implementation
  16:../SSC/Src/objdef.c **** This file contains the object dictionary access functions
  17:../SSC/Src/objdef.c **** 
  18:../SSC/Src/objdef.c **** \version 5.13
  19:../SSC/Src/objdef.c **** 
  20:../SSC/Src/objdef.c **** <br>Changes to version V5.12:<br>
  21:../SSC/Src/objdef.c **** V5.13 COE1: handling objects with 255 entries<br>
  22:../SSC/Src/objdef.c **** V5.13 COE4: update default entry name handling in case of 16Bit characters, add CoE Read/write indi
  23:../SSC/Src/objdef.c **** V5.13 COE9: prevent compiler warning in get entry description if char is 8bit<br>
  24:../SSC/Src/objdef.c **** V5.13 TEST7: add entries with bit9-16 types<br>
  25:../SSC/Src/objdef.c **** <br>Changes to version V5.11:<br>
  26:../SSC/Src/objdef.c **** V5.12 COE10: update object entry string handling<br>
  27:../SSC/Src/objdef.c **** V5.12 COE3: update entry access right handling<br>
  28:../SSC/Src/objdef.c **** V5.12 COE6: handle get object length in case of an out of range subindex<br>
  29:../SSC/Src/objdef.c **** V5.12 COE7: in case of a padding entry SDO upload/download return Unsupported access<br>
  30:../SSC/Src/objdef.c **** V5.12 COE9: SDO download 0xF030.0 shall be 0 before writing entries 1..n<br>
  31:../SSC/Src/objdef.c **** V5.12 ECAT1: update SM Parameter measurement (based on the system time), enhancement for input only
  32:../SSC/Src/objdef.c **** V5.12 ECAT5: update Sync error counter/flag handling,check enum memory alignment depending on the p
  33:../SSC/Src/objdef.c **** <br>Changes to version V5.10.1:<br>
  34:../SSC/Src/objdef.c **** V5.11 DIAG4: change parameter handling in DIAG_CreateNewMessage()<br>
  35:../SSC/Src/objdef.c **** V5.11 ECAT: <br>
  36:../SSC/Src/objdef.c **** V5.11 ECAT10: change PROTO handling to prevent compiler errors<br>
  37:../SSC/Src/objdef.c **** V5.11 ESM7: "add Sync define for 0x22 (""SYNCTYPE_SM2_SYNCHRON""), support value 0x22 for 0x1C33.1 
  38:../SSC/Src/objdef.c **** V5.11 OBJ1: OBJ_GetEntryOffset: return offset 0 for si0 (always offset 16 was returned before)<br>
  39:../SSC/Src/objdef.c **** V5.11 SDO1: "Obj_Read/Obj_Write: Check if entries > 8bit has even word offset (otherwise ""unsuppor
  40:../SSC/Src/objdef.c **** V5.11 SDO2: Obj_Read/Obj_Write: Handle arrays (string, array of byte, ...) with an odd word length 
  41:../SSC/Src/objdef.c **** V5.11 SDO3: handle not word aligned enums<br>
  42:../SSC/Src/objdef.c **** V5.11 SDO5: add missing swapping on SI0 write access<br>
  43:../SSC/Src/objdef.c **** V5.11 SDO6: OBJ_GetDesc ensure that the default string is used if no string was found<br>
  44:../SSC/Src/objdef.c **** V5.11 SDO7: add missing value swapping if memory values are bitwise modified on object read/write a
  45:../SSC/Src/objdef.c **** V5.11 SDO9: "handle SDO access for entries which are not accessible (in case of SDO complete access
  46:../SSC/Src/objdef.c **** V5.11 TEST2: add test 0x300C object (entry bitlength > 65535)<br>
  47:../SSC/Src/objdef.c **** V5.11 TEST8: create diag message on SDO write access to 0x3002<br>
  48:../SSC/Src/objdef.c **** <br>Changes to version V5.01:<br>
  49:../SSC/Src/objdef.c **** V5.10 COE2: Change return value of Get ObjectSize to UINT32<br>
  50:../SSC/Src/objdef.c ****             Change object size to UINT32<br>
  51:../SSC/Src/objdef.c **** V5.10 ECAT11: Add define "USE_SINGLE_PDO_MAPPING_ENTRY_DESCR" (Only one entry description is requir
  52:../SSC/Src/objdef.c **** V5.10 ECAT13: Update Synchronisation handling (FreeRun,SM Sync, Sync0, Sync1)<br>
  53:../SSC/Src/objdef.c ****               Compare DC UINT configuration (by ESC Config data) vs. DC activation register setting
  54:../SSC/Src/objdef.c ****               Update 0x1C3x entries<br>
  55:../SSC/Src/objdef.c **** V5.10 ECAT3: Add new datatype handling (BITARRxx)<br>
  56:../SSC/Src/objdef.c ****              Use read/write macro to access STRING entries<br>
  57:../SSC/Src/objdef.c **** V5.10 SDO1: Handle access to enums on odd memory addresses (only for MBX_16BIT_ACCESS)<br>
  58:../SSC/Src/objdef.c **** V5.10 SDO2: Check for termination char in every substring<br>
  59:../SSC/Src/objdef.c **** V5.10 SDO5: Check also for PDO mapping object if the subindex 0 was set to 0 before the entries wil
  60:../SSC/Src/objdef.c **** V5.10 SDO9: SDO complete write access update buffer offset calculation in case of SI0 is readonly<b
  61:../SSC/Src/objdef.c **** V5.10 TEST2: Add 0x3004.14 (Access to this entry will always rejected with the code "cannot be acce
  62:../SSC/Src/objdef.c **** V5.10 TEST4: Add CoE test (0x2020.5) to return always max object data on complete access (not limit
  63:../SSC/Src/objdef.c **** <br>Changes to version V5.0:<br>
  64:../SSC/Src/objdef.c **** V5.01 COE2: Calculate the bit offset also for SI0 in case if an SDO download access.<br>
  65:../SSC/Src/objdef.c **** V5.01 SDO1: Update alignment entry handling.<br>
  66:../SSC/Src/objdef.c **** V5.01 SDO5: Update offset calculation in case of an not accessible entry<br>
  67:../SSC/Src/objdef.c **** V5.01 SDO7: Update object length calculation in case of an BitArray<br>
  68:../SSC/Src/objdef.c **** V5.01 TEST5: Add slave configuration object handling (0x8000, if test application is active)<br>
  69:../SSC/Src/objdef.c **** V5.01 TEST6: Add test to create dummy object dictionary.<br>
  70:../SSC/Src/objdef.c **** <br>Changes to version V4.40:<br>
  71:../SSC/Src/objdef.c **** V5.0 TEST1: Add test application.<br>
  72:../SSC/Src/objdef.c **** V5.0 COE3: Update OCTED_STRING and VISIBLE_STRING read/write.<br>
  73:../SSC/Src/objdef.c **** V5.0 COE5: Add BigEndian support for enum SDO read, handle complete access also for objects with al
  74:../SSC/Src/objdef.c **** V5.0 COE7: Support SDO Info entry name handling for 16Bit access<br>
  75:../SSC/Src/objdef.c **** V5.0 DIAG2: SDO Info request for diagnosis messages 0x10F3 SI5 or greater return always description
  76:../SSC/Src/objdef.c **** V5.0 COE2: Add plausibility check for PDO assign objects.<br>
  77:../SSC/Src/objdef.c **** V5.0 OBJ2: Support DWORD/WORD aligned object structures.<br>
  78:../SSC/Src/objdef.c **** V5.0 SDO7: Update SDO read/write for object(entries) less or equal 8Bit.<br>
  79:../SSC/Src/objdef.c **** <br>Changes to version V4.30:<br>
  80:../SSC/Src/objdef.c **** V4.40 DIAG1: Add diagnosis access functions<br>
  81:../SSC/Src/objdef.c **** V4.40 OBJ2: change counter variable to prevent deadlock caused by overrun (required if subindex0 is
  82:../SSC/Src/objdef.c **** V4.40 COE2: Prevent accessing empty object dictionary entry<br>
  83:../SSC/Src/objdef.c **** V4.40 COE3: Read whole object dictionary<br>
  84:../SSC/Src/objdef.c **** V4.40 COE1: Prototype of OBJ_GetObjectList() changed, set abort code if object dictionary is empty<
  85:../SSC/Src/objdef.c **** V4.30 OBJ 3: Object dictionary list handling<br>
  86:../SSC/Src/objdef.c **** V4.30 OBJ 2: fix SDO complete access bug<br>
  87:../SSC/Src/objdef.c **** V4.11 OBJ 1-3: OBJ_GetDesc() Now, subindex 0 instead of 0xFF is used to return the description of t
  88:../SSC/Src/objdef.c **** Subindex 0xFF could be used like a normal subindex.<br>
  89:../SSC/Src/objdef.c **** <br>Changes to version V4.08:<br>
  90:../SSC/Src/objdef.c **** V4.10 OBJ 1: calculate size of PdoObjectEntry Index 1 and not Index 0<br>
  91:../SSC/Src/objdef.c **** V4.10 OBJ 2: the pointer of the object dictionary will be get by a function (COE_GetObjectDictionar
  92:../SSC/Src/objdef.c **** <br>Changes to version V4.07:<br>
  93:../SSC/Src/objdef.c **** V4.08 OBJ 1: if subindex 0 is writable, the maximum subindex should be checked in an object specifi
  94:../SSC/Src/objdef.c ****              because for the PDO mapping and PDO assign the object shall only be written if subinde
  95:../SSC/Src/objdef.c **** <br>Changes to version V4.04:<br>
  96:../SSC/Src/objdef.c **** V4.04 OBJ 1: The loop in OBJ_GetObjectList was one subindex too low<br>
  97:../SSC/Src/objdef.c **** <br>Changes to version V4.03:<br>
  98:../SSC/Src/objdef.c **** V4.04 SDO 1: The SDO interface was changed in that way that a SDO response<br>
  99:../SSC/Src/objdef.c ****              could be sent by the application to a later time. In that case<br>
 100:../SSC/Src/objdef.c ****                  the functions OBJ_Read and OBJ_Write shall return the value<br>
 101:../SSC/Src/objdef.c ****                  ABORTIDX_WORKING. To send the SDO response the new function SDOS_SdoRes<br>
 102:../SSC/Src/objdef.c ****                  has to be called by the application. While waiting for the call<br>
 103:../SSC/Src/objdef.c ****                  of SDOS_SdoRes the SDO interface will answer to another SDO request<br>
 104:../SSC/Src/objdef.c ****                  with the error MBXERR_SERVICEINWORK in the mailbox protocol<br>
 105:../SSC/Src/objdef.c **** V4.04 OBJ 1: The loop in OBJ_GetNoOfObjects was one subindex too low<br>
 106:../SSC/Src/objdef.c **** <br>Changes to version V4.02:<br>
 107:../SSC/Src/objdef.c **** V4.03 OBJ 1: The object list was not returned correctly for the list types 2-5<br>
 108:../SSC/Src/objdef.c **** <br>Changes to version V3.20:<br>
 109:../SSC/Src/objdef.c **** V4.00 OBJ 1: The OBJ functions are modified for a more flexible definition of<br>
 110:../SSC/Src/objdef.c ****              the object dictionary and to support bit types too<br>
 111:../SSC/Src/objdef.c **** V4.00 SDO 2: The object lists will be generated in the functions OBJ_GetNoOfObjects<br>
 112:../SSC/Src/objdef.c ****              and OBJ_GetObjectList in objdef.c to decouple the SDO services from<br>
 113:../SSC/Src/objdef.c ****              the implementation of the object dictionary<br>
 114:../SSC/Src/objdef.c **** V4.00 COEAPPL 2: The handling of backup parameters was included according to<br>
 115:../SSC/Src/objdef.c ****                  the EtherCAT Guidelines and Protocol Enhancements Specification
 116:../SSC/Src/objdef.c **** 
 117:../SSC/Src/objdef.c **** */
 118:../SSC/Src/objdef.c **** 
 119:../SSC/Src/objdef.c **** 
 120:../SSC/Src/objdef.c **** #define    OBJDEF       0x4000
 121:../SSC/Src/objdef.c **** #define    OBJDEFMAX    0x0A
 122:../SSC/Src/objdef.c **** 
 123:../SSC/Src/objdef.c **** /*---------------------------------------------------------------------------------------
 124:../SSC/Src/objdef.c **** ------
 125:../SSC/Src/objdef.c **** ------    Includes
 126:../SSC/Src/objdef.c **** ------
 127:../SSC/Src/objdef.c **** ---------------------------------------------------------------------------------------*/
 128:../SSC/Src/objdef.c **** 
 129:../SSC/Src/objdef.c **** #include "ecat_def.h"
 130:../SSC/Src/objdef.c **** 
 131:../SSC/Src/objdef.c **** 
 132:../SSC/Src/objdef.c **** #include "ecatslv.h"
 133:../SSC/Src/objdef.c **** #include "coeappl.h"
 134:../SSC/Src/objdef.c **** 
 135:../SSC/Src/objdef.c **** 
 136:../SSC/Src/objdef.c **** #define  _OBJDEF_    1
 137:../SSC/Src/objdef.c **** #include "objdef.h"
 138:../SSC/Src/objdef.c **** #undef    _OBJDEF_
 139:../SSC/Src/objdef.c **** /*remove definition of _OBJDEF_ (#ifdef is used in objdef.h)*/
 140:../SSC/Src/objdef.c **** 
 141:../SSC/Src/objdef.c **** #include "applInterface.h"
 142:../SSC/Src/objdef.c **** 
 143:../SSC/Src/objdef.c **** 
 144:../SSC/Src/objdef.c **** 
 145:../SSC/Src/objdef.c **** 
 146:../SSC/Src/objdef.c **** 
 147:../SSC/Src/objdef.c **** 
 148:../SSC/Src/objdef.c **** extern OBJCONST TOBJECT OBJMEM *pSdoInfoObjEntry;
 149:../SSC/Src/objdef.c **** extern OBJCONST TSDOINFOENTRYDESC OBJMEM * OBJ_GetEntryDesc(OBJCONST TOBJECT OBJMEM * pObjEntry, UI
 150:../SSC/Src/objdef.c **** 
 151:../SSC/Src/objdef.c **** //---------------------------------------------------------------------------------------
 152:../SSC/Src/objdef.c **** 
 153:../SSC/Src/objdef.c **** /*---------------------------------------------------------------------------------------
 154:../SSC/Src/objdef.c **** ------
 155:../SSC/Src/objdef.c **** ------    Internal types and defines
 156:../SSC/Src/objdef.c **** ------
 157:../SSC/Src/objdef.c **** ---------------------------------------------------------------------------------------*/
 158:../SSC/Src/objdef.c **** 
 159:../SSC/Src/objdef.c **** /*---------------------------------------------------------------------------------------
 160:../SSC/Src/objdef.c **** ------
 161:../SSC/Src/objdef.c **** ------    module internal function declarations
 162:../SSC/Src/objdef.c **** ------
 163:../SSC/Src/objdef.c **** ---------------------------------------------------------------------------------------*/
 164:../SSC/Src/objdef.c **** 
 165:../SSC/Src/objdef.c **** /*---------------------------------------------------------------------------------------
 166:../SSC/Src/objdef.c **** ------
 167:../SSC/Src/objdef.c **** ------    Module internal variable definitions
 168:../SSC/Src/objdef.c **** ------
 169:../SSC/Src/objdef.c **** ---------------------------------------------------------------------------------------*/
 170:../SSC/Src/objdef.c **** const UINT16 cBitMask[16] = {0x0000,0x0001,0x0003,0x0007,0x000F,0x001F,0x003F,0x007F,0x00FF,0x01FF,
 171:../SSC/Src/objdef.c **** /*---------------------------------------------------------------------------------------
 172:../SSC/Src/objdef.c **** ------
 173:../SSC/Src/objdef.c **** ------    Functions
 174:../SSC/Src/objdef.c **** ------
 175:../SSC/Src/objdef.c **** ---------------------------------------------------------------------------------------*/
 176:../SSC/Src/objdef.c **** 
 177:../SSC/Src/objdef.c **** 
 178:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
 179:../SSC/Src/objdef.c **** /**
 180:../SSC/Src/objdef.c ****  \param     index     Indicates the index of the dictionary object.
 181:../SSC/Src/objdef.c **** 
 182:../SSC/Src/objdef.c ****  \return    A handle to an object of the requested index or NULL if not found.
 183:../SSC/Src/objdef.c **** 
 184:../SSC/Src/objdef.c ****  \brief    The function looks in all objects of the dictionary after the indicated index
 185:../SSC/Src/objdef.c ****              and returns a handle if found.
 186:../SSC/Src/objdef.c **** 
 187:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
 188:../SSC/Src/objdef.c **** 
 189:../SSC/Src/objdef.c **** OBJCONST TOBJECT OBJMEM *  OBJ_GetObjectHandle( UINT16 index )
 190:../SSC/Src/objdef.c **** {
  72              	 .loc 1 190 0
  73              	 .cfi_startproc
  74              	 
  75              	 
  76 0000 80B5     	 push {r7,lr}
  77              	.LCFI0:
  78              	 .cfi_def_cfa_offset 8
  79              	 .cfi_offset 7,-8
  80              	 .cfi_offset 14,-4
  81 0002 84B0     	 sub sp,sp,#16
  82              	.LCFI1:
  83              	 .cfi_def_cfa_offset 24
  84 0004 00AF     	 add r7,sp,#0
  85              	.LCFI2:
  86              	 .cfi_def_cfa_register 7
  87 0006 0346     	 mov r3,r0
  88 0008 FB80     	 strh r3,[r7,#6]
 191:../SSC/Src/objdef.c ****     OBJCONST TOBJECT OBJMEM * pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();
  89              	 .loc 1 191 0
  90 000a FFF7FEFF 	 bl COE_GetObjectDictionary
  91 000e F860     	 str r0,[r7,#12]
 192:../SSC/Src/objdef.c **** 
 193:../SSC/Src/objdef.c ****     while (pObjEntry!= NULL)
  92              	 .loc 1 193 0
  93 0010 09E0     	 b .L2
  94              	.L5:
 194:../SSC/Src/objdef.c ****     {
 195:../SSC/Src/objdef.c ****         
 196:../SSC/Src/objdef.c ****         if (pObjEntry->Index == index)
  95              	 .loc 1 196 0
  96 0012 FB68     	 ldr r3,[r7,#12]
  97 0014 1B89     	 ldrh r3,[r3,#8]
  98 0016 FA88     	 ldrh r2,[r7,#6]
  99 0018 9A42     	 cmp r2,r3
 100 001a 01D1     	 bne .L3
 197:../SSC/Src/objdef.c ****         {
 198:../SSC/Src/objdef.c ****             return pObjEntry;
 101              	 .loc 1 198 0
 102 001c FB68     	 ldr r3,[r7,#12]
 103 001e 06E0     	 b .L4
 104              	.L3:
 199:../SSC/Src/objdef.c ****         }
 200:../SSC/Src/objdef.c ****         pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
 105              	 .loc 1 200 0
 106 0020 FB68     	 ldr r3,[r7,#12]
 107 0022 5B68     	 ldr r3,[r3,#4]
 108 0024 FB60     	 str r3,[r7,#12]
 109              	.L2:
 193:../SSC/Src/objdef.c ****     {
 110              	 .loc 1 193 0
 111 0026 FB68     	 ldr r3,[r7,#12]
 112 0028 002B     	 cmp r3,#0
 113 002a F2D1     	 bne .L5
 201:../SSC/Src/objdef.c ****     }
 202:../SSC/Src/objdef.c ****     return 0;
 114              	 .loc 1 202 0
 115 002c 0023     	 movs r3,#0
 116              	.L4:
 203:../SSC/Src/objdef.c **** }
 117              	 .loc 1 203 0
 118 002e 1846     	 mov r0,r3
 119 0030 1037     	 adds r7,r7,#16
 120              	.LCFI3:
 121              	 .cfi_def_cfa_offset 8
 122 0032 BD46     	 mov sp,r7
 123              	.LCFI4:
 124              	 .cfi_def_cfa_register 13
 125              	 
 126 0034 80BD     	 pop {r7,pc}
 127              	 .cfi_endproc
 128              	.LFE175:
 130 0036 00BF     	 .section .text.OBJ_GetObjectLength,"ax",%progbits
 131              	 .align 2
 132              	 .global OBJ_GetObjectLength
 133              	 .thumb
 134              	 .thumb_func
 136              	OBJ_GetObjectLength:
 137              	.LFB176:
 204:../SSC/Src/objdef.c **** 
 205:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
 206:../SSC/Src/objdef.c **** /**
 207:../SSC/Src/objdef.c ****  \param     index           Index of the requested object.
 208:../SSC/Src/objdef.c ****  \param     subindex        Subindex of the requested object.
 209:../SSC/Src/objdef.c ****  \param     pObjEntry       Handle to the dictionary object returned by
 210:../SSC/Src/objdef.c ****                             OBJ_GetObjectHandle which was called before
 211:../SSC/Src/objdef.c ****  \param     bCompleteAccess Indicates if a complete read of all subindices of the
 212:../SSC/Src/objdef.c ****                             object shall be done or not
 213:../SSC/Src/objdef.c **** 
 214:../SSC/Src/objdef.c ****  \return    The size of the object entry in bytes (!).
 215:../SSC/Src/objdef.c **** 
 216:../SSC/Src/objdef.c ****  \brief     This function returns the size of the requested entry. If bCompleteaccess is set the si
 217:../SSC/Src/objdef.c **** 
 218:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
 219:../SSC/Src/objdef.c **** UINT32 OBJ_GetObjectLength( UINT16 index, UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT
 220:../SSC/Src/objdef.c **** {
 138              	 .loc 1 220 0
 139              	 .cfi_startproc
 140              	 
 141              	 
 142              	 
 143 0000 80B4     	 push {r7}
 144              	.LCFI5:
 145              	 .cfi_def_cfa_offset 4
 146              	 .cfi_offset 7,-4
 147 0002 85B0     	 sub sp,sp,#20
 148              	.LCFI6:
 149              	 .cfi_def_cfa_offset 24
 150 0004 00AF     	 add r7,sp,#0
 151              	.LCFI7:
 152              	 .cfi_def_cfa_register 7
 153 0006 3A60     	 str r2,[r7]
 154 0008 1A46     	 mov r2,r3
 155 000a 0346     	 mov r3,r0
 156 000c FB80     	 strh r3,[r7,#6]
 157 000e 0B46     	 mov r3,r1
 158 0010 7B71     	 strb r3,[r7,#5]
 159 0012 1346     	 mov r3,r2
 160 0014 3B71     	 strb r3,[r7,#4]
 221:../SSC/Src/objdef.c ****     /* get the information of ObjCode and MaxSubindex in local variables to support different types
 222:../SSC/Src/objdef.c ****     UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
 161              	 .loc 1 222 0
 162 0016 3B68     	 ldr r3,[r7]
 163 0018 9B89     	 ldrh r3,[r3,#12]
 164 001a 03F47063 	 and r3,r3,#3840
 165 001e 1B12     	 asrs r3,r3,#8
 166 0020 7B72     	 strb r3,[r7,#9]
 223:../SSC/Src/objdef.c ****     
 224:../SSC/Src/objdef.c ****     UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUB
 167              	 .loc 1 224 0
 168 0022 3B68     	 ldr r3,[r7]
 169 0024 9B89     	 ldrh r3,[r3,#12]
 170 0026 3B72     	 strb r3,[r7,#8]
 225:../SSC/Src/objdef.c ****     UINT32 size = 0;
 171              	 .loc 1 225 0
 172 0028 0023     	 movs r3,#0
 173 002a FB60     	 str r3,[r7,#12]
 226:../SSC/Src/objdef.c **** 
 227:../SSC/Src/objdef.c ****     if ( bCompleteAccess )
 174              	 .loc 1 227 0
 175 002c 3B79     	 ldrb r3,[r7,#4]
 176 002e 002B     	 cmp r3,#0
 177 0030 44D0     	 beq .L7
 228:../SSC/Src/objdef.c ****     {
 229:../SSC/Src/objdef.c ****         if ( objCode == OBJCODE_VAR )
 178              	 .loc 1 229 0
 179 0032 7B7A     	 ldrb r3,[r7,#9]
 180 0034 072B     	 cmp r3,#7
 181 0036 01D1     	 bne .L8
 230:../SSC/Src/objdef.c ****         {
 231:../SSC/Src/objdef.c ****             return 0;
 182              	 .loc 1 231 0
 183 0038 0023     	 movs r3,#0
 184 003a 68E0     	 b .L9
 185              	.L8:
 232:../SSC/Src/objdef.c ****         }
 233:../SSC/Src/objdef.c ****         else if ((objCode == OBJCODE_ARR)
 186              	 .loc 1 233 0
 187 003c 7B7A     	 ldrb r3,[r7,#9]
 188 003e 082B     	 cmp r3,#8
 189 0040 18D1     	 bne .L10
 234:../SSC/Src/objdef.c ****             )
 235:../SSC/Src/objdef.c ****         {
 236:../SSC/Src/objdef.c **** 
 237:../SSC/Src/objdef.c ****             /* we have to get the maxSubindex from the actual value of subindex 0,
 238:../SSC/Src/objdef.c ****                 which is stored as UINT16 at the beginning of the object's variable */
 239:../SSC/Src/objdef.c ****             maxSubindex = (UINT8) ((UINT16 MBXMEM *) (pObjEntry->pVarPtr))[0];
 190              	 .loc 1 239 0
 191 0042 3B68     	 ldr r3,[r7]
 192 0044 9B69     	 ldr r3,[r3,#24]
 193 0046 1B88     	 ldrh r3,[r3]
 194 0048 3B72     	 strb r3,[r7,#8]
 240:../SSC/Src/objdef.c **** 
 241:../SSC/Src/objdef.c **** 
 242:../SSC/Src/objdef.c ****             size = pObjEntry->pEntryDesc[1].BitLength *maxSubindex;
 195              	 .loc 1 242 0
 196 004a 3B68     	 ldr r3,[r7]
 197 004c 1B69     	 ldr r3,[r3,#16]
 198 004e 0633     	 adds r3,r3,#6
 199 0050 5B88     	 ldrh r3,[r3,#2]
 200 0052 1A46     	 mov r2,r3
 201 0054 3B7A     	 ldrb r3,[r7,#8]
 202 0056 03FB02F3 	 mul r3,r3,r2
 203 005a FB60     	 str r3,[r7,#12]
 243:../SSC/Src/objdef.c **** 
 244:../SSC/Src/objdef.c **** /* no padding required: Bit entries within an array object may overlap byte borders*/
 245:../SSC/Src/objdef.c **** 
 246:../SSC/Src/objdef.c ****             /* we have to convert the size in bytes */
 247:../SSC/Src/objdef.c ****             size = BIT2BYTE(size);
 204              	 .loc 1 247 0
 205 005c FB68     	 ldr r3,[r7,#12]
 206 005e 0733     	 adds r3,r3,#7
 207 0060 DB08     	 lsrs r3,r3,#3
 208 0062 FB60     	 str r3,[r7,#12]
 248:../SSC/Src/objdef.c **** 
 249:../SSC/Src/objdef.c ****             if ( subindex == 0 )
 209              	 .loc 1 249 0
 210 0064 7B79     	 ldrb r3,[r7,#5]
 211 0066 002B     	 cmp r3,#0
 212 0068 02D1     	 bne .L11
 250:../SSC/Src/objdef.c ****             {
 251:../SSC/Src/objdef.c ****                 /* add size for subindex 0 (is transmitted as UINT16) */
 252:../SSC/Src/objdef.c ****                 size += 2;
 213              	 .loc 1 252 0
 214 006a FB68     	 ldr r3,[r7,#12]
 215 006c 0233     	 adds r3,r3,#2
 216 006e FB60     	 str r3,[r7,#12]
 217              	.L11:
 253:../SSC/Src/objdef.c ****             }
 254:../SSC/Src/objdef.c ****             return size;
 218              	 .loc 1 254 0
 219 0070 FB68     	 ldr r3,[r7,#12]
 220 0072 4CE0     	 b .L9
 221              	.L10:
 222              	.LBB2:
 255:../SSC/Src/objdef.c ****         }
 256:../SSC/Src/objdef.c ****         else
 257:../SSC/Src/objdef.c ****         {
 258:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.13) COE1*/
 259:../SSC/Src/objdef.c ****             UINT16 i;
 260:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.13) COE1*/
 261:../SSC/Src/objdef.c **** 
 262:../SSC/Src/objdef.c ****             /* add the sizes of all entries */
 263:../SSC/Src/objdef.c ****             for (i = 1; i <= maxSubindex; i++)
 223              	 .loc 1 263 0
 224 0074 0123     	 movs r3,#1
 225 0076 7B81     	 strh r3,[r7,#10]
 226 0078 0FE0     	 b .L12
 227              	.L13:
 264:../SSC/Src/objdef.c ****             {
 265:../SSC/Src/objdef.c ****                 size += pObjEntry->pEntryDesc[i].BitLength;
 228              	 .loc 1 265 0 discriminator 3
 229 007a 3B68     	 ldr r3,[r7]
 230 007c 1969     	 ldr r1,[r3,#16]
 231 007e 7A89     	 ldrh r2,[r7,#10]
 232 0080 1346     	 mov r3,r2
 233 0082 5B00     	 lsls r3,r3,#1
 234 0084 1344     	 add r3,r3,r2
 235 0086 5B00     	 lsls r3,r3,#1
 236 0088 0B44     	 add r3,r3,r1
 237 008a 5B88     	 ldrh r3,[r3,#2]
 238 008c 1A46     	 mov r2,r3
 239 008e FB68     	 ldr r3,[r7,#12]
 240 0090 1344     	 add r3,r3,r2
 241 0092 FB60     	 str r3,[r7,#12]
 263:../SSC/Src/objdef.c ****             {
 242              	 .loc 1 263 0 discriminator 3
 243 0094 7B89     	 ldrh r3,[r7,#10]
 244 0096 0133     	 adds r3,r3,#1
 245 0098 7B81     	 strh r3,[r7,#10]
 246              	.L12:
 263:../SSC/Src/objdef.c ****             {
 247              	 .loc 1 263 0 is_stmt 0 discriminator 1
 248 009a 3B7A     	 ldrb r3,[r7,#8]
 249 009c 9BB2     	 uxth r3,r3
 250 009e 7A89     	 ldrh r2,[r7,#10]
 251 00a0 9A42     	 cmp r2,r3
 252 00a2 EAD9     	 bls .L13
 266:../SSC/Src/objdef.c ****             }
 267:../SSC/Src/objdef.c ****             /* we have to convert the size in bytes */
 268:../SSC/Src/objdef.c ****             size = BIT2BYTE(size);
 253              	 .loc 1 268 0 is_stmt 1
 254 00a4 FB68     	 ldr r3,[r7,#12]
 255 00a6 0733     	 adds r3,r3,#7
 256 00a8 DB08     	 lsrs r3,r3,#3
 257 00aa FB60     	 str r3,[r7,#12]
 269:../SSC/Src/objdef.c **** 
 270:../SSC/Src/objdef.c ****             if ( subindex == 0 )
 258              	 .loc 1 270 0
 259 00ac 7B79     	 ldrb r3,[r7,#5]
 260 00ae 002B     	 cmp r3,#0
 261 00b0 02D1     	 bne .L14
 271:../SSC/Src/objdef.c ****             {
 272:../SSC/Src/objdef.c ****                 /* add size for subindex 0 (is transmitted as UINT16) */
 273:../SSC/Src/objdef.c ****                 size += 2;
 262              	 .loc 1 273 0
 263 00b2 FB68     	 ldr r3,[r7,#12]
 264 00b4 0233     	 adds r3,r3,#2
 265 00b6 FB60     	 str r3,[r7,#12]
 266              	.L14:
 274:../SSC/Src/objdef.c ****             }
 275:../SSC/Src/objdef.c ****             return size;
 267              	 .loc 1 275 0
 268 00b8 FB68     	 ldr r3,[r7,#12]
 269 00ba 28E0     	 b .L9
 270              	.L7:
 271              	.LBE2:
 276:../SSC/Src/objdef.c ****         }
 277:../SSC/Src/objdef.c ****     }
 278:../SSC/Src/objdef.c ****     else
 279:../SSC/Src/objdef.c ****     {
 280:../SSC/Src/objdef.c ****         if ( objCode == OBJCODE_VAR )
 272              	 .loc 1 280 0
 273 00bc 7B7A     	 ldrb r3,[r7,#9]
 274 00be 072B     	 cmp r3,#7
 275 00c0 05D1     	 bne .L15
 281:../SSC/Src/objdef.c ****         {
 282:../SSC/Src/objdef.c **** 
 283:../SSC/Src/objdef.c ****             return (BIT2BYTE(pObjEntry->pEntryDesc->BitLength));
 276              	 .loc 1 283 0
 277 00c2 3B68     	 ldr r3,[r7]
 278 00c4 1B69     	 ldr r3,[r3,#16]
 279 00c6 5B88     	 ldrh r3,[r3,#2]
 280 00c8 0733     	 adds r3,r3,#7
 281 00ca DB10     	 asrs r3,r3,#3
 282 00cc 1FE0     	 b .L9
 283              	.L15:
 284:../SSC/Src/objdef.c **** 
 285:../SSC/Src/objdef.c ****         }
 286:../SSC/Src/objdef.c ****         else if ( subindex == 0 )
 284              	 .loc 1 286 0
 285 00ce 7B79     	 ldrb r3,[r7,#5]
 286 00d0 002B     	 cmp r3,#0
 287 00d2 01D1     	 bne .L16
 287:../SSC/Src/objdef.c ****         {
 288:../SSC/Src/objdef.c ****             /* for single access subindex 0 is transmitted as UINT8 */
 289:../SSC/Src/objdef.c ****             return 1;
 288              	 .loc 1 289 0
 289 00d4 0123     	 movs r3,#1
 290 00d6 1AE0     	 b .L9
 291              	.L16:
 290:../SSC/Src/objdef.c ****         }
 291:../SSC/Src/objdef.c ****         else if((objCode == OBJCODE_ARR)
 292              	 .loc 1 291 0
 293 00d8 7B7A     	 ldrb r3,[r7,#9]
 294 00da 082B     	 cmp r3,#8
 295 00dc 06D1     	 bne .L17
 292:../SSC/Src/objdef.c ****             )
 293:../SSC/Src/objdef.c ****         {
 294:../SSC/Src/objdef.c ****             return (BIT2BYTE(pObjEntry->pEntryDesc[1].BitLength));
 296              	 .loc 1 294 0
 297 00de 3B68     	 ldr r3,[r7]
 298 00e0 1B69     	 ldr r3,[r3,#16]
 299 00e2 0633     	 adds r3,r3,#6
 300 00e4 5B88     	 ldrh r3,[r3,#2]
 301 00e6 0733     	 adds r3,r3,#7
 302 00e8 DB10     	 asrs r3,r3,#3
 303 00ea 10E0     	 b .L9
 304              	.L17:
 295:../SSC/Src/objdef.c ****         }
 296:../SSC/Src/objdef.c ****         else
 297:../SSC/Src/objdef.c ****         {
 298:../SSC/Src/objdef.c ****             {
 299:../SSC/Src/objdef.c ****                 if (maxSubindex < subindex)
 305              	 .loc 1 299 0
 306 00ec 3A7A     	 ldrb r2,[r7,#8]
 307 00ee 7B79     	 ldrb r3,[r7,#5]
 308 00f0 9A42     	 cmp r2,r3
 309 00f2 01D2     	 bcs .L18
 300:../SSC/Src/objdef.c ****                 {
 301:../SSC/Src/objdef.c ****                     return 0;
 310              	 .loc 1 301 0
 311 00f4 0023     	 movs r3,#0
 312 00f6 0AE0     	 b .L9
 313              	.L18:
 302:../SSC/Src/objdef.c **** 
 303:../SSC/Src/objdef.c ****                 }
 304:../SSC/Src/objdef.c ****                 else
 305:../SSC/Src/objdef.c ****                 {
 306:../SSC/Src/objdef.c ****                     return (BIT2BYTE(pObjEntry->pEntryDesc[subindex].BitLength));
 314              	 .loc 1 306 0
 315 00f8 3B68     	 ldr r3,[r7]
 316 00fa 1969     	 ldr r1,[r3,#16]
 317 00fc 7A79     	 ldrb r2,[r7,#5]
 318 00fe 1346     	 mov r3,r2
 319 0100 5B00     	 lsls r3,r3,#1
 320 0102 1344     	 add r3,r3,r2
 321 0104 5B00     	 lsls r3,r3,#1
 322 0106 0B44     	 add r3,r3,r1
 323 0108 5B88     	 ldrh r3,[r3,#2]
 324 010a 0733     	 adds r3,r3,#7
 325 010c DB10     	 asrs r3,r3,#3
 326              	.L9:
 307:../SSC/Src/objdef.c ****                 }
 308:../SSC/Src/objdef.c ****             }
 309:../SSC/Src/objdef.c ****         }
 310:../SSC/Src/objdef.c ****     }
 311:../SSC/Src/objdef.c **** }
 327              	 .loc 1 311 0
 328 010e 1846     	 mov r0,r3
 329 0110 1437     	 adds r7,r7,#20
 330              	.LCFI8:
 331              	 .cfi_def_cfa_offset 4
 332 0112 BD46     	 mov sp,r7
 333              	.LCFI9:
 334              	 .cfi_def_cfa_register 13
 335              	 
 336 0114 5DF8047B 	 ldr r7,[sp],#4
 337              	.LCFI10:
 338              	 .cfi_restore 7
 339              	 .cfi_def_cfa_offset 0
 340 0118 7047     	 bx lr
 341              	 .cfi_endproc
 342              	.LFE176:
 344 011a 00BF     	 .section .text.OBJ_CopyNumberToString,"ax",%progbits
 345              	 .align 2
 346              	 .global OBJ_CopyNumberToString
 347              	 .thumb
 348              	 .thumb_func
 350              	OBJ_CopyNumberToString:
 351              	.LFB177:
 312:../SSC/Src/objdef.c **** 
 313:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
 314:../SSC/Src/objdef.c **** /**
 315:../SSC/Src/objdef.c ****  \param     pStr         Pointer to a string
 316:../SSC/Src/objdef.c ****  \param  Number   Number to be included in the string
 317:../SSC/Src/objdef.c **** 
 318:../SSC/Src/objdef.c ****  \brief    The function copies the Number in the string pStr,
 319:../SSC/Src/objdef.c ****          which shall be initialized with 000
 320:../SSC/Src/objdef.c **** 
 321:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
 322:../SSC/Src/objdef.c **** 
 323:../SSC/Src/objdef.c **** void OBJ_CopyNumberToString(UCHAR MBXMEM *pStr, UINT8 Number)
 324:../SSC/Src/objdef.c **** {
 352              	 .loc 1 324 0
 353              	 .cfi_startproc
 354              	 
 355              	 
 356              	 
 357 0000 90B4     	 push {r4,r7}
 358              	.LCFI11:
 359              	 .cfi_def_cfa_offset 8
 360              	 .cfi_offset 4,-8
 361              	 .cfi_offset 7,-4
 362 0002 84B0     	 sub sp,sp,#16
 363              	.LCFI12:
 364              	 .cfi_def_cfa_offset 24
 365 0004 00AF     	 add r7,sp,#0
 366              	.LCFI13:
 367              	 .cfi_def_cfa_register 7
 368 0006 7860     	 str r0,[r7,#4]
 369 0008 0B46     	 mov r3,r1
 370 000a FB70     	 strb r3,[r7,#3]
 325:../SSC/Src/objdef.c ****     UINT8 Modulo;
 326:../SSC/Src/objdef.c **** 
 327:../SSC/Src/objdef.c ****     pStr[2] = '0';
 371              	 .loc 1 327 0
 372 000c 7B68     	 ldr r3,[r7,#4]
 373 000e 0233     	 adds r3,r3,#2
 374 0010 3022     	 movs r2,#48
 375 0012 1A70     	 strb r2,[r3]
 328:../SSC/Src/objdef.c ****     pStr[0] += (Number / 100);
 376              	 .loc 1 328 0
 377 0014 7B68     	 ldr r3,[r7,#4]
 378 0016 1A78     	 ldrb r2,[r3]
 379 0018 FB78     	 ldrb r3,[r7,#3]
 380 001a 1C49     	 ldr r1,.L20
 381 001c A1FB0313 	 umull r1,r3,r1,r3
 382 0020 5B09     	 lsrs r3,r3,#5
 383 0022 DBB2     	 uxtb r3,r3
 384 0024 1344     	 add r3,r3,r2
 385 0026 DAB2     	 uxtb r2,r3
 386 0028 7B68     	 ldr r3,[r7,#4]
 387 002a 1A70     	 strb r2,[r3]
 329:../SSC/Src/objdef.c ****     Modulo = Number % 100;
 388              	 .loc 1 329 0
 389 002c FB78     	 ldrb r3,[r7,#3]
 390 002e 174A     	 ldr r2,.L20
 391 0030 A2FB0312 	 umull r1,r2,r2,r3
 392 0034 5209     	 lsrs r2,r2,#5
 393 0036 6421     	 movs r1,#100
 394 0038 01FB02F2 	 mul r2,r1,r2
 395 003c 9B1A     	 subs r3,r3,r2
 396 003e FB73     	 strb r3,[r7,#15]
 330:../SSC/Src/objdef.c ****     pStr[1] += (Modulo / 10);
 397              	 .loc 1 330 0
 398 0040 7B68     	 ldr r3,[r7,#4]
 399 0042 0133     	 adds r3,r3,#1
 400 0044 7A68     	 ldr r2,[r7,#4]
 401 0046 0132     	 adds r2,r2,#1
 402 0048 1178     	 ldrb r1,[r2]
 403 004a FA7B     	 ldrb r2,[r7,#15]
 404 004c 1048     	 ldr r0,.L20+4
 405 004e A0FB0202 	 umull r0,r2,r0,r2
 406 0052 D208     	 lsrs r2,r2,#3
 407 0054 D2B2     	 uxtb r2,r2
 408 0056 0A44     	 add r2,r2,r1
 409 0058 D2B2     	 uxtb r2,r2
 410 005a 1A70     	 strb r2,[r3]
 331:../SSC/Src/objdef.c ****     pStr[2] += (Modulo % 10);
 411              	 .loc 1 331 0
 412 005c 7B68     	 ldr r3,[r7,#4]
 413 005e 981C     	 adds r0,r3,#2
 414 0060 7B68     	 ldr r3,[r7,#4]
 415 0062 0233     	 adds r3,r3,#2
 416 0064 1C78     	 ldrb r4,[r3]
 417 0066 FA7B     	 ldrb r2,[r7,#15]
 418 0068 094B     	 ldr r3,.L20+4
 419 006a A3FB0213 	 umull r1,r3,r3,r2
 420 006e D908     	 lsrs r1,r3,#3
 421 0070 0B46     	 mov r3,r1
 422 0072 9B00     	 lsls r3,r3,#2
 423 0074 0B44     	 add r3,r3,r1
 424 0076 5B00     	 lsls r3,r3,#1
 425 0078 D31A     	 subs r3,r2,r3
 426 007a DBB2     	 uxtb r3,r3
 427 007c 2344     	 add r3,r3,r4
 428 007e DBB2     	 uxtb r3,r3
 429 0080 0370     	 strb r3,[r0]
 332:../SSC/Src/objdef.c **** }
 430              	 .loc 1 332 0
 431 0082 1037     	 adds r7,r7,#16
 432              	.LCFI14:
 433              	 .cfi_def_cfa_offset 8
 434 0084 BD46     	 mov sp,r7
 435              	.LCFI15:
 436              	 .cfi_def_cfa_register 13
 437              	 
 438 0086 90BC     	 pop {r4,r7}
 439              	.LCFI16:
 440              	 .cfi_restore 7
 441              	 .cfi_restore 4
 442              	 .cfi_def_cfa_offset 0
 443 0088 7047     	 bx lr
 444              	.L21:
 445 008a 00BF     	 .align 2
 446              	.L20:
 447 008c 1F85EB51 	 .word 1374389535
 448 0090 CDCCCCCC 	 .word -858993459
 449              	 .cfi_endproc
 450              	.LFE177:
 452              	 .section .text.OBJ_GetNoOfObjects,"ax",%progbits
 453              	 .align 2
 454              	 .global OBJ_GetNoOfObjects
 455              	 .thumb
 456              	 .thumb_func
 458              	OBJ_GetNoOfObjects:
 459              	.LFB178:
 333:../SSC/Src/objdef.c **** 
 334:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
 335:../SSC/Src/objdef.c **** /**
 336:../SSC/Src/objdef.c ****  \param     listType requested listType (0=all objects, 1=RxPDO mappable objects,
 337:../SSC/Src/objdef.c ****                         2=TxPDO mappable objects, 3=backup objects, 4=setting objects)
 338:../SSC/Src/objdef.c **** 
 339:../SSC/Src/objdef.c ****  \return Number of objects of the requested list type
 340:../SSC/Src/objdef.c **** 
 341:../SSC/Src/objdef.c ****  \brief    The function counts the number of objects of the requested list type
 342:../SSC/Src/objdef.c **** 
 343:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
 344:../SSC/Src/objdef.c **** 
 345:../SSC/Src/objdef.c **** UINT16    OBJ_GetNoOfObjects(UINT8 listType)
 346:../SSC/Src/objdef.c **** {
 460              	 .loc 1 346 0
 461              	 .cfi_startproc
 462              	 
 463              	 
 464 0000 80B5     	 push {r7,lr}
 465              	.LCFI17:
 466              	 .cfi_def_cfa_offset 8
 467              	 .cfi_offset 7,-8
 468              	 .cfi_offset 14,-4
 469 0002 86B0     	 sub sp,sp,#24
 470              	.LCFI18:
 471              	 .cfi_def_cfa_offset 32
 472 0004 00AF     	 add r7,sp,#0
 473              	.LCFI19:
 474              	 .cfi_def_cfa_register 7
 475 0006 0346     	 mov r3,r0
 476 0008 FB71     	 strb r3,[r7,#7]
 347:../SSC/Src/objdef.c ****     /* the variable listFlags contains the mask used for the ObjAccess in the Entry-Desc
 348:../SSC/Src/objdef.c ****        see the structure TSDOINFOENTRYDESC in sdoserv.h, listType = 0 indicates that
 349:../SSC/Src/objdef.c ****        all objects has to be counted */
 350:../SSC/Src/objdef.c ****     
 351:../SSC/Src/objdef.c ****     UINT16 listFlags = 0x0020 << listType;
 477              	 .loc 1 351 0
 478 000a FB79     	 ldrb r3,[r7,#7]
 479 000c 2022     	 movs r2,#32
 480 000e 02FA03F3 	 lsl r3,r2,r3
 481 0012 BB81     	 strh r3,[r7,#12]
 352:../SSC/Src/objdef.c ****     
 353:../SSC/Src/objdef.c ****     /* set pObjEntry to the beginning of the object dictionary */
 354:../SSC/Src/objdef.c ****     OBJCONST TOBJECT OBJMEM * pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();
 482              	 .loc 1 354 0
 483 0014 FFF7FEFF 	 bl COE_GetObjectDictionary
 484 0018 7861     	 str r0,[r7,#20]
 355:../SSC/Src/objdef.c ****     UINT16 n = 0;
 485              	 .loc 1 355 0
 486 001a 0023     	 movs r3,#0
 487 001c 7B82     	 strh r3,[r7,#18]
 356:../SSC/Src/objdef.c **** 
 357:../SSC/Src/objdef.c **** 
 358:../SSC/Src/objdef.c ****     while (pObjEntry != NULL)
 488              	 .loc 1 358 0
 489 001e 32E0     	 b .L23
 490              	.L29:
 359:../SSC/Src/objdef.c ****     {
 360:../SSC/Src/objdef.c ****         /* count the objects of the requested list type */
 361:../SSC/Src/objdef.c ****         if ( pObjEntry->Index >= 0x1000 )
 491              	 .loc 1 361 0
 492 0020 7B69     	 ldr r3,[r7,#20]
 493 0022 1B89     	 ldrh r3,[r3,#8]
 494 0024 B3F5805F 	 cmp r3,#4096
 495 0028 2AD3     	 bcc .L24
 496              	.LBB3:
 362:../SSC/Src/objdef.c ****         {
 363:../SSC/Src/objdef.c ****             UINT8 t = listType;
 497              	 .loc 1 363 0
 498 002a FB79     	 ldrb r3,[r7,#7]
 499 002c 7B74     	 strb r3,[r7,#17]
 364:../SSC/Src/objdef.c ****             if ( t )
 500              	 .loc 1 364 0
 501 002e 7B7C     	 ldrb r3,[r7,#17]
 502 0030 002B     	 cmp r3,#0
 503 0032 1FD0     	 beq .L25
 504              	.LBB4:
 365:../SSC/Src/objdef.c ****             {
 366:../SSC/Src/objdef.c ****                 UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJ
 505              	 .loc 1 366 0
 506 0034 7B69     	 ldr r3,[r7,#20]
 507 0036 9B89     	 ldrh r3,[r3,#12]
 508 0038 FB72     	 strb r3,[r7,#11]
 367:../SSC/Src/objdef.c ****                 UINT16 i = 0;
 509              	 .loc 1 367 0
 510 003a 0023     	 movs r3,#0
 511 003c FB81     	 strh r3,[r7,#14]
 368:../SSC/Src/objdef.c **** 
 369:../SSC/Src/objdef.c ****                 while ( t && i <= maxSubindex )
 512              	 .loc 1 369 0
 513 003e 11E0     	 b .L26
 514              	.L28:
 370:../SSC/Src/objdef.c ****                 {
 371:../SSC/Src/objdef.c ****                     if ( OBJ_GetEntryDesc(pObjEntry,(UINT8) i)->ObjAccess & listFlags )
 515              	 .loc 1 371 0
 516 0040 FB89     	 ldrh r3,[r7,#14]
 517 0042 DBB2     	 uxtb r3,r3
 518 0044 7869     	 ldr r0,[r7,#20]
 519 0046 1946     	 mov r1,r3
 520 0048 FFF7FEFF 	 bl OBJ_GetEntryDesc
 521 004c 0346     	 mov r3,r0
 522 004e 9A88     	 ldrh r2,[r3,#4]
 523 0050 BB89     	 ldrh r3,[r7,#12]
 524 0052 1340     	 ands r3,r3,r2
 525 0054 9BB2     	 uxth r3,r3
 526 0056 002B     	 cmp r3,#0
 527 0058 01D0     	 beq .L27
 372:../SSC/Src/objdef.c ****                     {
 373:../SSC/Src/objdef.c ****                         t = 0;
 528              	 .loc 1 373 0
 529 005a 0023     	 movs r3,#0
 530 005c 7B74     	 strb r3,[r7,#17]
 531              	.L27:
 374:../SSC/Src/objdef.c ****                     }
 375:../SSC/Src/objdef.c ****                     i++;
 532              	 .loc 1 375 0
 533 005e FB89     	 ldrh r3,[r7,#14]
 534 0060 0133     	 adds r3,r3,#1
 535 0062 FB81     	 strh r3,[r7,#14]
 536              	.L26:
 369:../SSC/Src/objdef.c ****                 {
 537              	 .loc 1 369 0
 538 0064 7B7C     	 ldrb r3,[r7,#17]
 539 0066 002B     	 cmp r3,#0
 540 0068 04D0     	 beq .L25
 369:../SSC/Src/objdef.c ****                 {
 541              	 .loc 1 369 0 is_stmt 0 discriminator 1
 542 006a FB7A     	 ldrb r3,[r7,#11]
 543 006c 9BB2     	 uxth r3,r3
 544 006e FA89     	 ldrh r2,[r7,#14]
 545 0070 9A42     	 cmp r2,r3
 546 0072 E5D9     	 bls .L28
 547              	.L25:
 548              	.LBE4:
 376:../SSC/Src/objdef.c ****                 }
 377:../SSC/Src/objdef.c ****             }
 378:../SSC/Src/objdef.c ****             if ( !t )
 549              	 .loc 1 378 0 is_stmt 1
 550 0074 7B7C     	 ldrb r3,[r7,#17]
 551 0076 002B     	 cmp r3,#0
 552 0078 02D1     	 bne .L24
 379:../SSC/Src/objdef.c ****             {
 380:../SSC/Src/objdef.c ****                 /* object from listType found */
 381:../SSC/Src/objdef.c ****                 n++;
 553              	 .loc 1 381 0
 554 007a 7B8A     	 ldrh r3,[r7,#18]
 555 007c 0133     	 adds r3,r3,#1
 556 007e 7B82     	 strh r3,[r7,#18]
 557              	.L24:
 558              	.LBE3:
 382:../SSC/Src/objdef.c ****             }
 383:../SSC/Src/objdef.c ****         }
 384:../SSC/Src/objdef.c ****         /* next object in object dictionary */
 385:../SSC/Src/objdef.c ****         pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
 559              	 .loc 1 385 0
 560 0080 7B69     	 ldr r3,[r7,#20]
 561 0082 5B68     	 ldr r3,[r3,#4]
 562 0084 7B61     	 str r3,[r7,#20]
 563              	.L23:
 358:../SSC/Src/objdef.c ****     {
 564              	 .loc 1 358 0
 565 0086 7B69     	 ldr r3,[r7,#20]
 566 0088 002B     	 cmp r3,#0
 567 008a C9D1     	 bne .L29
 386:../SSC/Src/objdef.c ****     }
 387:../SSC/Src/objdef.c **** 
 388:../SSC/Src/objdef.c ****     return n;
 568              	 .loc 1 388 0
 569 008c 7B8A     	 ldrh r3,[r7,#18]
 389:../SSC/Src/objdef.c **** }
 570              	 .loc 1 389 0
 571 008e 1846     	 mov r0,r3
 572 0090 1837     	 adds r7,r7,#24
 573              	.LCFI20:
 574              	 .cfi_def_cfa_offset 8
 575 0092 BD46     	 mov sp,r7
 576              	.LCFI21:
 577              	 .cfi_def_cfa_register 13
 578              	 
 579 0094 80BD     	 pop {r7,pc}
 580              	 .cfi_endproc
 581              	.LFE178:
 583 0096 00BF     	 .section .text.OBJ_GetObjectList,"ax",%progbits
 584              	 .align 2
 585              	 .global OBJ_GetObjectList
 586              	 .thumb
 587              	 .thumb_func
 589              	OBJ_GetObjectList:
 590              	.LFB179:
 390:../SSC/Src/objdef.c **** 
 391:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
 392:../SSC/Src/objdef.c **** /**
 393:../SSC/Src/objdef.c ****  \param     listType 	Requested listType (0=all objects, 1=RxPDO mappable objects,
 394:../SSC/Src/objdef.c ****                         2=TxPDO mappable objects, 3=backup objects, 4=setting objects)
 395:../SSC/Src/objdef.c ****  \param     pIndex     	Pointer to the next Index of the object list to copied in the mailbox buffe
 396:../SSC/Src/objdef.c ****                          has to adapted    at the end of the function
 397:../SSC/Src/objdef.c ****  \param     size        Size of the available mailbox buffer
 398:../SSC/Src/objdef.c ****  \param     pData     	Pointer to the mailbox buffer where (the part of) the object list requested 
 399:../SSC/Src/objdef.c ****  \param     pAbort    	Pointer to abortCode
 400:../SSC/Src/objdef.c **** 
 401:../SSC/Src/objdef.c ****  \return 	Size of the available mailbox buffer which was not copied to
 402:../SSC/Src/objdef.c **** 
 403:../SSC/Src/objdef.c ****  \brief    The function copies (the part of) the object list in the mailbox buffer
 404:../SSC/Src/objdef.c **** 
 405:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
 406:../SSC/Src/objdef.c **** UINT16    OBJ_GetObjectList(UINT16 listType, UINT16 *pIndex, UINT16 size, UINT16 MBXMEM *pData,UINT
 407:../SSC/Src/objdef.c **** {
 591              	 .loc 1 407 0
 592              	 .cfi_startproc
 593              	 
 594              	 
 595 0000 80B5     	 push {r7,lr}
 596              	.LCFI22:
 597              	 .cfi_def_cfa_offset 8
 598              	 .cfi_offset 7,-8
 599              	 .cfi_offset 14,-4
 600 0002 88B0     	 sub sp,sp,#32
 601              	.LCFI23:
 602              	 .cfi_def_cfa_offset 40
 603 0004 00AF     	 add r7,sp,#0
 604              	.LCFI24:
 605              	 .cfi_def_cfa_register 7
 606 0006 B960     	 str r1,[r7,#8]
 607 0008 7B60     	 str r3,[r7,#4]
 608 000a 0346     	 mov r3,r0
 609 000c FB81     	 strh r3,[r7,#14]
 610 000e 1346     	 mov r3,r2
 611 0010 BB81     	 strh r3,[r7,#12]
 408:../SSC/Src/objdef.c ****     /* the variable listFlags contains the mask used for the ObjAccess in the Entry-Desc
 409:../SSC/Src/objdef.c ****        see the structure TSDOINFOENTRYDESC in sdoserv.h, listType = 0 indicates that
 410:../SSC/Src/objdef.c ****        all objects has to be counted */
 411:../SSC/Src/objdef.c ****     UINT16 listFlags = 0x0020 << listType;
 612              	 .loc 1 411 0
 613 0012 FB89     	 ldrh r3,[r7,#14]
 614 0014 2022     	 movs r2,#32
 615 0016 02FA03F3 	 lsl r3,r2,r3
 616 001a FB82     	 strh r3,[r7,#22]
 412:../SSC/Src/objdef.c ****     OBJCONST TOBJECT OBJMEM * pObjEntry;
 413:../SSC/Src/objdef.c **** 
 414:../SSC/Src/objdef.c **** 
 415:../SSC/Src/objdef.c ****     if ( pIndex[0] == 0x1000 )
 617              	 .loc 1 415 0
 618 001c BB68     	 ldr r3,[r7,#8]
 619 001e 1B88     	 ldrh r3,[r3]
 620 0020 B3F5805F 	 cmp r3,#4096
 621 0024 0CD1     	 bne .L32
 416:../SSC/Src/objdef.c ****     {
 417:../SSC/Src/objdef.c ****         /* beginning of object list, set pObjEntry to the beginning of the object dictionary */
 418:../SSC/Src/objdef.c ****        pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();
 622              	 .loc 1 418 0
 623 0026 FFF7FEFF 	 bl COE_GetObjectDictionary
 624 002a F861     	 str r0,[r7,#28]
 419:../SSC/Src/objdef.c ****         // set abort code if no object dictionary is available
 420:../SSC/Src/objdef.c ****         if((pObjEntry == NULL) && (pAbort != NULL))
 625              	 .loc 1 420 0
 626 002c FB69     	 ldr r3,[r7,#28]
 627 002e 002B     	 cmp r3,#0
 628 0030 09D1     	 bne .L34
 629              	 .loc 1 420 0 is_stmt 0 discriminator 1
 630 0032 BB6A     	 ldr r3,[r7,#40]
 631 0034 002B     	 cmp r3,#0
 632 0036 06D0     	 beq .L34
 421:../SSC/Src/objdef.c ****         {
 422:../SSC/Src/objdef.c ****             *pAbort = ABORTIDX_NO_OBJECT_DICTIONARY_IS_PRESENT;
 633              	 .loc 1 422 0 is_stmt 1
 634 0038 BB6A     	 ldr r3,[r7,#40]
 635 003a 1B22     	 movs r2,#27
 636 003c 1A70     	 strb r2,[r3]
 637 003e 02E0     	 b .L34
 638              	.L32:
 423:../SSC/Src/objdef.c ****         }
 424:../SSC/Src/objdef.c ****     }
 425:../SSC/Src/objdef.c ****     else
 426:../SSC/Src/objdef.c ****     {
 427:../SSC/Src/objdef.c ****         /* next fragment, the next object to be handled was stored in pSdoInfoObjEntry */
 428:../SSC/Src/objdef.c ****         pObjEntry = pSdoInfoObjEntry;
 639              	 .loc 1 428 0
 640 0040 2D4B     	 ldr r3,.L46
 641 0042 1B68     	 ldr r3,[r3]
 642 0044 FB61     	 str r3,[r7,#28]
 643              	.L34:
 429:../SSC/Src/objdef.c ****     }
 430:../SSC/Src/objdef.c **** 
 431:../SSC/Src/objdef.c ****     if ( pObjEntry != NULL )
 644              	 .loc 1 431 0
 645 0046 FB69     	 ldr r3,[r7,#28]
 646 0048 002B     	 cmp r3,#0
 647 004a 40D0     	 beq .L35
 432:../SSC/Src/objdef.c ****     {
 433:../SSC/Src/objdef.c ****         while (pObjEntry != NULL && size > 1 )
 648              	 .loc 1 433 0
 649 004c 39E0     	 b .L36
 650              	.L42:
 434:../SSC/Src/objdef.c ****         {
 435:../SSC/Src/objdef.c ****             /* get the next index of the requested object list if there is enough space in the mail
 436:../SSC/Src/objdef.c ****             if ( pObjEntry->Index >= 0x1000 )
 651              	 .loc 1 436 0
 652 004e FB69     	 ldr r3,[r7,#28]
 653 0050 1B89     	 ldrh r3,[r3,#8]
 654 0052 B3F5805F 	 cmp r3,#4096
 655 0056 31D3     	 bcc .L37
 656              	.LBB5:
 437:../SSC/Src/objdef.c ****             {
 438:../SSC/Src/objdef.c ****                 /* UINT8 was changed to UINT16 */
 439:../SSC/Src/objdef.c ****                 UINT16 t = listType;
 657              	 .loc 1 439 0
 658 0058 FB89     	 ldrh r3,[r7,#14]
 659 005a 7B83     	 strh r3,[r7,#26]
 440:../SSC/Src/objdef.c ****                 if ( t )
 660              	 .loc 1 440 0
 661 005c 7B8B     	 ldrh r3,[r7,#26]
 662 005e 002B     	 cmp r3,#0
 663 0060 1FD0     	 beq .L38
 664              	.LBB6:
 441:../SSC/Src/objdef.c ****                 {
 442:../SSC/Src/objdef.c ****                     UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >>
 665              	 .loc 1 442 0
 666 0062 FB69     	 ldr r3,[r7,#28]
 667 0064 9B89     	 ldrh r3,[r3,#12]
 668 0066 7B75     	 strb r3,[r7,#21]
 443:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.13) COE1*/
 444:../SSC/Src/objdef.c ****                     UINT16 i = 0;
 669              	 .loc 1 444 0
 670 0068 0023     	 movs r3,#0
 671 006a 3B83     	 strh r3,[r7,#24]
 445:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.13) COE1*/
 446:../SSC/Src/objdef.c **** 
 447:../SSC/Src/objdef.c ****                     while ( t && i <= maxSubindex )
 672              	 .loc 1 447 0
 673 006c 11E0     	 b .L39
 674              	.L41:
 448:../SSC/Src/objdef.c ****                     {
 449:../SSC/Src/objdef.c ****                         if ( OBJ_GetEntryDesc(pObjEntry, (UINT8)i)->ObjAccess & listFlags )
 675              	 .loc 1 449 0
 676 006e 3B8B     	 ldrh r3,[r7,#24]
 677 0070 DBB2     	 uxtb r3,r3
 678 0072 F869     	 ldr r0,[r7,#28]
 679 0074 1946     	 mov r1,r3
 680 0076 FFF7FEFF 	 bl OBJ_GetEntryDesc
 681 007a 0346     	 mov r3,r0
 682 007c 9A88     	 ldrh r2,[r3,#4]
 683 007e FB8A     	 ldrh r3,[r7,#22]
 684 0080 1340     	 ands r3,r3,r2
 685 0082 9BB2     	 uxth r3,r3
 686 0084 002B     	 cmp r3,#0
 687 0086 01D0     	 beq .L40
 450:../SSC/Src/objdef.c ****                         {
 451:../SSC/Src/objdef.c ****                             t = 0;
 688              	 .loc 1 451 0
 689 0088 0023     	 movs r3,#0
 690 008a 7B83     	 strh r3,[r7,#26]
 691              	.L40:
 452:../SSC/Src/objdef.c ****                         }
 453:../SSC/Src/objdef.c ****                         i++;
 692              	 .loc 1 453 0
 693 008c 3B8B     	 ldrh r3,[r7,#24]
 694 008e 0133     	 adds r3,r3,#1
 695 0090 3B83     	 strh r3,[r7,#24]
 696              	.L39:
 447:../SSC/Src/objdef.c ****                     {
 697              	 .loc 1 447 0
 698 0092 7B8B     	 ldrh r3,[r7,#26]
 699 0094 002B     	 cmp r3,#0
 700 0096 04D0     	 beq .L38
 447:../SSC/Src/objdef.c ****                     {
 701              	 .loc 1 447 0 is_stmt 0 discriminator 1
 702 0098 7B7D     	 ldrb r3,[r7,#21]
 703 009a 9BB2     	 uxth r3,r3
 704 009c 3A8B     	 ldrh r2,[r7,#24]
 705 009e 9A42     	 cmp r2,r3
 706 00a0 E5D9     	 bls .L41
 707              	.L38:
 708              	.LBE6:
 454:../SSC/Src/objdef.c ****                     }
 455:../SSC/Src/objdef.c ****                 }
 456:../SSC/Src/objdef.c ****                 if ( !t )
 709              	 .loc 1 456 0 is_stmt 1
 710 00a2 7B8B     	 ldrh r3,[r7,#26]
 711 00a4 002B     	 cmp r3,#0
 712 00a6 09D1     	 bne .L37
 457:../SSC/Src/objdef.c ****                 {
 458:../SSC/Src/objdef.c ****                     /* store the index in the mailbox buffer */
 459:../SSC/Src/objdef.c ****                     *pData = SWAPWORD(pObjEntry->Index);
 713              	 .loc 1 459 0
 714 00a8 FB69     	 ldr r3,[r7,#28]
 715 00aa 1A89     	 ldrh r2,[r3,#8]
 716 00ac 7B68     	 ldr r3,[r7,#4]
 717 00ae 1A80     	 strh r2,[r3]
 460:../SSC/Src/objdef.c ****                     pData++;
 718              	 .loc 1 460 0
 719 00b0 7B68     	 ldr r3,[r7,#4]
 720 00b2 0233     	 adds r3,r3,#2
 721 00b4 7B60     	 str r3,[r7,#4]
 461:../SSC/Src/objdef.c ****                     size -= 2;
 722              	 .loc 1 461 0
 723 00b6 BB89     	 ldrh r3,[r7,#12]
 724 00b8 023B     	 subs r3,r3,#2
 725 00ba BB81     	 strh r3,[r7,#12]
 726              	.L37:
 727              	.LBE5:
 462:../SSC/Src/objdef.c ****                 }
 463:../SSC/Src/objdef.c ****             }
 464:../SSC/Src/objdef.c ****         pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
 728              	 .loc 1 464 0
 729 00bc FB69     	 ldr r3,[r7,#28]
 730 00be 5B68     	 ldr r3,[r3,#4]
 731 00c0 FB61     	 str r3,[r7,#28]
 732              	.L36:
 433:../SSC/Src/objdef.c ****         {
 733              	 .loc 1 433 0
 734 00c2 FB69     	 ldr r3,[r7,#28]
 735 00c4 002B     	 cmp r3,#0
 736 00c6 02D0     	 beq .L35
 433:../SSC/Src/objdef.c ****         {
 737              	 .loc 1 433 0 is_stmt 0 discriminator 1
 738 00c8 BB89     	 ldrh r3,[r7,#12]
 739 00ca 012B     	 cmp r3,#1
 740 00cc BFD8     	 bhi .L42
 741              	.L35:
 465:../SSC/Src/objdef.c ****         }
 466:../SSC/Src/objdef.c ****     }
 467:../SSC/Src/objdef.c **** 
 468:../SSC/Src/objdef.c ****         /* return the next Index to be handled */
 469:../SSC/Src/objdef.c ****         if(pObjEntry != NULL)
 742              	 .loc 1 469 0 is_stmt 1
 743 00ce FB69     	 ldr r3,[r7,#28]
 744 00d0 002B     	 cmp r3,#0
 745 00d2 04D0     	 beq .L43
 470:../SSC/Src/objdef.c ****         {
 471:../SSC/Src/objdef.c ****             pIndex[0] = pObjEntry->Index;
 746              	 .loc 1 471 0
 747 00d4 FB69     	 ldr r3,[r7,#28]
 748 00d6 1A89     	 ldrh r2,[r3,#8]
 749 00d8 BB68     	 ldr r3,[r7,#8]
 750 00da 1A80     	 strh r2,[r3]
 751 00dc 03E0     	 b .L44
 752              	.L43:
 472:../SSC/Src/objdef.c ****         }
 473:../SSC/Src/objdef.c ****         else
 474:../SSC/Src/objdef.c ****         {
 475:../SSC/Src/objdef.c ****             /*last entry reached*/
 476:../SSC/Src/objdef.c ****             pIndex[0] = 0xFFFF;
 753              	 .loc 1 476 0
 754 00de BB68     	 ldr r3,[r7,#8]
 755 00e0 4FF6FF72 	 movw r2,#65535
 756 00e4 1A80     	 strh r2,[r3]
 757              	.L44:
 477:../SSC/Src/objdef.c ****         }
 478:../SSC/Src/objdef.c **** 
 479:../SSC/Src/objdef.c ****     /* store object description pointer and index for next fragment */
 480:../SSC/Src/objdef.c ****     pSdoInfoObjEntry = pObjEntry;
 758              	 .loc 1 480 0
 759 00e6 044A     	 ldr r2,.L46
 760 00e8 FB69     	 ldr r3,[r7,#28]
 761 00ea 1360     	 str r3,[r2]
 481:../SSC/Src/objdef.c **** 
 482:../SSC/Src/objdef.c ****     /* return the size of the available mailbox buffer which was not copied to */
 483:../SSC/Src/objdef.c ****     return size;
 762              	 .loc 1 483 0
 763 00ec BB89     	 ldrh r3,[r7,#12]
 484:../SSC/Src/objdef.c **** }
 764              	 .loc 1 484 0
 765 00ee 1846     	 mov r0,r3
 766 00f0 2037     	 adds r7,r7,#32
 767              	.LCFI25:
 768              	 .cfi_def_cfa_offset 8
 769 00f2 BD46     	 mov sp,r7
 770              	.LCFI26:
 771              	 .cfi_def_cfa_register 13
 772              	 
 773 00f4 80BD     	 pop {r7,pc}
 774              	.L47:
 775 00f6 00BF     	 .align 2
 776              	.L46:
 777 00f8 00000000 	 .word pSdoInfoObjEntry
 778              	 .cfi_endproc
 779              	.LFE179:
 781              	 .section .text.OBJ_GetDesc,"ax",%progbits
 782              	 .align 2
 783              	 .global OBJ_GetDesc
 784              	 .thumb
 785              	 .thumb_func
 787              	OBJ_GetDesc:
 788              	.LFB180:
 485:../SSC/Src/objdef.c **** 
 486:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
 487:../SSC/Src/objdef.c **** /**
 488:../SSC/Src/objdef.c ****  \param     index     Indicates the index of the dictionary object.
 489:../SSC/Src/objdef.c ****  \param  	subindex  Indicates the subindex of the dictionary object.
 490:../SSC/Src/objdef.c ****                         Subindex 0xff returns the description of the whole object ( the name of
 491:../SSC/Src/objdef.c ****                         the object ).
 492:../SSC/Src/objdef.c ****                         Subindex 0x00 returns the description of the subindex 0 and so on.
 493:../SSC/Src/objdef.c ****  \param     pObjEntry Is a handle to the dictionary object ( for faster access ) or NULL.						
 494:../SSC/Src/objdef.c ****  \param    pData        Is the memory field for the description string or NULL ( if the size of
 495:../SSC/Src/objdef.c ****                         string is unknown ):
 496:../SSC/Src/objdef.c **** 
 497:../SSC/Src/objdef.c ****  \return    The size in bytes of the description string (without null termination byte ).
 498:../SSC/Src/objdef.c ****             0 will be returned if a description for the indicated entry was not found.
 499:../SSC/Src/objdef.c **** 
 500:../SSC/Src/objdef.c ****  \brief    The function returns size and description string of the requested entry.
 501:../SSC/Src/objdef.c **** 
 502:../SSC/Src/objdef.c ****             Its possible to define all description strings of one entry ( including the name
 503:../SSC/Src/objdef.c ****             of the object ) in one structure:        <br>
 504:../SSC/Src/objdef.c ****             {                                                    <br>
 505:../SSC/Src/objdef.c ****                 name_of_object with index,              <br>
 506:../SSC/Src/objdef.c ****                 description_of_subindex0,                <br>
 507:../SSC/Src/objdef.c ****                 .                                                <br>
 508:../SSC/Src/objdef.c ****                 description_of_subindexN,                <br>
 509:../SSC/Src/objdef.c ****                 0xFF                                            <br>
 510:../SSC/Src/objdef.c ****             }
 511:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
 512:../SSC/Src/objdef.c **** 
 513:../SSC/Src/objdef.c **** UINT16 OBJ_GetDesc( UINT16 index, UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT16 MBXME
 514:../SSC/Src/objdef.c **** {
 789              	 .loc 1 514 0
 790              	 .cfi_startproc
 791              	 
 792              	 
 793 0000 90B5     	 push {r4,r7,lr}
 794              	.LCFI27:
 795              	 .cfi_def_cfa_offset 12
 796              	 .cfi_offset 4,-12
 797              	 .cfi_offset 7,-8
 798              	 .cfi_offset 14,-4
 799 0002 8DB0     	 sub sp,sp,#52
 800              	.LCFI28:
 801              	 .cfi_def_cfa_offset 64
 802 0004 00AF     	 add r7,sp,#0
 803              	.LCFI29:
 804              	 .cfi_def_cfa_register 7
 805 0006 BA60     	 str r2,[r7,#8]
 806 0008 7B60     	 str r3,[r7,#4]
 807 000a 0346     	 mov r3,r0
 808 000c FB81     	 strh r3,[r7,#14]
 809 000e 0B46     	 mov r3,r1
 810 0010 7B73     	 strb r3,[r7,#13]
 515:../SSC/Src/objdef.c ****     UINT16 strSize = 0;
 811              	 .loc 1 515 0
 812 0012 0023     	 movs r3,#0
 813 0014 FB85     	 strh r3,[r7,#46]
 516:../SSC/Src/objdef.c ****     OBJCONST UCHAR OBJMEM * pDesc = (OBJCONST UCHAR OBJMEM *) pObjEntry->pName;
 814              	 .loc 1 516 0
 815 0016 BB68     	 ldr r3,[r7,#8]
 816 0018 5B69     	 ldr r3,[r3,#20]
 817 001a 7B62     	 str r3,[r7,#36]
 517:../SSC/Src/objdef.c **** /* get the information of ObjCode and MaxSubindex in local variables to support different types of 
 518:../SSC/Src/objdef.c ****     UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
 818              	 .loc 1 518 0
 819 001c BB68     	 ldr r3,[r7,#8]
 820 001e 9B89     	 ldrh r3,[r3,#12]
 821 0020 03F47063 	 and r3,r3,#3840
 822 0024 1B12     	 asrs r3,r3,#8
 823 0026 87F82330 	 strb r3,[r7,#35]
 519:../SSC/Src/objdef.c **** 
 520:../SSC/Src/objdef.c **** 
 521:../SSC/Src/objdef.c **** 
 522:../SSC/Src/objdef.c ****     if ( (subindex == 0) || (objCode == OBJCODE_VAR) )
 824              	 .loc 1 522 0
 825 002a 7B7B     	 ldrb r3,[r7,#13]
 826 002c 002B     	 cmp r3,#0
 827 002e 03D0     	 beq .L49
 828              	 .loc 1 522 0 is_stmt 0 discriminator 1
 829 0030 97F82330 	 ldrb r3,[r7,#35]
 830 0034 072B     	 cmp r3,#7
 831 0036 0FD1     	 bne .L50
 832              	.L49:
 523:../SSC/Src/objdef.c ****     {
 524:../SSC/Src/objdef.c ****         // Get object description length
 525:../SSC/Src/objdef.c ****        strSize = (UINT16) OBJSTRLEN((OBJCONST CHAR OBJMEM *) pDesc);
 833              	 .loc 1 525 0 is_stmt 1
 834 0038 786A     	 ldr r0,[r7,#36]
 835 003a FFF7FEFF 	 bl strlen
 836 003e 0346     	 mov r3,r0
 837 0040 FB85     	 strh r3,[r7,#46]
 526:../SSC/Src/objdef.c **** 
 527:../SSC/Src/objdef.c ****         // If there is a pointer given, copy data:
 528:../SSC/Src/objdef.c ****         if ( pData )
 838              	 .loc 1 528 0
 839 0042 7B68     	 ldr r3,[r7,#4]
 840 0044 002B     	 cmp r3,#0
 841 0046 06D0     	 beq .L51
 529:../SSC/Src/objdef.c ****         {
 530:../SSC/Src/objdef.c ****             OBJTOMBXSTRCPY( pData, pDesc, strSize );
 842              	 .loc 1 530 0
 843 0048 FB8D     	 ldrh r3,[r7,#46]
 844 004a 7868     	 ldr r0,[r7,#4]
 845 004c 796A     	 ldr r1,[r7,#36]
 846 004e 1A46     	 mov r2,r3
 847 0050 FFF7FEFF 	 bl memcpy
 528:../SSC/Src/objdef.c ****         {
 848              	 .loc 1 528 0
 849 0054 5DE0     	 b .L52
 850              	.L51:
 851 0056 5CE0     	 b .L52
 852              	.L50:
 531:../SSC/Src/objdef.c ****         }
 532:../SSC/Src/objdef.c ****     }
 533:../SSC/Src/objdef.c ****     else
 534:../SSC/Src/objdef.c ****     {
 535:../SSC/Src/objdef.c ****         if ( objCode == OBJCODE_REC )
 853              	 .loc 1 535 0
 854 0058 97F82330 	 ldrb r3,[r7,#35]
 855 005c 092B     	 cmp r3,#9
 856 005e 3AD1     	 bne .L53
 857              	.LBB7:
 536:../SSC/Src/objdef.c ****         {
 537:../SSC/Src/objdef.c ****             {
 538:../SSC/Src/objdef.c ****             // get pointer to description of subindex 1 :
 539:../SSC/Src/objdef.c ****             // 16bit variable to avoid overflow if subindex 0xFF is read
 540:../SSC/Src/objdef.c ****             UINT16 i = 1;
 858              	 .loc 1 540 0
 859 0060 0123     	 movs r3,#1
 860 0062 BB85     	 strh r3,[r7,#44]
 541:../SSC/Src/objdef.c ****             UINT16 tmpSubindex = subindex;
 861              	 .loc 1 541 0
 862 0064 7B7B     	 ldrb r3,[r7,#13]
 863 0066 3B84     	 strh r3,[r7,#32]
 864              	.LBB8:
 542:../SSC/Src/objdef.c **** 
 543:../SSC/Src/objdef.c ****             {
 544:../SSC/Src/objdef.c **** 
 545:../SSC/Src/objdef.c ****             OBJCONST UCHAR OBJMEM * pSubDesc = (OBJCONST UCHAR OBJMEM *) OBJGETNEXTSTR( pDesc );
 865              	 .loc 1 545 0
 866 0068 786A     	 ldr r0,[r7,#36]
 867 006a FFF7FEFF 	 bl strlen
 868 006e 0346     	 mov r3,r0
 869 0070 0133     	 adds r3,r3,#1
 870 0072 7A6A     	 ldr r2,[r7,#36]
 871 0074 1344     	 add r3,r3,r2
 872 0076 BB62     	 str r3,[r7,#40]
 546:../SSC/Src/objdef.c ****             while (( i <= tmpSubindex )
 873              	 .loc 1 546 0
 874 0078 21E0     	 b .L54
 875              	.L57:
 547:../SSC/Src/objdef.c ****                 &&( pSubDesc[0] != 0xFF && pSubDesc[0] != 0xFE 
 548:../SSC/Src/objdef.c **** /* ECATCHANGE_START(V5.13) COE9*/
 549:../SSC/Src/objdef.c **** /* ECATCHANGE_END(V5.13) COE9*/
 550:../SSC/Src/objdef.c ****                     ))
 551:../SSC/Src/objdef.c ****             {
 552:../SSC/Src/objdef.c ****                 if ( i == tmpSubindex )
 876              	 .loc 1 552 0
 877 007a BA8D     	 ldrh r2,[r7,#44]
 878 007c 3B8C     	 ldrh r3,[r7,#32]
 879 007e 9A42     	 cmp r2,r3
 880 0080 12D1     	 bne .L55
 553:../SSC/Src/objdef.c ****                 {
 554:../SSC/Src/objdef.c ****                    strSize = (UINT16) OBJSTRLEN((OBJCONST CHAR OBJMEM *) pSubDesc);
 881              	 .loc 1 554 0
 882 0082 B86A     	 ldr r0,[r7,#40]
 883 0084 FFF7FEFF 	 bl strlen
 884 0088 0346     	 mov r3,r0
 885 008a FB85     	 strh r3,[r7,#46]
 555:../SSC/Src/objdef.c ****                     if ( pData && strSize )
 886              	 .loc 1 555 0
 887 008c 7B68     	 ldr r3,[r7,#4]
 888 008e 002B     	 cmp r3,#0
 889 0090 09D0     	 beq .L56
 890              	 .loc 1 555 0 is_stmt 0 discriminator 1
 891 0092 FB8D     	 ldrh r3,[r7,#46]
 892 0094 002B     	 cmp r3,#0
 893 0096 06D0     	 beq .L56
 556:../SSC/Src/objdef.c ****                     {
 557:../SSC/Src/objdef.c ****                         OBJTOMBXSTRCPY( pData, pSubDesc, strSize );
 894              	 .loc 1 557 0 is_stmt 1
 895 0098 FB8D     	 ldrh r3,[r7,#46]
 896 009a 7868     	 ldr r0,[r7,#4]
 897 009c B96A     	 ldr r1,[r7,#40]
 898 009e 1A46     	 mov r2,r3
 899 00a0 FFF7FEFF 	 bl memcpy
 558:../SSC/Src/objdef.c ****                     }
 559:../SSC/Src/objdef.c ****                     break;
 900              	 .loc 1 559 0
 901 00a4 17E0     	 b .L53
 902              	.L56:
 903 00a6 16E0     	 b .L53
 904              	.L55:
 560:../SSC/Src/objdef.c ****                 }
 561:../SSC/Src/objdef.c ****                 else
 562:../SSC/Src/objdef.c ****                 {
 563:../SSC/Src/objdef.c ****                     i++;
 905              	 .loc 1 563 0
 906 00a8 BB8D     	 ldrh r3,[r7,#44]
 907 00aa 0133     	 adds r3,r3,#1
 908 00ac BB85     	 strh r3,[r7,#44]
 564:../SSC/Src/objdef.c ****                     pSubDesc = (OBJCONST UCHAR OBJMEM *) OBJGETNEXTSTR( pSubDesc );
 909              	 .loc 1 564 0
 910 00ae B86A     	 ldr r0,[r7,#40]
 911 00b0 FFF7FEFF 	 bl strlen
 912 00b4 0346     	 mov r3,r0
 913 00b6 0133     	 adds r3,r3,#1
 914 00b8 BA6A     	 ldr r2,[r7,#40]
 915 00ba 1344     	 add r3,r3,r2
 916 00bc BB62     	 str r3,[r7,#40]
 917              	.L54:
 546:../SSC/Src/objdef.c ****                 &&( pSubDesc[0] != 0xFF && pSubDesc[0] != 0xFE 
 918              	 .loc 1 546 0
 919 00be BA8D     	 ldrh r2,[r7,#44]
 920 00c0 3B8C     	 ldrh r3,[r7,#32]
 921 00c2 9A42     	 cmp r2,r3
 922 00c4 07D8     	 bhi .L53
 547:../SSC/Src/objdef.c **** /* ECATCHANGE_START(V5.13) COE9*/
 923              	 .loc 1 547 0
 924 00c6 BB6A     	 ldr r3,[r7,#40]
 925 00c8 1B78     	 ldrb r3,[r3]
 926 00ca FF2B     	 cmp r3,#255
 927 00cc 03D0     	 beq .L53
 547:../SSC/Src/objdef.c **** /* ECATCHANGE_START(V5.13) COE9*/
 928              	 .loc 1 547 0 is_stmt 0 discriminator 1
 929 00ce BB6A     	 ldr r3,[r7,#40]
 930 00d0 1B78     	 ldrb r3,[r3]
 931 00d2 FE2B     	 cmp r3,#254
 932 00d4 D1D1     	 bne .L57
 933              	.L53:
 934              	.LBE8:
 935              	.LBE7:
 565:../SSC/Src/objdef.c ****                 }
 566:../SSC/Src/objdef.c ****             }
 567:../SSC/Src/objdef.c ****             }
 568:../SSC/Src/objdef.c ****             }
 569:../SSC/Src/objdef.c ****         }
 570:../SSC/Src/objdef.c **** 
 571:../SSC/Src/objdef.c ****         if ( strSize == 0 )
 936              	 .loc 1 571 0 is_stmt 1
 937 00d6 FB8D     	 ldrh r3,[r7,#46]
 938 00d8 002B     	 cmp r3,#0
 939 00da 1AD1     	 bne .L52
 572:../SSC/Src/objdef.c ****         {
 573:../SSC/Src/objdef.c ****             // no string found for subindex x -> name is Subindex x
 574:../SSC/Src/objdef.c ****             strSize =    12;
 940              	 .loc 1 574 0
 941 00dc 0C23     	 movs r3,#12
 942 00de FB85     	 strh r3,[r7,#46]
 575:../SSC/Src/objdef.c **** 
 576:../SSC/Src/objdef.c ****             if ( pData )
 943              	 .loc 1 576 0
 944 00e0 7B68     	 ldr r3,[r7,#4]
 945 00e2 002B     	 cmp r3,#0
 946 00e4 15D0     	 beq .L52
 947              	.LBB9:
 577:../SSC/Src/objdef.c ****             {
 578:../SSC/Src/objdef.c ****                 UCHAR OBJMEM         TmpDescr[13];
 579:../SSC/Src/objdef.c ****                 /* ECATCHANGE_START(V5.13) COE4*/
 580:../SSC/Src/objdef.c ****                 MEMCPY(TmpDescr, aSubindexDesc, SIZEOF(TmpDescr));
 948              	 .loc 1 580 0
 949 00e6 0D4B     	 ldr r3,.L59
 950 00e8 07F11004 	 add r4,r7,#16
 951 00ec 0FCB     	 ldmia r3,{r0,r1,r2,r3}
 952 00ee 07C4     	 stmia r4!,{r0,r1,r2}
 953 00f0 2370     	 strb r3,[r4]
 581:../SSC/Src/objdef.c ****                 /* ECATCHANGE_END(V5.13) COE4*/
 582:../SSC/Src/objdef.c ****                 
 583:../SSC/Src/objdef.c ****                 OBJ_CopyNumberToString( &TmpDescr[9], subindex );
 954              	 .loc 1 583 0
 955 00f2 07F11003 	 add r3,r7,#16
 956 00f6 03F10902 	 add r2,r3,#9
 957 00fa 7B7B     	 ldrb r3,[r7,#13]
 958 00fc 1046     	 mov r0,r2
 959 00fe 1946     	 mov r1,r3
 960 0100 FFF7FEFF 	 bl OBJ_CopyNumberToString
 584:../SSC/Src/objdef.c ****                 MBXSTRCPY( pData, TmpDescr, SIZEOF(TmpDescr) );
 961              	 .loc 1 584 0
 962 0104 07F11003 	 add r3,r7,#16
 963 0108 7868     	 ldr r0,[r7,#4]
 964 010a 1946     	 mov r1,r3
 965 010c 0D22     	 movs r2,#13
 966 010e FFF7FEFF 	 bl memcpy
 967              	.L52:
 968              	.LBE9:
 585:../SSC/Src/objdef.c ****             }
 586:../SSC/Src/objdef.c ****         }
 587:../SSC/Src/objdef.c ****     }
 588:../SSC/Src/objdef.c **** 
 589:../SSC/Src/objdef.c ****     return strSize;
 969              	 .loc 1 589 0
 970 0112 FB8D     	 ldrh r3,[r7,#46]
 590:../SSC/Src/objdef.c **** }
 971              	 .loc 1 590 0
 972 0114 1846     	 mov r0,r3
 973 0116 3437     	 adds r7,r7,#52
 974              	.LCFI30:
 975              	 .cfi_def_cfa_offset 12
 976 0118 BD46     	 mov sp,r7
 977              	.LCFI31:
 978              	 .cfi_def_cfa_register 13
 979              	 
 980 011a 90BD     	 pop {r4,r7,pc}
 981              	.L60:
 982              	 .align 2
 983              	.L59:
 984 011c 00000000 	 .word aSubindexDesc
 985              	 .cfi_endproc
 986              	.LFE180:
 988              	 .section .text.OBJ_GetEntryDesc,"ax",%progbits
 989              	 .align 2
 990              	 .global OBJ_GetEntryDesc
 991              	 .thumb
 992              	 .thumb_func
 994              	OBJ_GetEntryDesc:
 995              	.LFB181:
 591:../SSC/Src/objdef.c **** 
 592:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
 593:../SSC/Src/objdef.c **** /**
 594:../SSC/Src/objdef.c ****  \param     pObjEntry            handle to the dictionary object returned by
 595:../SSC/Src/objdef.c ****                                      OBJ_GetObjectHandle which was called before
 596:../SSC/Src/objdef.c ****  \param     Subindex                subindex of the requested object.
 597:../SSC/Src/objdef.c **** 
 598:../SSC/Src/objdef.c ****  \return    Pointer to the EntryDesc of the Subindex
 599:../SSC/Src/objdef.c **** 
 600:../SSC/Src/objdef.c ****  \brief    The function returns the Entry-Desc of a subindex to allow the application
 601:../SSC/Src/objdef.c ****          to define the object dictionary independent of the sdoserv-files
 602:../SSC/Src/objdef.c **** 
 603:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
 604:../SSC/Src/objdef.c **** 
 605:../SSC/Src/objdef.c **** OBJCONST TSDOINFOENTRYDESC OBJMEM * OBJ_GetEntryDesc(OBJCONST TOBJECT OBJMEM * pObjEntry, UINT8 Sub
 606:../SSC/Src/objdef.c **** {
 996              	 .loc 1 606 0
 997              	 .cfi_startproc
 998              	 
 999              	 
 1000              	 
 1001 0000 80B4     	 push {r7}
 1002              	.LCFI32:
 1003              	 .cfi_def_cfa_offset 4
 1004              	 .cfi_offset 7,-4
 1005 0002 85B0     	 sub sp,sp,#20
 1006              	.LCFI33:
 1007              	 .cfi_def_cfa_offset 24
 1008 0004 00AF     	 add r7,sp,#0
 1009              	.LCFI34:
 1010              	 .cfi_def_cfa_register 7
 1011 0006 7860     	 str r0,[r7,#4]
 1012 0008 0B46     	 mov r3,r1
 1013 000a FB70     	 strb r3,[r7,#3]
 607:../SSC/Src/objdef.c ****     OBJCONST TSDOINFOENTRYDESC OBJMEM *pEntry;
 608:../SSC/Src/objdef.c ****     UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
 1014              	 .loc 1 608 0
 1015 000c 7B68     	 ldr r3,[r7,#4]
 1016 000e 9B89     	 ldrh r3,[r3,#12]
 1017 0010 03F47063 	 and r3,r3,#3840
 1018 0014 1B12     	 asrs r3,r3,#8
 1019 0016 FB72     	 strb r3,[r7,#11]
 609:../SSC/Src/objdef.c **** 
 610:../SSC/Src/objdef.c ****     if ((objCode == OBJCODE_ARR)
 1020              	 .loc 1 610 0
 1021 0018 FB7A     	 ldrb r3,[r7,#11]
 1022 001a 082B     	 cmp r3,#8
 1023 001c 0BD1     	 bne .L62
 611:../SSC/Src/objdef.c ****         )
 612:../SSC/Src/objdef.c ****     {
 613:../SSC/Src/objdef.c ****         /* object is an array */
 614:../SSC/Src/objdef.c ****         if ( Subindex == 0 )
 1024              	 .loc 1 614 0
 1025 001e FB78     	 ldrb r3,[r7,#3]
 1026 0020 002B     	 cmp r3,#0
 1027 0022 03D1     	 bne .L63
 615:../SSC/Src/objdef.c ****         {
 616:../SSC/Src/objdef.c ****             /* subindex 0 has a description */
 617:../SSC/Src/objdef.c ****             pEntry = &pObjEntry->pEntryDesc[0];
 1028              	 .loc 1 617 0
 1029 0024 7B68     	 ldr r3,[r7,#4]
 1030 0026 1B69     	 ldr r3,[r3,#16]
 1031 0028 FB60     	 str r3,[r7,#12]
 1032 002a 0DE0     	 b .L65
 1033              	.L63:
 618:../SSC/Src/objdef.c ****         }
 619:../SSC/Src/objdef.c ****         else
 620:../SSC/Src/objdef.c ****         {
 621:../SSC/Src/objdef.c ****             /* and all other elements have the same description */
 622:../SSC/Src/objdef.c ****             pEntry = &pObjEntry->pEntryDesc[1];
 1034              	 .loc 1 622 0
 1035 002c 7B68     	 ldr r3,[r7,#4]
 1036 002e 1B69     	 ldr r3,[r3,#16]
 1037 0030 0633     	 adds r3,r3,#6
 1038 0032 FB60     	 str r3,[r7,#12]
 1039 0034 08E0     	 b .L65
 1040              	.L62:
 623:../SSC/Src/objdef.c ****         }
 624:../SSC/Src/objdef.c ****     }
 625:../SSC/Src/objdef.c ****     else
 626:../SSC/Src/objdef.c ****     {
 627:../SSC/Src/objdef.c ****         {
 628:../SSC/Src/objdef.c ****             /* object is a variable or a record return the corresponding entry */
 629:../SSC/Src/objdef.c ****             pEntry = &pObjEntry->pEntryDesc[Subindex];
 1041              	 .loc 1 629 0
 1042 0036 7B68     	 ldr r3,[r7,#4]
 1043 0038 1969     	 ldr r1,[r3,#16]
 1044 003a FA78     	 ldrb r2,[r7,#3]
 1045 003c 1346     	 mov r3,r2
 1046 003e 5B00     	 lsls r3,r3,#1
 1047 0040 1344     	 add r3,r3,r2
 1048 0042 5B00     	 lsls r3,r3,#1
 1049 0044 0B44     	 add r3,r3,r1
 1050 0046 FB60     	 str r3,[r7,#12]
 1051              	.L65:
 630:../SSC/Src/objdef.c ****         }
 631:../SSC/Src/objdef.c ****     }
 632:../SSC/Src/objdef.c **** 
 633:../SSC/Src/objdef.c ****     return pEntry;
 1052              	 .loc 1 633 0
 1053 0048 FB68     	 ldr r3,[r7,#12]
 634:../SSC/Src/objdef.c **** }
 1054              	 .loc 1 634 0
 1055 004a 1846     	 mov r0,r3
 1056 004c 1437     	 adds r7,r7,#20
 1057              	.LCFI35:
 1058              	 .cfi_def_cfa_offset 4
 1059 004e BD46     	 mov sp,r7
 1060              	.LCFI36:
 1061              	 .cfi_def_cfa_register 13
 1062              	 
 1063 0050 5DF8047B 	 ldr r7,[sp],#4
 1064              	.LCFI37:
 1065              	 .cfi_restore 7
 1066              	 .cfi_def_cfa_offset 0
 1067 0054 7047     	 bx lr
 1068              	 .cfi_endproc
 1069              	.LFE181:
 1071 0056 00BF     	 .section .text.OBJ_GetObjDesc,"ax",%progbits
 1072              	 .align 2
 1073              	 .global OBJ_GetObjDesc
 1074              	 .thumb
 1075              	 .thumb_func
 1077              	OBJ_GetObjDesc:
 1078              	.LFB182:
 635:../SSC/Src/objdef.c **** 
 636:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
 637:../SSC/Src/objdef.c **** /**
 638:../SSC/Src/objdef.c ****  \param     pObjEntry            handle to the dictionary object returned by
 639:../SSC/Src/objdef.c ****                                      OBJ_GetObjectHandle which was called before
 640:../SSC/Src/objdef.c **** 
 641:../SSC/Src/objdef.c ****  \return    Pointer to the ObjDesc of the Object
 642:../SSC/Src/objdef.c **** 
 643:../SSC/Src/objdef.c ****  \brief    The function returns the Obj-Desc of an object to allow the application
 644:../SSC/Src/objdef.c ****          to define the object dictionary independent of the sdoserv-files
 645:../SSC/Src/objdef.c **** 
 646:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
 647:../SSC/Src/objdef.c **** 
 648:../SSC/Src/objdef.c **** OBJCONST TSDOINFOOBJDESC OBJMEM * OBJ_GetObjDesc(OBJCONST TOBJECT OBJMEM * pObjEntry)
 649:../SSC/Src/objdef.c **** {
 1079              	 .loc 1 649 0
 1080              	 .cfi_startproc
 1081              	 
 1082              	 
 1083              	 
 1084 0000 80B4     	 push {r7}
 1085              	.LCFI38:
 1086              	 .cfi_def_cfa_offset 4
 1087              	 .cfi_offset 7,-4
 1088 0002 83B0     	 sub sp,sp,#12
 1089              	.LCFI39:
 1090              	 .cfi_def_cfa_offset 16
 1091 0004 00AF     	 add r7,sp,#0
 1092              	.LCFI40:
 1093              	 .cfi_def_cfa_register 7
 1094 0006 7860     	 str r0,[r7,#4]
 650:../SSC/Src/objdef.c ****     return &pObjEntry->ObjDesc;
 1095              	 .loc 1 650 0
 1096 0008 7B68     	 ldr r3,[r7,#4]
 1097 000a 0A33     	 adds r3,r3,#10
 651:../SSC/Src/objdef.c **** }
 1098              	 .loc 1 651 0
 1099 000c 1846     	 mov r0,r3
 1100 000e 0C37     	 adds r7,r7,#12
 1101              	.LCFI41:
 1102              	 .cfi_def_cfa_offset 4
 1103 0010 BD46     	 mov sp,r7
 1104              	.LCFI42:
 1105              	 .cfi_def_cfa_register 13
 1106              	 
 1107 0012 5DF8047B 	 ldr r7,[sp],#4
 1108              	.LCFI43:
 1109              	 .cfi_restore 7
 1110              	 .cfi_def_cfa_offset 0
 1111 0016 7047     	 bx lr
 1112              	 .cfi_endproc
 1113              	.LFE182:
 1115              	 .section .text.OBJ_GetEntryOffset,"ax",%progbits
 1116              	 .align 2
 1117              	 .global OBJ_GetEntryOffset
 1118              	 .thumb
 1119              	 .thumb_func
 1121              	OBJ_GetEntryOffset:
 1122              	.LFB183:
 652:../SSC/Src/objdef.c **** 
 653:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
 654:../SSC/Src/objdef.c **** /**
 655:../SSC/Src/objdef.c ****  \param     subindex                subindex of the entry
 656:../SSC/Src/objdef.c ****  \param     pObjEntry            handle to the dictionary object returned by
 657:../SSC/Src/objdef.c ****                                      OBJ_GetObjectHandle which was called before
 658:../SSC/Src/objdef.c **** 
 659:../SSC/Src/objdef.c ****  \return    bit offset of the entry in the variable
 660:../SSC/Src/objdef.c **** 
 661:../SSC/Src/objdef.c ****  \brief    This function calculates the bit offset of the entry in the object's variable
 662:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
 663:../SSC/Src/objdef.c **** 
 664:../SSC/Src/objdef.c **** UINT16 OBJ_GetEntryOffset(UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry)
 665:../SSC/Src/objdef.c **** {
 1123              	 .loc 1 665 0
 1124              	 .cfi_startproc
 1125              	 
 1126              	 
 1127              	 
 1128 0000 80B4     	 push {r7}
 1129              	.LCFI44:
 1130              	 .cfi_def_cfa_offset 4
 1131              	 .cfi_offset 7,-4
 1132 0002 87B0     	 sub sp,sp,#28
 1133              	.LCFI45:
 1134              	 .cfi_def_cfa_offset 32
 1135 0004 00AF     	 add r7,sp,#0
 1136              	.LCFI46:
 1137              	 .cfi_def_cfa_register 7
 1138 0006 0346     	 mov r3,r0
 1139 0008 3960     	 str r1,[r7]
 1140 000a FB71     	 strb r3,[r7,#7]
 666:../SSC/Src/objdef.c ****     UINT16 i;
 667:../SSC/Src/objdef.c ****     /* bitOffset will be initialized with the bit offset of subindex 1 */
 668:../SSC/Src/objdef.c ****     UINT16 bitOffset = 0;
 1141              	 .loc 1 668 0
 1142 000c 0023     	 movs r3,#0
 1143 000e BB82     	 strh r3,[r7,#20]
 669:../SSC/Src/objdef.c ****     UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
 1144              	 .loc 1 669 0
 1145 0010 3B68     	 ldr r3,[r7]
 1146 0012 9B89     	 ldrh r3,[r3,#12]
 1147 0014 03F47063 	 and r3,r3,#3840
 1148 0018 1B12     	 asrs r3,r3,#8
 1149 001a FB73     	 strb r3,[r7,#15]
 670:../SSC/Src/objdef.c ****     OBJCONST TSDOINFOENTRYDESC OBJMEM *pEntry;
 671:../SSC/Src/objdef.c **** 
 672:../SSC/Src/objdef.c ****     
 673:../SSC/Src/objdef.c ****     if(subindex > 0)
 1150              	 .loc 1 673 0
 1151 001c FB79     	 ldrb r3,[r7,#7]
 1152 001e 002B     	 cmp r3,#0
 1153 0020 02D0     	 beq .L70
 674:../SSC/Src/objdef.c ****     {
 675:../SSC/Src/objdef.c ****         /*subindex 1 has an offset of 16Bit (even if Si0 is only an UINT8) */
 676:../SSC/Src/objdef.c ****         bitOffset +=16;
 1154              	 .loc 1 676 0
 1155 0022 BB8A     	 ldrh r3,[r7,#20]
 1156 0024 1033     	 adds r3,r3,#16
 1157 0026 BB82     	 strh r3,[r7,#20]
 1158              	.L70:
 677:../SSC/Src/objdef.c ****     }
 678:../SSC/Src/objdef.c **** 
 679:../SSC/Src/objdef.c ****     if (objCode == OBJCODE_VAR)
 1159              	 .loc 1 679 0
 1160 0028 FB7B     	 ldrb r3,[r7,#15]
 1161 002a 072B     	 cmp r3,#7
 1162 002c 01D1     	 bne .L71
 680:../SSC/Src/objdef.c ****     {
 681:../SSC/Src/objdef.c ****         return 0;
 1163              	 .loc 1 681 0
 1164 002e 0023     	 movs r3,#0
 1165 0030 A9E0     	 b .L72
 1166              	.L71:
 682:../SSC/Src/objdef.c ****     }
 683:../SSC/Src/objdef.c **** 
 684:../SSC/Src/objdef.c ****     for (i = 1; i <= subindex; i++)
 1167              	 .loc 1 684 0
 1168 0032 0123     	 movs r3,#1
 1169 0034 FB82     	 strh r3,[r7,#22]
 1170 0036 9FE0     	 b .L73
 1171              	.L93:
 685:../SSC/Src/objdef.c ****     {
 686:../SSC/Src/objdef.c ****         /* get the entry description */
 687:../SSC/Src/objdef.c ****         if ((objCode == OBJCODE_ARR)
 1172              	 .loc 1 687 0
 1173 0038 FB7B     	 ldrb r3,[r7,#15]
 1174 003a 082B     	 cmp r3,#8
 1175 003c 04D1     	 bne .L74
 688:../SSC/Src/objdef.c ****            )
 689:../SSC/Src/objdef.c ****            {
 690:../SSC/Src/objdef.c ****             pEntry = &pObjEntry->pEntryDesc[1];
 1176              	 .loc 1 690 0
 1177 003e 3B68     	 ldr r3,[r7]
 1178 0040 1B69     	 ldr r3,[r3,#16]
 1179 0042 0633     	 adds r3,r3,#6
 1180 0044 3B61     	 str r3,[r7,#16]
 1181 0046 08E0     	 b .L75
 1182              	.L74:
 691:../SSC/Src/objdef.c ****            }
 692:../SSC/Src/objdef.c ****         else
 693:../SSC/Src/objdef.c ****         {
 694:../SSC/Src/objdef.c ****             pEntry = &pObjEntry->pEntryDesc[i];
 1183              	 .loc 1 694 0
 1184 0048 3B68     	 ldr r3,[r7]
 1185 004a 1969     	 ldr r1,[r3,#16]
 1186 004c FA8A     	 ldrh r2,[r7,#22]
 1187 004e 1346     	 mov r3,r2
 1188 0050 5B00     	 lsls r3,r3,#1
 1189 0052 1344     	 add r3,r3,r2
 1190 0054 5B00     	 lsls r3,r3,#1
 1191 0056 0B44     	 add r3,r3,r1
 1192 0058 3B61     	 str r3,[r7,#16]
 1193              	.L75:
 695:../SSC/Src/objdef.c ****         }
 696:../SSC/Src/objdef.c **** 
 697:../SSC/Src/objdef.c ****         switch (pEntry->DataType)
 1194              	 .loc 1 697 0
 1195 005a 3B69     	 ldr r3,[r7,#16]
 1196 005c 1B88     	 ldrh r3,[r3]
 1197 005e 152B     	 cmp r3,#21
 1198 0060 6BD0     	 beq .L77
 1199 0062 152B     	 cmp r3,#21
 1200 0064 0FDC     	 bgt .L78
 1201 0066 082B     	 cmp r3,#8
 1202 0068 08DC     	 bgt .L79
 1203 006a 072B     	 cmp r3,#7
 1204 006c 43DA     	 bge .L80
 1205 006e 042B     	 cmp r3,#4
 1206 0070 41D0     	 beq .L80
 1207 0072 062B     	 cmp r3,#6
 1208 0074 20D0     	 beq .L81
 1209 0076 032B     	 cmp r3,#3
 1210 0078 1ED0     	 beq .L81
 1211 007a 6EE0     	 b .L76
 1212              	.L79:
 1213 007c 0B2B     	 cmp r3,#11
 1214 007e 1BD0     	 beq .L81
 1215 0080 112B     	 cmp r3,#17
 1216 0082 5AD0     	 beq .L77
 1217 0084 69E0     	 b .L76
 1218              	.L78:
 1219 0086 2E2B     	 cmp r3,#46
 1220 0088 16D0     	 beq .L81
 1221 008a 2E2B     	 cmp r3,#46
 1222 008c 06DC     	 bgt .L82
 1223 008e 1F2B     	 cmp r3,#31
 1224 0090 12D0     	 beq .L81
 1225 0092 202B     	 cmp r3,#32
 1226 0094 2FD0     	 beq .L80
 1227 0096 1B2B     	 cmp r3,#27
 1228 0098 4FD0     	 beq .L77
 1229 009a 5EE0     	 b .L76
 1230              	.L82:
 1231 009c B3F5187F 	 cmp r3,#608
 1232 00a0 0AD0     	 beq .L81
 1233 00a2 B3F5187F 	 cmp r3,#608
 1234 00a6 02DC     	 bgt .L83
 1235 00a8 2F2B     	 cmp r3,#47
 1236 00aa 24D0     	 beq .L80
 1237 00ac 55E0     	 b .L76
 1238              	.L83:
 1239 00ae A3F26223 	 subw r3,r3,#610
 1240 00b2 012B     	 cmp r3,#1
 1241 00b4 51D8     	 bhi .L76
 1242 00b6 1EE0     	 b .L80
 1243              	.L81:
 698:../SSC/Src/objdef.c ****         {
 699:../SSC/Src/objdef.c ****         case    DEFTYPE_INTEGER16:
 700:../SSC/Src/objdef.c ****         case    DEFTYPE_UNSIGNED16:
 701:../SSC/Src/objdef.c ****         case    DEFTYPE_BITARR16:
 702:../SSC/Src/objdef.c ****         case    DEFTYPE_WORD:
 703:../SSC/Src/objdef.c ****         case    DEFTYPE_UNICODE_STRING:
 704:../SSC/Src/objdef.c ****         case    DEFTYPE_ARRAY_OF_INT :
 705:../SSC/Src/objdef.c **** 
 706:../SSC/Src/objdef.c **** #if OBJ_WORD_ALIGN    || OBJ_DWORD_ALIGN
 707:../SSC/Src/objdef.c ****             /* the 16-bit variables in the structure are word-aligned,
 708:../SSC/Src/objdef.c ****                align the actual bitOffset to a word */
 709:../SSC/Src/objdef.c ****             bitOffset = (bitOffset+15) & 0xFFF0;
 1244              	 .loc 1 709 0
 1245 00b8 BB8A     	 ldrh r3,[r7,#20]
 1246 00ba 0F33     	 adds r3,r3,#15
 1247 00bc 9BB2     	 uxth r3,r3
 1248 00be 23F00F03 	 bic r3,r3,#15
 1249 00c2 BB82     	 strh r3,[r7,#20]
 710:../SSC/Src/objdef.c **** #endif
 711:../SSC/Src/objdef.c **** 
 712:../SSC/Src/objdef.c **** 
 713:../SSC/Src/objdef.c ****             if (i < subindex)
 1250              	 .loc 1 713 0
 1251 00c4 FB79     	 ldrb r3,[r7,#7]
 1252 00c6 9BB2     	 uxth r3,r3
 1253 00c8 FA8A     	 ldrh r2,[r7,#22]
 1254 00ca 9A42     	 cmp r2,r3
 1255 00cc 12D2     	 bcs .L84
 714:../SSC/Src/objdef.c ****             {
 715:../SSC/Src/objdef.c ****                 if((pEntry->DataType == DEFTYPE_UNICODE_STRING)
 1256              	 .loc 1 715 0
 1257 00ce 3B69     	 ldr r3,[r7,#16]
 1258 00d0 1B88     	 ldrh r3,[r3]
 1259 00d2 0B2B     	 cmp r3,#11
 1260 00d4 04D0     	 beq .L85
 716:../SSC/Src/objdef.c ****                     ||(pEntry->DataType == DEFTYPE_ARRAY_OF_INT))
 1261              	 .loc 1 716 0
 1262 00d6 3B69     	 ldr r3,[r7,#16]
 1263 00d8 1B88     	 ldrh r3,[r3]
 1264 00da B3F5187F 	 cmp r3,#608
 1265 00de 05D1     	 bne .L86
 1266              	.L85:
 717:../SSC/Src/objdef.c ****                 {
 718:../SSC/Src/objdef.c ****                     bitOffset += pEntry->BitLength;
 1267              	 .loc 1 718 0
 1268 00e0 3B69     	 ldr r3,[r7,#16]
 1269 00e2 5A88     	 ldrh r2,[r3,#2]
 1270 00e4 BB8A     	 ldrh r3,[r7,#20]
 1271 00e6 1344     	 add r3,r3,r2
 1272 00e8 BB82     	 strh r3,[r7,#20]
 1273 00ea 03E0     	 b .L84
 1274              	.L86:
 719:../SSC/Src/objdef.c ****                 }
 720:../SSC/Src/objdef.c ****                 else
 721:../SSC/Src/objdef.c ****                 {
 722:../SSC/Src/objdef.c ****                     bitOffset += 16;
 1275              	 .loc 1 722 0
 1276 00ec BB8A     	 ldrh r3,[r7,#20]
 1277 00ee 1033     	 adds r3,r3,#16
 1278 00f0 BB82     	 strh r3,[r7,#20]
 723:../SSC/Src/objdef.c ****                 }
 724:../SSC/Src/objdef.c ****             }
 725:../SSC/Src/objdef.c ****             break;
 1279              	 .loc 1 725 0
 1280 00f2 3EE0     	 b .L87
 1281              	.L84:
 1282 00f4 3DE0     	 b .L87
 1283              	.L80:
 726:../SSC/Src/objdef.c ****         case    DEFTYPE_UNSIGNED32:
 727:../SSC/Src/objdef.c ****         case    DEFTYPE_INTEGER32:
 728:../SSC/Src/objdef.c ****         case    DEFTYPE_REAL32:
 729:../SSC/Src/objdef.c ****         case    DEFTYPE_BITARR32:
 730:../SSC/Src/objdef.c ****         case    DEFTYPE_DWORD:
 731:../SSC/Src/objdef.c ****         case    DEFTYPE_ARRAY_OF_DINT :
 732:../SSC/Src/objdef.c ****         case    DEFTYPE_ARRAY_OF_UDINT:
 733:../SSC/Src/objdef.c **** #if OBJ_DWORD_ALIGN
 734:../SSC/Src/objdef.c ****             /* the 32-bit variables in the structure are dword-aligned,
 735:../SSC/Src/objdef.c ****                align the actual bitOffset to a dword */
 736:../SSC/Src/objdef.c ****             bitOffset = (bitOffset+31) & 0xFFE0;
 1284              	 .loc 1 736 0
 1285 00f6 BB8A     	 ldrh r3,[r7,#20]
 1286 00f8 1F33     	 adds r3,r3,#31
 1287 00fa 9BB2     	 uxth r3,r3
 1288 00fc 23F01F03 	 bic r3,r3,#31
 1289 0100 BB82     	 strh r3,[r7,#20]
 737:../SSC/Src/objdef.c **** #elif OBJ_WORD_ALIGN
 738:../SSC/Src/objdef.c ****             /* the 32-bit variables in the structure are word-aligned,
 739:../SSC/Src/objdef.c ****                align the actual bitOffset to a word */
 740:../SSC/Src/objdef.c ****             bitOffset = (bitOffset+15) & 0xFFF0;
 741:../SSC/Src/objdef.c **** #endif
 742:../SSC/Src/objdef.c **** 
 743:../SSC/Src/objdef.c ****             if (i < subindex)
 1290              	 .loc 1 743 0
 1291 0102 FB79     	 ldrb r3,[r7,#7]
 1292 0104 9BB2     	 uxth r3,r3
 1293 0106 FA8A     	 ldrh r2,[r7,#22]
 1294 0108 9A42     	 cmp r2,r3
 1295 010a 15D2     	 bcs .L88
 744:../SSC/Src/objdef.c ****             {
 745:../SSC/Src/objdef.c ****                 if((pEntry->DataType == DEFTYPE_ARRAY_OF_DINT)
 1296              	 .loc 1 745 0
 1297 010c 3B69     	 ldr r3,[r7,#16]
 1298 010e 1B88     	 ldrh r3,[r3]
 1299 0110 40F26222 	 movw r2,#610
 1300 0114 9342     	 cmp r3,r2
 1301 0116 05D0     	 beq .L89
 746:../SSC/Src/objdef.c ****                     ||(pEntry->DataType == DEFTYPE_ARRAY_OF_UDINT))
 1302              	 .loc 1 746 0
 1303 0118 3B69     	 ldr r3,[r7,#16]
 1304 011a 1B88     	 ldrh r3,[r3]
 1305 011c 40F26322 	 movw r2,#611
 1306 0120 9342     	 cmp r3,r2
 1307 0122 05D1     	 bne .L90
 1308              	.L89:
 747:../SSC/Src/objdef.c ****                 {
 748:../SSC/Src/objdef.c ****                     bitOffset += pEntry->BitLength;
 1309              	 .loc 1 748 0
 1310 0124 3B69     	 ldr r3,[r7,#16]
 1311 0126 5A88     	 ldrh r2,[r3,#2]
 1312 0128 BB8A     	 ldrh r3,[r7,#20]
 1313 012a 1344     	 add r3,r3,r2
 1314 012c BB82     	 strh r3,[r7,#20]
 1315 012e 03E0     	 b .L88
 1316              	.L90:
 749:../SSC/Src/objdef.c ****                 }
 750:../SSC/Src/objdef.c ****                 else
 751:../SSC/Src/objdef.c ****                 {
 752:../SSC/Src/objdef.c ****                    bitOffset += 32;
 1317              	 .loc 1 752 0
 1318 0130 BB8A     	 ldrh r3,[r7,#20]
 1319 0132 2033     	 adds r3,r3,#32
 1320 0134 BB82     	 strh r3,[r7,#20]
 753:../SSC/Src/objdef.c ****                 }
 754:../SSC/Src/objdef.c ****             }
 755:../SSC/Src/objdef.c ****             break;
 1321              	 .loc 1 755 0
 1322 0136 1CE0     	 b .L87
 1323              	.L88:
 1324 0138 1BE0     	 b .L87
 1325              	.L77:
 756:../SSC/Src/objdef.c ****         
 757:../SSC/Src/objdef.c ****         case DEFTYPE_REAL64:
 758:../SSC/Src/objdef.c ****         case DEFTYPE_INTEGER64:
 759:../SSC/Src/objdef.c ****         case DEFTYPE_UNSIGNED64:
 760:../SSC/Src/objdef.c **** #if OBJ_DWORD_ALIGN
 761:../SSC/Src/objdef.c ****             /* the 64-bit variables in the structure are dword-aligned,
 762:../SSC/Src/objdef.c ****                align the actual bitOffset to a dword */
 763:../SSC/Src/objdef.c ****             bitOffset = (bitOffset + 31) & 0xFFE0;
 1326              	 .loc 1 763 0
 1327 013a BB8A     	 ldrh r3,[r7,#20]
 1328 013c 1F33     	 adds r3,r3,#31
 1329 013e 9BB2     	 uxth r3,r3
 1330 0140 23F01F03 	 bic r3,r3,#31
 1331 0144 BB82     	 strh r3,[r7,#20]
 764:../SSC/Src/objdef.c **** #elif OBJ_WORD_ALIGN
 765:../SSC/Src/objdef.c ****             /* the 64-bit variables in the structure are word-aligned,
 766:../SSC/Src/objdef.c ****                align the actual bitOffset to a word */
 767:../SSC/Src/objdef.c ****             bitOffset = (bitOffset + 15) & 0xFFF0;
 768:../SSC/Src/objdef.c **** #endif
 769:../SSC/Src/objdef.c **** 
 770:../SSC/Src/objdef.c ****             if (i < subindex)
 1332              	 .loc 1 770 0
 1333 0146 FB79     	 ldrb r3,[r7,#7]
 1334 0148 9BB2     	 uxth r3,r3
 1335 014a FA8A     	 ldrh r2,[r7,#22]
 1336 014c 9A42     	 cmp r2,r3
 1337 014e 03D2     	 bcs .L91
 771:../SSC/Src/objdef.c ****             {
 772:../SSC/Src/objdef.c **** 
 773:../SSC/Src/objdef.c ****                 bitOffset += 64;
 1338              	 .loc 1 773 0
 1339 0150 BB8A     	 ldrh r3,[r7,#20]
 1340 0152 4033     	 adds r3,r3,#64
 1341 0154 BB82     	 strh r3,[r7,#20]
 774:../SSC/Src/objdef.c ****             }
 775:../SSC/Src/objdef.c ****             break;
 1342              	 .loc 1 775 0
 1343 0156 0CE0     	 b .L87
 1344              	.L91:
 1345 0158 0BE0     	 b .L87
 1346              	.L76:
 776:../SSC/Src/objdef.c ****         default:
 777:../SSC/Src/objdef.c ****             /* align the actual bitOffset to a byte */
 778:../SSC/Src/objdef.c ****             if (i < subindex)
 1347              	 .loc 1 778 0
 1348 015a FB79     	 ldrb r3,[r7,#7]
 1349 015c 9BB2     	 uxth r3,r3
 1350 015e FA8A     	 ldrh r2,[r7,#22]
 1351 0160 9A42     	 cmp r2,r3
 1352 0162 05D2     	 bcs .L92
 779:../SSC/Src/objdef.c ****             {
 780:../SSC/Src/objdef.c ****                 bitOffset += pEntry->BitLength;
 1353              	 .loc 1 780 0
 1354 0164 3B69     	 ldr r3,[r7,#16]
 1355 0166 5A88     	 ldrh r2,[r3,#2]
 1356 0168 BB8A     	 ldrh r3,[r7,#20]
 1357 016a 1344     	 add r3,r3,r2
 1358 016c BB82     	 strh r3,[r7,#20]
 781:../SSC/Src/objdef.c ****             }
 782:../SSC/Src/objdef.c ****             break;
 1359              	 .loc 1 782 0
 1360 016e FFE7     	 b .L94
 1361              	.L92:
 1362              	.L94:
 1363 0170 00BF     	 nop
 1364              	.L87:
 684:../SSC/Src/objdef.c ****     {
 1365              	 .loc 1 684 0 discriminator 2
 1366 0172 FB8A     	 ldrh r3,[r7,#22]
 1367 0174 0133     	 adds r3,r3,#1
 1368 0176 FB82     	 strh r3,[r7,#22]
 1369              	.L73:
 684:../SSC/Src/objdef.c ****     {
 1370              	 .loc 1 684 0 is_stmt 0 discriminator 1
 1371 0178 FB79     	 ldrb r3,[r7,#7]
 1372 017a 9BB2     	 uxth r3,r3
 1373 017c FA8A     	 ldrh r2,[r7,#22]
 1374 017e 9A42     	 cmp r2,r3
 1375 0180 7FF65AAF 	 bls .L93
 783:../SSC/Src/objdef.c ****         }
 784:../SSC/Src/objdef.c ****     }
 785:../SSC/Src/objdef.c **** 
 786:../SSC/Src/objdef.c ****     return bitOffset;
 1376              	 .loc 1 786 0 is_stmt 1
 1377 0184 BB8A     	 ldrh r3,[r7,#20]
 1378              	.L72:
 787:../SSC/Src/objdef.c **** }
 1379              	 .loc 1 787 0
 1380 0186 1846     	 mov r0,r3
 1381 0188 1C37     	 adds r7,r7,#28
 1382              	.LCFI47:
 1383              	 .cfi_def_cfa_offset 4
 1384 018a BD46     	 mov sp,r7
 1385              	.LCFI48:
 1386              	 .cfi_def_cfa_register 13
 1387              	 
 1388 018c 5DF8047B 	 ldr r7,[sp],#4
 1389              	.LCFI49:
 1390              	 .cfi_restore 7
 1391              	 .cfi_def_cfa_offset 0
 1392 0190 7047     	 bx lr
 1393              	 .cfi_endproc
 1394              	.LFE183:
 1396 0192 00BF     	 .section .text.CheckSyncTypeValue,"ax",%progbits
 1397              	 .align 2
 1398              	 .global CheckSyncTypeValue
 1399              	 .thumb
 1400              	 .thumb_func
 1402              	CheckSyncTypeValue:
 1403              	.LFB184:
 788:../SSC/Src/objdef.c **** 
 789:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
 790:../SSC/Src/objdef.c **** /**
 791:../SSC/Src/objdef.c ****  \param     index                 index of the SyncManager Parameter object 
 792:../SSC/Src/objdef.c ****  \param     NewSyncType           New value for the Sync Type (SubIndex 1)
 793:../SSC/Src/objdef.c **** 
 794:../SSC/Src/objdef.c ****  \return    result                Result of the value validation
 795:../SSC/Src/objdef.c **** 
 796:../SSC/Src/objdef.c ****  \brief    Checks if the new Sync type value is valid
 797:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
 798:../SSC/Src/objdef.c **** UINT8 CheckSyncTypeValue(UINT16 index, UINT16 NewSyncType)
 799:../SSC/Src/objdef.c **** {
 1404              	 .loc 1 799 0
 1405              	 .cfi_startproc
 1406              	 
 1407              	 
 1408              	 
 1409 0000 80B4     	 push {r7}
 1410              	.LCFI50:
 1411              	 .cfi_def_cfa_offset 4
 1412              	 .cfi_offset 7,-4
 1413 0002 83B0     	 sub sp,sp,#12
 1414              	.LCFI51:
 1415              	 .cfi_def_cfa_offset 16
 1416 0004 00AF     	 add r7,sp,#0
 1417              	.LCFI52:
 1418              	 .cfi_def_cfa_register 7
 1419 0006 0346     	 mov r3,r0
 1420 0008 0A46     	 mov r2,r1
 1421 000a FB80     	 strh r3,[r7,#6]
 1422 000c 1346     	 mov r3,r2
 1423 000e BB80     	 strh r3,[r7,#4]
 800:../SSC/Src/objdef.c ****     switch (NewSyncType)
 1424              	 .loc 1 800 0
 1425 0010 BB88     	 ldrh r3,[r7,#4]
 1426 0012 222B     	 cmp r3,#34
 1427 0014 00F2BB80 	 bhi .L96
 1428 0018 01A2     	 adr r2,.L98
 1429 001a 52F823F0 	 ldr pc,[r2,r3,lsl#2]
 1430 001e 00BF     	 .p2align 2
 1431              	.L98:
 1432 0020 AD000000 	 .word .L97+1
 1433 0024 B1000000 	 .word .L99+1
 1434 0028 23010000 	 .word .L100+1
 1435 002c 59010000 	 .word .L101+1
 1436 0030 8F010000 	 .word .L96+1
 1437 0034 8F010000 	 .word .L96+1
 1438 0038 8F010000 	 .word .L96+1
 1439 003c 8F010000 	 .word .L96+1
 1440 0040 8F010000 	 .word .L96+1
 1441 0044 8F010000 	 .word .L96+1
 1442 0048 8F010000 	 .word .L96+1
 1443 004c 8F010000 	 .word .L96+1
 1444 0050 8F010000 	 .word .L96+1
 1445 0054 8F010000 	 .word .L96+1
 1446 0058 8F010000 	 .word .L96+1
 1447 005c 8F010000 	 .word .L96+1
 1448 0060 8F010000 	 .word .L96+1
 1449 0064 8F010000 	 .word .L96+1
 1450 0068 8F010000 	 .word .L96+1
 1451 006c 8F010000 	 .word .L96+1
 1452 0070 8F010000 	 .word .L96+1
 1453 0074 8F010000 	 .word .L96+1
 1454 0078 8F010000 	 .word .L96+1
 1455 007c 8F010000 	 .word .L96+1
 1456 0080 8F010000 	 .word .L96+1
 1457 0084 8F010000 	 .word .L96+1
 1458 0088 8F010000 	 .word .L96+1
 1459 008c 8F010000 	 .word .L96+1
 1460 0090 8F010000 	 .word .L96+1
 1461 0094 8F010000 	 .word .L96+1
 1462 0098 8F010000 	 .word .L96+1
 1463 009c 8F010000 	 .word .L96+1
 1464 00a0 8F010000 	 .word .L96+1
 1465 00a4 8F010000 	 .word .L96+1
 1466 00a8 FF000000 	 .word .L102+1
 1467              	 .p2align 1
 1468              	.L97:
 801:../SSC/Src/objdef.c ****     {
 802:../SSC/Src/objdef.c ****     case SYNCTYPE_FREERUN:
 803:../SSC/Src/objdef.c ****         return 0; //free run sync mode is always accepted
 1469              	 .loc 1 803 0
 1470 00ac 0023     	 movs r3,#0
 1471 00ae 6FE0     	 b .L103
 1472              	.L99:
 804:../SSC/Src/objdef.c **** 
 805:../SSC/Src/objdef.c ****     case SYNCTYPE_SM_SYNCHRON:
 806:../SSC/Src/objdef.c ****         if ((index == 0x1C32) 
 1473              	 .loc 1 806 0
 1474 00b0 FB88     	 ldrh r3,[r7,#6]
 1475 00b2 41F63242 	 movw r2,#7218
 1476 00b6 9342     	 cmp r3,r2
 1477 00b8 0BD1     	 bne .L104
 807:../SSC/Src/objdef.c ****             && (nPdOutputSize > 0) 
 1478              	 .loc 1 807 0
 1479 00ba 384B     	 ldr r3,.L111
 1480 00bc 1B88     	 ldrh r3,[r3]
 1481 00be 002B     	 cmp r3,#0
 1482 00c0 07D0     	 beq .L104
 808:../SSC/Src/objdef.c ****             && ((sSyncManOutPar.u16SyncTypesSupported & SYNCTYPE_SYNCHRONSUPP) > 0))
 1483              	 .loc 1 808 0
 1484 00c2 374B     	 ldr r3,.L111+4
 1485 00c4 9B89     	 ldrh r3,[r3,#12]
 1486 00c6 03F00203 	 and r3,r3,#2
 1487 00ca 002B     	 cmp r3,#0
 1488 00cc 01DD     	 ble .L104
 809:../SSC/Src/objdef.c ****         {
 810:../SSC/Src/objdef.c ****             /*SyncManager sync mode is supported and output process data is configured*/
 811:../SSC/Src/objdef.c ****             return 0;
 1489              	 .loc 1 811 0
 1490 00ce 0023     	 movs r3,#0
 1491 00d0 5EE0     	 b .L103
 1492              	.L104:
 812:../SSC/Src/objdef.c ****         }
 813:../SSC/Src/objdef.c ****         else
 814:../SSC/Src/objdef.c ****         if ((index == 0x1C33) 
 1493              	 .loc 1 814 0
 1494 00d2 FB88     	 ldrh r3,[r7,#6]
 1495 00d4 41F63342 	 movw r2,#7219
 1496 00d8 9342     	 cmp r3,r2
 1497 00da 0FD1     	 bne .L105
 815:../SSC/Src/objdef.c ****             && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_SYNCHRONSUPP) > 0)
 1498              	 .loc 1 815 0
 1499 00dc 314B     	 ldr r3,.L111+8
 1500 00de 9B89     	 ldrh r3,[r3,#12]
 1501 00e0 03F00203 	 and r3,r3,#2
 1502 00e4 002B     	 cmp r3,#0
 1503 00e6 09DD     	 ble .L105
 816:../SSC/Src/objdef.c ****             && (nPdOutputSize == 0) 
 1504              	 .loc 1 816 0
 1505 00e8 2C4B     	 ldr r3,.L111
 1506 00ea 1B88     	 ldrh r3,[r3]
 1507 00ec 002B     	 cmp r3,#0
 1508 00ee 05D1     	 bne .L105
 817:../SSC/Src/objdef.c ****             && (nPdInputSize > 0))
 1509              	 .loc 1 817 0
 1510 00f0 2D4B     	 ldr r3,.L111+12
 1511 00f2 1B88     	 ldrh r3,[r3]
 1512 00f4 002B     	 cmp r3,#0
 1513 00f6 01D0     	 beq .L105
 818:../SSC/Src/objdef.c ****             {
 819:../SSC/Src/objdef.c ****                 /*SyncManager sync mode is supported and input only shall be configured*/
 820:../SSC/Src/objdef.c ****                 return 0;
 1514              	 .loc 1 820 0
 1515 00f8 0023     	 movs r3,#0
 1516 00fa 49E0     	 b .L103
 1517              	.L105:
 821:../SSC/Src/objdef.c ****             }
 822:../SSC/Src/objdef.c ****         break;
 1518              	 .loc 1 822 0
 1519 00fc 47E0     	 b .L96
 1520              	.L102:
 823:../SSC/Src/objdef.c **** 
 824:../SSC/Src/objdef.c ****     case SYNCTYPE_SM2_SYNCHRON:
 825:../SSC/Src/objdef.c ****         if ((index == 0x1C33) 
 1521              	 .loc 1 825 0
 1522 00fe FB88     	 ldrh r3,[r7,#6]
 1523 0100 41F63342 	 movw r2,#7219
 1524 0104 9342     	 cmp r3,r2
 1525 0106 0BD1     	 bne .L106
 826:../SSC/Src/objdef.c ****             && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_SYNCHRONSUPP) > 0)
 1526              	 .loc 1 826 0
 1527 0108 264B     	 ldr r3,.L111+8
 1528 010a 9B89     	 ldrh r3,[r3,#12]
 1529 010c 03F00203 	 and r3,r3,#2
 1530 0110 002B     	 cmp r3,#0
 1531 0112 05DD     	 ble .L106
 827:../SSC/Src/objdef.c ****             && (nPdOutputSize > 0))
 1532              	 .loc 1 827 0
 1533 0114 214B     	 ldr r3,.L111
 1534 0116 1B88     	 ldrh r3,[r3]
 1535 0118 002B     	 cmp r3,#0
 1536 011a 01D0     	 beq .L106
 828:../SSC/Src/objdef.c ****             {
 829:../SSC/Src/objdef.c ****                 /*SyncManager sync mode is supported and outputs are defined*/
 830:../SSC/Src/objdef.c ****                 return 0;
 1537              	 .loc 1 830 0
 1538 011c 0023     	 movs r3,#0
 1539 011e 37E0     	 b .L103
 1540              	.L106:
 831:../SSC/Src/objdef.c ****             }
 832:../SSC/Src/objdef.c ****         break;
 1541              	 .loc 1 832 0
 1542 0120 35E0     	 b .L96
 1543              	.L100:
 833:../SSC/Src/objdef.c **** 
 834:../SSC/Src/objdef.c ****     case SYNCTYPE_DCSYNC0:
 835:../SSC/Src/objdef.c ****         if ((index == 0x1C32) && ((sSyncManOutPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC0SUPP) > 0
 1544              	 .loc 1 835 0
 1545 0122 FB88     	 ldrh r3,[r7,#6]
 1546 0124 41F63242 	 movw r2,#7218
 1547 0128 9342     	 cmp r3,r2
 1548 012a 07D1     	 bne .L107
 1549              	 .loc 1 835 0 is_stmt 0 discriminator 1
 1550 012c 1C4B     	 ldr r3,.L111+4
 1551 012e 9B89     	 ldrh r3,[r3,#12]
 1552 0130 03F00403 	 and r3,r3,#4
 1553 0134 002B     	 cmp r3,#0
 1554 0136 01DD     	 ble .L107
 836:../SSC/Src/objdef.c ****         {
 837:../SSC/Src/objdef.c ****             return 0;
 1555              	 .loc 1 837 0 is_stmt 1
 1556 0138 0023     	 movs r3,#0
 1557 013a 29E0     	 b .L103
 1558              	.L107:
 838:../SSC/Src/objdef.c ****         }
 839:../SSC/Src/objdef.c ****         else
 840:../SSC/Src/objdef.c ****         if ((index == 0x1C33) && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC0SUPP) > 0)
 1559              	 .loc 1 840 0
 1560 013c FB88     	 ldrh r3,[r7,#6]
 1561 013e 41F63342 	 movw r2,#7219
 1562 0142 9342     	 cmp r3,r2
 1563 0144 07D1     	 bne .L108
 1564              	 .loc 1 840 0 is_stmt 0 discriminator 1
 1565 0146 174B     	 ldr r3,.L111+8
 1566 0148 9B89     	 ldrh r3,[r3,#12]
 1567 014a 03F00403 	 and r3,r3,#4
 1568 014e 002B     	 cmp r3,#0
 1569 0150 01DD     	 ble .L108
 841:../SSC/Src/objdef.c ****         {
 842:../SSC/Src/objdef.c ****             return 0;
 1570              	 .loc 1 842 0 is_stmt 1
 1571 0152 0023     	 movs r3,#0
 1572 0154 1CE0     	 b .L103
 1573              	.L108:
 843:../SSC/Src/objdef.c ****         }
 844:../SSC/Src/objdef.c ****         break;
 1574              	 .loc 1 844 0
 1575 0156 1AE0     	 b .L96
 1576              	.L101:
 845:../SSC/Src/objdef.c **** 
 846:../SSC/Src/objdef.c ****     case SYNCTYPE_DCSYNC1:
 847:../SSC/Src/objdef.c ****         if ((index == 0x1C32) && ((sSyncManOutPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC1SUPP) > 0
 1577              	 .loc 1 847 0
 1578 0158 FB88     	 ldrh r3,[r7,#6]
 1579 015a 41F63242 	 movw r2,#7218
 1580 015e 9342     	 cmp r3,r2
 1581 0160 07D1     	 bne .L109
 1582              	 .loc 1 847 0 is_stmt 0 discriminator 1
 1583 0162 0F4B     	 ldr r3,.L111+4
 1584 0164 9B89     	 ldrh r3,[r3,#12]
 1585 0166 03F00803 	 and r3,r3,#8
 1586 016a 002B     	 cmp r3,#0
 1587 016c 01DD     	 ble .L109
 848:../SSC/Src/objdef.c ****         {
 849:../SSC/Src/objdef.c ****             return 0;
 1588              	 .loc 1 849 0 is_stmt 1
 1589 016e 0023     	 movs r3,#0
 1590 0170 0EE0     	 b .L103
 1591              	.L109:
 850:../SSC/Src/objdef.c ****         }
 851:../SSC/Src/objdef.c ****         else
 852:../SSC/Src/objdef.c ****         if ((index == 0x1C33) && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC1SUPP) > 0)
 1592              	 .loc 1 852 0
 1593 0172 FB88     	 ldrh r3,[r7,#6]
 1594 0174 41F63342 	 movw r2,#7219
 1595 0178 9342     	 cmp r3,r2
 1596 017a 07D1     	 bne .L110
 1597              	 .loc 1 852 0 is_stmt 0 discriminator 1
 1598 017c 094B     	 ldr r3,.L111+8
 1599 017e 9B89     	 ldrh r3,[r3,#12]
 1600 0180 03F00803 	 and r3,r3,#8
 1601 0184 002B     	 cmp r3,#0
 1602 0186 01DD     	 ble .L110
 853:../SSC/Src/objdef.c ****         {
 854:../SSC/Src/objdef.c ****             return 0;
 1603              	 .loc 1 854 0 is_stmt 1
 1604 0188 0023     	 movs r3,#0
 1605 018a 01E0     	 b .L103
 1606              	.L110:
 855:../SSC/Src/objdef.c ****         }
 856:../SSC/Src/objdef.c ****         break;
 1607              	 .loc 1 856 0
 1608 018c 00BF     	 nop
 1609              	.L96:
 857:../SSC/Src/objdef.c ****     } //switch 
 858:../SSC/Src/objdef.c ****     return ABORTIDX_VALUE_EXCEEDED;
 1610              	 .loc 1 858 0
 1611 018e 1223     	 movs r3,#18
 1612              	.L103:
 859:../SSC/Src/objdef.c **** 
 860:../SSC/Src/objdef.c **** }
 1613              	 .loc 1 860 0
 1614 0190 1846     	 mov r0,r3
 1615 0192 0C37     	 adds r7,r7,#12
 1616              	.LCFI53:
 1617              	 .cfi_def_cfa_offset 4
 1618 0194 BD46     	 mov sp,r7
 1619              	.LCFI54:
 1620              	 .cfi_def_cfa_register 13
 1621              	 
 1622 0196 5DF8047B 	 ldr r7,[sp],#4
 1623              	.LCFI55:
 1624              	 .cfi_restore 7
 1625              	 .cfi_def_cfa_offset 0
 1626 019a 7047     	 bx lr
 1627              	.L112:
 1628              	 .align 2
 1629              	.L111:
 1630 019c 00000000 	 .word nPdOutputSize
 1631 01a0 00000000 	 .word sSyncManOutPar
 1632 01a4 00000000 	 .word sSyncManInPar
 1633 01a8 00000000 	 .word nPdInputSize
 1634              	 .cfi_endproc
 1635              	.LFE184:
 1637              	 .section .text.OBJ_Read,"ax",%progbits
 1638              	 .align 2
 1639              	 .global OBJ_Read
 1640              	 .thumb
 1641              	 .thumb_func
 1643              	OBJ_Read:
 1644              	.LFB185:
 861:../SSC/Src/objdef.c **** 
 862:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
 863:../SSC/Src/objdef.c **** /**
 864:../SSC/Src/objdef.c ****  \param     index                 index of the requested object.
 865:../SSC/Src/objdef.c ****  \param     subindex                subindex of the requested object.
 866:../SSC/Src/objdef.c ****  \param    objSize                Size of the object, returned by the function OBJ_GetObjectLength
 867:../SSC/Src/objdef.c ****                                      which was called before
 868:../SSC/Src/objdef.c ****  \param     pObjEntry            handle to the dictionary object returned by
 869:../SSC/Src/objdef.c ****                                      OBJ_GetObjectHandle which was called before
 870:../SSC/Src/objdef.c ****  \param    pData                    Pointer to the buffer where the read data shall be copied to
 871:../SSC/Src/objdef.c ****  \param    bCompleteAccess    Indicates if a complete read of all subindices of the
 872:../SSC/Src/objdef.c ****                                      object shall be done or not
 873:../SSC/Src/objdef.c **** 
 874:../SSC/Src/objdef.c ****  \return    result of the read operation (0 (success) or an abort code (ABORTIDX_.... defined in
 875:../SSC/Src/objdef.c ****             sdosrv.h))
 876:../SSC/Src/objdef.c **** 
 877:../SSC/Src/objdef.c ****  \brief    This function reads the requested object
 878:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
 879:../SSC/Src/objdef.c **** 
 880:../SSC/Src/objdef.c **** UINT8 OBJ_Read( UINT16 index, UINT8 subindex, UINT32 objSize, OBJCONST TOBJECT OBJMEM * pObjEntry, 
 881:../SSC/Src/objdef.c **** {
 1645              	 .loc 1 881 0
 1646              	 .cfi_startproc
 1647              	 
 1648              	 
 1649 0000 90B5     	 push {r4,r7,lr}
 1650              	.LCFI56:
 1651              	 .cfi_def_cfa_offset 12
 1652              	 .cfi_offset 4,-12
 1653              	 .cfi_offset 7,-8
 1654              	 .cfi_offset 14,-4
 1655 0002 91B0     	 sub sp,sp,#68
 1656              	.LCFI57:
 1657              	 .cfi_def_cfa_offset 80
 1658 0004 02AF     	 add r7,sp,#8
 1659              	.LCFI58:
 1660              	 .cfi_def_cfa 7,72
 1661 0006 BA60     	 str r2,[r7,#8]
 1662 0008 7B60     	 str r3,[r7,#4]
 1663 000a 0346     	 mov r3,r0
 1664 000c FB81     	 strh r3,[r7,#14]
 1665 000e 0B46     	 mov r3,r1
 1666 0010 7B73     	 strb r3,[r7,#13]
 882:../SSC/Src/objdef.c ****     UINT16 i = subindex;
 1667              	 .loc 1 882 0
 1668 0012 7B7B     	 ldrb r3,[r7,#13]
 1669 0014 FB86     	 strh r3,[r7,#54]
 883:../SSC/Src/objdef.c ****     /* get the information of ObjCode and MaxSubindex in local variables to support different types
 884:../SSC/Src/objdef.c ****     UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
 1670              	 .loc 1 884 0
 1671 0016 7B68     	 ldr r3,[r7,#4]
 1672 0018 9B89     	 ldrh r3,[r3,#12]
 1673 001a 03F47063 	 and r3,r3,#3840
 1674 001e 1B12     	 asrs r3,r3,#8
 1675 0020 87F82A30 	 strb r3,[r7,#42]
 885:../SSC/Src/objdef.c ****     UINT16 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSU
 1676              	 .loc 1 885 0
 1677 0024 7B68     	 ldr r3,[r7,#4]
 1678 0026 9B89     	 ldrh r3,[r3,#12]
 1679 0028 DBB2     	 uxtb r3,r3
 1680 002a BB86     	 strh r3,[r7,#52]
 886:../SSC/Src/objdef.c ****     OBJCONST TSDOINFOENTRYDESC OBJMEM *pEntry;
 887:../SSC/Src/objdef.c ****     /* lastSubindex is used for complete access to make loop over the requested entries
 888:../SSC/Src/objdef.c ****     to be read, we initialize this variable with the requested subindex that only
 889:../SSC/Src/objdef.c ****     one loop will be done for a single access */
 890:../SSC/Src/objdef.c ****     UINT16 lastSubindex = subindex;
 1681              	 .loc 1 890 0
 1682 002c 7B7B     	 ldrb r3,[r7,#13]
 1683 002e 7B86     	 strh r3,[r7,#50]
 891:../SSC/Src/objdef.c **** 
 892:../SSC/Src/objdef.c ****     if ( objCode != OBJCODE_VAR && index >= 0x1000 )
 1684              	 .loc 1 892 0
 1685 0030 97F82A30 	 ldrb r3,[r7,#42]
 1686 0034 072B     	 cmp r3,#7
 1687 0036 08D0     	 beq .L114
 1688              	 .loc 1 892 0 is_stmt 0 discriminator 1
 1689 0038 FB89     	 ldrh r3,[r7,#14]
 1690 003a B3F5805F 	 cmp r3,#4096
 1691 003e 04D3     	 bcc .L114
 893:../SSC/Src/objdef.c ****     {
 894:../SSC/Src/objdef.c ****         /* if the object is an array or record we have to get the maxSubindex from the
 895:../SSC/Src/objdef.c ****         actual value of subindex 0, which is stored as UINT16 at the beginning of the
 896:../SSC/Src/objdef.c ****         object's variable */
 897:../SSC/Src/objdef.c ****         maxSubindex = (*((UINT16 *) (pObjEntry->pVarPtr))) & 0x00FF;
 1692              	 .loc 1 897 0 is_stmt 1
 1693 0040 7B68     	 ldr r3,[r7,#4]
 1694 0042 9B69     	 ldr r3,[r3,#24]
 1695 0044 1B88     	 ldrh r3,[r3]
 1696 0046 DBB2     	 uxtb r3,r3
 1697 0048 BB86     	 strh r3,[r7,#52]
 1698              	.L114:
 898:../SSC/Src/objdef.c **** 
 899:../SSC/Src/objdef.c ****     }
 900:../SSC/Src/objdef.c **** 
 901:../SSC/Src/objdef.c ****     if ( bCompleteAccess )
 1699              	 .loc 1 901 0
 1700 004a 97F84C30 	 ldrb r3,[r7,#76]
 1701 004e 002B     	 cmp r3,#0
 1702 0050 0CD0     	 beq .L115
 902:../SSC/Src/objdef.c ****     {
 903:../SSC/Src/objdef.c ****         if ( objCode == OBJCODE_VAR || index < 0x1000 )
 1703              	 .loc 1 903 0
 1704 0052 97F82A30 	 ldrb r3,[r7,#42]
 1705 0056 072B     	 cmp r3,#7
 1706 0058 03D0     	 beq .L116
 1707              	 .loc 1 903 0 is_stmt 0 discriminator 1
 1708 005a FB89     	 ldrh r3,[r7,#14]
 1709 005c B3F5805F 	 cmp r3,#4096
 1710 0060 01D2     	 bcs .L117
 1711              	.L116:
 904:../SSC/Src/objdef.c ****         {
 905:../SSC/Src/objdef.c ****             /* complete access is not supported with simple objects or ENUM descriptions */
 906:../SSC/Src/objdef.c ****             return ABORTIDX_UNSUPPORTED_ACCESS;
 1712              	 .loc 1 906 0 is_stmt 1
 1713 0062 0523     	 movs r3,#5
 1714 0064 B0E2     	 b .L118
 1715              	.L117:
 907:../SSC/Src/objdef.c ****         }
 908:../SSC/Src/objdef.c **** 
 909:../SSC/Src/objdef.c **** 
 910:../SSC/Src/objdef.c ****         /* we read until the maximum subindex */
 911:../SSC/Src/objdef.c ****         lastSubindex = maxSubindex;
 1716              	 .loc 1 911 0
 1717 0066 BB8E     	 ldrh r3,[r7,#52]
 1718 0068 7B86     	 strh r3,[r7,#50]
 1719 006a 2DE0     	 b .L119
 1720              	.L115:
 912:../SSC/Src/objdef.c ****     }
 913:../SSC/Src/objdef.c ****     else
 914:../SSC/Src/objdef.c ****         if ( subindex > maxSubindex )
 1721              	 .loc 1 914 0
 1722 006c 7B7B     	 ldrb r3,[r7,#13]
 1723 006e 9BB2     	 uxth r3,r3
 1724 0070 BA8E     	 ldrh r2,[r7,#52]
 1725 0072 9A42     	 cmp r2,r3
 1726 0074 01D2     	 bcs .L120
 915:../SSC/Src/objdef.c ****         {
 916:../SSC/Src/objdef.c ****             /* the maximum subindex is reached */
 917:../SSC/Src/objdef.c ****             return ABORTIDX_SUBINDEX_NOT_EXISTING;
 1727              	 .loc 1 917 0
 1728 0076 1123     	 movs r3,#17
 1729 0078 A6E2     	 b .L118
 1730              	.L120:
 918:../SSC/Src/objdef.c ****         }
 919:../SSC/Src/objdef.c ****         else
 920:../SSC/Src/objdef.c ****         {
 921:../SSC/Src/objdef.c ****             /* get the corresponding entry description */
 922:../SSC/Src/objdef.c ****             pEntry = OBJ_GetEntryDesc(pObjEntry, (UINT8)i);
 1731              	 .loc 1 922 0
 1732 007a FB8E     	 ldrh r3,[r7,#54]
 1733 007c DBB2     	 uxtb r3,r3
 1734 007e 7868     	 ldr r0,[r7,#4]
 1735 0080 1946     	 mov r1,r3
 1736 0082 FFF7FEFF 	 bl OBJ_GetEntryDesc
 1737 0086 7862     	 str r0,[r7,#36]
 923:../SSC/Src/objdef.c **** 
 924:../SSC/Src/objdef.c ****             /*Check access only for non-align entries*/
 925:../SSC/Src/objdef.c ****             if(pEntry->ObjAccess != 0x0)
 1738              	 .loc 1 925 0
 1739 0088 7B6A     	 ldr r3,[r7,#36]
 1740 008a 9B88     	 ldrh r3,[r3,#4]
 1741 008c 002B     	 cmp r3,#0
 1742 008e 19D0     	 beq .L121
 926:../SSC/Src/objdef.c ****             {
 927:../SSC/Src/objdef.c ****                 /* check if we have read access (bits 0-2 (PREOP, SAFEOP, OP) of ObjAccess)
 928:../SSC/Src/objdef.c ****                 by comparing with the actual state (bits 1-3 (PREOP, SAFEOP, OP) of AL Status) */
 929:../SSC/Src/objdef.c ****                 if (0 == (((UINT8) ((pEntry->ObjAccess & ACCESS_READ)<<1)) & (nAlStatus & STATE_MAS
 1743              	 .loc 1 929 0
 1744 0090 7B6A     	 ldr r3,[r7,#36]
 1745 0092 9B88     	 ldrh r3,[r3,#4]
 1746 0094 DBB2     	 uxtb r3,r3
 1747 0096 03F00703 	 and r3,r3,#7
 1748 009a DBB2     	 uxtb r3,r3
 1749 009c 5B00     	 lsls r3,r3,#1
 1750 009e DBB2     	 uxtb r3,r3
 1751 00a0 1A46     	 mov r2,r3
 1752 00a2 A74B     	 ldr r3,.L173
 1753 00a4 1B78     	 ldrb r3,[r3]
 1754 00a6 03F00F03 	 and r3,r3,#15
 1755 00aa 1340     	 ands r3,r3,r2
 1756 00ac 002B     	 cmp r3,#0
 1757 00ae 0BD1     	 bne .L119
 930:../SSC/Src/objdef.c ****                 {
 931:../SSC/Src/objdef.c ****                     /* we don't have read access */
 932:../SSC/Src/objdef.c ****                     if ( (pEntry->ObjAccess & ACCESS_READ) == 0 )
 1758              	 .loc 1 932 0
 1759 00b0 7B6A     	 ldr r3,[r7,#36]
 1760 00b2 9B88     	 ldrh r3,[r3,#4]
 1761 00b4 03F00703 	 and r3,r3,#7
 1762 00b8 002B     	 cmp r3,#0
 1763 00ba 01D1     	 bne .L122
 933:../SSC/Src/objdef.c ****                     {
 934:../SSC/Src/objdef.c ****                         /* it is a write only entry */
 935:../SSC/Src/objdef.c ****                         return ABORTIDX_WRITE_ONLY_ENTRY;
 1764              	 .loc 1 935 0
 1765 00bc 0623     	 movs r3,#6
 1766 00be 83E2     	 b .L118
 1767              	.L122:
 936:../SSC/Src/objdef.c ****                     }
 937:../SSC/Src/objdef.c ****                     else
 938:../SSC/Src/objdef.c ****                     {
 939:../SSC/Src/objdef.c ****                         /* we don't have read access in this state */
 940:../SSC/Src/objdef.c ****                         return ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED;
 1768              	 .loc 1 940 0
 1769 00c0 1A23     	 movs r3,#26
 1770 00c2 81E2     	 b .L118
 1771              	.L121:
 941:../SSC/Src/objdef.c ****                     }
 942:../SSC/Src/objdef.c ****                 }
 943:../SSC/Src/objdef.c ****             }
 944:../SSC/Src/objdef.c ****             else
 945:../SSC/Src/objdef.c ****             {
 946:../SSC/Src/objdef.c ****                 return ABORTIDX_UNSUPPORTED_ACCESS;
 1772              	 .loc 1 946 0
 1773 00c4 0523     	 movs r3,#5
 1774 00c6 7FE2     	 b .L118
 1775              	.L119:
 947:../SSC/Src/objdef.c ****             }
 948:../SSC/Src/objdef.c **** 
 949:../SSC/Src/objdef.c ****         }
 950:../SSC/Src/objdef.c **** 
 951:../SSC/Src/objdef.c ****     /* ECATCHANGE_START(V5.13) COE4*/
 952:../SSC/Src/objdef.c ****         if (pAPPL_CoeReadInd != NULL)
 1776              	 .loc 1 952 0
 1777 00c8 9E4B     	 ldr r3,.L173+4
 1778 00ca 1B68     	 ldr r3,[r3]
 1779 00cc 002B     	 cmp r3,#0
 1780 00ce 0BD0     	 beq .L123
 953:../SSC/Src/objdef.c ****         {
 954:../SSC/Src/objdef.c ****             pAPPL_CoeReadInd(index, subindex, bCompleteAccess);
 1781              	 .loc 1 954 0
 1782 00d0 9C4B     	 ldr r3,.L173+4
 1783 00d2 1B68     	 ldr r3,[r3]
 1784 00d4 97F84C20 	 ldrb r2,[r7,#76]
 1785 00d8 002A     	 cmp r2,#0
 1786 00da 14BF     	 ite ne
 1787 00dc 0122     	 movne r2,#1
 1788 00de 0022     	 moveq r2,#0
 1789 00e0 D2B2     	 uxtb r2,r2
 1790 00e2 F889     	 ldrh r0,[r7,#14]
 1791 00e4 797B     	 ldrb r1,[r7,#13]
 1792 00e6 9847     	 blx r3
 1793              	.L123:
 955:../SSC/Src/objdef.c ****         }
 956:../SSC/Src/objdef.c ****         /* ECATCHANGE_END(V5.13) COE4*/
 957:../SSC/Src/objdef.c **** 
 958:../SSC/Src/objdef.c ****         if ( pObjEntry->Read != NULL )
 1794              	 .loc 1 958 0
 1795 00e8 7B68     	 ldr r3,[r7,#4]
 1796 00ea DB69     	 ldr r3,[r3,#28]
 1797 00ec 002B     	 cmp r3,#0
 1798 00ee 0DD0     	 beq .L124
 959:../SSC/Src/objdef.c ****         {
 960:../SSC/Src/objdef.c ****             /* Read function is defined, we call the object specific read function */
 961:../SSC/Src/objdef.c ****             return pObjEntry->Read(index, subindex, objSize, pData, bCompleteAccess);
 1799              	 .loc 1 961 0
 1800 00f0 7B68     	 ldr r3,[r7,#4]
 1801 00f2 DC69     	 ldr r4,[r3,#28]
 1802 00f4 F989     	 ldrh r1,[r7,#14]
 1803 00f6 7A7B     	 ldrb r2,[r7,#13]
 1804 00f8 97F84C30 	 ldrb r3,[r7,#76]
 1805 00fc 0093     	 str r3,[sp]
 1806 00fe 0846     	 mov r0,r1
 1807 0100 1146     	 mov r1,r2
 1808 0102 BA68     	 ldr r2,[r7,#8]
 1809 0104 BB6C     	 ldr r3,[r7,#72]
 1810 0106 A047     	 blx r4
 1811 0108 0346     	 mov r3,r0
 1812 010a 5DE2     	 b .L118
 1813              	.L124:
 962:../SSC/Src/objdef.c ****         }
 963:../SSC/Src/objdef.c ****         else if ( index < 0x1000 && subindex != 0 )
 1814              	 .loc 1 963 0
 1815 010c FB89     	 ldrh r3,[r7,#14]
 1816 010e B3F5805F 	 cmp r3,#4096
 1817 0112 32D2     	 bcs .L125
 1818              	 .loc 1 963 0 is_stmt 0 discriminator 1
 1819 0114 7B7B     	 ldrb r3,[r7,#13]
 1820 0116 002B     	 cmp r3,#0
 1821 0118 2FD0     	 beq .L125
 1822              	.LBB10:
 964:../SSC/Src/objdef.c ****         {
 965:../SSC/Src/objdef.c ****             /* an ENUM description is read */
 966:../SSC/Src/objdef.c ****             UINT16 size;
 967:../SSC/Src/objdef.c ****             UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
 1823              	 .loc 1 967 0 is_stmt 1
 1824 011a 7B68     	 ldr r3,[r7,#4]
 1825 011c 9B69     	 ldr r3,[r3,#24]
 1826 011e 3B62     	 str r3,[r7,#32]
 968:../SSC/Src/objdef.c ****             CHAR **p;
 969:../SSC/Src/objdef.c **** 
 970:../SSC/Src/objdef.c ****             /* we get the corresponding entry description */
 971:../SSC/Src/objdef.c ****             pEntry = OBJ_GetEntryDesc(pObjEntry, subindex);
 1827              	 .loc 1 971 0
 1828 0120 7B7B     	 ldrb r3,[r7,#13]
 1829 0122 7868     	 ldr r0,[r7,#4]
 1830 0124 1946     	 mov r1,r3
 1831 0126 FFF7FEFF 	 bl OBJ_GetEntryDesc
 1832 012a 7862     	 str r0,[r7,#36]
 972:../SSC/Src/objdef.c ****             size = BIT2BYTE(pEntry->BitLength);
 1833              	 .loc 1 972 0
 1834 012c 7B6A     	 ldr r3,[r7,#36]
 1835 012e 5B88     	 ldrh r3,[r3,#2]
 1836 0130 0733     	 adds r3,r3,#7
 1837 0132 DB10     	 asrs r3,r3,#3
 1838 0134 FB83     	 strh r3,[r7,#30]
 973:../SSC/Src/objdef.c **** 
 974:../SSC/Src/objdef.c ****             p = (CHAR **) pVarPtr;
 1839              	 .loc 1 974 0
 1840 0136 3B6A     	 ldr r3,[r7,#32]
 1841 0138 BB61     	 str r3,[r7,#24]
 975:../SSC/Src/objdef.c ****             pVarPtr = (UINT16 MBXMEM *)p[subindex-1];
 1842              	 .loc 1 975 0
 1843 013a 7B7B     	 ldrb r3,[r7,#13]
 1844 013c 03F18043 	 add r3,r3,#1073741824
 1845 0140 013B     	 subs r3,r3,#1
 1846 0142 9B00     	 lsls r3,r3,#2
 1847 0144 BA69     	 ldr r2,[r7,#24]
 1848 0146 1344     	 add r3,r3,r2
 1849 0148 1B68     	 ldr r3,[r3]
 1850 014a 3B62     	 str r3,[r7,#32]
 976:../SSC/Src/objdef.c **** 
 977:../SSC/Src/objdef.c ****             /*ECATCHANGE_START(V5.13) */
 978:../SSC/Src/objdef.c ****             {
 979:../SSC/Src/objdef.c ****             // Get enum value (first 32Bit)
 980:../SSC/Src/objdef.c **** /*ECATCHANGE_START(V5.13) */
 981:../SSC/Src/objdef.c **** 
 982:../SSC/Src/objdef.c ****             pData[0] = pVarPtr[0];
 1851              	 .loc 1 982 0
 1852 014c 3B6A     	 ldr r3,[r7,#32]
 1853 014e 1A88     	 ldrh r2,[r3]
 1854 0150 BB6C     	 ldr r3,[r7,#72]
 1855 0152 1A80     	 strh r2,[r3]
 983:../SSC/Src/objdef.c ****             pData[1] = pVarPtr[1];
 1856              	 .loc 1 983 0
 1857 0154 BB6C     	 ldr r3,[r7,#72]
 1858 0156 0233     	 adds r3,r3,#2
 1859 0158 3A6A     	 ldr r2,[r7,#32]
 1860 015a 5288     	 ldrh r2,[r2,#2]
 1861 015c 1A80     	 strh r2,[r3]
 984:../SSC/Src/objdef.c ****             pData += 2;
 1862              	 .loc 1 984 0
 1863 015e BB6C     	 ldr r3,[r7,#72]
 1864 0160 0433     	 adds r3,r3,#4
 1865 0162 BB64     	 str r3,[r7,#72]
 985:../SSC/Src/objdef.c ****             pVarPtr += 2;
 1866              	 .loc 1 985 0
 1867 0164 3B6A     	 ldr r3,[r7,#32]
 1868 0166 0433     	 adds r3,r3,#4
 1869 0168 3B62     	 str r3,[r7,#32]
 986:../SSC/Src/objdef.c **** /*ECATCHANGE_END(V5.13) */
 987:../SSC/Src/objdef.c **** 
 988:../SSC/Src/objdef.c ****             // Get enum description
 989:../SSC/Src/objdef.c ****             OBJTOMBXSTRCPY(pData,pVarPtr,size-4);
 1870              	 .loc 1 989 0
 1871 016a FB8B     	 ldrh r3,[r7,#30]
 1872 016c 043B     	 subs r3,r3,#4
 1873 016e B86C     	 ldr r0,[r7,#72]
 1874 0170 396A     	 ldr r1,[r7,#32]
 1875 0172 1A46     	 mov r2,r3
 1876 0174 FFF7FEFF 	 bl memcpy
 1877              	.LBE10:
 964:../SSC/Src/objdef.c ****             /* an ENUM description is read */
 1878              	 .loc 1 964 0
 1879 0178 25E2     	 b .L126
 1880              	.L125:
 1881              	.LBB11:
 990:../SSC/Src/objdef.c ****             }
 991:../SSC/Src/objdef.c ****         }
 992:../SSC/Src/objdef.c ****         else
 993:../SSC/Src/objdef.c ****         {
 994:../SSC/Src/objdef.c ****             UINT8 bRead = 0x0;
 1882              	 .loc 1 994 0
 1883 017a 0023     	 movs r3,#0
 1884 017c 87F83130 	 strb r3,[r7,#49]
 995:../SSC/Src/objdef.c ****             UINT8 result = 0;
 1885              	 .loc 1 995 0
 1886 0180 0023     	 movs r3,#0
 1887 0182 87F83030 	 strb r3,[r7,#48]
 996:../SSC/Src/objdef.c **** 
 997:../SSC/Src/objdef.c **** 
 998:../SSC/Src/objdef.c ****             /* a variable object is read */
 999:../SSC/Src/objdef.c ****             for (i = subindex; i <= lastSubindex; i++)
 1888              	 .loc 1 999 0
 1889 0186 7B7B     	 ldrb r3,[r7,#13]
 1890 0188 FB86     	 strh r3,[r7,#54]
 1891 018a 10E2     	 b .L127
 1892              	.L172:
 1893              	.LBB12:
1000:../SSC/Src/objdef.c ****             {
1001:../SSC/Src/objdef.c ****                 /* if only a single entry is requested, this loop will only be done once */
1002:../SSC/Src/objdef.c ****                 UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
 1894              	 .loc 1 1002 0
 1895 018c 7B68     	 ldr r3,[r7,#4]
 1896 018e 9B69     	 ldr r3,[r3,#24]
 1897 0190 7B61     	 str r3,[r7,#20]
1003:../SSC/Src/objdef.c ****                 UINT16 bitOffset = 0;
 1898              	 .loc 1 1003 0
 1899 0192 0023     	 movs r3,#0
 1900 0194 FB85     	 strh r3,[r7,#46]
1004:../SSC/Src/objdef.c **** 
1005:../SSC/Src/objdef.c ****                 
1006:../SSC/Src/objdef.c ****                 if (i == 0)
 1901              	 .loc 1 1006 0
 1902 0196 FB8E     	 ldrh r3,[r7,#54]
 1903 0198 002B     	 cmp r3,#0
 1904 019a 0BD0     	 beq .L128
1007:../SSC/Src/objdef.c ****                 {
1008:../SSC/Src/objdef.c ****                     /* subindex 0 is requested, the entry's data is at the beginning of the object'
1009:../SSC/Src/objdef.c ****                 }
1010:../SSC/Src/objdef.c ****                 else if ( index >= 0x1000 )
 1905              	 .loc 1 1010 0
 1906 019c FB89     	 ldrh r3,[r7,#14]
 1907 019e B3F5805F 	 cmp r3,#4096
 1908 01a2 07D3     	 bcc .L128
1011:../SSC/Src/objdef.c ****                 {
1012:../SSC/Src/objdef.c ****                     /* subindex 1-n of an variable object is requested, we get the offset of the va
1013:../SSC/Src/objdef.c ****                     bitOffset = OBJ_GetEntryOffset((UINT8)i, pObjEntry);
 1909              	 .loc 1 1013 0
 1910 01a4 FB8E     	 ldrh r3,[r7,#54]
 1911 01a6 DBB2     	 uxtb r3,r3
 1912 01a8 1846     	 mov r0,r3
 1913 01aa 7968     	 ldr r1,[r7,#4]
 1914 01ac FFF7FEFF 	 bl OBJ_GetEntryOffset
 1915 01b0 0346     	 mov r3,r0
 1916 01b2 FB85     	 strh r3,[r7,#46]
 1917              	.L128:
1014:../SSC/Src/objdef.c ****                 }
1015:../SSC/Src/objdef.c **** 
1016:../SSC/Src/objdef.c ****                 /* we increment the variable pointer to the corresponding word address */
1017:../SSC/Src/objdef.c ****                 pVarPtr += (bitOffset >> 4);
 1918              	 .loc 1 1017 0
 1919 01b4 FB8D     	 ldrh r3,[r7,#46]
 1920 01b6 1B09     	 lsrs r3,r3,#4
 1921 01b8 9BB2     	 uxth r3,r3
 1922 01ba 5B00     	 lsls r3,r3,#1
 1923 01bc 7A69     	 ldr r2,[r7,#20]
 1924 01be 1344     	 add r3,r3,r2
 1925 01c0 7B61     	 str r3,[r7,#20]
1018:../SSC/Src/objdef.c **** 
1019:../SSC/Src/objdef.c ****                 /* get the corresponding entry description */
1020:../SSC/Src/objdef.c ****                 pEntry = OBJ_GetEntryDesc(pObjEntry, (UINT8)i);
 1926              	 .loc 1 1020 0
 1927 01c2 FB8E     	 ldrh r3,[r7,#54]
 1928 01c4 DBB2     	 uxtb r3,r3
 1929 01c6 7868     	 ldr r0,[r7,#4]
 1930 01c8 1946     	 mov r1,r3
 1931 01ca FFF7FEFF 	 bl OBJ_GetEntryDesc
 1932 01ce 7862     	 str r0,[r7,#36]
1021:../SSC/Src/objdef.c ****                 if (0 != (((UINT8) ((pEntry->ObjAccess & ACCESS_READ)<<1)) & (nAlStatus & STATE_MAS
 1933              	 .loc 1 1021 0
 1934 01d0 7B6A     	 ldr r3,[r7,#36]
 1935 01d2 9B88     	 ldrh r3,[r3,#4]
 1936 01d4 DBB2     	 uxtb r3,r3
 1937 01d6 03F00703 	 and r3,r3,#7
 1938 01da DBB2     	 uxtb r3,r3
 1939 01dc 5B00     	 lsls r3,r3,#1
 1940 01de DBB2     	 uxtb r3,r3
 1941 01e0 1A46     	 mov r2,r3
 1942 01e2 574B     	 ldr r3,.L173
 1943 01e4 1B78     	 ldrb r3,[r3]
 1944 01e6 03F00F03 	 and r3,r3,#15
 1945 01ea 1340     	 ands r3,r3,r2
 1946 01ec 002B     	 cmp r3,#0
 1947 01ee 00F09781 	 beq .L129
1022:../SSC/Src/objdef.c ****                 {
1023:../SSC/Src/objdef.c ****                     if ( i == subindex                                     /* requested entry */
 1948              	 .loc 1 1023 0
 1949 01f2 7B7B     	 ldrb r3,[r7,#13]
 1950 01f4 9BB2     	 uxth r3,r3
 1951 01f6 FA8E     	 ldrh r2,[r7,#54]
 1952 01f8 9A42     	 cmp r2,r3
 1953 01fa 0AD0     	 beq .L130
1024:../SSC/Src/objdef.c ****                         || (bCompleteAccess && i >= subindex) )       /* complete access and entry 
 1954              	 .loc 1 1024 0
 1955 01fc 97F84C30 	 ldrb r3,[r7,#76]
 1956 0200 002B     	 cmp r3,#0
 1957 0202 00F08C81 	 beq .L131
 1958              	 .loc 1 1024 0 is_stmt 0 discriminator 1
 1959 0206 7B7B     	 ldrb r3,[r7,#13]
 1960 0208 9BB2     	 uxth r3,r3
 1961 020a FA8E     	 ldrh r2,[r7,#54]
 1962 020c 9A42     	 cmp r2,r3
 1963 020e C0F08681 	 bcc .L131
 1964              	.L130:
 1965              	.LBB13:
1025:../SSC/Src/objdef.c ****                     {
1026:../SSC/Src/objdef.c ****                         UINT16 bitMask;
1027:../SSC/Src/objdef.c **** 
1028:../SSC/Src/objdef.c ****                         /* we have to copy the entry */
1029:../SSC/Src/objdef.c ****                         if ( i == 0 && objCode != OBJCODE_VAR )
 1966              	 .loc 1 1029 0 is_stmt 1
 1967 0212 FB8E     	 ldrh r3,[r7,#54]
 1968 0214 002B     	 cmp r3,#0
 1969 0216 0AD1     	 bne .L132
 1970              	 .loc 1 1029 0 is_stmt 0 discriminator 1
 1971 0218 97F82A30 	 ldrb r3,[r7,#42]
 1972 021c 072B     	 cmp r3,#7
 1973 021e 06D0     	 beq .L132
1030:../SSC/Src/objdef.c ****                         {
1031:../SSC/Src/objdef.c ****                             /* we read subindex 0 of an array or record */
1032:../SSC/Src/objdef.c ****                             {
1033:../SSC/Src/objdef.c ****                                 pData[0] = SWAPWORD((UINT16)maxSubindex);
 1974              	 .loc 1 1033 0 is_stmt 1
 1975 0220 BB6C     	 ldr r3,[r7,#72]
 1976 0222 BA8E     	 ldrh r2,[r7,#52]
 1977 0224 1A80     	 strh r2,[r3]
1034:../SSC/Src/objdef.c ****                             }
1035:../SSC/Src/objdef.c **** 
1036:../SSC/Src/objdef.c ****                             /* we increment the destination pointer by 2 because the subindex 0 wil
1037:../SSC/Src/objdef.c ****                             transmitted as UINT16 for a complete access */
1038:../SSC/Src/objdef.c ****                             pData++;
 1978              	 .loc 1 1038 0
 1979 0226 BB6C     	 ldr r3,[r7,#72]
 1980 0228 0233     	 adds r3,r3,#2
 1981 022a BB64     	 str r3,[r7,#72]
 1982 022c 77E1     	 b .L131
 1983              	.L132:
 1984              	.LBB14:
1039:../SSC/Src/objdef.c ****                         }
1040:../SSC/Src/objdef.c ****                         else
1041:../SSC/Src/objdef.c ****                         {
1042:../SSC/Src/objdef.c ****                             UINT16 dataType = pEntry->DataType;
 1985              	 .loc 1 1042 0
 1986 022e 7B6A     	 ldr r3,[r7,#36]
 1987 0230 1B88     	 ldrh r3,[r3]
 1988 0232 BB85     	 strh r3,[r7,#44]
1043:../SSC/Src/objdef.c ****                             
1044:../SSC/Src/objdef.c ****                             if (pEntry->DataType >= 0x700)
 1989              	 .loc 1 1044 0
 1990 0234 7B6A     	 ldr r3,[r7,#36]
 1991 0236 1B88     	 ldrh r3,[r3]
 1992 0238 B3F5E06F 	 cmp r3,#1792
 1993 023c 15D3     	 bcc .L133
1045:../SSC/Src/objdef.c ****                             {
1046:../SSC/Src/objdef.c ****                                 /* the ENUM data types are defined from index 0x700 in this example
1047:../SSC/Src/objdef.c ****                                 convert in standard data type for the read access */
1048:../SSC/Src/objdef.c ****                                 if ( pEntry->BitLength <= 8 )
 1994              	 .loc 1 1048 0
 1995 023e 7B6A     	 ldr r3,[r7,#36]
 1996 0240 5B88     	 ldrh r3,[r3,#2]
 1997 0242 082B     	 cmp r3,#8
 1998 0244 04D8     	 bhi .L134
1049:../SSC/Src/objdef.c ****                                 {
1050:../SSC/Src/objdef.c ****                                     dataType = DEFTYPE_BIT1-1+pEntry->BitLength;
 1999              	 .loc 1 1050 0
 2000 0246 7B6A     	 ldr r3,[r7,#36]
 2001 0248 5B88     	 ldrh r3,[r3,#2]
 2002 024a 2F33     	 adds r3,r3,#47
 2003 024c BB85     	 strh r3,[r7,#44]
 2004 024e 0CE0     	 b .L133
 2005              	.L134:
1051:../SSC/Src/objdef.c ****                                 }
1052:../SSC/Src/objdef.c ****                                 else if ( pEntry->BitLength == 16 )
 2006              	 .loc 1 1052 0
 2007 0250 7B6A     	 ldr r3,[r7,#36]
 2008 0252 5B88     	 ldrh r3,[r3,#2]
 2009 0254 102B     	 cmp r3,#16
 2010 0256 02D1     	 bne .L135
1053:../SSC/Src/objdef.c ****                                 {
1054:../SSC/Src/objdef.c ****                                     dataType = DEFTYPE_UNSIGNED16;
 2011              	 .loc 1 1054 0
 2012 0258 0623     	 movs r3,#6
 2013 025a BB85     	 strh r3,[r7,#44]
 2014 025c 05E0     	 b .L133
 2015              	.L135:
1055:../SSC/Src/objdef.c ****                                 }
1056:../SSC/Src/objdef.c ****                                 else if ( pEntry->BitLength == 32 )
 2016              	 .loc 1 1056 0
 2017 025e 7B6A     	 ldr r3,[r7,#36]
 2018 0260 5B88     	 ldrh r3,[r3,#2]
 2019 0262 202B     	 cmp r3,#32
 2020 0264 01D1     	 bne .L133
1057:../SSC/Src/objdef.c ****                                 {
1058:../SSC/Src/objdef.c ****                                     dataType = DEFTYPE_UNSIGNED32;
 2021              	 .loc 1 1058 0
 2022 0266 0723     	 movs r3,#7
 2023 0268 BB85     	 strh r3,[r7,#44]
 2024              	.L133:
1059:../SSC/Src/objdef.c ****                                 }
1060:../SSC/Src/objdef.c ****                             }
1061:../SSC/Src/objdef.c **** 
1062:../SSC/Src/objdef.c ****                             switch (dataType)
 2025              	 .loc 1 1062 0
 2026 026a BB8D     	 ldrh r3,[r7,#44]
 2027 026c 112B     	 cmp r3,#17
 2028 026e 00F0E280 	 beq .L137
 2029 0272 112B     	 cmp r3,#17
 2030 0274 1EDC     	 bgt .L138
 2031 0276 052B     	 cmp r3,#5
 2032 0278 68D0     	 beq .L139
 2033 027a 052B     	 cmp r3,#5
 2034 027c 0DDC     	 bgt .L140
 2035 027e 022B     	 cmp r3,#2
 2036 0280 04DC     	 bgt .L141
 2037 0282 012B     	 cmp r3,#1
 2038 0284 62DA     	 bge .L139
 2039 0286 002B     	 cmp r3,#0
 2040 0288 3BD0     	 beq .L142
 2041 028a 42E1     	 b .L136
 2042              	.L141:
 2043 028c 032B     	 cmp r3,#3
 2044 028e 00F0AF80 	 beq .L143
 2045 0292 042B     	 cmp r3,#4
 2046 0294 00F0BB80 	 beq .L144
 2047 0298 3BE1     	 b .L136
 2048              	.L140:
 2049 029a 082B     	 cmp r3,#8
 2050 029c 03DC     	 bgt .L145
 2051 029e 072B     	 cmp r3,#7
 2052 02a0 80F2B580 	 bge .L144
 2053 02a4 A4E0     	 b .L143
 2054              	.L145:
 2055 02a6 092B     	 cmp r3,#9
 2056 02a8 00F00B81 	 beq .L146
 2057 02ac 0B2B     	 cmp r3,#11
 2058 02ae 00F33081 	 bgt .L136
 2059 02b2 DEE0     	 b .L147
 2060              	.L138:
 2061 02b4 2D2B     	 cmp r3,#45
 2062 02b6 49D0     	 beq .L139
 2063 02b8 2D2B     	 cmp r3,#45
 2064 02ba 11DC     	 bgt .L148
 2065 02bc 1E2B     	 cmp r3,#30
 2066 02be 45D0     	 beq .L139
 2067 02c0 1E2B     	 cmp r3,#30
 2068 02c2 06DC     	 bgt .L149
 2069 02c4 152B     	 cmp r3,#21
 2070 02c6 00F0B680 	 beq .L137
 2071 02ca 1B2B     	 cmp r3,#27
 2072 02cc 00F0B380 	 beq .L137
 2073 02d0 1FE1     	 b .L136
 2074              	.L149:
 2075 02d2 1F2B     	 cmp r3,#31
 2076 02d4 00F08C80 	 beq .L143
 2077 02d8 202B     	 cmp r3,#32
 2078 02da 00F09880 	 beq .L144
 2079 02de 18E1     	 b .L136
 2080              	.L148:
 2081 02e0 372B     	 cmp r3,#55
 2082 02e2 08DC     	 bgt .L150
 2083 02e4 302B     	 cmp r3,#48
 2084 02e6 31DA     	 bge .L139
 2085 02e8 2E2B     	 cmp r3,#46
 2086 02ea 00F08180 	 beq .L143
 2087 02ee 2F2B     	 cmp r3,#47
 2088 02f0 00F08D80 	 beq .L144
 2089 02f4 0DE1     	 b .L136
 2090              	.L150:
 2091 02f6 A3F51873 	 sub r3,r3,#608
 2092 02fa 032B     	 cmp r3,#3
 2093 02fc 00F20981 	 bhi .L136
 2094 0300 B7E0     	 b .L147
 2095              	.L142:
1063:../SSC/Src/objdef.c ****                             {
1064:../SSC/Src/objdef.c ****                             case DEFTYPE_NULL:
1065:../SSC/Src/objdef.c ****                                 if(bCompleteAccess)
 2096              	 .loc 1 1065 0
 2097 0302 97F84C30 	 ldrb r3,[r7,#76]
 2098 0306 002B     	 cmp r3,#0
 2099 0308 1ED0     	 beq .L151
1066:../SSC/Src/objdef.c ****                                 {
1067:../SSC/Src/objdef.c ****                                     /*Handle alignment entry*/
1068:../SSC/Src/objdef.c ****                                     if (((pEntry->BitLength & 0xF) > 0)
 2100              	 .loc 1 1068 0
 2101 030a 7B6A     	 ldr r3,[r7,#36]
 2102 030c 5B88     	 ldrh r3,[r3,#2]
 2103 030e 03F00F03 	 and r3,r3,#15
 2104 0312 002B     	 cmp r3,#0
 2105 0314 0ADD     	 ble .L152
1069:../SSC/Src/objdef.c ****                                         && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
 2106              	 .loc 1 1069 0
 2107 0316 FB8D     	 ldrh r3,[r7,#46]
 2108 0318 7A6A     	 ldr r2,[r7,#36]
 2109 031a 5288     	 ldrh r2,[r2,#2]
 2110 031c 1344     	 add r3,r3,r2
 2111 031e 03F00F03 	 and r3,r3,#15
 2112 0322 002B     	 cmp r3,#0
 2113 0324 02D1     	 bne .L152
1070:../SSC/Src/objdef.c ****                                     {
1071:../SSC/Src/objdef.c ****                                         /* we have reached the UINT16 border */
1072:../SSC/Src/objdef.c ****                                         pData++;
 2114              	 .loc 1 1072 0
 2115 0326 BB6C     	 ldr r3,[r7,#72]
 2116 0328 0233     	 adds r3,r3,#2
 2117 032a BB64     	 str r3,[r7,#72]
 2118              	.L152:
1073:../SSC/Src/objdef.c ****                                     }
1074:../SSC/Src/objdef.c **** 
1075:../SSC/Src/objdef.c ****                                     /*increment WORD offset*/
1076:../SSC/Src/objdef.c ****                                     pData += ((pEntry->BitLength & 0xF0) >> 4);
 2119              	 .loc 1 1076 0
 2120 032c 7B6A     	 ldr r3,[r7,#36]
 2121 032e 5B88     	 ldrh r3,[r3,#2]
 2122 0330 03F0F003 	 and r3,r3,#240
 2123 0334 1B11     	 asrs r3,r3,#4
 2124 0336 5B00     	 lsls r3,r3,#1
 2125 0338 BA6C     	 ldr r2,[r7,#72]
 2126 033a 1344     	 add r3,r3,r2
 2127 033c BB64     	 str r3,[r7,#72]
1077:../SSC/Src/objdef.c ****                                 }
1078:../SSC/Src/objdef.c ****                                 else
1079:../SSC/Src/objdef.c ****                                 {
1080:../SSC/Src/objdef.c ****                                     return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
1081:../SSC/Src/objdef.c ****                                 }
1082:../SSC/Src/objdef.c ****                                 break;
 2128              	 .loc 1 1082 0
 2129 033e EAE0     	 b .L154
 2130              	.L174:
 2131              	 .align 2
 2132              	.L173:
 2133 0340 00000000 	 .word nAlStatus
 2134 0344 00000000 	 .word pAPPL_CoeReadInd
 2135              	.L151:
1080:../SSC/Src/objdef.c ****                                 }
 2136              	 .loc 1 1080 0
 2137 0348 1823     	 movs r3,#24
 2138 034a 3DE1     	 b .L118
 2139              	.L139:
 2140              	.LBB15:
1083:../SSC/Src/objdef.c ****                             case     DEFTYPE_BOOLEAN:
1084:../SSC/Src/objdef.c ****                             case     DEFTYPE_BIT1:
1085:../SSC/Src/objdef.c ****                             case     DEFTYPE_BIT2:
1086:../SSC/Src/objdef.c ****                             case     DEFTYPE_BIT3:
1087:../SSC/Src/objdef.c ****                             case     DEFTYPE_BIT4:
1088:../SSC/Src/objdef.c ****                             case     DEFTYPE_BIT5:
1089:../SSC/Src/objdef.c ****                             case     DEFTYPE_BIT6:
1090:../SSC/Src/objdef.c ****                             case     DEFTYPE_BIT7:
1091:../SSC/Src/objdef.c ****                             case     DEFTYPE_BIT8:
1092:../SSC/Src/objdef.c ****                             case     DEFTYPE_BITARR8:
1093:../SSC/Src/objdef.c ****                                 /* in this example the objects are defined in that way,
1094:../SSC/Src/objdef.c ****                                 that the bit types are always inside a 16-bit field,
1095:../SSC/Src/objdef.c ****                                 and they shall not overlap a byte border*/
1096:../SSC/Src/objdef.c ****                             case    DEFTYPE_INTEGER8:
1097:../SSC/Src/objdef.c ****                             case    DEFTYPE_UNSIGNED8:
1098:../SSC/Src/objdef.c ****                             case    DEFTYPE_BYTE :
1099:../SSC/Src/objdef.c ****                                 {
1100:../SSC/Src/objdef.c ****                                     /* depending on the bitOffset we have to copy the Hi or the Lo-
1101:../SSC/Src/objdef.c ****                                     UINT16 TmpValue = 0x0000;
 2141              	 .loc 1 1101 0
 2142 034c 0023     	 movs r3,#0
 2143 034e 7B82     	 strh r3,[r7,#18]
1102:../SSC/Src/objdef.c **** 
1103:../SSC/Src/objdef.c ****                                     
1104:../SSC/Src/objdef.c ****                                     bitMask = cBitMask[pEntry->BitLength] << (bitOffset & 0x0F);
 2144              	 .loc 1 1104 0
 2145 0350 7B6A     	 ldr r3,[r7,#36]
 2146 0352 5B88     	 ldrh r3,[r3,#2]
 2147 0354 1A46     	 mov r2,r3
 2148 0356 9E4B     	 ldr r3,.L175
 2149 0358 33F81230 	 ldrh r3,[r3,r2,lsl#1]
 2150 035c 1A46     	 mov r2,r3
 2151 035e FB8D     	 ldrh r3,[r7,#46]
 2152 0360 03F00F03 	 and r3,r3,#15
 2153 0364 02FA03F3 	 lsl r3,r2,r3
 2154 0368 3B82     	 strh r3,[r7,#16]
1105:../SSC/Src/objdef.c **** 
1106:../SSC/Src/objdef.c ****                                     /*Swap object data (if required); all masks and offsets are def
1107:../SSC/Src/objdef.c ****                                     TmpValue = SWAPWORD(pVarPtr[0]);
 2155              	 .loc 1 1107 0
 2156 036a 7B69     	 ldr r3,[r7,#20]
 2157 036c 1B88     	 ldrh r3,[r3]
 2158 036e 7B82     	 strh r3,[r7,#18]
1108:../SSC/Src/objdef.c **** 
1109:../SSC/Src/objdef.c ****                                     /*Clear pData if the first bits within the WORD memory will be 
1110:../SSC/Src/objdef.c ****                                     if ((bitOffset & 0x0F) == 0) 
 2159              	 .loc 1 1110 0
 2160 0370 FB8D     	 ldrh r3,[r7,#46]
 2161 0372 03F00F03 	 and r3,r3,#15
 2162 0376 002B     	 cmp r3,#0
 2163 0378 02D1     	 bne .L155
1111:../SSC/Src/objdef.c ****                                     {
1112:../SSC/Src/objdef.c ****                                         pData[0] = 0;
 2164              	 .loc 1 1112 0
 2165 037a BB6C     	 ldr r3,[r7,#72]
 2166 037c 0022     	 movs r2,#0
 2167 037e 1A80     	 strh r2,[r3]
 2168              	.L155:
1113:../SSC/Src/objdef.c ****                                     }
1114:../SSC/Src/objdef.c **** 
1115:../SSC/Src/objdef.c ****                                     pData[0] = SWAPWORD(pData[0]);
 2169              	 .loc 1 1115 0
 2170 0380 BB6C     	 ldr r3,[r7,#72]
 2171 0382 1A88     	 ldrh r2,[r3]
 2172 0384 BB6C     	 ldr r3,[r7,#72]
 2173 0386 1A80     	 strh r2,[r3]
1116:../SSC/Src/objdef.c **** 
1117:../SSC/Src/objdef.c ****                                     if (bCompleteAccess) 
 2174              	 .loc 1 1117 0
 2175 0388 97F84C30 	 ldrb r3,[r7,#76]
 2176 038c 002B     	 cmp r3,#0
 2177 038e 0AD0     	 beq .L156
1118:../SSC/Src/objdef.c ****                                     {
1119:../SSC/Src/objdef.c ****                                         /*shifting is not required for Complete access because the 
1120:../SSC/Src/objdef.c ****                                         pData[0] |= TmpValue & bitMask;
 2178              	 .loc 1 1120 0
 2179 0390 BB6C     	 ldr r3,[r7,#72]
 2180 0392 1A88     	 ldrh r2,[r3]
 2181 0394 798A     	 ldrh r1,[r7,#18]
 2182 0396 3B8A     	 ldrh r3,[r7,#16]
 2183 0398 0B40     	 ands r3,r3,r1
 2184 039a 9BB2     	 uxth r3,r3
 2185 039c 1343     	 orrs r3,r3,r2
 2186 039e 9AB2     	 uxth r2,r3
 2187 03a0 BB6C     	 ldr r3,[r7,#72]
 2188 03a2 1A80     	 strh r2,[r3]
 2189 03a4 13E0     	 b .L157
 2190              	.L156:
1121:../SSC/Src/objdef.c ****                                     }
1122:../SSC/Src/objdef.c ****                                     else
1123:../SSC/Src/objdef.c ****                                     {
1124:../SSC/Src/objdef.c ****                                         /*Shift Bits to the beginning of the mailbox memory*/
1125:../SSC/Src/objdef.c ****                                         pData[0] |= ((TmpValue & bitMask) >> (bitOffset & 0x0F));
 2191              	 .loc 1 1125 0
 2192 03a6 BB6C     	 ldr r3,[r7,#72]
 2193 03a8 1B88     	 ldrh r3,[r3]
 2194 03aa 99B2     	 uxth r1,r3
 2195 03ac 7A8A     	 ldrh r2,[r7,#18]
 2196 03ae 3B8A     	 ldrh r3,[r7,#16]
 2197 03b0 1340     	 ands r3,r3,r2
 2198 03b2 9BB2     	 uxth r3,r3
 2199 03b4 1A46     	 mov r2,r3
 2200 03b6 FB8D     	 ldrh r3,[r7,#46]
 2201 03b8 03F00F03 	 and r3,r3,#15
 2202 03bc 42FA03F3 	 asr r3,r2,r3
 2203 03c0 9BB2     	 uxth r3,r3
 2204 03c2 0A46     	 mov r2,r1
 2205 03c4 1343     	 orrs r3,r3,r2
 2206 03c6 9BB2     	 uxth r3,r3
 2207 03c8 9AB2     	 uxth r2,r3
 2208 03ca BB6C     	 ldr r3,[r7,#72]
 2209 03cc 1A80     	 strh r2,[r3]
 2210              	.L157:
1126:../SSC/Src/objdef.c ****                                     }
1127:../SSC/Src/objdef.c **** 
1128:../SSC/Src/objdef.c ****                                     pData[0] = SWAPWORD(pData[0]);
 2211              	 .loc 1 1128 0
 2212 03ce BB6C     	 ldr r3,[r7,#72]
 2213 03d0 1A88     	 ldrh r2,[r3]
 2214 03d2 BB6C     	 ldr r3,[r7,#72]
 2215 03d4 1A80     	 strh r2,[r3]
1129:../SSC/Src/objdef.c ****                                     if ( ((bitOffset + pEntry->BitLength) & 0x0F) == 0 )
 2216              	 .loc 1 1129 0
 2217 03d6 FB8D     	 ldrh r3,[r7,#46]
 2218 03d8 7A6A     	 ldr r2,[r7,#36]
 2219 03da 5288     	 ldrh r2,[r2,#2]
 2220 03dc 1344     	 add r3,r3,r2
 2221 03de 03F00F03 	 and r3,r3,#15
 2222 03e2 002B     	 cmp r3,#0
 2223 03e4 03D1     	 bne .L158
1130:../SSC/Src/objdef.c ****                                     {
1131:../SSC/Src/objdef.c ****                                         /* we have reached the UINT16 border */
1132:../SSC/Src/objdef.c ****                                         pData++;
 2224              	 .loc 1 1132 0
 2225 03e6 BB6C     	 ldr r3,[r7,#72]
 2226 03e8 0233     	 adds r3,r3,#2
 2227 03ea BB64     	 str r3,[r7,#72]
 2228              	.LBE15:
1133:../SSC/Src/objdef.c ****                                     }
1134:../SSC/Src/objdef.c **** 
1135:../SSC/Src/objdef.c ****                                 }
1136:../SSC/Src/objdef.c ****                                 break;
 2229              	 .loc 1 1136 0
 2230 03ec 93E0     	 b .L154
 2231              	.L158:
 2232 03ee 92E0     	 b .L154
 2233              	.L143:
1137:../SSC/Src/objdef.c ****                             case    DEFTYPE_INTEGER16:
1138:../SSC/Src/objdef.c ****                             case    DEFTYPE_UNSIGNED16:
1139:../SSC/Src/objdef.c ****                             case    DEFTYPE_BITARR16:
1140:../SSC/Src/objdef.c ****                             case    DEFTYPE_WORD:
1141:../SSC/Src/objdef.c **** 
1142:../SSC/Src/objdef.c ****                                 if(bitOffset & 0xF)
 2234              	 .loc 1 1142 0
 2235 03f0 FB8D     	 ldrh r3,[r7,#46]
 2236 03f2 03F00F03 	 and r3,r3,#15
 2237 03f6 002B     	 cmp r3,#0
 2238 03f8 01D0     	 beq .L159
1143:../SSC/Src/objdef.c ****                                 {
1144:../SSC/Src/objdef.c ****                                     /* return an error in case of an odd word offset (to support 16
1145:../SSC/Src/objdef.c ****                                     return ABORTIDX_UNSUPPORTED_ACCESS;
 2239              	 .loc 1 1145 0
 2240 03fa 0523     	 movs r3,#5
 2241 03fc E4E0     	 b .L118
 2242              	.L159:
1146:../SSC/Src/objdef.c ****                                 }
1147:../SSC/Src/objdef.c ****                                 /* in this example the objects are defined in that way,
1148:../SSC/Src/objdef.c ****                                 that the 16 bit type are always starting at an exact WORD offset */
1149:../SSC/Src/objdef.c ****                                 pData[0] = SWAPWORD(pVarPtr[0]);
 2243              	 .loc 1 1149 0
 2244 03fe 7B69     	 ldr r3,[r7,#20]
 2245 0400 1A88     	 ldrh r2,[r3]
 2246 0402 BB6C     	 ldr r3,[r7,#72]
 2247 0404 1A80     	 strh r2,[r3]
1150:../SSC/Src/objdef.c ****                                 pData++;
 2248              	 .loc 1 1150 0
 2249 0406 BB6C     	 ldr r3,[r7,#72]
 2250 0408 0233     	 adds r3,r3,#2
 2251 040a BB64     	 str r3,[r7,#72]
1151:../SSC/Src/objdef.c ****                                 break;
 2252              	 .loc 1 1151 0
 2253 040c 83E0     	 b .L154
 2254              	.L144:
1152:../SSC/Src/objdef.c ****                             case    DEFTYPE_UNSIGNED32:
1153:../SSC/Src/objdef.c ****                             case    DEFTYPE_INTEGER32:
1154:../SSC/Src/objdef.c ****                             case    DEFTYPE_REAL32:
1155:../SSC/Src/objdef.c ****                             case    DEFTYPE_BITARR32:
1156:../SSC/Src/objdef.c ****                             case    DEFTYPE_DWORD:
1157:../SSC/Src/objdef.c ****                                 if(bitOffset & 0xF)
 2255              	 .loc 1 1157 0
 2256 040e FB8D     	 ldrh r3,[r7,#46]
 2257 0410 03F00F03 	 and r3,r3,#15
 2258 0414 002B     	 cmp r3,#0
 2259 0416 01D0     	 beq .L160
1158:../SSC/Src/objdef.c ****                                 {
1159:../SSC/Src/objdef.c ****                                     /* return an error in case of an odd word offset (to support 16
1160:../SSC/Src/objdef.c ****                                     return ABORTIDX_UNSUPPORTED_ACCESS;
 2260              	 .loc 1 1160 0
 2261 0418 0523     	 movs r3,#5
 2262 041a D5E0     	 b .L118
 2263              	.L160:
1161:../SSC/Src/objdef.c ****                                 }
1162:../SSC/Src/objdef.c **** 
1163:../SSC/Src/objdef.c ****                                 /* in this example the objects are defined in that way,
1164:../SSC/Src/objdef.c ****                                 that the 32 bit type are always starting at an exact WORD offset */
1165:../SSC/Src/objdef.c ****                                 pData[0] = pVarPtr[0];
 2264              	 .loc 1 1165 0
 2265 041c 7B69     	 ldr r3,[r7,#20]
 2266 041e 1A88     	 ldrh r2,[r3]
 2267 0420 BB6C     	 ldr r3,[r7,#72]
 2268 0422 1A80     	 strh r2,[r3]
1166:../SSC/Src/objdef.c ****                                 pData[1] = pVarPtr[1];
 2269              	 .loc 1 1166 0
 2270 0424 BB6C     	 ldr r3,[r7,#72]
 2271 0426 0233     	 adds r3,r3,#2
 2272 0428 7A69     	 ldr r2,[r7,#20]
 2273 042a 5288     	 ldrh r2,[r2,#2]
 2274 042c 1A80     	 strh r2,[r3]
1167:../SSC/Src/objdef.c ****                                 pData += 2;
 2275              	 .loc 1 1167 0
 2276 042e BB6C     	 ldr r3,[r7,#72]
 2277 0430 0433     	 adds r3,r3,#4
 2278 0432 BB64     	 str r3,[r7,#72]
1168:../SSC/Src/objdef.c ****                                 break;
 2279              	 .loc 1 1168 0
 2280 0434 6FE0     	 b .L154
 2281              	.L137:
1169:../SSC/Src/objdef.c ****                             case    DEFTYPE_REAL64:
1170:../SSC/Src/objdef.c ****                             case 	DEFTYPE_INTEGER64:
1171:../SSC/Src/objdef.c ****                             case    DEFTYPE_UNSIGNED64:
1172:../SSC/Src/objdef.c ****                                 if(bitOffset & 0xF)
 2282              	 .loc 1 1172 0
 2283 0436 FB8D     	 ldrh r3,[r7,#46]
 2284 0438 03F00F03 	 and r3,r3,#15
 2285 043c 002B     	 cmp r3,#0
 2286 043e 01D0     	 beq .L161
1173:../SSC/Src/objdef.c ****                                 {
1174:../SSC/Src/objdef.c ****                                     /* return an error in case of an odd word offset (to support 16
1175:../SSC/Src/objdef.c ****                                     return ABORTIDX_UNSUPPORTED_ACCESS;
 2287              	 .loc 1 1175 0
 2288 0440 0523     	 movs r3,#5
 2289 0442 C1E0     	 b .L118
 2290              	.L161:
1176:../SSC/Src/objdef.c ****                                 }
1177:../SSC/Src/objdef.c **** 
1178:../SSC/Src/objdef.c ****                                 /* in this example the objects are defined in that way,
1179:../SSC/Src/objdef.c ****                                 that the 64 bit type are always starting at an exact WORD offset */
1180:../SSC/Src/objdef.c ****                                 pData[0] = pVarPtr[0];
 2291              	 .loc 1 1180 0
 2292 0444 7B69     	 ldr r3,[r7,#20]
 2293 0446 1A88     	 ldrh r2,[r3]
 2294 0448 BB6C     	 ldr r3,[r7,#72]
 2295 044a 1A80     	 strh r2,[r3]
1181:../SSC/Src/objdef.c ****                                 pData[1] = pVarPtr[1];
 2296              	 .loc 1 1181 0
 2297 044c BB6C     	 ldr r3,[r7,#72]
 2298 044e 0233     	 adds r3,r3,#2
 2299 0450 7A69     	 ldr r2,[r7,#20]
 2300 0452 5288     	 ldrh r2,[r2,#2]
 2301 0454 1A80     	 strh r2,[r3]
1182:../SSC/Src/objdef.c ****                                 pData[2] = pVarPtr[2];
 2302              	 .loc 1 1182 0
 2303 0456 BB6C     	 ldr r3,[r7,#72]
 2304 0458 0433     	 adds r3,r3,#4
 2305 045a 7A69     	 ldr r2,[r7,#20]
 2306 045c 9288     	 ldrh r2,[r2,#4]
 2307 045e 1A80     	 strh r2,[r3]
1183:../SSC/Src/objdef.c ****                                 pData[3] = pVarPtr[3];
 2308              	 .loc 1 1183 0
 2309 0460 BB6C     	 ldr r3,[r7,#72]
 2310 0462 0633     	 adds r3,r3,#6
 2311 0464 7A69     	 ldr r2,[r7,#20]
 2312 0466 D288     	 ldrh r2,[r2,#6]
 2313 0468 1A80     	 strh r2,[r3]
1184:../SSC/Src/objdef.c ****                                 pData += 4;
 2314              	 .loc 1 1184 0
 2315 046a BB6C     	 ldr r3,[r7,#72]
 2316 046c 0833     	 adds r3,r3,#8
 2317 046e BB64     	 str r3,[r7,#72]
1185:../SSC/Src/objdef.c ****                                 break;
 2318              	 .loc 1 1185 0
 2319 0470 51E0     	 b .L154
 2320              	.L147:
1186:../SSC/Src/objdef.c ****                             case    DEFTYPE_OCTETSTRING:
1187:../SSC/Src/objdef.c ****                             case    DEFTYPE_UNICODE_STRING:
1188:../SSC/Src/objdef.c ****                             case DEFTYPE_ARRAY_OF_INT :
1189:../SSC/Src/objdef.c ****                             case DEFTYPE_ARRAY_OF_SINT :
1190:../SSC/Src/objdef.c ****                             case DEFTYPE_ARRAY_OF_DINT :
1191:../SSC/Src/objdef.c ****                             case DEFTYPE_ARRAY_OF_UDINT:
1192:../SSC/Src/objdef.c **** 
1193:../SSC/Src/objdef.c ****                                 if(bitOffset & 0xF)
 2321              	 .loc 1 1193 0
 2322 0472 FB8D     	 ldrh r3,[r7,#46]
 2323 0474 03F00F03 	 and r3,r3,#15
 2324 0478 002B     	 cmp r3,#0
 2325 047a 01D0     	 beq .L162
1194:../SSC/Src/objdef.c ****                                 {
1195:../SSC/Src/objdef.c ****                                     /* return an error in case of an odd word offset (to support 16
1196:../SSC/Src/objdef.c ****                                     return ABORTIDX_UNSUPPORTED_ACCESS;
 2326              	 .loc 1 1196 0
 2327 047c 0523     	 movs r3,#5
 2328 047e A3E0     	 b .L118
 2329              	.L162:
1197:../SSC/Src/objdef.c ****                                 }
1198:../SSC/Src/objdef.c **** 
1199:../SSC/Src/objdef.c ****                                 OBJTOMBXMEMCPY(pData, pVarPtr, BIT2BYTE(pEntry->BitLength));
 2330              	 .loc 1 1199 0
 2331 0480 7B6A     	 ldr r3,[r7,#36]
 2332 0482 5B88     	 ldrh r3,[r3,#2]
 2333 0484 0733     	 adds r3,r3,#7
 2334 0486 DB10     	 asrs r3,r3,#3
 2335 0488 B86C     	 ldr r0,[r7,#72]
 2336 048a 7969     	 ldr r1,[r7,#20]
 2337 048c 1A46     	 mov r2,r3
 2338 048e FFF7FEFF 	 bl memcpy
1200:../SSC/Src/objdef.c **** 
1201:../SSC/Src/objdef.c ****                                 pData += BIT2WORD((pEntry->BitLength & ~0xF));
 2339              	 .loc 1 1201 0
 2340 0492 7B6A     	 ldr r3,[r7,#36]
 2341 0494 5B88     	 ldrh r3,[r3,#2]
 2342 0496 23F00F03 	 bic r3,r3,#15
 2343 049a 0F33     	 adds r3,r3,#15
 2344 049c 1B11     	 asrs r3,r3,#4
 2345 049e 5B00     	 lsls r3,r3,#1
 2346 04a0 BA6C     	 ldr r2,[r7,#72]
 2347 04a2 1344     	 add r3,r3,r2
 2348 04a4 BB64     	 str r3,[r7,#72]
1202:../SSC/Src/objdef.c ****                                 
1203:../SSC/Src/objdef.c ****                                 if((pEntry->BitLength & 0xF) != 0)
 2349              	 .loc 1 1203 0
 2350 04a6 7B6A     	 ldr r3,[r7,#36]
 2351 04a8 5B88     	 ldrh r3,[r3,#2]
 2352 04aa 03F00F03 	 and r3,r3,#15
 2353 04ae 002B     	 cmp r3,#0
 2354 04b0 06D0     	 beq .L163
1204:../SSC/Src/objdef.c ****                                 {
1205:../SSC/Src/objdef.c ****                                     /*current entry has an odd word length => clear last byte of ne
1206:../SSC/Src/objdef.c ****                                     *pData &= 0xFF;
 2355              	 .loc 1 1206 0
 2356 04b2 BB6C     	 ldr r3,[r7,#72]
 2357 04b4 1B88     	 ldrh r3,[r3]
 2358 04b6 DBB2     	 uxtb r3,r3
 2359 04b8 9AB2     	 uxth r2,r3
 2360 04ba BB6C     	 ldr r3,[r7,#72]
 2361 04bc 1A80     	 strh r2,[r3]
1207:../SSC/Src/objdef.c ****                                 }
1208:../SSC/Src/objdef.c **** 
1209:../SSC/Src/objdef.c ****                                 break;
 2362              	 .loc 1 1209 0
 2363 04be 2AE0     	 b .L154
 2364              	.L163:
 2365 04c0 29E0     	 b .L154
 2366              	.L146:
1210:../SSC/Src/objdef.c ****                             case    DEFTYPE_VISIBLESTRING:
1211:../SSC/Src/objdef.c ****                                 if(bitOffset & 0xF)
 2367              	 .loc 1 1211 0
 2368 04c2 FB8D     	 ldrh r3,[r7,#46]
 2369 04c4 03F00F03 	 and r3,r3,#15
 2370 04c8 002B     	 cmp r3,#0
 2371 04ca 01D0     	 beq .L164
1212:../SSC/Src/objdef.c ****                                 {
1213:../SSC/Src/objdef.c ****                                     /* return an error in case of an odd word offset (to support 16
1214:../SSC/Src/objdef.c ****                                     return ABORTIDX_UNSUPPORTED_ACCESS;
 2372              	 .loc 1 1214 0
 2373 04cc 0523     	 movs r3,#5
 2374 04ce 7BE0     	 b .L118
 2375              	.L164:
1215:../SSC/Src/objdef.c ****                                 }
1216:../SSC/Src/objdef.c **** 
1217:../SSC/Src/objdef.c ****                                 /* in this example the objects are defined in that way,
1218:../SSC/Src/objdef.c ****                                 that these types are always starting at an even WORD offset */
1219:../SSC/Src/objdef.c ****                                 OBJTOMBXSTRCPY(pData, pVarPtr, BIT2BYTE(pEntry->BitLength));
 2376              	 .loc 1 1219 0
 2377 04d0 7B6A     	 ldr r3,[r7,#36]
 2378 04d2 5B88     	 ldrh r3,[r3,#2]
 2379 04d4 0733     	 adds r3,r3,#7
 2380 04d6 DB10     	 asrs r3,r3,#3
 2381 04d8 B86C     	 ldr r0,[r7,#72]
 2382 04da 7969     	 ldr r1,[r7,#20]
 2383 04dc 1A46     	 mov r2,r3
 2384 04de FFF7FEFF 	 bl memcpy
1220:../SSC/Src/objdef.c ****                                 pData += BIT2WORD((pEntry->BitLength & ~0xF));
 2385              	 .loc 1 1220 0
 2386 04e2 7B6A     	 ldr r3,[r7,#36]
 2387 04e4 5B88     	 ldrh r3,[r3,#2]
 2388 04e6 23F00F03 	 bic r3,r3,#15
 2389 04ea 0F33     	 adds r3,r3,#15
 2390 04ec 1B11     	 asrs r3,r3,#4
 2391 04ee 5B00     	 lsls r3,r3,#1
 2392 04f0 BA6C     	 ldr r2,[r7,#72]
 2393 04f2 1344     	 add r3,r3,r2
 2394 04f4 BB64     	 str r3,[r7,#72]
1221:../SSC/Src/objdef.c **** 
1222:../SSC/Src/objdef.c ****                                 if((pEntry->BitLength & 0xF) != 0)
 2395              	 .loc 1 1222 0
 2396 04f6 7B6A     	 ldr r3,[r7,#36]
 2397 04f8 5B88     	 ldrh r3,[r3,#2]
 2398 04fa 03F00F03 	 and r3,r3,#15
 2399 04fe 002B     	 cmp r3,#0
 2400 0500 06D0     	 beq .L165
1223:../SSC/Src/objdef.c ****                                 {
1224:../SSC/Src/objdef.c ****                                     /*current entry has an odd word length => clear last byte of ne
1225:../SSC/Src/objdef.c ****                                     *pData &= 0xFF;
 2401              	 .loc 1 1225 0
 2402 0502 BB6C     	 ldr r3,[r7,#72]
 2403 0504 1B88     	 ldrh r3,[r3]
 2404 0506 DBB2     	 uxtb r3,r3
 2405 0508 9AB2     	 uxth r2,r3
 2406 050a BB6C     	 ldr r3,[r7,#72]
 2407 050c 1A80     	 strh r2,[r3]
1226:../SSC/Src/objdef.c ****                                 }
1227:../SSC/Src/objdef.c ****                                 
1228:../SSC/Src/objdef.c ****                                 break;
 2408              	 .loc 1 1228 0
 2409 050e 02E0     	 b .L154
 2410              	.L165:
 2411 0510 01E0     	 b .L154
 2412              	.L136:
1229:../SSC/Src/objdef.c ****                             default:
1230:../SSC/Src/objdef.c ****                                 /* other data types are not supported from this example */
1231:../SSC/Src/objdef.c ****                                 return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
 2413              	 .loc 1 1231 0
 2414 0512 1823     	 movs r3,#24
 2415 0514 58E0     	 b .L118
 2416              	.L154:
1232:../SSC/Src/objdef.c ****                             } //switch (deftype)
1233:../SSC/Src/objdef.c **** 
1234:../SSC/Src/objdef.c ****                             bRead = 1;
 2417              	 .loc 1 1234 0
 2418 0516 0123     	 movs r3,#1
 2419 0518 87F83130 	 strb r3,[r7,#49]
 2420              	.LBE14:
 2421              	.LBE13:
 2422 051c 44E0     	 b .L166
 2423              	.L131:
 2424 051e 43E0     	 b .L166
 2425              	.L129:
 2426              	.LBB16:
1235:../SSC/Src/objdef.c ****                         }
1236:../SSC/Src/objdef.c ****                     }
1237:../SSC/Src/objdef.c ****                 }
1238:../SSC/Src/objdef.c ****                 else
1239:../SSC/Src/objdef.c ****                 {
1240:../SSC/Src/objdef.c ****                     /*No access to current object entry => shift pData if required*/
1241:../SSC/Src/objdef.c ****                     UINT8 cnt = 0;
 2427              	 .loc 1 1241 0
 2428 0520 0023     	 movs r3,#0
 2429 0522 87F82B30 	 strb r3,[r7,#43]
1242:../SSC/Src/objdef.c **** 
1243:../SSC/Src/objdef.c ****                     /*If this entry is the first in the 16Bit block clear the memory*/
1244:../SSC/Src/objdef.c ****                     if ((bitOffset & 0x0F) == 0) 
 2430              	 .loc 1 1244 0
 2431 0526 FB8D     	 ldrh r3,[r7,#46]
 2432 0528 03F00F03 	 and r3,r3,#15
 2433 052c 002B     	 cmp r3,#0
 2434 052e 02D1     	 bne .L167
1245:../SSC/Src/objdef.c ****                     {
1246:../SSC/Src/objdef.c ****                         *pData = 0;
 2435              	 .loc 1 1246 0
 2436 0530 BB6C     	 ldr r3,[r7,#72]
 2437 0532 0022     	 movs r2,#0
 2438 0534 1A80     	 strh r2,[r3]
 2439              	.L167:
1247:../SSC/Src/objdef.c ****                     }
1248:../SSC/Src/objdef.c **** 
1249:../SSC/Src/objdef.c ****                     /*Handle Bit/Byte Offset*/
1250:../SSC/Src/objdef.c ****                     if (((pEntry->BitLength & 0xF) > 0)
 2440              	 .loc 1 1250 0
 2441 0536 7B6A     	 ldr r3,[r7,#36]
 2442 0538 5B88     	 ldrh r3,[r3,#2]
 2443 053a 03F00F03 	 and r3,r3,#15
 2444 053e 002B     	 cmp r3,#0
 2445 0540 0DDD     	 ble .L168
1251:../SSC/Src/objdef.c ****                         && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
 2446              	 .loc 1 1251 0
 2447 0542 FB8D     	 ldrh r3,[r7,#46]
 2448 0544 7A6A     	 ldr r2,[r7,#36]
 2449 0546 5288     	 ldrh r2,[r2,#2]
 2450 0548 1344     	 add r3,r3,r2
 2451 054a 03F00F03 	 and r3,r3,#15
 2452 054e 002B     	 cmp r3,#0
 2453 0550 05D1     	 bne .L168
1252:../SSC/Src/objdef.c ****                     {
1253:../SSC/Src/objdef.c ****                         /* we have reached the UINT16 border */
1254:../SSC/Src/objdef.c ****                         pData++;
 2454              	 .loc 1 1254 0
 2455 0552 BB6C     	 ldr r3,[r7,#72]
 2456 0554 0233     	 adds r3,r3,#2
 2457 0556 BB64     	 str r3,[r7,#72]
1255:../SSC/Src/objdef.c ****                         
1256:../SSC/Src/objdef.c ****                         /*Clear new buffer*/
1257:../SSC/Src/objdef.c ****                         *pData = 0;
 2458              	 .loc 1 1257 0
 2459 0558 BB6C     	 ldr r3,[r7,#72]
 2460 055a 0022     	 movs r2,#0
 2461 055c 1A80     	 strh r2,[r3]
 2462              	.L168:
1258:../SSC/Src/objdef.c ****                     }
1259:../SSC/Src/objdef.c **** 
1260:../SSC/Src/objdef.c ****                     /*increment WORD offset*/
1261:../SSC/Src/objdef.c ****                     for(cnt = 0; cnt <((pEntry->BitLength & 0xF0) >> 4); cnt++)
 2463              	 .loc 1 1261 0
 2464 055e 0023     	 movs r3,#0
 2465 0560 87F82B30 	 strb r3,[r7,#43]
 2466 0564 0AE0     	 b .L169
 2467              	.L170:
1262:../SSC/Src/objdef.c ****                     {
1263:../SSC/Src/objdef.c ****                         
1264:../SSC/Src/objdef.c ****                         /*current 16Bit are skipped => clear current buffer */
1265:../SSC/Src/objdef.c ****                         pData++;
 2468              	 .loc 1 1265 0 discriminator 3
 2469 0566 BB6C     	 ldr r3,[r7,#72]
 2470 0568 0233     	 adds r3,r3,#2
 2471 056a BB64     	 str r3,[r7,#72]
1266:../SSC/Src/objdef.c **** 
1267:../SSC/Src/objdef.c ****                         /*Clear new buffer*/
1268:../SSC/Src/objdef.c ****                         *pData = 0;
 2472              	 .loc 1 1268 0 discriminator 3
 2473 056c BB6C     	 ldr r3,[r7,#72]
 2474 056e 0022     	 movs r2,#0
 2475 0570 1A80     	 strh r2,[r3]
1261:../SSC/Src/objdef.c ****                     {
 2476              	 .loc 1 1261 0 discriminator 3
 2477 0572 97F82B30 	 ldrb r3,[r7,#43]
 2478 0576 0133     	 adds r3,r3,#1
 2479 0578 87F82B30 	 strb r3,[r7,#43]
 2480              	.L169:
1261:../SSC/Src/objdef.c ****                     {
 2481              	 .loc 1 1261 0 is_stmt 0 discriminator 1
 2482 057c 97F82B20 	 ldrb r2,[r7,#43]
 2483 0580 7B6A     	 ldr r3,[r7,#36]
 2484 0582 5B88     	 ldrh r3,[r3,#2]
 2485 0584 03F0F003 	 and r3,r3,#240
 2486 0588 1B11     	 asrs r3,r3,#4
 2487 058a 9A42     	 cmp r2,r3
 2488 058c EBDB     	 blt .L170
1269:../SSC/Src/objdef.c ****                     }
1270:../SSC/Src/objdef.c **** 
1271:../SSC/Src/objdef.c **** 
1272:../SSC/Src/objdef.c ****                     
1273:../SSC/Src/objdef.c **** 
1274:../SSC/Src/objdef.c ****                     /* we don't have read access */
1275:../SSC/Src/objdef.c ****                     if ( (pEntry->ObjAccess & ACCESS_READ) == 0 )
 2489              	 .loc 1 1275 0 is_stmt 1
 2490 058e 7B6A     	 ldr r3,[r7,#36]
 2491 0590 9B88     	 ldrh r3,[r3,#4]
 2492 0592 03F00703 	 and r3,r3,#7
 2493 0596 002B     	 cmp r3,#0
 2494 0598 03D1     	 bne .L171
1276:../SSC/Src/objdef.c ****                     {
1277:../SSC/Src/objdef.c ****                         /* it is a write only entry */
1278:../SSC/Src/objdef.c ****                         result = ABORTIDX_WRITE_ONLY_ENTRY;
 2495              	 .loc 1 1278 0
 2496 059a 0623     	 movs r3,#6
 2497 059c 87F83030 	 strb r3,[r7,#48]
 2498 05a0 02E0     	 b .L166
 2499              	.L171:
1279:../SSC/Src/objdef.c ****                     }
1280:../SSC/Src/objdef.c ****                     else
1281:../SSC/Src/objdef.c ****                     {
1282:../SSC/Src/objdef.c ****                         /* we don't have read access in this state */
1283:../SSC/Src/objdef.c ****                         result = ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED;
 2500              	 .loc 1 1283 0
 2501 05a2 1A23     	 movs r3,#26
 2502 05a4 87F83030 	 strb r3,[r7,#48]
 2503              	.L166:
 2504              	.LBE16:
 2505              	.LBE12:
 999:../SSC/Src/objdef.c ****             {
 2506              	 .loc 1 999 0 discriminator 2
 2507 05a8 FB8E     	 ldrh r3,[r7,#54]
 2508 05aa 0133     	 adds r3,r3,#1
 2509 05ac FB86     	 strh r3,[r7,#54]
 2510              	.L127:
 999:../SSC/Src/objdef.c ****             {
 2511              	 .loc 1 999 0 is_stmt 0 discriminator 1
 2512 05ae FA8E     	 ldrh r2,[r7,#54]
 2513 05b0 7B8E     	 ldrh r3,[r7,#50]
 2514 05b2 9A42     	 cmp r2,r3
 2515 05b4 7FF6EAAD 	 bls .L172
1284:../SSC/Src/objdef.c ****                     }
1285:../SSC/Src/objdef.c ****                 }
1286:../SSC/Src/objdef.c ****             }
1287:../SSC/Src/objdef.c **** 
1288:../SSC/Src/objdef.c ****             if(bRead == 0)
 2516              	 .loc 1 1288 0 is_stmt 1
 2517 05b8 97F83130 	 ldrb r3,[r7,#49]
 2518 05bc 002B     	 cmp r3,#0
 2519 05be 02D1     	 bne .L126
1289:../SSC/Src/objdef.c ****             {
1290:../SSC/Src/objdef.c ****                 return result;
 2520              	 .loc 1 1290 0
 2521 05c0 97F83030 	 ldrb r3,[r7,#48]
 2522 05c4 00E0     	 b .L118
 2523              	.L126:
 2524              	.LBE11:
1291:../SSC/Src/objdef.c ****             }
1292:../SSC/Src/objdef.c ****         }
1293:../SSC/Src/objdef.c **** 
1294:../SSC/Src/objdef.c ****     return 0;
 2525              	 .loc 1 1294 0
 2526 05c6 0023     	 movs r3,#0
 2527              	.L118:
1295:../SSC/Src/objdef.c **** }
 2528              	 .loc 1 1295 0
 2529 05c8 1846     	 mov r0,r3
 2530 05ca 3C37     	 adds r7,r7,#60
 2531              	.LCFI59:
 2532              	 .cfi_def_cfa_offset 12
 2533 05cc BD46     	 mov sp,r7
 2534              	.LCFI60:
 2535              	 .cfi_def_cfa_register 13
 2536              	 
 2537 05ce 90BD     	 pop {r4,r7,pc}
 2538              	.L176:
 2539              	 .align 2
 2540              	.L175:
 2541 05d0 00000000 	 .word cBitMask
 2542              	 .cfi_endproc
 2543              	.LFE185:
 2545              	 .section .text.OBJ_Write,"ax",%progbits
 2546              	 .align 2
 2547              	 .global OBJ_Write
 2548              	 .thumb
 2549              	 .thumb_func
 2551              	OBJ_Write:
 2552              	.LFB186:
1296:../SSC/Src/objdef.c **** 
1297:../SSC/Src/objdef.c **** /////////////////////////////////////////////////////////////////////////////////////////
1298:../SSC/Src/objdef.c **** /**
1299:../SSC/Src/objdef.c ****  \param     index                 index of the requested object.
1300:../SSC/Src/objdef.c ****  \param     subindex                subindex of the requested object.
1301:../SSC/Src/objdef.c ****  \param    dataSize                received data size of the SDO Download
1302:../SSC/Src/objdef.c ****  \param     pObjEntry            handle to the dictionary object returned by
1303:../SSC/Src/objdef.c ****                                      OBJ_GetObjectHandle which was called before
1304:../SSC/Src/objdef.c ****  \param    pData                    Pointer to the buffer where the written data can be copied from
1305:../SSC/Src/objdef.c ****  \param    bCompleteAccess    Indicates if a complete write of all subindices of the
1306:../SSC/Src/objdef.c ****                                      object shall be done or not
1307:../SSC/Src/objdef.c **** 
1308:../SSC/Src/objdef.c ****  \return    result of the write operation (0 (success) or an abort code (ABORTIDX_.... defined in
1309:../SSC/Src/objdef.c ****             sdoserv.h))
1310:../SSC/Src/objdef.c **** 
1311:../SSC/Src/objdef.c ****  \brief    This function writes the requested object
1312:../SSC/Src/objdef.c **** *////////////////////////////////////////////////////////////////////////////////////////
1313:../SSC/Src/objdef.c **** 
1314:../SSC/Src/objdef.c **** UINT8 OBJ_Write( UINT16 index, UINT8 subindex, UINT32 dataSize, OBJCONST TOBJECT OBJMEM * pObjEntry
1315:../SSC/Src/objdef.c **** {
 2553              	 .loc 1 1315 0
 2554              	 .cfi_startproc
 2555              	 
 2556              	 
 2557 0000 90B5     	 push {r4,r7,lr}
 2558              	.LCFI61:
 2559              	 .cfi_def_cfa_offset 12
 2560              	 .cfi_offset 4,-12
 2561              	 .cfi_offset 7,-8
 2562              	 .cfi_offset 14,-4
 2563 0002 91B0     	 sub sp,sp,#68
 2564              	.LCFI62:
 2565              	 .cfi_def_cfa_offset 80
 2566 0004 02AF     	 add r7,sp,#8
 2567              	.LCFI63:
 2568              	 .cfi_def_cfa 7,72
 2569 0006 BA60     	 str r2,[r7,#8]
 2570 0008 7B60     	 str r3,[r7,#4]
 2571 000a 0346     	 mov r3,r0
 2572 000c FB81     	 strh r3,[r7,#14]
 2573 000e 0B46     	 mov r3,r1
 2574 0010 7B73     	 strb r3,[r7,#13]
1316:../SSC/Src/objdef.c ****     UINT16 i = subindex;
 2575              	 .loc 1 1316 0
 2576 0012 7B7B     	 ldrb r3,[r7,#13]
 2577 0014 FB86     	 strh r3,[r7,#54]
1317:../SSC/Src/objdef.c ****     /* get the information of ObjCode and MaxSubindex in local variables to support different types
1318:../SSC/Src/objdef.c ****     UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
 2578              	 .loc 1 1318 0
 2579 0016 7B68     	 ldr r3,[r7,#4]
 2580 0018 9B89     	 ldrh r3,[r3,#12]
 2581 001a 03F47063 	 and r3,r3,#3840
 2582 001e 1B12     	 asrs r3,r3,#8
 2583 0020 87F82330 	 strb r3,[r7,#35]
1319:../SSC/Src/objdef.c ****     UINT16 maxSubindex = 0;
 2584              	 .loc 1 1319 0
 2585 0024 0023     	 movs r3,#0
 2586 0026 BB86     	 strh r3,[r7,#52]
1320:../SSC/Src/objdef.c ****     UINT16 maxConfiguredSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJF
 2587              	 .loc 1 1320 0
 2588 0028 7B68     	 ldr r3,[r7,#4]
 2589 002a 9B89     	 ldrh r3,[r3,#12]
 2590 002c DBB2     	 uxtb r3,r3
 2591 002e 3B84     	 strh r3,[r7,#32]
1321:../SSC/Src/objdef.c ****     OBJCONST TSDOINFOENTRYDESC OBJMEM *pEntry;
1322:../SSC/Src/objdef.c ****     BOOL bClearSubindex0Required = FALSE;
 2592              	 .loc 1 1322 0
 2593 0030 0023     	 movs r3,#0
 2594 0032 87F83330 	 strb r3,[r7,#51]
1323:../SSC/Src/objdef.c ****     /* lastSubindex is used for complete access to make loop over the requested entries
1324:../SSC/Src/objdef.c ****        to be read, we initialize this variable with the requested subindex that only
1325:../SSC/Src/objdef.c ****        one loop will be done for a single access */
1326:../SSC/Src/objdef.c ****     UINT16 lastSubindex = subindex;
 2595              	 .loc 1 1326 0
 2596 0036 7B7B     	 ldrb r3,[r7,#13]
 2597 0038 3B86     	 strh r3,[r7,#48]
1327:../SSC/Src/objdef.c **** 
1328:../SSC/Src/objdef.c ****     /* if subindex 0 is writable, the maximum subindex should be checked in an object specific func
1329:../SSC/Src/objdef.c ****         because for the PDO mapping and PDO assign the object shall only be written if subindex 0 i
1330:../SSC/Src/objdef.c ****     if ( objCode != OBJCODE_VAR )
 2598              	 .loc 1 1330 0
 2599 003a 97F82330 	 ldrb r3,[r7,#35]
 2600 003e 072B     	 cmp r3,#7
 2601 0040 28D0     	 beq .L178
1331:../SSC/Src/objdef.c ****     {
1332:../SSC/Src/objdef.c ****         /* if the object is an array or record we have to get the maxSubindex from the
1333:../SSC/Src/objdef.c ****            actual value of subindex 0, which is stored as UINT16 at the beginning of the
1334:../SSC/Src/objdef.c ****             object's variable */
1335:../SSC/Src/objdef.c ****         maxSubindex = (UINT8) ((UINT16 MBXMEM *) (pObjEntry->pVarPtr))[0];
 2602              	 .loc 1 1335 0
 2603 0042 7B68     	 ldr r3,[r7,#4]
 2604 0044 9B69     	 ldr r3,[r3,#24]
 2605 0046 1B88     	 ldrh r3,[r3]
 2606 0048 DBB2     	 uxtb r3,r3
 2607 004a BB86     	 strh r3,[r7,#52]
1336:../SSC/Src/objdef.c **** 
1337:../SSC/Src/objdef.c ****         /*If the subindex0 of a PDO assign or PDO mapping object is 0 the maximum subindex is speci
1338:../SSC/Src/objdef.c ****         if(maxSubindex == 0 && (IS_PDO_ASSIGN(index) || IS_RX_PDO(index) || IS_TX_PDO(index) || (in
 2608              	 .loc 1 1338 0
 2609 004c BB8E     	 ldrh r3,[r7,#52]
 2610 004e 002B     	 cmp r3,#0
 2611 0050 20D1     	 bne .L178
 2612              	 .loc 1 1338 0 is_stmt 0 discriminator 1
 2613 0052 FB89     	 ldrh r3,[r7,#14]
 2614 0054 41F60F42 	 movw r2,#7183
 2615 0058 9342     	 cmp r3,r2
 2616 005a 04D9     	 bls .L179
 2617              	 .loc 1 1338 0 discriminator 2
 2618 005c FB89     	 ldrh r3,[r7,#14]
 2619 005e 41F62F42 	 movw r2,#7215
 2620 0062 9342     	 cmp r3,r2
 2621 0064 14D9     	 bls .L180
 2622              	.L179:
 2623              	 .loc 1 1338 0 discriminator 4
 2624 0066 FB89     	 ldrh r3,[r7,#14]
 2625 0068 B3F5B05F 	 cmp r3,#5632
 2626 006c 03D3     	 bcc .L181
 2627              	 .loc 1 1338 0 discriminator 5
 2628 006e FB89     	 ldrh r3,[r7,#14]
 2629 0070 B3F5C05F 	 cmp r3,#6144
 2630 0074 0CD3     	 bcc .L180
 2631              	.L181:
 2632              	 .loc 1 1338 0 discriminator 7
 2633 0076 FB89     	 ldrh r3,[r7,#14]
 2634 0078 B3F5D05F 	 cmp r3,#6656
 2635 007c 03D3     	 bcc .L182
 2636              	 .loc 1 1338 0 discriminator 8
 2637 007e FB89     	 ldrh r3,[r7,#14]
 2638 0080 B3F5E05F 	 cmp r3,#7168
 2639 0084 04D3     	 bcc .L180
 2640              	.L182:
 2641              	 .loc 1 1338 0 discriminator 10
 2642 0086 FB89     	 ldrh r3,[r7,#14]
 2643 0088 4FF23002 	 movw r2,#61488
 2644 008c 9342     	 cmp r3,r2
 2645 008e 01D1     	 bne .L178
 2646              	.L180:
1339:../SSC/Src/objdef.c ****         {
1340:../SSC/Src/objdef.c ****             maxSubindex = maxConfiguredSubindex;
 2647              	 .loc 1 1340 0 is_stmt 1
 2648 0090 3B8C     	 ldrh r3,[r7,#32]
 2649 0092 BB86     	 strh r3,[r7,#52]
 2650              	.L178:
1341:../SSC/Src/objdef.c ****         }
1342:../SSC/Src/objdef.c ****     }
1343:../SSC/Src/objdef.c **** 
1344:../SSC/Src/objdef.c **** 
1345:../SSC/Src/objdef.c ****     if ( bCompleteAccess )
 2651              	 .loc 1 1345 0
 2652 0094 97F84C30 	 ldrb r3,[r7,#76]
 2653 0098 002B     	 cmp r3,#0
 2654 009a 12D0     	 beq .L183
1346:../SSC/Src/objdef.c ****     {
1347:../SSC/Src/objdef.c ****         if ( objCode == OBJCODE_VAR )
 2655              	 .loc 1 1347 0
 2656 009c 97F82330 	 ldrb r3,[r7,#35]
 2657 00a0 072B     	 cmp r3,#7
 2658 00a2 01D1     	 bne .L184
1348:../SSC/Src/objdef.c ****         {
1349:../SSC/Src/objdef.c ****             /* complete access is not supported with simple objects */
1350:../SSC/Src/objdef.c ****             return ABORTIDX_UNSUPPORTED_ACCESS;
 2659              	 .loc 1 1350 0
 2660 00a4 0523     	 movs r3,#5
 2661 00a6 37E3     	 b .L185
 2662              	.L184:
1351:../SSC/Src/objdef.c ****         }
1352:../SSC/Src/objdef.c **** 
1353:../SSC/Src/objdef.c ****         if ((subindex == 0) && (dataSize > 0))
 2663              	 .loc 1 1353 0
 2664 00a8 7B7B     	 ldrb r3,[r7,#13]
 2665 00aa 002B     	 cmp r3,#0
 2666 00ac 06D1     	 bne .L186
 2667              	 .loc 1 1353 0 is_stmt 0 discriminator 1
 2668 00ae BB68     	 ldr r3,[r7,#8]
 2669 00b0 002B     	 cmp r3,#0
 2670 00b2 03D0     	 beq .L186
1354:../SSC/Src/objdef.c ****         {
1355:../SSC/Src/objdef.c ****             /* we change the subindex 0 */
1356:../SSC/Src/objdef.c ****             maxSubindex = (UINT8) SWAPWORD(pData[0]);
 2671              	 .loc 1 1356 0 is_stmt 1
 2672 00b4 BB6C     	 ldr r3,[r7,#72]
 2673 00b6 1B88     	 ldrh r3,[r3]
 2674 00b8 DBB2     	 uxtb r3,r3
 2675 00ba BB86     	 strh r3,[r7,#52]
 2676              	.L186:
1357:../SSC/Src/objdef.c ****         }
1358:../SSC/Src/objdef.c **** 
1359:../SSC/Src/objdef.c **** 
1360:../SSC/Src/objdef.c ****         /* we write until the maximum subindex */
1361:../SSC/Src/objdef.c ****         lastSubindex = maxSubindex;
 2677              	 .loc 1 1361 0
 2678 00bc BB8E     	 ldrh r3,[r7,#52]
 2679 00be 3B86     	 strh r3,[r7,#48]
 2680 00c0 2AE0     	 b .L187
 2681              	.L183:
1362:../SSC/Src/objdef.c ****     }
1363:../SSC/Src/objdef.c ****     else
1364:../SSC/Src/objdef.c ****     if (subindex > maxSubindex)
 2682              	 .loc 1 1364 0
 2683 00c2 7B7B     	 ldrb r3,[r7,#13]
 2684 00c4 9BB2     	 uxth r3,r3
 2685 00c6 BA8E     	 ldrh r2,[r7,#52]
 2686 00c8 9A42     	 cmp r2,r3
 2687 00ca 01D2     	 bcs .L188
1365:../SSC/Src/objdef.c ****     {
1366:../SSC/Src/objdef.c ****         /* the maximum subindex is reached */
1367:../SSC/Src/objdef.c ****         return ABORTIDX_SUBINDEX_NOT_EXISTING;
 2688              	 .loc 1 1367 0
 2689 00cc 1123     	 movs r3,#17
 2690 00ce 23E3     	 b .L185
 2691              	.L188:
1368:../SSC/Src/objdef.c ****     }
1369:../SSC/Src/objdef.c ****     else
1370:../SSC/Src/objdef.c ****     {
1371:../SSC/Src/objdef.c ****         /* we check the write access for single accesses here, a complete write access
1372:../SSC/Src/objdef.c ****            is allowed if at least one entry is writable (in this case the values for the
1373:../SSC/Src/objdef.c ****             read only entries shall be ignored) */
1374:../SSC/Src/objdef.c ****         /* we get the corresponding entry description */
1375:../SSC/Src/objdef.c ****         pEntry = OBJ_GetEntryDesc(pObjEntry, subindex);
 2692              	 .loc 1 1375 0
 2693 00d0 7B7B     	 ldrb r3,[r7,#13]
 2694 00d2 7868     	 ldr r0,[r7,#4]
 2695 00d4 1946     	 mov r1,r3
 2696 00d6 FFF7FEFF 	 bl OBJ_GetEntryDesc
 2697 00da F861     	 str r0,[r7,#28]
1376:../SSC/Src/objdef.c **** 
1377:../SSC/Src/objdef.c ****         /* check if we have write access (bits 3-5 (PREOP, SAFEOP, OP) of ObjAccess)
1378:../SSC/Src/objdef.c ****            by comparing with the actual state (bits 1-3 (PREOP, SAFEOP, OP) of AL Status) */
1379:../SSC/Src/objdef.c ****         if (0 == (((UINT8)((pEntry->ObjAccess & ACCESS_WRITE) >> 2)) & (nAlStatus & STATE_MASK) ))
 2698              	 .loc 1 1379 0
 2699 00dc FB69     	 ldr r3,[r7,#28]
 2700 00de 9B88     	 ldrh r3,[r3,#4]
 2701 00e0 03F03803 	 and r3,r3,#56
 2702 00e4 9B10     	 asrs r3,r3,#2
 2703 00e6 DBB2     	 uxtb r3,r3
 2704 00e8 1A46     	 mov r2,r3
 2705 00ea 9D4B     	 ldr r3,.L254
 2706 00ec 1B78     	 ldrb r3,[r3]
 2707 00ee 03F00F03 	 and r3,r3,#15
 2708 00f2 1340     	 ands r3,r3,r2
 2709 00f4 002B     	 cmp r3,#0
 2710 00f6 0FD1     	 bne .L187
1380:../SSC/Src/objdef.c ****         {
1381:../SSC/Src/objdef.c ****             /* we don't have write access */
1382:../SSC/Src/objdef.c ****             if ( (pEntry->ObjAccess & ACCESS_WRITE) == 0 )
 2711              	 .loc 1 1382 0
 2712 00f8 FB69     	 ldr r3,[r7,#28]
 2713 00fa 9B88     	 ldrh r3,[r3,#4]
 2714 00fc 03F03803 	 and r3,r3,#56
 2715 0100 002B     	 cmp r3,#0
 2716 0102 07D1     	 bne .L189
1383:../SSC/Src/objdef.c ****             {
1384:../SSC/Src/objdef.c ****                 if (pEntry->ObjAccess == 0)
 2717              	 .loc 1 1384 0
 2718 0104 FB69     	 ldr r3,[r7,#28]
 2719 0106 9B88     	 ldrh r3,[r3,#4]
 2720 0108 002B     	 cmp r3,#0
 2721 010a 01D1     	 bne .L190
1385:../SSC/Src/objdef.c ****                 {
1386:../SSC/Src/objdef.c ****                         return ABORTIDX_UNSUPPORTED_ACCESS;
 2722              	 .loc 1 1386 0
 2723 010c 0523     	 movs r3,#5
 2724 010e 03E3     	 b .L185
 2725              	.L190:
1387:../SSC/Src/objdef.c ****                 }
1388:../SSC/Src/objdef.c ****                 else
1389:../SSC/Src/objdef.c ****                 {
1390:../SSC/Src/objdef.c ****                         /* it is a read only entry */
1391:../SSC/Src/objdef.c ****                         return ABORTIDX_READ_ONLY_ENTRY;
 2726              	 .loc 1 1391 0
 2727 0110 0723     	 movs r3,#7
 2728 0112 01E3     	 b .L185
 2729              	.L189:
1392:../SSC/Src/objdef.c ****                 }
1393:../SSC/Src/objdef.c ****             }
1394:../SSC/Src/objdef.c ****             else
1395:../SSC/Src/objdef.c ****             {
1396:../SSC/Src/objdef.c ****                 /* we don't have write access in this state */
1397:../SSC/Src/objdef.c ****                 return ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED;
 2730              	 .loc 1 1397 0
 2731 0114 1A23     	 movs r3,#26
 2732 0116 FFE2     	 b .L185
 2733              	.L187:
1398:../SSC/Src/objdef.c ****             }
1399:../SSC/Src/objdef.c ****         }
1400:../SSC/Src/objdef.c **** 
1401:../SSC/Src/objdef.c **** 
1402:../SSC/Src/objdef.c ****     }
1403:../SSC/Src/objdef.c **** 
1404:../SSC/Src/objdef.c ****     /* Subindex 0 shall be set to zero if a single PDO / PDO assign entry is written
1405:../SSC/Src/objdef.c ****     or a complete access without subindex0 is requested */
1406:../SSC/Src/objdef.c ****     if((subindex > 0) &&
 2734              	 .loc 1 1406 0
 2735 0118 7B7B     	 ldrb r3,[r7,#13]
 2736 011a 002B     	 cmp r3,#0
 2737 011c 29D0     	 beq .L191
 2738              	 .loc 1 1406 0 is_stmt 0 discriminator 1
 2739 011e FB89     	 ldrh r3,[r7,#14]
 2740 0120 41F60F42 	 movw r2,#7183
 2741 0124 9342     	 cmp r3,r2
 2742 0126 04D9     	 bls .L192
1407:../SSC/Src/objdef.c ****         (IS_PDO_ASSIGN(index) || IS_RX_PDO(index)|| IS_TX_PDO(index) || (index == 0xF030))
 2743              	 .loc 1 1407 0 is_stmt 1
 2744 0128 FB89     	 ldrh r3,[r7,#14]
 2745 012a 41F62F42 	 movw r2,#7215
 2746 012e 9342     	 cmp r3,r2
 2747 0130 14D9     	 bls .L193
 2748              	.L192:
 2749              	 .loc 1 1407 0 is_stmt 0 discriminator 1
 2750 0132 FB89     	 ldrh r3,[r7,#14]
 2751 0134 B3F5B05F 	 cmp r3,#5632
 2752 0138 03D3     	 bcc .L194
 2753              	 .loc 1 1407 0 discriminator 2
 2754 013a FB89     	 ldrh r3,[r7,#14]
 2755 013c B3F5C05F 	 cmp r3,#6144
 2756 0140 0CD3     	 bcc .L193
 2757              	.L194:
 2758              	 .loc 1 1407 0 discriminator 4
 2759 0142 FB89     	 ldrh r3,[r7,#14]
 2760 0144 B3F5D05F 	 cmp r3,#6656
 2761 0148 03D3     	 bcc .L195
 2762              	 .loc 1 1407 0 discriminator 5
 2763 014a FB89     	 ldrh r3,[r7,#14]
 2764 014c B3F5E05F 	 cmp r3,#7168
 2765 0150 04D3     	 bcc .L193
 2766              	.L195:
 2767              	 .loc 1 1407 0 discriminator 7
 2768 0152 FB89     	 ldrh r3,[r7,#14]
 2769 0154 4FF23002 	 movw r2,#61488
 2770 0158 9342     	 cmp r3,r2
 2771 015a 0AD1     	 bne .L191
 2772              	.L193:
 2773              	.LBB17:
1408:../SSC/Src/objdef.c ****         )
1409:../SSC/Src/objdef.c ****     {
1410:../SSC/Src/objdef.c ****         /*Check if Subindex0 was cleared before*/
1411:../SSC/Src/objdef.c ****         UINT16 Subindex0 = (*(UINT16 *)pObjEntry->pVarPtr) & 0x00FF;
 2774              	 .loc 1 1411 0 is_stmt 1
 2775 015c 7B68     	 ldr r3,[r7,#4]
 2776 015e 9B69     	 ldr r3,[r3,#24]
 2777 0160 1B88     	 ldrh r3,[r3]
 2778 0162 DBB2     	 uxtb r3,r3
 2779 0164 7B83     	 strh r3,[r7,#26]
1412:../SSC/Src/objdef.c ****         if(Subindex0 != 0x00)
 2780              	 .loc 1 1412 0
 2781 0166 7B8B     	 ldrh r3,[r7,#26]
 2782 0168 002B     	 cmp r3,#0
 2783 016a 02D0     	 beq .L191
1413:../SSC/Src/objdef.c ****         {
1414:../SSC/Src/objdef.c ****             bClearSubindex0Required = TRUE;
 2784              	 .loc 1 1414 0
 2785 016c 0123     	 movs r3,#1
 2786 016e 87F83330 	 strb r3,[r7,#51]
 2787              	.L191:
 2788              	.LBE17:
1415:../SSC/Src/objdef.c ****         }
1416:../SSC/Src/objdef.c ****     }
1417:../SSC/Src/objdef.c **** 
1418:../SSC/Src/objdef.c ****     if ( pObjEntry->Write != NULL )
 2789              	 .loc 1 1418 0
 2790 0172 7B68     	 ldr r3,[r7,#4]
 2791 0174 1B6A     	 ldr r3,[r3,#32]
 2792 0176 002B     	 cmp r3,#0
 2793 0178 24D0     	 beq .L196
 2794              	.LBB18:
1419:../SSC/Src/objdef.c ****     {
1420:../SSC/Src/objdef.c ****         /* Write function is defined, we call the object specific write function */
1421:../SSC/Src/objdef.c ****         /* ECATCHANGE_START(V5.13) COE4*/
1422:../SSC/Src/objdef.c ****         UINT8 result = 0;
 2795              	 .loc 1 1422 0
 2796 017a 0023     	 movs r3,#0
 2797 017c 7B76     	 strb r3,[r7,#25]
1423:../SSC/Src/objdef.c **** 
1424:../SSC/Src/objdef.c ****         result = pObjEntry->Write(index, subindex, dataSize, pData, bCompleteAccess);
 2798              	 .loc 1 1424 0
 2799 017e 7B68     	 ldr r3,[r7,#4]
 2800 0180 1C6A     	 ldr r4,[r3,#32]
 2801 0182 F989     	 ldrh r1,[r7,#14]
 2802 0184 7A7B     	 ldrb r2,[r7,#13]
 2803 0186 97F84C30 	 ldrb r3,[r7,#76]
 2804 018a 0093     	 str r3,[sp]
 2805 018c 0846     	 mov r0,r1
 2806 018e 1146     	 mov r1,r2
 2807 0190 BA68     	 ldr r2,[r7,#8]
 2808 0192 BB6C     	 ldr r3,[r7,#72]
 2809 0194 A047     	 blx r4
 2810 0196 0346     	 mov r3,r0
 2811 0198 7B76     	 strb r3,[r7,#25]
1425:../SSC/Src/objdef.c **** 
1426:../SSC/Src/objdef.c ****         if ((result == 0) && (pAPPL_CoeWriteInd != NULL))
 2812              	 .loc 1 1426 0
 2813 019a 7B7E     	 ldrb r3,[r7,#25]
 2814 019c 002B     	 cmp r3,#0
 2815 019e 0FD1     	 bne .L197
 2816              	 .loc 1 1426 0 is_stmt 0 discriminator 1
 2817 01a0 704B     	 ldr r3,.L254+4
 2818 01a2 1B68     	 ldr r3,[r3]
 2819 01a4 002B     	 cmp r3,#0
 2820 01a6 0BD0     	 beq .L197
1427:../SSC/Src/objdef.c ****         {
1428:../SSC/Src/objdef.c ****             pAPPL_CoeWriteInd(index, subindex, bCompleteAccess);
 2821              	 .loc 1 1428 0 is_stmt 1
 2822 01a8 6E4B     	 ldr r3,.L254+4
 2823 01aa 1B68     	 ldr r3,[r3]
 2824 01ac 97F84C20 	 ldrb r2,[r7,#76]
 2825 01b0 002A     	 cmp r2,#0
 2826 01b2 14BF     	 ite ne
 2827 01b4 0122     	 movne r2,#1
 2828 01b6 0022     	 moveq r2,#0
 2829 01b8 D2B2     	 uxtb r2,r2
 2830 01ba F889     	 ldrh r0,[r7,#14]
 2831 01bc 797B     	 ldrb r1,[r7,#13]
 2832 01be 9847     	 blx r3
 2833              	.L197:
1429:../SSC/Src/objdef.c ****         }
1430:../SSC/Src/objdef.c ****         
1431:../SSC/Src/objdef.c ****         return result;
 2834              	 .loc 1 1431 0
 2835 01c0 7B7E     	 ldrb r3,[r7,#25]
 2836 01c2 A9E2     	 b .L185
 2837              	.L196:
 2838              	.LBE18:
 2839              	.LBB19:
1432:../SSC/Src/objdef.c ****         /* ECATCHANGE_END(V5.13) COE4*/
1433:../SSC/Src/objdef.c ****     }
1434:../SSC/Src/objdef.c ****     else
1435:../SSC/Src/objdef.c ****     {
1436:../SSC/Src/objdef.c ****         UINT8 bWritten = 0;
 2840              	 .loc 1 1436 0
 2841 01c4 0023     	 movs r3,#0
 2842 01c6 87F82F30 	 strb r3,[r7,#47]
1437:../SSC/Src/objdef.c ****         UINT8 result = ABORTIDX_READ_ONLY_ENTRY;
 2843              	 .loc 1 1437 0
 2844 01ca 0723     	 movs r3,#7
 2845 01cc 87F82E30 	 strb r3,[r7,#46]
1438:../SSC/Src/objdef.c **** 
1439:../SSC/Src/objdef.c ****         if (dataSize == 0)
 2846              	 .loc 1 1439 0
 2847 01d0 BB68     	 ldr r3,[r7,#8]
 2848 01d2 002B     	 cmp r3,#0
 2849 01d4 01D1     	 bne .L198
1440:../SSC/Src/objdef.c ****         {
1441:../SSC/Src/objdef.c ****            return 0; //no error
 2850              	 .loc 1 1441 0
 2851 01d6 0023     	 movs r3,#0
 2852 01d8 9EE2     	 b .L185
 2853              	.L198:
1442:../SSC/Src/objdef.c ****         }
1443:../SSC/Src/objdef.c **** 
1444:../SSC/Src/objdef.c ****         /* we use the standard write function */
1445:../SSC/Src/objdef.c ****         for (i = subindex; i <= lastSubindex; i++)
 2854              	 .loc 1 1445 0
 2855 01da 7B7B     	 ldrb r3,[r7,#13]
 2856 01dc FB86     	 strh r3,[r7,#54]
 2857 01de 7EE2     	 b .L199
 2858              	.L251:
 2859              	.LBB20:
1446:../SSC/Src/objdef.c ****         {
1447:../SSC/Src/objdef.c ****             /* if only a single entry is requested, this loop will only be done once */
1448:../SSC/Src/objdef.c ****             UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
 2860              	 .loc 1 1448 0
 2861 01e0 7B68     	 ldr r3,[r7,#4]
 2862 01e2 9B69     	 ldr r3,[r3,#24]
 2863 01e4 BB62     	 str r3,[r7,#40]
1449:../SSC/Src/objdef.c ****             UINT16 bitOffset = 0;
 2864              	 .loc 1 1449 0
 2865 01e6 0023     	 movs r3,#0
 2866 01e8 FB82     	 strh r3,[r7,#22]
1450:../SSC/Src/objdef.c **** 
1451:../SSC/Src/objdef.c ****             /* we get the corresponding entry description */
1452:../SSC/Src/objdef.c ****             pEntry = OBJ_GetEntryDesc(pObjEntry,(UINT8) i);
 2867              	 .loc 1 1452 0
 2868 01ea FB8E     	 ldrh r3,[r7,#54]
 2869 01ec DBB2     	 uxtb r3,r3
 2870 01ee 7868     	 ldr r0,[r7,#4]
 2871 01f0 1946     	 mov r1,r3
 2872 01f2 FFF7FEFF 	 bl OBJ_GetEntryDesc
 2873 01f6 F861     	 str r0,[r7,#28]
1453:../SSC/Src/objdef.c **** 
1454:../SSC/Src/objdef.c ****             /*Get the bitOffset before check the access rights to calculate pData offset*/
1455:../SSC/Src/objdef.c ****             bitOffset = OBJ_GetEntryOffset((UINT8)i, pObjEntry);
 2874              	 .loc 1 1455 0
 2875 01f8 FB8E     	 ldrh r3,[r7,#54]
 2876 01fa DBB2     	 uxtb r3,r3
 2877 01fc 1846     	 mov r0,r3
 2878 01fe 7968     	 ldr r1,[r7,#4]
 2879 0200 FFF7FEFF 	 bl OBJ_GetEntryOffset
 2880 0204 0346     	 mov r3,r0
 2881 0206 FB82     	 strh r3,[r7,#22]
1456:../SSC/Src/objdef.c **** 
1457:../SSC/Src/objdef.c ****             /* we check if we have write access (bits 3-5 (PREOP, SAFEOP, OP) of ObjAccess)
1458:../SSC/Src/objdef.c ****                by comparing with the actual state (bits 1-3 (PREOP, SAFEOP, OP) of AL Status) */
1459:../SSC/Src/objdef.c ****             if (0 != (((UINT8)((pEntry->ObjAccess & ACCESS_WRITE) >> 2)) & (nAlStatus & STATE_MASK)
 2882              	 .loc 1 1459 0
 2883 0208 FB69     	 ldr r3,[r7,#28]
 2884 020a 9B88     	 ldrh r3,[r3,#4]
 2885 020c 03F03803 	 and r3,r3,#56
 2886 0210 9B10     	 asrs r3,r3,#2
 2887 0212 DBB2     	 uxtb r3,r3
 2888 0214 1A46     	 mov r2,r3
 2889 0216 524B     	 ldr r3,.L254
 2890 0218 1B78     	 ldrb r3,[r3]
 2891 021a 03F00F03 	 and r3,r3,#15
 2892 021e 1340     	 ands r3,r3,r2
 2893 0220 002B     	 cmp r3,#0
 2894 0222 00F03682 	 beq .L200
1460:../SSC/Src/objdef.c ****             {
1461:../SSC/Src/objdef.c ****                 /* we have write access for this entry */
1462:../SSC/Src/objdef.c ****                 if (i != 0)
 2895              	 .loc 1 1462 0
 2896 0226 FB8E     	 ldrh r3,[r7,#54]
 2897 0228 002B     	 cmp r3,#0
 2898 022a 06D0     	 beq .L201
1463:../SSC/Src/objdef.c ****                 {
1464:../SSC/Src/objdef.c ****                     /* we increment the variable pointer to the corresponding word address */
1465:../SSC/Src/objdef.c ****                     pVarPtr += (bitOffset >> 4);
 2899              	 .loc 1 1465 0
 2900 022c FB8A     	 ldrh r3,[r7,#22]
 2901 022e 1B09     	 lsrs r3,r3,#4
 2902 0230 9BB2     	 uxth r3,r3
 2903 0232 5B00     	 lsls r3,r3,#1
 2904 0234 BA6A     	 ldr r2,[r7,#40]
 2905 0236 1344     	 add r3,r3,r2
 2906 0238 BB62     	 str r3,[r7,#40]
 2907              	.L201:
1466:../SSC/Src/objdef.c ****                 }
1467:../SSC/Src/objdef.c **** 
1468:../SSC/Src/objdef.c **** 
1469:../SSC/Src/objdef.c ****                 if ( i == subindex                                     /* requested entry */
 2908              	 .loc 1 1469 0
 2909 023a 7B7B     	 ldrb r3,[r7,#13]
 2910 023c 9BB2     	 uxth r3,r3
 2911 023e FA8E     	 ldrh r2,[r7,#54]
 2912 0240 9A42     	 cmp r2,r3
 2913 0242 0AD0     	 beq .L202
1470:../SSC/Src/objdef.c ****                   || (bCompleteAccess && i >= subindex) )       /* complete access and entry should
 2914              	 .loc 1 1470 0
 2915 0244 97F84C30 	 ldrb r3,[r7,#76]
 2916 0248 002B     	 cmp r3,#0
 2917 024a 00F04582 	 beq .L247
 2918              	 .loc 1 1470 0 is_stmt 0 discriminator 1
 2919 024e 7B7B     	 ldrb r3,[r7,#13]
 2920 0250 9BB2     	 uxth r3,r3
 2921 0252 FA8E     	 ldrh r2,[r7,#54]
 2922 0254 9A42     	 cmp r2,r3
 2923 0256 C0F03F82 	 bcc .L247
 2924              	.L202:
 2925              	.LBB21:
1471:../SSC/Src/objdef.c ****                 {
1472:../SSC/Src/objdef.c ****                     UINT16 bitMask;
1473:../SSC/Src/objdef.c **** 
1474:../SSC/Src/objdef.c ****                     /* we have to copy the entry */
1475:../SSC/Src/objdef.c ****                     if (i == 0 && objCode != OBJCODE_VAR)
 2926              	 .loc 1 1475 0 is_stmt 1
 2927 025a FB8E     	 ldrh r3,[r7,#54]
 2928 025c 002B     	 cmp r3,#0
 2929 025e 15D1     	 bne .L204
 2930              	 .loc 1 1475 0 is_stmt 0 discriminator 1
 2931 0260 97F82330 	 ldrb r3,[r7,#35]
 2932 0264 072B     	 cmp r3,#7
 2933 0266 11D0     	 beq .L204
 2934              	.LBB22:
1476:../SSC/Src/objdef.c ****                     {
1477:../SSC/Src/objdef.c ****                         /*check if the value for subindex0 is valid */
1478:../SSC/Src/objdef.c ****                         UINT8 NewSubindex0 = (UINT8) SWAPWORD(pData[0]);
 2935              	 .loc 1 1478 0 is_stmt 1
 2936 0268 BB6C     	 ldr r3,[r7,#72]
 2937 026a 1B88     	 ldrh r3,[r3]
 2938 026c 7B74     	 strb r3,[r7,#17]
1479:../SSC/Src/objdef.c ****                         
1480:../SSC/Src/objdef.c ****                         if(maxConfiguredSubindex < NewSubindex0)
 2939              	 .loc 1 1480 0
 2940 026e 7B7C     	 ldrb r3,[r7,#17]
 2941 0270 9BB2     	 uxth r3,r3
 2942 0272 3A8C     	 ldrh r2,[r7,#32]
 2943 0274 9A42     	 cmp r2,r3
 2944 0276 01D2     	 bcs .L205
1481:../SSC/Src/objdef.c ****                         {
1482:../SSC/Src/objdef.c ****                             return ABORTIDX_VALUE_TOO_GREAT;
 2945              	 .loc 1 1482 0
 2946 0278 1323     	 movs r3,#19
 2947 027a 4DE2     	 b .L185
 2948              	.L205:
1483:../SSC/Src/objdef.c ****                         }
1484:../SSC/Src/objdef.c **** 
1485:../SSC/Src/objdef.c ****                         /* subindex 0 of an array or record shall be written */
1486:../SSC/Src/objdef.c ****                         pVarPtr[0] = SWAPWORD(pData[0]);
 2949              	 .loc 1 1486 0
 2950 027c BB6C     	 ldr r3,[r7,#72]
 2951 027e 1A88     	 ldrh r2,[r3]
 2952 0280 BB6A     	 ldr r3,[r7,#40]
 2953 0282 1A80     	 strh r2,[r3]
1487:../SSC/Src/objdef.c ****                         /* we increment the destination pointer by 2 because the subindex 0 will be
1488:../SSC/Src/objdef.c ****                            transmitted as UINT16 for a complete access */
1489:../SSC/Src/objdef.c ****                         pData++;
 2954              	 .loc 1 1489 0
 2955 0284 BB6C     	 ldr r3,[r7,#72]
 2956 0286 0233     	 adds r3,r3,#2
 2957 0288 BB64     	 str r3,[r7,#72]
 2958              	.LBE22:
1476:../SSC/Src/objdef.c ****                         /*check if the value for subindex0 is valid */
 2959              	 .loc 1 1476 0
 2960 028a FEE1     	 b .L206
 2961              	.L204:
 2962              	.LBB23:
1490:../SSC/Src/objdef.c ****                     }
1491:../SSC/Src/objdef.c ****                     else
1492:../SSC/Src/objdef.c ****                     {
1493:../SSC/Src/objdef.c ****                         UINT16 dataType = pEntry->DataType;
 2963              	 .loc 1 1493 0
 2964 028c FB69     	 ldr r3,[r7,#28]
 2965 028e 1B88     	 ldrh r3,[r3]
 2966 0290 FB84     	 strh r3,[r7,#38]
1494:../SSC/Src/objdef.c ****                         if (pEntry->DataType >= 0x700)
 2967              	 .loc 1 1494 0
 2968 0292 FB69     	 ldr r3,[r7,#28]
 2969 0294 1B88     	 ldrh r3,[r3]
 2970 0296 B3F5E06F 	 cmp r3,#1792
 2971 029a 15D3     	 bcc .L207
1495:../SSC/Src/objdef.c ****                         {
1496:../SSC/Src/objdef.c ****                             /* the ENUM data types are defined from index 0x700 in this example
1497:../SSC/Src/objdef.c ****                                convert in standard data type for the write access */
1498:../SSC/Src/objdef.c ****                             if ( pEntry->BitLength <= 8 )
 2972              	 .loc 1 1498 0
 2973 029c FB69     	 ldr r3,[r7,#28]
 2974 029e 5B88     	 ldrh r3,[r3,#2]
 2975 02a0 082B     	 cmp r3,#8
 2976 02a2 04D8     	 bhi .L208
1499:../SSC/Src/objdef.c ****                             {
1500:../SSC/Src/objdef.c ****                                 dataType = DEFTYPE_BIT1-1+pEntry->BitLength;
 2977              	 .loc 1 1500 0
 2978 02a4 FB69     	 ldr r3,[r7,#28]
 2979 02a6 5B88     	 ldrh r3,[r3,#2]
 2980 02a8 2F33     	 adds r3,r3,#47
 2981 02aa FB84     	 strh r3,[r7,#38]
 2982 02ac 0CE0     	 b .L207
 2983              	.L208:
1501:../SSC/Src/objdef.c ****                             }
1502:../SSC/Src/objdef.c ****                             else if ( pEntry->BitLength == 16 )
 2984              	 .loc 1 1502 0
 2985 02ae FB69     	 ldr r3,[r7,#28]
 2986 02b0 5B88     	 ldrh r3,[r3,#2]
 2987 02b2 102B     	 cmp r3,#16
 2988 02b4 02D1     	 bne .L209
1503:../SSC/Src/objdef.c ****                             {
1504:../SSC/Src/objdef.c ****                                 dataType = DEFTYPE_UNSIGNED16;
 2989              	 .loc 1 1504 0
 2990 02b6 0623     	 movs r3,#6
 2991 02b8 FB84     	 strh r3,[r7,#38]
 2992 02ba 05E0     	 b .L207
 2993              	.L209:
1505:../SSC/Src/objdef.c ****                             }
1506:../SSC/Src/objdef.c ****                             else if ( pEntry->BitLength == 32 )
 2994              	 .loc 1 1506 0
 2995 02bc FB69     	 ldr r3,[r7,#28]
 2996 02be 5B88     	 ldrh r3,[r3,#2]
 2997 02c0 202B     	 cmp r3,#32
 2998 02c2 01D1     	 bne .L207
1507:../SSC/Src/objdef.c ****                             {
1508:../SSC/Src/objdef.c ****                                 dataType = DEFTYPE_UNSIGNED32;
 2999              	 .loc 1 1508 0
 3000 02c4 0723     	 movs r3,#7
 3001 02c6 FB84     	 strh r3,[r7,#38]
 3002              	.L207:
1509:../SSC/Src/objdef.c ****                             }
1510:../SSC/Src/objdef.c ****                         }
1511:../SSC/Src/objdef.c **** 
1512:../SSC/Src/objdef.c ****                         switch (dataType)
 3003              	 .loc 1 1512 0
 3004 02c8 FB8C     	 ldrh r3,[r7,#38]
 3005 02ca 112B     	 cmp r3,#17
 3006 02cc 00F07D81 	 beq .L211
 3007 02d0 112B     	 cmp r3,#17
 3008 02d2 1EDC     	 bgt .L212
 3009 02d4 052B     	 cmp r3,#5
 3010 02d6 68D0     	 beq .L213
 3011 02d8 052B     	 cmp r3,#5
 3012 02da 0DDC     	 bgt .L214
 3013 02dc 022B     	 cmp r3,#2
 3014 02de 04DC     	 bgt .L215
 3015 02e0 012B     	 cmp r3,#1
 3016 02e2 62DA     	 bge .L213
 3017 02e4 002B     	 cmp r3,#0
 3018 02e6 3FD0     	 beq .L216
 3019 02e8 CDE1     	 b .L210
 3020              	.L215:
 3021 02ea 032B     	 cmp r3,#3
 3022 02ec 00F0B780 	 beq .L217
 3023 02f0 042B     	 cmp r3,#4
 3024 02f2 00F04281 	 beq .L218
 3025 02f6 C6E1     	 b .L210
 3026              	.L214:
 3027 02f8 082B     	 cmp r3,#8
 3028 02fa 03DC     	 bgt .L219
 3029 02fc 072B     	 cmp r3,#7
 3030 02fe 80F23C81 	 bge .L218
 3031 0302 ACE0     	 b .L217
 3032              	.L219:
 3033 0304 092B     	 cmp r3,#9
 3034 0306 00F07E81 	 beq .L220
 3035 030a 0B2B     	 cmp r3,#11
 3036 030c 00F3BB81 	 bgt .L210
 3037 0310 9EE1     	 b .L221
 3038              	.L212:
 3039 0312 2D2B     	 cmp r3,#45
 3040 0314 49D0     	 beq .L213
 3041 0316 2D2B     	 cmp r3,#45
 3042 0318 11DC     	 bgt .L222
 3043 031a 1E2B     	 cmp r3,#30
 3044 031c 45D0     	 beq .L213
 3045 031e 1E2B     	 cmp r3,#30
 3046 0320 06DC     	 bgt .L223
 3047 0322 152B     	 cmp r3,#21
 3048 0324 00F05181 	 beq .L211
 3049 0328 1B2B     	 cmp r3,#27
 3050 032a 00F04E81 	 beq .L211
 3051 032e AAE1     	 b .L210
 3052              	.L223:
 3053 0330 1F2B     	 cmp r3,#31
 3054 0332 00F09480 	 beq .L217
 3055 0336 202B     	 cmp r3,#32
 3056 0338 00F01F81 	 beq .L218
 3057 033c A3E1     	 b .L210
 3058              	.L222:
 3059 033e 372B     	 cmp r3,#55
 3060 0340 08DC     	 bgt .L224
 3061 0342 302B     	 cmp r3,#48
 3062 0344 31DA     	 bge .L213
 3063 0346 2E2B     	 cmp r3,#46
 3064 0348 00F08980 	 beq .L217
 3065 034c 2F2B     	 cmp r3,#47
 3066 034e 00F01481 	 beq .L218
 3067 0352 98E1     	 b .L210
 3068              	.L224:
 3069 0354 A3F51873 	 sub r3,r3,#608
 3070 0358 032B     	 cmp r3,#3
 3071 035a 00F29481 	 bhi .L210
 3072 035e 77E1     	 b .L221
 3073              	.L255:
 3074              	 .align 2
 3075              	.L254:
 3076 0360 00000000 	 .word nAlStatus
 3077 0364 00000000 	 .word pAPPL_CoeWriteInd
 3078              	.L216:
1513:../SSC/Src/objdef.c ****                         {
1514:../SSC/Src/objdef.c ****                         case DEFTYPE_NULL:
1515:../SSC/Src/objdef.c ****                             if(bCompleteAccess)
 3079              	 .loc 1 1515 0
 3080 0368 97F84C30 	 ldrb r3,[r7,#76]
 3081 036c 002B     	 cmp r3,#0
 3082 036e 1AD0     	 beq .L225
1516:../SSC/Src/objdef.c ****                             {
1517:../SSC/Src/objdef.c ****                                 /*Handle alignment entry*/
1518:../SSC/Src/objdef.c ****                                 if (((pEntry->BitLength & 0xF) > 0)
 3083              	 .loc 1 1518 0
 3084 0370 FB69     	 ldr r3,[r7,#28]
 3085 0372 5B88     	 ldrh r3,[r3,#2]
 3086 0374 03F00F03 	 and r3,r3,#15
 3087 0378 002B     	 cmp r3,#0
 3088 037a 0ADD     	 ble .L226
1519:../SSC/Src/objdef.c ****                                     && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
 3089              	 .loc 1 1519 0
 3090 037c FB8A     	 ldrh r3,[r7,#22]
 3091 037e FA69     	 ldr r2,[r7,#28]
 3092 0380 5288     	 ldrh r2,[r2,#2]
 3093 0382 1344     	 add r3,r3,r2
 3094 0384 03F00F03 	 and r3,r3,#15
 3095 0388 002B     	 cmp r3,#0
 3096 038a 02D1     	 bne .L226
1520:../SSC/Src/objdef.c ****                                 {
1521:../SSC/Src/objdef.c ****                                     /* we have reached the UINT16 border */
1522:../SSC/Src/objdef.c ****                                     pData++;
 3097              	 .loc 1 1522 0
 3098 038c BB6C     	 ldr r3,[r7,#72]
 3099 038e 0233     	 adds r3,r3,#2
 3100 0390 BB64     	 str r3,[r7,#72]
 3101              	.L226:
1523:../SSC/Src/objdef.c ****                                 }
1524:../SSC/Src/objdef.c **** 
1525:../SSC/Src/objdef.c ****                                 /*increment WORD offset*/
1526:../SSC/Src/objdef.c ****                                 pData += ((pEntry->BitLength & 0xF0) >> 4);
 3102              	 .loc 1 1526 0
 3103 0392 FB69     	 ldr r3,[r7,#28]
 3104 0394 5B88     	 ldrh r3,[r3,#2]
 3105 0396 03F0F003 	 and r3,r3,#240
 3106 039a 1B11     	 asrs r3,r3,#4
 3107 039c 5B00     	 lsls r3,r3,#1
 3108 039e BA6C     	 ldr r2,[r7,#72]
 3109 03a0 1344     	 add r3,r3,r2
 3110 03a2 BB64     	 str r3,[r7,#72]
1527:../SSC/Src/objdef.c ****                             }
1528:../SSC/Src/objdef.c ****                             else
1529:../SSC/Src/objdef.c ****                             {
1530:../SSC/Src/objdef.c ****                                 return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
1531:../SSC/Src/objdef.c ****                             }
1532:../SSC/Src/objdef.c ****                             break;
 3111              	 .loc 1 1532 0
 3112 03a4 71E1     	 b .L206
 3113              	.L225:
1530:../SSC/Src/objdef.c ****                             }
 3114              	 .loc 1 1530 0
 3115 03a6 1823     	 movs r3,#24
 3116 03a8 B6E1     	 b .L185
 3117              	.L213:
 3118              	.LBB24:
1533:../SSC/Src/objdef.c ****                         case     DEFTYPE_BOOLEAN:
1534:../SSC/Src/objdef.c ****                         case     DEFTYPE_BIT1:
1535:../SSC/Src/objdef.c ****                         case     DEFTYPE_BIT2:
1536:../SSC/Src/objdef.c ****                         case     DEFTYPE_BIT3:
1537:../SSC/Src/objdef.c ****                         case     DEFTYPE_BIT4:
1538:../SSC/Src/objdef.c ****                         case     DEFTYPE_BIT5:
1539:../SSC/Src/objdef.c ****                         case     DEFTYPE_BIT6:
1540:../SSC/Src/objdef.c ****                         case     DEFTYPE_BIT7:
1541:../SSC/Src/objdef.c ****                         case     DEFTYPE_BIT8:
1542:../SSC/Src/objdef.c ****                         case     DEFTYPE_BITARR8:
1543:../SSC/Src/objdef.c ****                             /* in this example the objects are defined in that way,
1544:../SSC/Src/objdef.c ****                                that the bit types are always inside a 16-bit field,
1545:../SSC/Src/objdef.c ****                                and shall not overlap a byte border*/
1546:../SSC/Src/objdef.c ****                         case    DEFTYPE_INTEGER8:
1547:../SSC/Src/objdef.c ****                         case    DEFTYPE_UNSIGNED8:
1548:../SSC/Src/objdef.c ****                         case    DEFTYPE_BYTE :
1549:../SSC/Src/objdef.c ****                         {
1550:../SSC/Src/objdef.c ****                             /* depending on the bitOffset we have to copy the Hi or the Lo-Byte */
1551:../SSC/Src/objdef.c ****                             UINT16 TmpValue = 0x0000;
 3119              	 .loc 1 1551 0
 3120 03aa 0023     	 movs r3,#0
 3121 03ac BB84     	 strh r3,[r7,#36]
1552:../SSC/Src/objdef.c **** 
1553:../SSC/Src/objdef.c ****                             bitMask = cBitMask[pEntry->BitLength] << (bitOffset & 0x0F);
 3122              	 .loc 1 1553 0
 3123 03ae FB69     	 ldr r3,[r7,#28]
 3124 03b0 5B88     	 ldrh r3,[r3,#2]
 3125 03b2 1A46     	 mov r2,r3
 3126 03b4 A14B     	 ldr r3,.L256
 3127 03b6 33F81230 	 ldrh r3,[r3,r2,lsl#1]
 3128 03ba 1A46     	 mov r2,r3
 3129 03bc FB8A     	 ldrh r3,[r7,#22]
 3130 03be 03F00F03 	 and r3,r3,#15
 3131 03c2 02FA03F3 	 lsl r3,r2,r3
 3132 03c6 BB82     	 strh r3,[r7,#20]
1554:../SSC/Src/objdef.c **** 
1555:../SSC/Src/objdef.c ****                             /*Swap object data (if required); all masks and offsets are defined for
1556:../SSC/Src/objdef.c ****                             TmpValue = SWAPWORD(pVarPtr[0]);
 3133              	 .loc 1 1556 0
 3134 03c8 BB6A     	 ldr r3,[r7,#40]
 3135 03ca 1B88     	 ldrh r3,[r3]
 3136 03cc BB84     	 strh r3,[r7,#36]
1557:../SSC/Src/objdef.c **** 
1558:../SSC/Src/objdef.c ****                             /*Clear corresponding bits*/
1559:../SSC/Src/objdef.c ****                             TmpValue &= ~bitMask;
 3137              	 .loc 1 1559 0
 3138 03ce BB8A     	 ldrh r3,[r7,#20]
 3139 03d0 DB43     	 mvns r3,r3
 3140 03d2 9AB2     	 uxth r2,r3
 3141 03d4 BB8C     	 ldrh r3,[r7,#36]
 3142 03d6 1340     	 ands r3,r3,r2
 3143 03d8 9BB2     	 uxth r3,r3
 3144 03da BB84     	 strh r3,[r7,#36]
1560:../SSC/Src/objdef.c **** 
1561:../SSC/Src/objdef.c ****                             if (bCompleteAccess) 
 3145              	 .loc 1 1561 0
 3146 03dc 97F84C30 	 ldrb r3,[r7,#76]
 3147 03e0 002B     	 cmp r3,#0
 3148 03e2 08D0     	 beq .L228
1562:../SSC/Src/objdef.c ****                             {
1563:../SSC/Src/objdef.c ****                                 /*shifting is not required for Complete access because the bits are
1564:../SSC/Src/objdef.c ****                                 TmpValue |= (SWAPWORD(pData[0]) & bitMask);
 3149              	 .loc 1 1564 0
 3150 03e4 BB6C     	 ldr r3,[r7,#72]
 3151 03e6 1A88     	 ldrh r2,[r3]
 3152 03e8 BB8A     	 ldrh r3,[r7,#20]
 3153 03ea 1340     	 ands r3,r3,r2
 3154 03ec 9AB2     	 uxth r2,r3
 3155 03ee BB8C     	 ldrh r3,[r7,#36]
 3156 03f0 1343     	 orrs r3,r3,r2
 3157 03f2 BB84     	 strh r3,[r7,#36]
 3158 03f4 23E0     	 b .L229
 3159              	.L228:
1565:../SSC/Src/objdef.c ****                             }
1566:../SSC/Src/objdef.c ****                             else
1567:../SSC/Src/objdef.c ****                             {
1568:../SSC/Src/objdef.c ****                                 if((SWAPWORD(pData[0]) & ~cBitMask[pEntry->BitLength]))
 3160              	 .loc 1 1568 0
 3161 03f6 BB6C     	 ldr r3,[r7,#72]
 3162 03f8 1B88     	 ldrh r3,[r3]
 3163 03fa 1A46     	 mov r2,r3
 3164 03fc FB69     	 ldr r3,[r7,#28]
 3165 03fe 5B88     	 ldrh r3,[r3,#2]
 3166 0400 1946     	 mov r1,r3
 3167 0402 8E4B     	 ldr r3,.L256
 3168 0404 33F81130 	 ldrh r3,[r3,r1,lsl#1]
 3169 0408 DB43     	 mvns r3,r3
 3170 040a 1340     	 ands r3,r3,r2
 3171 040c 002B     	 cmp r3,#0
 3172 040e 01D0     	 beq .L230
1569:../SSC/Src/objdef.c ****                                 {
1570:../SSC/Src/objdef.c ****                                     /*written value exceed entry range*/
1571:../SSC/Src/objdef.c ****                                     return ABORTIDX_VALUE_EXCEEDED;
 3173              	 .loc 1 1571 0
 3174 0410 1223     	 movs r3,#18
 3175 0412 81E1     	 b .L185
 3176              	.L230:
1572:../SSC/Src/objdef.c ****                                 }
1573:../SSC/Src/objdef.c ****                                 else
1574:../SSC/Src/objdef.c ****                                 {
1575:../SSC/Src/objdef.c ****                                     /*Shift Bits to corresponding offset within the object memory*/
1576:../SSC/Src/objdef.c ****                                     TmpValue |= ((SWAPWORD(pData[0]) & cBitMask[pEntry->BitLength])
 3177              	 .loc 1 1576 0
 3178 0414 BB6C     	 ldr r3,[r7,#72]
 3179 0416 1A88     	 ldrh r2,[r3]
 3180 0418 FB69     	 ldr r3,[r7,#28]
 3181 041a 5B88     	 ldrh r3,[r3,#2]
 3182 041c 1946     	 mov r1,r3
 3183 041e 874B     	 ldr r3,.L256
 3184 0420 33F81130 	 ldrh r3,[r3,r1,lsl#1]
 3185 0424 1340     	 ands r3,r3,r2
 3186 0426 9BB2     	 uxth r3,r3
 3187 0428 1A46     	 mov r2,r3
 3188 042a FB8A     	 ldrh r3,[r7,#22]
 3189 042c 03F00F03 	 and r3,r3,#15
 3190 0430 02FA03F3 	 lsl r3,r2,r3
 3191 0434 9AB2     	 uxth r2,r3
 3192 0436 BB8C     	 ldrh r3,[r7,#36]
 3193 0438 1343     	 orrs r3,r3,r2
 3194 043a 9BB2     	 uxth r3,r3
 3195 043c BB84     	 strh r3,[r7,#36]
 3196              	.L229:
1577:../SSC/Src/objdef.c ****                                 }
1578:../SSC/Src/objdef.c ****                             }
1579:../SSC/Src/objdef.c **** 
1580:../SSC/Src/objdef.c ****                             /*Swap written data to big endian format (if required)*/
1581:../SSC/Src/objdef.c ****                             pVarPtr[0] = SWAPWORD(TmpValue);
 3197              	 .loc 1 1581 0
 3198 043e BB6A     	 ldr r3,[r7,#40]
 3199 0440 BA8C     	 ldrh r2,[r7,#36]
 3200 0442 1A80     	 strh r2,[r3]
1582:../SSC/Src/objdef.c **** 
1583:../SSC/Src/objdef.c ****                             if ( ((bitOffset+pEntry->BitLength) & 0x0F) == 0 )
 3201              	 .loc 1 1583 0
 3202 0444 FB8A     	 ldrh r3,[r7,#22]
 3203 0446 FA69     	 ldr r2,[r7,#28]
 3204 0448 5288     	 ldrh r2,[r2,#2]
 3205 044a 1344     	 add r3,r3,r2
 3206 044c 03F00F03 	 and r3,r3,#15
 3207 0450 002B     	 cmp r3,#0
 3208 0452 03D1     	 bne .L231
1584:../SSC/Src/objdef.c ****                             {
1585:../SSC/Src/objdef.c ****                                 /* we have reached the UINT16 border */
1586:../SSC/Src/objdef.c ****                                 pData++;
 3209              	 .loc 1 1586 0
 3210 0454 BB6C     	 ldr r3,[r7,#72]
 3211 0456 0233     	 adds r3,r3,#2
 3212 0458 BB64     	 str r3,[r7,#72]
 3213              	.LBE24:
1587:../SSC/Src/objdef.c ****                             }
1588:../SSC/Src/objdef.c ****                         }
1589:../SSC/Src/objdef.c ****                             break;
 3214              	 .loc 1 1589 0
 3215 045a 16E1     	 b .L206
 3216              	.L231:
 3217 045c 15E1     	 b .L206
 3218              	.L217:
1590:../SSC/Src/objdef.c ****                         case    DEFTYPE_INTEGER16:
1591:../SSC/Src/objdef.c ****                         case    DEFTYPE_UNSIGNED16:
1592:../SSC/Src/objdef.c ****                         case    DEFTYPE_BITARR16:
1593:../SSC/Src/objdef.c ****                         case    DEFTYPE_WORD:
1594:../SSC/Src/objdef.c ****                             if(bitOffset & 0xF)
 3219              	 .loc 1 1594 0
 3220 045e FB8A     	 ldrh r3,[r7,#22]
 3221 0460 03F00F03 	 and r3,r3,#15
 3222 0464 002B     	 cmp r3,#0
 3223 0466 01D0     	 beq .L232
1595:../SSC/Src/objdef.c ****                             {
1596:../SSC/Src/objdef.c ****                                 /* return an error in case of an odd word offset (to support 16bit 
1597:../SSC/Src/objdef.c ****                                 return ABORTIDX_UNSUPPORTED_ACCESS;
 3224              	 .loc 1 1597 0
 3225 0468 0523     	 movs r3,#5
 3226 046a 55E1     	 b .L185
 3227              	.L232:
 3228              	.LBB25:
1598:../SSC/Src/objdef.c ****                             }
1599:../SSC/Src/objdef.c **** 
1600:../SSC/Src/objdef.c ****                             {
1601:../SSC/Src/objdef.c ****                             /* in this example the objects are defined in that way,
1602:../SSC/Src/objdef.c ****                             that the 16 bit type are always starting at an exact WORD offset */
1603:../SSC/Src/objdef.c ****                             UINT16 u16NewData = SWAPWORD(pData[0]);
 3229              	 .loc 1 1603 0
 3230 046c BB6C     	 ldr r3,[r7,#72]
 3231 046e 1B88     	 ldrh r3,[r3]
 3232 0470 7B82     	 strh r3,[r7,#18]
1604:../SSC/Src/objdef.c ****                             if(bClearSubindex0Required && (pVarPtr[0] != u16NewData))
 3233              	 .loc 1 1604 0
 3234 0472 97F83330 	 ldrb r3,[r7,#51]
 3235 0476 002B     	 cmp r3,#0
 3236 0478 06D0     	 beq .L233
 3237              	 .loc 1 1604 0 is_stmt 0 discriminator 1
 3238 047a BB6A     	 ldr r3,[r7,#40]
 3239 047c 1B88     	 ldrh r3,[r3]
 3240 047e 7A8A     	 ldrh r2,[r7,#18]
 3241 0480 9A42     	 cmp r2,r3
 3242 0482 01D0     	 beq .L233
1605:../SSC/Src/objdef.c ****                             {
1606:../SSC/Src/objdef.c ****                                 /* try to write new data when subindex0 shall be reset*/
1607:../SSC/Src/objdef.c ****                                 return ABORTIDX_ENTRY_CANT_BE_WRITTEN_SI0_NOT_0;
 3243              	 .loc 1 1607 0 is_stmt 1
 3244 0484 1C23     	 movs r3,#28
 3245 0486 47E1     	 b .L185
 3246              	.L233:
1608:../SSC/Src/objdef.c ****                             }
1609:../SSC/Src/objdef.c **** 
1610:../SSC/Src/objdef.c ****                             /*check value if a new PDO assign entry should be written*/
1611:../SSC/Src/objdef.c ****                             if(IS_PDO_ASSIGN(index))  //PDO assign
 3247              	 .loc 1 1611 0
 3248 0488 FB89     	 ldrh r3,[r7,#14]
 3249 048a 41F60F42 	 movw r2,#7183
 3250 048e 9342     	 cmp r3,r2
 3251 0490 19D9     	 bls .L234
 3252              	 .loc 1 1611 0 is_stmt 0 discriminator 1
 3253 0492 FB89     	 ldrh r3,[r7,#14]
 3254 0494 41F62F42 	 movw r2,#7215
 3255 0498 9342     	 cmp r3,r2
 3256 049a 14D8     	 bhi .L234
1612:../SSC/Src/objdef.c ****                             {
1613:../SSC/Src/objdef.c ****                                 if (!IS_RX_PDO(u16NewData) && !IS_TX_PDO(u16NewData) && (u16NewData
 3257              	 .loc 1 1613 0 is_stmt 1
 3258 049c 7B8A     	 ldrh r3,[r7,#18]
 3259 049e B3F5B05F 	 cmp r3,#5632
 3260 04a2 03D3     	 bcc .L235
 3261              	 .loc 1 1613 0 is_stmt 0 discriminator 2
 3262 04a4 7B8A     	 ldrh r3,[r7,#18]
 3263 04a6 B3F5C05F 	 cmp r3,#6144
 3264 04aa 0CD3     	 bcc .L234
 3265              	.L235:
 3266              	 .loc 1 1613 0 discriminator 3
 3267 04ac 7B8A     	 ldrh r3,[r7,#18]
 3268 04ae B3F5D05F 	 cmp r3,#6656
 3269 04b2 03D3     	 bcc .L236
 3270              	 .loc 1 1613 0 discriminator 5
 3271 04b4 7B8A     	 ldrh r3,[r7,#18]
 3272 04b6 B3F5E05F 	 cmp r3,#7168
 3273 04ba 04D3     	 bcc .L234
 3274              	.L236:
 3275              	 .loc 1 1613 0 discriminator 6
 3276 04bc 7B8A     	 ldrh r3,[r7,#18]
 3277 04be 002B     	 cmp r3,#0
 3278 04c0 01D0     	 beq .L234
1614:../SSC/Src/objdef.c ****                                 {
1615:../SSC/Src/objdef.c ****                                     return ABORTIDX_VALUE_EXCEEDED;
 3279              	 .loc 1 1615 0 is_stmt 1
 3280 04c2 1223     	 movs r3,#18
 3281 04c4 28E1     	 b .L185
 3282              	.L234:
1616:../SSC/Src/objdef.c ****                                 }
1617:../SSC/Src/objdef.c ****                             }
1618:../SSC/Src/objdef.c **** 
1619:../SSC/Src/objdef.c ****                             if(index == 0x1C32 || index == 0x1C33)
 3283              	 .loc 1 1619 0
 3284 04c6 FB89     	 ldrh r3,[r7,#14]
 3285 04c8 41F63242 	 movw r2,#7218
 3286 04cc 9342     	 cmp r3,r2
 3287 04ce 04D0     	 beq .L237
 3288              	 .loc 1 1619 0 is_stmt 0 discriminator 1
 3289 04d0 FB89     	 ldrh r3,[r7,#14]
 3290 04d2 41F63342 	 movw r2,#7219
 3291 04d6 9342     	 cmp r3,r2
 3292 04d8 48D1     	 bne .L238
 3293              	.L237:
1620:../SSC/Src/objdef.c ****                             {
1621:../SSC/Src/objdef.c ****                                if (i == 1) /* "Synchronisation type" written */
 3294              	 .loc 1 1621 0 is_stmt 1
 3295 04da FB8E     	 ldrh r3,[r7,#54]
 3296 04dc 012B     	 cmp r3,#1
 3297 04de 17D1     	 bne .L239
1622:../SSC/Src/objdef.c ****                                {
1623:../SSC/Src/objdef.c ****                                   /* The Synchronisation type (0x1C3x.1) was written by the user =>
1624:../SSC/Src/objdef.c ****                                   if (pVarPtr[0] != u16NewData)
 3298              	 .loc 1 1624 0
 3299 04e0 BB6A     	 ldr r3,[r7,#40]
 3300 04e2 1B88     	 ldrh r3,[r3]
 3301 04e4 7A8A     	 ldrh r2,[r7,#18]
 3302 04e6 9A42     	 cmp r2,r3
 3303 04e8 0FD0     	 beq .L240
1625:../SSC/Src/objdef.c ****                                   {
1626:../SSC/Src/objdef.c ****                                      result = CheckSyncTypeValue(index, u16NewData);
 3304              	 .loc 1 1626 0
 3305 04ea FA89     	 ldrh r2,[r7,#14]
 3306 04ec 7B8A     	 ldrh r3,[r7,#18]
 3307 04ee 1046     	 mov r0,r2
 3308 04f0 1946     	 mov r1,r3
 3309 04f2 FFF7FEFF 	 bl CheckSyncTypeValue
 3310 04f6 0346     	 mov r3,r0
 3311 04f8 87F82E30 	 strb r3,[r7,#46]
1627:../SSC/Src/objdef.c **** 
1628:../SSC/Src/objdef.c ****                                      if (result != 0)
 3312              	 .loc 1 1628 0
 3313 04fc 97F82E30 	 ldrb r3,[r7,#46]
 3314 0500 002B     	 cmp r3,#0
 3315 0502 02D0     	 beq .L240
1629:../SSC/Src/objdef.c ****                                      {
1630:../SSC/Src/objdef.c ****                                         return result;
 3316              	 .loc 1 1630 0
 3317 0504 97F82E30 	 ldrb r3,[r7,#46]
 3318 0508 06E1     	 b .L185
 3319              	.L240:
1631:../SSC/Src/objdef.c ****                                      }
1632:../SSC/Src/objdef.c ****                                   }
1633:../SSC/Src/objdef.c **** 
1634:../SSC/Src/objdef.c ****                                   /* The user may force to current Sync Mode for that reason the fl
1635:../SSC/Src/objdef.c ****                                   bSyncSetByUser = TRUE;
 3320              	 .loc 1 1635 0
 3321 050a 4D4B     	 ldr r3,.L256+4
 3322 050c 0122     	 movs r2,#1
 3323 050e 1A70     	 strb r2,[r3]
 3324              	.L239:
1636:../SSC/Src/objdef.c ****                                }
1637:../SSC/Src/objdef.c **** 
1638:../SSC/Src/objdef.c ****                                if (i == 8) /* "Get Cycle Time" written*/
 3325              	 .loc 1 1638 0
 3326 0510 FB8E     	 ldrh r3,[r7,#54]
 3327 0512 082B     	 cmp r3,#8
 3328 0514 2AD1     	 bne .L238
1639:../SSC/Src/objdef.c ****                                {
1640:../SSC/Src/objdef.c **** 
1641:../SSC/Src/objdef.c ****                                    sSyncManOutPar.u32CalcAndCopyTime = (PD_OUTPUT_CALC_AND_COPY_TIM
 3329              	 .loc 1 1641 0
 3330 0516 4B4B     	 ldr r3,.L256+8
 3331 0518 0022     	 movs r2,#0
 3332 051a 5A61     	 str r2,[r3,#20]
1642:../SSC/Src/objdef.c ****                                    sSyncManOutPar.u32MinCycleTime = (MIN_PD_CYCLE_TIME);
 3333              	 .loc 1 1642 0
 3334 051c 494B     	 ldr r3,.L256+8
 3335 051e 4A4A     	 ldr r2,.L256+12
 3336 0520 1A61     	 str r2,[r3,#16]
1643:../SSC/Src/objdef.c ****                                    sSyncManOutPar.u32CycleTime = 0;
 3337              	 .loc 1 1643 0
 3338 0522 484B     	 ldr r3,.L256+8
 3339 0524 0022     	 movs r2,#0
 3340 0526 5A60     	 str r2,[r3,#4]
1644:../SSC/Src/objdef.c **** 
1645:../SSC/Src/objdef.c ****                                    sSyncManInPar.u32CalcAndCopyTime = (PD_INPUT_CALC_AND_COPY_TIME)
 3341              	 .loc 1 1645 0
 3342 0528 484B     	 ldr r3,.L256+16
 3343 052a 0022     	 movs r2,#0
 3344 052c 5A61     	 str r2,[r3,#20]
1646:../SSC/Src/objdef.c ****                                    sSyncManInPar.u32MinCycleTime = (MIN_PD_CYCLE_TIME);
 3345              	 .loc 1 1646 0
 3346 052e 474B     	 ldr r3,.L256+16
 3347 0530 454A     	 ldr r2,.L256+12
 3348 0532 1A61     	 str r2,[r3,#16]
1647:../SSC/Src/objdef.c ****                                    sSyncManInPar.u32CycleTime = 0;
 3349              	 .loc 1 1647 0
 3350 0534 454B     	 ldr r3,.L256+16
 3351 0536 0022     	 movs r2,#0
 3352 0538 5A60     	 str r2,[r3,#4]
1648:../SSC/Src/objdef.c **** 
1649:../SSC/Src/objdef.c **** 
1650:../SSC/Src/objdef.c ****                                   if ((u16NewData & 0x2) == 0x2)
 3353              	 .loc 1 1650 0
 3354 053a 7B8A     	 ldrh r3,[r7,#18]
 3355 053c 03F00203 	 and r3,r3,#2
 3356 0540 002B     	 cmp r3,#0
 3357 0542 13D0     	 beq .L238
1651:../SSC/Src/objdef.c ****                                   {
1652:../SSC/Src/objdef.c ****                                      /* reset the error counters*/
1653:../SSC/Src/objdef.c ****                                      sSyncManOutPar.u16CycleExceededCounter = 0;
 3358              	 .loc 1 1653 0
 3359 0544 3F4B     	 ldr r3,.L256+8
 3360 0546 0022     	 movs r2,#0
 3361 0548 5A85     	 strh r2,[r3,#42]
1654:../SSC/Src/objdef.c ****                                      sSyncManOutPar.u16SmEventMissedCounter = 0;
 3362              	 .loc 1 1654 0
 3363 054a 3E4B     	 ldr r3,.L256+8
 3364 054c 0022     	 movs r2,#0
 3365 054e 1A85     	 strh r2,[r3,#40]
1655:../SSC/Src/objdef.c ****                                      sSyncManOutPar.u8SyncError = 0;
 3366              	 .loc 1 1655 0
 3367 0550 3C4B     	 ldr r3,.L256+8
 3368 0552 0022     	 movs r2,#0
 3369 0554 83F84020 	 strb r2,[r3,#64]
1656:../SSC/Src/objdef.c **** 
1657:../SSC/Src/objdef.c ****                                      sSyncManInPar.u16CycleExceededCounter = 0;
 3370              	 .loc 1 1657 0
 3371 0558 3C4B     	 ldr r3,.L256+16
 3372 055a 0022     	 movs r2,#0
 3373 055c 5A85     	 strh r2,[r3,#42]
1658:../SSC/Src/objdef.c ****                                      sSyncManInPar.u16SmEventMissedCounter = 0;
 3374              	 .loc 1 1658 0
 3375 055e 3B4B     	 ldr r3,.L256+16
 3376 0560 0022     	 movs r2,#0
 3377 0562 1A85     	 strh r2,[r3,#40]
1659:../SSC/Src/objdef.c ****                                      sSyncManInPar.u8SyncError = 0;
 3378              	 .loc 1 1659 0
 3379 0564 394B     	 ldr r3,.L256+16
 3380 0566 0022     	 movs r2,#0
 3381 0568 83F84020 	 strb r2,[r3,#64]
 3382              	.L238:
1660:../SSC/Src/objdef.c ****                                   }
1661:../SSC/Src/objdef.c ****                                } /* Subindex 8 written*/
1662:../SSC/Src/objdef.c ****                             }
1663:../SSC/Src/objdef.c **** 
1664:../SSC/Src/objdef.c ****                             pVarPtr[0] = u16NewData;
 3383              	 .loc 1 1664 0
 3384 056c BB6A     	 ldr r3,[r7,#40]
 3385 056e 7A8A     	 ldrh r2,[r7,#18]
 3386 0570 1A80     	 strh r2,[r3]
1665:../SSC/Src/objdef.c ****                             pData++;
 3387              	 .loc 1 1665 0
 3388 0572 BB6C     	 ldr r3,[r7,#72]
 3389 0574 0233     	 adds r3,r3,#2
 3390 0576 BB64     	 str r3,[r7,#72]
 3391              	.LBE25:
1666:../SSC/Src/objdef.c ****                             }
1667:../SSC/Src/objdef.c ****                             break;
 3392              	 .loc 1 1667 0
 3393 0578 87E0     	 b .L206
 3394              	.L218:
1668:../SSC/Src/objdef.c ****                         case    DEFTYPE_UNSIGNED32:
1669:../SSC/Src/objdef.c ****                         case    DEFTYPE_INTEGER32:
1670:../SSC/Src/objdef.c ****                         case    DEFTYPE_REAL32:
1671:../SSC/Src/objdef.c ****                         case    DEFTYPE_BITARR32:
1672:../SSC/Src/objdef.c ****                         case    DEFTYPE_DWORD:
1673:../SSC/Src/objdef.c ****                             if(bitOffset & 0xF)
 3395              	 .loc 1 1673 0
 3396 057a FB8A     	 ldrh r3,[r7,#22]
 3397 057c 03F00F03 	 and r3,r3,#15
 3398 0580 002B     	 cmp r3,#0
 3399 0582 01D0     	 beq .L241
1674:../SSC/Src/objdef.c ****                             {
1675:../SSC/Src/objdef.c ****                                 /* return an error in case of an odd word offset (to support 16bit 
1676:../SSC/Src/objdef.c ****                                 return ABORTIDX_UNSUPPORTED_ACCESS;
 3400              	 .loc 1 1676 0
 3401 0584 0523     	 movs r3,#5
 3402 0586 C7E0     	 b .L185
 3403              	.L241:
1677:../SSC/Src/objdef.c ****                             }
1678:../SSC/Src/objdef.c ****                             {
1679:../SSC/Src/objdef.c **** 
1680:../SSC/Src/objdef.c ****                             /* in this example the objects are defined in that way,
1681:../SSC/Src/objdef.c ****                                that the 32 bit type are always starting at an exact WORD offset */
1682:../SSC/Src/objdef.c ****                             if(bClearSubindex0Required && 
 3404              	 .loc 1 1682 0
 3405 0588 97F83330 	 ldrb r3,[r7,#51]
 3406 058c 002B     	 cmp r3,#0
 3407 058e 0FD0     	 beq .L242
1683:../SSC/Src/objdef.c ****                                 ((pVarPtr[0] != pData[0])
 3408              	 .loc 1 1683 0 discriminator 1
 3409 0590 BB6A     	 ldr r3,[r7,#40]
 3410 0592 1A88     	 ldrh r2,[r3]
 3411 0594 BB6C     	 ldr r3,[r7,#72]
 3412 0596 1B88     	 ldrh r3,[r3]
1682:../SSC/Src/objdef.c ****                                 ((pVarPtr[0] != pData[0])
 3413              	 .loc 1 1682 0 discriminator 1
 3414 0598 9A42     	 cmp r2,r3
 3415 059a 07D1     	 bne .L243
1684:../SSC/Src/objdef.c ****                                 || (pVarPtr[1] != pData[1])))
 3416              	 .loc 1 1684 0
 3417 059c BB6A     	 ldr r3,[r7,#40]
 3418 059e 0233     	 adds r3,r3,#2
 3419 05a0 1A88     	 ldrh r2,[r3]
 3420 05a2 BB6C     	 ldr r3,[r7,#72]
 3421 05a4 0233     	 adds r3,r3,#2
 3422 05a6 1B88     	 ldrh r3,[r3]
 3423 05a8 9A42     	 cmp r2,r3
 3424 05aa 01D0     	 beq .L242
 3425              	.L243:
1685:../SSC/Src/objdef.c ****                             {
1686:../SSC/Src/objdef.c ****                                 /* try to write new data when subindex0 shall be reset*/
1687:../SSC/Src/objdef.c ****                                 return ABORTIDX_ENTRY_CANT_BE_WRITTEN_SI0_NOT_0;
 3426              	 .loc 1 1687 0
 3427 05ac 1C23     	 movs r3,#28
 3428 05ae B3E0     	 b .L185
 3429              	.L242:
1688:../SSC/Src/objdef.c ****                             }
1689:../SSC/Src/objdef.c **** 
1690:../SSC/Src/objdef.c ****                             pVarPtr[0] = pData[0];
 3430              	 .loc 1 1690 0
 3431 05b0 BB6C     	 ldr r3,[r7,#72]
 3432 05b2 1A88     	 ldrh r2,[r3]
 3433 05b4 BB6A     	 ldr r3,[r7,#40]
 3434 05b6 1A80     	 strh r2,[r3]
1691:../SSC/Src/objdef.c ****                             pVarPtr[1] = pData[1];
 3435              	 .loc 1 1691 0
 3436 05b8 BB6A     	 ldr r3,[r7,#40]
 3437 05ba 0233     	 adds r3,r3,#2
 3438 05bc BA6C     	 ldr r2,[r7,#72]
 3439 05be 5288     	 ldrh r2,[r2,#2]
 3440 05c0 1A80     	 strh r2,[r3]
1692:../SSC/Src/objdef.c ****                             pData += 2;
 3441              	 .loc 1 1692 0
 3442 05c2 BB6C     	 ldr r3,[r7,#72]
 3443 05c4 0433     	 adds r3,r3,#4
 3444 05c6 BB64     	 str r3,[r7,#72]
1693:../SSC/Src/objdef.c ****                             }
1694:../SSC/Src/objdef.c ****                             break;
 3445              	 .loc 1 1694 0
 3446 05c8 5FE0     	 b .L206
 3447              	.L211:
1695:../SSC/Src/objdef.c ****                         case    DEFTYPE_REAL64:
1696:../SSC/Src/objdef.c ****                         case 	DEFTYPE_INTEGER64:
1697:../SSC/Src/objdef.c ****                         case    DEFTYPE_UNSIGNED64:
1698:../SSC/Src/objdef.c ****                             if(bitOffset & 0xF)
 3448              	 .loc 1 1698 0
 3449 05ca FB8A     	 ldrh r3,[r7,#22]
 3450 05cc 03F00F03 	 and r3,r3,#15
 3451 05d0 002B     	 cmp r3,#0
 3452 05d2 01D0     	 beq .L244
1699:../SSC/Src/objdef.c ****                             {
1700:../SSC/Src/objdef.c ****                                 /* return an error in case of an odd word offset (to support 16bit 
1701:../SSC/Src/objdef.c ****                                 return ABORTIDX_UNSUPPORTED_ACCESS;
 3453              	 .loc 1 1701 0
 3454 05d4 0523     	 movs r3,#5
 3455 05d6 9FE0     	 b .L185
 3456              	.L244:
1702:../SSC/Src/objdef.c ****                             }
1703:../SSC/Src/objdef.c ****                             /* in this example the objects are defined in that way,
1704:../SSC/Src/objdef.c ****                                that the 64 bit type are always starting at an exact WORD offset */
1705:../SSC/Src/objdef.c ****                             pVarPtr[0] = pData[0];
 3457              	 .loc 1 1705 0
 3458 05d8 BB6C     	 ldr r3,[r7,#72]
 3459 05da 1A88     	 ldrh r2,[r3]
 3460 05dc BB6A     	 ldr r3,[r7,#40]
 3461 05de 1A80     	 strh r2,[r3]
1706:../SSC/Src/objdef.c ****                             pVarPtr[1] = pData[1];
 3462              	 .loc 1 1706 0
 3463 05e0 BB6A     	 ldr r3,[r7,#40]
 3464 05e2 0233     	 adds r3,r3,#2
 3465 05e4 BA6C     	 ldr r2,[r7,#72]
 3466 05e6 5288     	 ldrh r2,[r2,#2]
 3467 05e8 1A80     	 strh r2,[r3]
1707:../SSC/Src/objdef.c ****                             pVarPtr[2] = pData[2];
 3468              	 .loc 1 1707 0
 3469 05ea BB6A     	 ldr r3,[r7,#40]
 3470 05ec 0433     	 adds r3,r3,#4
 3471 05ee BA6C     	 ldr r2,[r7,#72]
 3472 05f0 9288     	 ldrh r2,[r2,#4]
 3473 05f2 1A80     	 strh r2,[r3]
1708:../SSC/Src/objdef.c ****                             pVarPtr[3] = pData[3];
 3474              	 .loc 1 1708 0
 3475 05f4 BB6A     	 ldr r3,[r7,#40]
 3476 05f6 0633     	 adds r3,r3,#6
 3477 05f8 BA6C     	 ldr r2,[r7,#72]
 3478 05fa D288     	 ldrh r2,[r2,#6]
 3479 05fc 1A80     	 strh r2,[r3]
1709:../SSC/Src/objdef.c ****                             pData += 4;
 3480              	 .loc 1 1709 0
 3481 05fe BB6C     	 ldr r3,[r7,#72]
 3482 0600 0833     	 adds r3,r3,#8
 3483 0602 BB64     	 str r3,[r7,#72]
1710:../SSC/Src/objdef.c ****                             break;
 3484              	 .loc 1 1710 0
 3485 0604 41E0     	 b .L206
 3486              	.L220:
1711:../SSC/Src/objdef.c ****                         case    DEFTYPE_VISIBLESTRING:
1712:../SSC/Src/objdef.c ****                             if(bitOffset & 0xF)
 3487              	 .loc 1 1712 0
 3488 0606 FB8A     	 ldrh r3,[r7,#22]
 3489 0608 03F00F03 	 and r3,r3,#15
 3490 060c 002B     	 cmp r3,#0
 3491 060e 01D0     	 beq .L245
1713:../SSC/Src/objdef.c ****                             {
1714:../SSC/Src/objdef.c ****                                 /* return an error in case of an odd word offset (to support 16bit 
1715:../SSC/Src/objdef.c ****                                 return ABORTIDX_UNSUPPORTED_ACCESS;
 3492              	 .loc 1 1715 0
 3493 0610 0523     	 movs r3,#5
 3494 0612 81E0     	 b .L185
 3495              	.L245:
1716:../SSC/Src/objdef.c ****                             }
1717:../SSC/Src/objdef.c **** 
1718:../SSC/Src/objdef.c ****                             OBJTOMBXSTRCPY(pVarPtr, pData, BIT2BYTE(pEntry->BitLength));
 3496              	 .loc 1 1718 0
 3497 0614 FB69     	 ldr r3,[r7,#28]
 3498 0616 5B88     	 ldrh r3,[r3,#2]
 3499 0618 0733     	 adds r3,r3,#7
 3500 061a DB10     	 asrs r3,r3,#3
 3501 061c B86A     	 ldr r0,[r7,#40]
 3502 061e B96C     	 ldr r1,[r7,#72]
 3503 0620 1A46     	 mov r2,r3
 3504 0622 FFF7FEFF 	 bl memcpy
1719:../SSC/Src/objdef.c **** 
1720:../SSC/Src/objdef.c ****                             pData += BIT2WORD((pEntry->BitLength)& ~0xF);
 3505              	 .loc 1 1720 0
 3506 0626 FB69     	 ldr r3,[r7,#28]
 3507 0628 5B88     	 ldrh r3,[r3,#2]
 3508 062a 23F00F03 	 bic r3,r3,#15
 3509 062e 0F33     	 adds r3,r3,#15
 3510 0630 1B11     	 asrs r3,r3,#4
 3511 0632 5B00     	 lsls r3,r3,#1
 3512 0634 BA6C     	 ldr r2,[r7,#72]
 3513 0636 1344     	 add r3,r3,r2
 3514 0638 BB64     	 str r3,[r7,#72]
1721:../SSC/Src/objdef.c ****                             break;
 3515              	 .loc 1 1721 0
 3516 063a 26E0     	 b .L206
 3517              	.L257:
 3518              	 .align 2
 3519              	.L256:
 3520 063c 00000000 	 .word cBitMask
 3521 0640 00000000 	 .word bSyncSetByUser
 3522 0644 00000000 	 .word sSyncManOutPar
 3523 0648 48E80100 	 .word 125000
 3524 064c 00000000 	 .word sSyncManInPar
 3525              	.L221:
1722:../SSC/Src/objdef.c ****                         case    DEFTYPE_OCTETSTRING:
1723:../SSC/Src/objdef.c ****                         case    DEFTYPE_UNICODE_STRING:
1724:../SSC/Src/objdef.c ****                             case DEFTYPE_ARRAY_OF_INT :
1725:../SSC/Src/objdef.c ****                             case DEFTYPE_ARRAY_OF_SINT :
1726:../SSC/Src/objdef.c ****                             case DEFTYPE_ARRAY_OF_DINT :
1727:../SSC/Src/objdef.c ****                             case DEFTYPE_ARRAY_OF_UDINT:
1728:../SSC/Src/objdef.c ****                             if(bitOffset & 0xF)
 3526              	 .loc 1 1728 0
 3527 0650 FB8A     	 ldrh r3,[r7,#22]
 3528 0652 03F00F03 	 and r3,r3,#15
 3529 0656 002B     	 cmp r3,#0
 3530 0658 01D0     	 beq .L246
1729:../SSC/Src/objdef.c ****                             {
1730:../SSC/Src/objdef.c ****                                 /* return an error in case of an odd word offset (to support 16bit 
1731:../SSC/Src/objdef.c ****                                 return ABORTIDX_UNSUPPORTED_ACCESS;
 3531              	 .loc 1 1731 0
 3532 065a 0523     	 movs r3,#5
 3533 065c 5CE0     	 b .L185
 3534              	.L246:
1732:../SSC/Src/objdef.c ****                             }
1733:../SSC/Src/objdef.c **** 
1734:../SSC/Src/objdef.c ****                             /* in this example the objects are defined in that way,
1735:../SSC/Src/objdef.c ****                                that the other types are always starting at an even byte offset */
1736:../SSC/Src/objdef.c ****                             OBJTOMBXMEMCPY(pVarPtr, pData, BIT2BYTE(pEntry->BitLength));
 3535              	 .loc 1 1736 0
 3536 065e FB69     	 ldr r3,[r7,#28]
 3537 0660 5B88     	 ldrh r3,[r3,#2]
 3538 0662 0733     	 adds r3,r3,#7
 3539 0664 DB10     	 asrs r3,r3,#3
 3540 0666 B86A     	 ldr r0,[r7,#40]
 3541 0668 B96C     	 ldr r1,[r7,#72]
 3542 066a 1A46     	 mov r2,r3
 3543 066c FFF7FEFF 	 bl memcpy
1737:../SSC/Src/objdef.c ****                             pData += BIT2WORD((pEntry->BitLength) & ~0xF);
 3544              	 .loc 1 1737 0
 3545 0670 FB69     	 ldr r3,[r7,#28]
 3546 0672 5B88     	 ldrh r3,[r3,#2]
 3547 0674 23F00F03 	 bic r3,r3,#15
 3548 0678 0F33     	 adds r3,r3,#15
 3549 067a 1B11     	 asrs r3,r3,#4
 3550 067c 5B00     	 lsls r3,r3,#1
 3551 067e BA6C     	 ldr r2,[r7,#72]
 3552 0680 1344     	 add r3,r3,r2
 3553 0682 BB64     	 str r3,[r7,#72]
1738:../SSC/Src/objdef.c **** 
1739:../SSC/Src/objdef.c ****                             break;
 3554              	 .loc 1 1739 0
 3555 0684 01E0     	 b .L206
 3556              	.L210:
1740:../SSC/Src/objdef.c ****                         default:
1741:../SSC/Src/objdef.c ****                             /* other data types are not supported from this example */
1742:../SSC/Src/objdef.c ****                             return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
 3557              	 .loc 1 1742 0
 3558 0686 1823     	 movs r3,#24
 3559 0688 46E0     	 b .L185
 3560              	.L206:
 3561              	.LBE23:
1743:../SSC/Src/objdef.c ****                         }
1744:../SSC/Src/objdef.c ****                     }
1745:../SSC/Src/objdef.c **** 
1746:../SSC/Src/objdef.c ****                     /* set flag */
1747:../SSC/Src/objdef.c ****                     bWritten = 1;
 3562              	 .loc 1 1747 0
 3563 068a 0123     	 movs r3,#1
 3564 068c 87F82F30 	 strb r3,[r7,#47]
 3565 0690 22E0     	 b .L247
 3566              	.L200:
 3567              	.LBE21:
1748:../SSC/Src/objdef.c **** 
1749:../SSC/Src/objdef.c ****                 }
1750:../SSC/Src/objdef.c ****             }
1751:../SSC/Src/objdef.c ****             else
1752:../SSC/Src/objdef.c ****             {
1753:../SSC/Src/objdef.c ****                 if(i == 0)
 3568              	 .loc 1 1753 0
 3569 0692 FB8E     	 ldrh r3,[r7,#54]
 3570 0694 002B     	 cmp r3,#0
 3571 0696 03D1     	 bne .L248
1754:../SSC/Src/objdef.c ****                 {
1755:../SSC/Src/objdef.c ****                     /* For SubIndex0 16Bit are reserved even if the BitLength is 8 */
1756:../SSC/Src/objdef.c ****                     pData++;
 3572              	 .loc 1 1756 0
 3573 0698 BB6C     	 ldr r3,[r7,#72]
 3574 069a 0233     	 adds r3,r3,#2
 3575 069c BB64     	 str r3,[r7,#72]
 3576 069e 18E0     	 b .L249
 3577              	.L248:
1757:../SSC/Src/objdef.c ****                 }
1758:../SSC/Src/objdef.c ****                 else
1759:../SSC/Src/objdef.c ****                 {
1760:../SSC/Src/objdef.c ****                     /*Handle Bit/Byte Offset*/
1761:../SSC/Src/objdef.c ****                     if (((pEntry->BitLength & 0xF) > 0)
 3578              	 .loc 1 1761 0
 3579 06a0 FB69     	 ldr r3,[r7,#28]
 3580 06a2 5B88     	 ldrh r3,[r3,#2]
 3581 06a4 03F00F03 	 and r3,r3,#15
 3582 06a8 002B     	 cmp r3,#0
 3583 06aa 0ADD     	 ble .L250
1762:../SSC/Src/objdef.c ****                         && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
 3584              	 .loc 1 1762 0
 3585 06ac FB8A     	 ldrh r3,[r7,#22]
 3586 06ae FA69     	 ldr r2,[r7,#28]
 3587 06b0 5288     	 ldrh r2,[r2,#2]
 3588 06b2 1344     	 add r3,r3,r2
 3589 06b4 03F00F03 	 and r3,r3,#15
 3590 06b8 002B     	 cmp r3,#0
 3591 06ba 02D1     	 bne .L250
1763:../SSC/Src/objdef.c ****                     {
1764:../SSC/Src/objdef.c ****                         /* we have reached the UINT16 border */
1765:../SSC/Src/objdef.c ****                         pData++;
 3592              	 .loc 1 1765 0
 3593 06bc BB6C     	 ldr r3,[r7,#72]
 3594 06be 0233     	 adds r3,r3,#2
 3595 06c0 BB64     	 str r3,[r7,#72]
 3596              	.L250:
1766:../SSC/Src/objdef.c ****                     }
1767:../SSC/Src/objdef.c **** 
1768:../SSC/Src/objdef.c ****                     /*increment WORD offset*/
1769:../SSC/Src/objdef.c ****                     pData += ((pEntry->BitLength & 0xFFF0) >> 4);
 3597              	 .loc 1 1769 0
 3598 06c2 FB69     	 ldr r3,[r7,#28]
 3599 06c4 5B88     	 ldrh r3,[r3,#2]
 3600 06c6 1B09     	 lsrs r3,r3,#4
 3601 06c8 9BB2     	 uxth r3,r3
 3602 06ca 5B00     	 lsls r3,r3,#1
 3603 06cc BA6C     	 ldr r2,[r7,#72]
 3604 06ce 1344     	 add r3,r3,r2
 3605 06d0 BB64     	 str r3,[r7,#72]
 3606              	.L249:
1770:../SSC/Src/objdef.c ****                 }
1771:../SSC/Src/objdef.c ****                 /*If no other entry was written this result will be returned*/
1772:../SSC/Src/objdef.c ****                 result = ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
 3607              	 .loc 1 1772 0
 3608 06d2 1823     	 movs r3,#24
 3609 06d4 87F82E30 	 strb r3,[r7,#46]
 3610              	.L247:
 3611              	.LBE20:
1445:../SSC/Src/objdef.c ****         {
 3612              	 .loc 1 1445 0 discriminator 2
 3613 06d8 FB8E     	 ldrh r3,[r7,#54]
 3614 06da 0133     	 adds r3,r3,#1
 3615 06dc FB86     	 strh r3,[r7,#54]
 3616              	.L199:
1445:../SSC/Src/objdef.c ****         {
 3617              	 .loc 1 1445 0 is_stmt 0 discriminator 1
 3618 06de FA8E     	 ldrh r2,[r7,#54]
 3619 06e0 3B8E     	 ldrh r3,[r7,#48]
 3620 06e2 9A42     	 cmp r2,r3
 3621 06e4 7FF67CAD 	 bls .L251
1773:../SSC/Src/objdef.c ****             }
1774:../SSC/Src/objdef.c ****         }
1775:../SSC/Src/objdef.c **** 
1776:../SSC/Src/objdef.c ****         if (bWritten == 0)
 3622              	 .loc 1 1776 0 is_stmt 1
 3623 06e8 97F82F30 	 ldrb r3,[r7,#47]
 3624 06ec 002B     	 cmp r3,#0
 3625 06ee 02D1     	 bne .L252
1777:../SSC/Src/objdef.c ****         {
1778:../SSC/Src/objdef.c ****             /* we didn't write anything, so we have to return the stored error code */
1779:../SSC/Src/objdef.c ****             return result;
 3626              	 .loc 1 1779 0
 3627 06f0 97F82E30 	 ldrb r3,[r7,#46]
 3628 06f4 10E0     	 b .L185
 3629              	.L252:
 3630              	.LBE19:
1780:../SSC/Src/objdef.c ****         }
1781:../SSC/Src/objdef.c ****     }
1782:../SSC/Src/objdef.c **** 
1783:../SSC/Src/objdef.c ****     /* ECATCHANGE_START(V5.13) COE4*/
1784:../SSC/Src/objdef.c ****     if (pAPPL_CoeWriteInd != NULL)
 3631              	 .loc 1 1784 0
 3632 06f6 0A4B     	 ldr r3,.L258
 3633 06f8 1B68     	 ldr r3,[r3]
 3634 06fa 002B     	 cmp r3,#0
 3635 06fc 0BD0     	 beq .L253
1785:../SSC/Src/objdef.c ****     {
1786:../SSC/Src/objdef.c ****         pAPPL_CoeWriteInd(index, subindex, bCompleteAccess);
 3636              	 .loc 1 1786 0
 3637 06fe 084B     	 ldr r3,.L258
 3638 0700 1B68     	 ldr r3,[r3]
 3639 0702 97F84C20 	 ldrb r2,[r7,#76]
 3640 0706 002A     	 cmp r2,#0
 3641 0708 14BF     	 ite ne
 3642 070a 0122     	 movne r2,#1
 3643 070c 0022     	 moveq r2,#0
 3644 070e D2B2     	 uxtb r2,r2
 3645 0710 F889     	 ldrh r0,[r7,#14]
 3646 0712 797B     	 ldrb r1,[r7,#13]
 3647 0714 9847     	 blx r3
 3648              	.L253:
1787:../SSC/Src/objdef.c ****     }
1788:../SSC/Src/objdef.c ****     /* ECATCHANGE_END(V5.13) COE4*/
1789:../SSC/Src/objdef.c **** 
1790:../SSC/Src/objdef.c ****     return 0;
 3649              	 .loc 1 1790 0
 3650 0716 0023     	 movs r3,#0
 3651              	.L185:
1791:../SSC/Src/objdef.c **** }
 3652              	 .loc 1 1791 0
 3653 0718 1846     	 mov r0,r3
 3654 071a 3C37     	 adds r7,r7,#60
 3655              	.LCFI64:
 3656              	 .cfi_def_cfa_offset 12
 3657 071c BD46     	 mov sp,r7
 3658              	.LCFI65:
 3659              	 .cfi_def_cfa_register 13
 3660              	 
 3661 071e 90BD     	 pop {r4,r7,pc}
 3662              	.L259:
 3663              	 .align 2
 3664              	.L258:
 3665 0720 00000000 	 .word pAPPL_CoeWriteInd
 3666              	 .cfi_endproc
 3667              	.LFE186:
 3669              	 .text
 3670              	.Letext0:
 3671              	 .file 2 "d:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 3672              	 .file 3 "d:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 3673              	 .file 4 "../SSC/Src/sdoserv.h"
 3674              	 .file 5 "../SSC/Src/objdef.h"
 3675              	 .file 6 "D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/CMSIS/Include/cmsis_gcc.h"
 3676              	 .file 7 "D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/CMSIS/Include/core_cm4.h"
 3677              	 .file 8 "../SSC/Src/ecatslv.h"
 3678              	 .file 9 "../SSC/Src/applInterface.h"
DEFINED SYMBOLS
                            *ABS*:00000000 objdef.c
                            *COM*:00000001 bSyncSetByUser
                            *COM*:00000002 sCycleDiag
                            *COM*:00000044 sSyncManOutPar
                            *COM*:00000044 sSyncManInPar
    {standard input}:28     .data.sErrorSettings:00000000 sErrorSettings
    {standard input}:25     .data.sErrorSettings:00000000 $d
    {standard input}:39     .data.aSubindexDesc:00000000 aSubindexDesc
    {standard input}:36     .data.aSubindexDesc:00000000 $d
    {standard input}:46     .rodata.cBitMask:00000000 cBitMask
    {standard input}:43     .rodata.cBitMask:00000000 $d
    {standard input}:64     .text.OBJ_GetObjectHandle:00000000 $t
    {standard input}:69     .text.OBJ_GetObjectHandle:00000000 OBJ_GetObjectHandle
    {standard input}:131    .text.OBJ_GetObjectLength:00000000 $t
    {standard input}:136    .text.OBJ_GetObjectLength:00000000 OBJ_GetObjectLength
    {standard input}:345    .text.OBJ_CopyNumberToString:00000000 $t
    {standard input}:350    .text.OBJ_CopyNumberToString:00000000 OBJ_CopyNumberToString
    {standard input}:447    .text.OBJ_CopyNumberToString:0000008c $d
    {standard input}:453    .text.OBJ_GetNoOfObjects:00000000 $t
    {standard input}:458    .text.OBJ_GetNoOfObjects:00000000 OBJ_GetNoOfObjects
    {standard input}:994    .text.OBJ_GetEntryDesc:00000000 OBJ_GetEntryDesc
    {standard input}:584    .text.OBJ_GetObjectList:00000000 $t
    {standard input}:589    .text.OBJ_GetObjectList:00000000 OBJ_GetObjectList
    {standard input}:777    .text.OBJ_GetObjectList:000000f8 $d
    {standard input}:782    .text.OBJ_GetDesc:00000000 $t
    {standard input}:787    .text.OBJ_GetDesc:00000000 OBJ_GetDesc
    {standard input}:984    .text.OBJ_GetDesc:0000011c $d
    {standard input}:989    .text.OBJ_GetEntryDesc:00000000 $t
    {standard input}:1072   .text.OBJ_GetObjDesc:00000000 $t
    {standard input}:1077   .text.OBJ_GetObjDesc:00000000 OBJ_GetObjDesc
    {standard input}:1116   .text.OBJ_GetEntryOffset:00000000 $t
    {standard input}:1121   .text.OBJ_GetEntryOffset:00000000 OBJ_GetEntryOffset
    {standard input}:1397   .text.CheckSyncTypeValue:00000000 $t
    {standard input}:1402   .text.CheckSyncTypeValue:00000000 CheckSyncTypeValue
    {standard input}:1432   .text.CheckSyncTypeValue:00000020 $d
    {standard input}:1467   .text.CheckSyncTypeValue:000000ac $t
    {standard input}:1630   .text.CheckSyncTypeValue:0000019c $d
    {standard input}:1638   .text.OBJ_Read:00000000 $t
    {standard input}:1643   .text.OBJ_Read:00000000 OBJ_Read
    {standard input}:2133   .text.OBJ_Read:00000340 $d
    {standard input}:2137   .text.OBJ_Read:00000348 $t
    {standard input}:2541   .text.OBJ_Read:000005d0 $d
    {standard input}:2546   .text.OBJ_Write:00000000 $t
    {standard input}:2551   .text.OBJ_Write:00000000 OBJ_Write
    {standard input}:3076   .text.OBJ_Write:00000360 $d
    {standard input}:3080   .text.OBJ_Write:00000368 $t
    {standard input}:3520   .text.OBJ_Write:0000063c $d
    {standard input}:3527   .text.OBJ_Write:00000650 $t
    {standard input}:3665   .text.OBJ_Write:00000720 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
COE_GetObjectDictionary
pSdoInfoObjEntry
strlen
memcpy
nPdOutputSize
nPdInputSize
nAlStatus
pAPPL_CoeReadInd
pAPPL_CoeWriteInd
