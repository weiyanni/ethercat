   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "ecatslv.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .section .text.XMC_ECAT_GetALEventRegister,"ax",%progbits
  20              	 .align 2
  21              	 .thumb
  22              	 .thumb_func
  24              	XMC_ECAT_GetALEventRegister:
  25              	.LFB134:
  26              	 .file 1 "D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc/xmc_ecat.h"
   1:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
   2:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** /**
   3:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @file xmc_ecat.h
   4:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @date 2015-12-27
   5:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
   6:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @cond
   7:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *****************************************************************************
   8:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * XMClib v2.2.0 - XMC Peripheral Driver Library
   9:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
  10:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * Copyright (c) 2015-2020, Infineon Technologies AG
  11:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * All rights reserved.
  12:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
  13:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * Boost Software License - Version 1.0 - August 17th, 2003
  14:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
  15:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * Permission is hereby granted, free of charge, to any person or organization
  16:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * obtaining a copy of the software and accompanying documentation covered by
  17:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * this license (the "Software") to use, reproduce, display, distribute,
  18:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * execute, and transmit the Software, and to prepare derivative works of the
  19:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * Software, and to permit third-parties to whom the Software is furnished to
  20:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * do so, all subject to the following:
  21:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
  22:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * The copyright notices in the Software and this entire statement, including
  23:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * the above license grant, this restriction and the following disclaimer,
  24:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * must be included in all copies of the Software, in whole or in part, and
  25:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * all derivative works of the Software, unless such copies or derivative
  26:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * works are solely in the form of machine-executable object code generated by
  27:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * a source language processor.
  28:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
  29:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  30:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  31:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
  32:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
  33:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
  34:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  35:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * DEALINGS IN THE SOFTWARE.
  36:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
  37:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * To improve the quality of the software, users are encouraged to share
  38:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * modifications, enhancements or bug fixes with Infineon Technologies AG
  39:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * at XMCSupport@infineon.com.
  40:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *****************************************************************************
  41:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
  42:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * Change History
  43:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * --------------
  44:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
  45:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * 2015-12-27:
  46:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *     - Initial Version<br>
  47:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
  48:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @endcond
  49:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  */
  50:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
  51:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** /**
  52:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @addtogroup XMClib XMC Peripheral Library
  53:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @{
  54:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  */
  55:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
  56:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** /**
  57:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @addtogroup ECAT
  58:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @brief EtherCAT Low level driver for XMC4800/XMC4300 series.
  59:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
  60:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * EtherCAT is an Ethernet-based fieldbus system.
  61:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * The EtherCAT Slave Controller (ECAT) read the data addressed to them while the telegram passes t
  62:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * An EtherCAT Slave Controller (ESC) takes care of the EtherCAT communication as an interface betw
  63:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * fieldbus and the slave application. EtherCAT uses standard IEEE 802.3 Ethernet frames, thus a st
  64:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * controller can be used and no special hardware is required on master side. EtherCAT has a reserv
  65:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * 0x88A4 that distinguishes it from other Ethernet frames. Thus, EtherCAT can run in parallel to o
  66:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * protocols. EtherCAT does not require the IP protocol, however it can be encapsulated in IP/UDP. 
  67:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * Slave Controller processes the frame in hardware. Thus, communication performance is independent
  68:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * power.
  69:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
  70:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * The XMC_ECAT low level driver provides functions to configure and initialize the ECAT hardware p
  71:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * For EHTERCAT stack integration, the necessary hardware accees layer APIs shall be explicitly imp
  72:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * upon the stack provider. The XMC_ECAT lld layer provides only the hardware initialization functi
  73:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * basic functionalities.
  74:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @{
  75:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  */
  76:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
  77:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** #ifndef XMC_ECAT_H
  78:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** #define XMC_ECAT_H
  79:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
  80:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** /**************************************************************************************************
  81:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * HEADER FILES
  82:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  **************************************************************************************************
  83:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
  84:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** #include "xmc_common.h"
  85:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
  86:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** #if defined (ECAT0)
  87:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
  88:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** #include "xmc_ecat_map.h"
  89:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
  90:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** /**************************************************************************************************
  91:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * MACROS
  92:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  **************************************************************************************************
  93:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
  94:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** /**************************************************************************************************
  95:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * ENUMS
  96:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  **************************************************************************************************
  97:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
  98:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** /**
  99:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * ECAT status return values
 100:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 101:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** typedef enum XMC_ECAT_STATUS
 102:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** {
 103:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_STATUS_OK    = 0U, /**< Driver accepted application request */
 104:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_STATUS_BUSY  = 1U, /**< Driver is busy and cannot handle request */
 105:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_STATUS_ERROR = 2U  /**< Driver could not fulfil application request */
 106:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** } XMC_ECAT_STATUS_t;
 107:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 108:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 109:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * EtherCAT event enumeration types
 110:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 111:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** typedef enum XMC_ECAT_EVENT
 112:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** {
 113:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_AL_CONTROL = ECAT_AL_EVENT_MASK_AL_CE_MASK_Msk, /**< Application control event mas
 114:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_DC_LATCH = ECAT_AL_EVENT_MASK_DC_LE_MASK_Msk,  /**< Distributed Clock latch event 
 115:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_DC_SYNC0 = ECAT_AL_EVENT_MASK_ST_S0_MASK_Msk, /**< State of distributed clock sync
 116:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_DC_SYNC1 = ECAT_AL_EVENT_MASK_ST_S1_MASK_Msk, /**< State of distributed clock sync
 117:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_SM_ACTIVATION_REGISTER = ECAT_AL_EVENT_MASK_SM_A_MASK_Msk, /**< SyncManager activa
 118:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_EEPROM = ECAT_AL_EVENT_MASK_EEP_E_MASK_Msk, /**< EEPROM Emulation event mask*/
 119:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_WATCHDOG = ECAT_AL_EVENT_MASK_WP_D_MASK_Msk, /**< WATCHDOG process data event mask
 120:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_SM0 = ECAT_AL_EVENT_MASK_SMI_0_MASK_Msk, /**< Sync Manager 0 event mask*/
 121:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_SM1 = ECAT_AL_EVENT_MASK_SMI_1_MASK_Msk, /**< Sync Manager 1 event mask*/
 122:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_SM2 = ECAT_AL_EVENT_MASK_SMI_2_MASK_Msk, /**< Sync Manager 2 event mask*/
 123:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_SM3 = ECAT_AL_EVENT_MASK_SMI_3_MASK_Msk, /**< Sync Manager 3 event mask*/
 124:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_SM4 = ECAT_AL_EVENT_MASK_SMI_4_MASK_Msk, /**< Sync Manager 4 event mask*/
 125:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_SM5 = ECAT_AL_EVENT_MASK_SMI_5_MASK_Msk, /**< Sync Manager 5 event mask*/
 126:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_SM6 = ECAT_AL_EVENT_MASK_SMI_6_MASK_Msk, /**< Sync Manager 6 event mask*/
 127:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   XMC_ECAT_EVENT_SM7 = ECAT_AL_EVENT_MASK_SMI_7_MASK_Msk  /**< Sync Manager 7 event mask*/
 128:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** } XMC_ECAT_EVENT_t;
 129:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 130:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** /**************************************************************************************************
 131:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * DATA STRUCTURES
 132:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  **************************************************************************************************
 133:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 134:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** /* Anonymous structure/union guard start */
 135:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** #if defined (__CC_ARM)
 136:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** #pragma push
 137:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** #pragma anon_unions
 138:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** #elif defined (__TASKING__)
 139:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** #pragma warning 586
 140:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** #endif
 141:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 142:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 143:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * ECAT port control data structure
 144:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 145:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** typedef struct XMC_ECAT_PORT_CTRL
 146:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** {
 147:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   union
 148:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   {
 149:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****     struct
 150:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****     {
 151:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t enable_rstreq: 1;     /**< Master can trigger a reset of the XMC4700 / XMC4800 (::bo
 152:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t: 7;                   /**< Reserved bits */
 153:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t latch_input0: 2;      /**< Latch input 0 selection (::XMC_ECAT_PORT_LATCHIN0_t) */
 154:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t: 2;                   /**< Reserved bits */
 155:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t latch_input1: 2;      /**< Latch input 1 selection (::XMC_ECAT_PORT_LATCHIN1_t) */
 156:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t: 2;                   /**< Reserved bits */
 157:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t phyaddr_offset: 5;    /**< Ethernet PHY address offset, address of port 0 */
 158:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t: 1;                   /**< Reserved bits */
 159:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t mdio: 2;              /**< Bidirectional, push-pull management data I/O line (::XMC_
 160:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t: 8;                   /**< Reserved bits */
 161:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****     };
 162:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 163:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t raw;
 164:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   } common;
 165:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 166:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   union
 167:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   {
 168:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****     struct
 169:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****     {
 170:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rxd0: 2;     /**< Receive data bit 0 (::XMC_ECAT_PORT0_CTRL_RXD0_t) */
 171:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rxd1: 2;     /**< Receive data bit 1 (::XMC_ECAT_PORT0_CTRL_RXD1_t) */
 172:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rxd2: 2;     /**< Receive data bit 2 (::XMC_ECAT_PORT0_CTRL_RXD2_t) */
 173:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rxd3: 2;     /**< Receive data bit 3 (::XMC_ECAT_PORT0_CTRL_RXD3_t) */
 174:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rx_err: 2;   /**< RX Error (::XMC_ECAT_PORT0_CTRL_RX_ERR_t) */
 175:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rx_dv: 2;    /**< RX Data valid (::XMC_ECAT_PORT0_CTRL_RX_DV_t) */
 176:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rx_clk: 2;   /**< RX Clock (::XMC_ECAT_PORT0_CTRL_RX_CLK_t) */
 177:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t: 2;          /**< Reserved bits */
 178:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t link: 2;     /**< Link status (::XMC_ECAT_PORT0_CTRL_LINK_t) */
 179:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t: 10;         /**< Reserved bits */
 180:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t tx_clk: 2;   /**< TX Clock (::XMC_ECAT_PORT0_CTRL_TX_CLK_t) */
 181:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t tx_shift: 2; /**< TX signal delay (::XMC_ECAT_PORT0_CTRL_TX_SHIFT_t) */
 182:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****     };
 183:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 184:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t raw;
 185:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   } port0;
 186:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 187:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   union
 188:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   {
 189:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****     struct
 190:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****     {
 191:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rxd0: 2;     /**< Receive data bit 0 (::XMC_ECAT_PORT_CTRL_RXD0_t) */
 192:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rxd1: 2;     /**< Receive data bit 1 (::XMC_ECAT_PORT_CTRL_RXD1_t) */
 193:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rxd2: 2;     /**< Receive data bit 2 (::XMC_ECAT_PORT_CTRL_RXD2_t) */
 194:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rxd3: 2;     /**< Receive data bit 3 (::XMC_ECAT_PORT_CTRL_RXD3_t) */
 195:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rx_err: 2;   /**< RX Error (::XMC_ECAT_PORT_CTRL_RX_ERR_t) */
 196:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rx_dv: 2;    /**< RX Data valid (::XMC_ECAT_PORT_CTRL_RX_DV_t) */
 197:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t rx_clk: 2;   /**< RX Clock (::XMC_ECAT_PORT_CTRL_RX_CLK_t) */
 198:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t: 2;          /**< Reserved bits */
 199:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t link: 2;     /**< Link status (::XMC_ECAT_PORT_CTRL_LINK_t) */
 200:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t: 10;         /**< Reserved bits */
 201:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t tx_clk: 2;   /**< TX Clock (::XMC_ECAT_PORT_CTRL_TX_CLK_t) */
 202:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****       uint32_t tx_shift: 2; /**< TX signal delay (::XMC_ECAT_PORT1_CTRL_TX_SHIFT_t) */
 203:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****     };
 204:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 205:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t raw;
 206:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   } port1;
 207:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 208:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** } XMC_ECAT_PORT_CTRL_t;
 209:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 210:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 211:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * ECAT EEPROM configuration area data structure
 212:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 213:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** typedef union XMC_ECAT_CONFIG
 214:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** {
 215:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   struct
 216:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   {
 217:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t : 8;
 218:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 219:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t : 2;
 220:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t enable_dc_sync_out : 1;
 221:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t enable_dc_latch_in : 1;
 222:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t enable_enhanced_link_p0 : 1;
 223:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t enable_enhanced_link_p1 : 1;
 224:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t : 2;
 225:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 226:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t : 16;
 227:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 228:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****     uint16_t sync_pulse_length; /**< Initialization value for Pulse Length of SYNC Signals register
 229:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 230:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****     uint32_t : 16;
 231:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 232:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****     uint16_t station_alias; /**< Initialization value for Configured Station Alias Address register
 233:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 234:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****     uint16_t : 16;
 235:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 236:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****     uint16_t : 16;
 237:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 238:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****     uint16_t checksum;
 239:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   };
 240:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 241:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   uint32_t dword[4]; /**< Four 32 bit double word equivalent to 8 16 bit configuration area word. *
 242:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** } XMC_ECAT_CONFIG_t;
 243:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 244:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** /* Anonymous structure/union guard end */
 245:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** #if defined (__CC_ARM)
 246:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** #pragma pop
 247:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** #elif defined (__TASKING__)
 248:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** #pragma warning restore
 249:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** #endif
 250:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 251:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** /**************************************************************************************************
 252:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * API PROTOTYPES
 253:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  **************************************************************************************************
 254:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 255:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** #ifdef __cplusplus
 256:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** extern "C" {
 257:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** #endif
 258:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 259:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 260:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param config XMC_ECAT_CONFIG_t
 261:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return XMC_ECAT_STATUS_t ECAT Initialization status
 262:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 263:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 264:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * Initialize the Ethernet MAC peripheral <br>
 265:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 266:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 267:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * The function sets the link speed, applies the duplex mode, sets auto-negotiation
 268:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * and loop-back settings.
 269:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 270:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** void XMC_ECAT_Init(XMC_ECAT_CONFIG_t *const config);
 271:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 272:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 273:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param None
 274:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return None
 275:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 276:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 277:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * Enable the EtherCAT peripheral <br>
 278:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 279:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 280:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * The function de-asserts the peripheral reset.
 281:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 282:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** void XMC_ECAT_Enable(void);
 283:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 284:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 285:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param None
 286:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return None
 287:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 288:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 289:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * Disable the EtherCAT peripheral <br>
 290:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 291:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 292:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * The function asserts the peripheral reset.
 293:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 294:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** void XMC_ECAT_Disable(void);
 295:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 296:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 297:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param phy_addr PHY address
 298:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param reg_addr Register address
 299:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param data The destination to which the read data needs to be copied to.
 300:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 301:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return XMC_ECAT_STATUS_t EtherCAT Read PHY API return status
 302:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 303:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 304:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * Read a PHY register <br>
 305:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 306:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 307:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * The function reads a PHY register. It essentially polls busy bit during max
 308:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * PHY_TIMEOUT time and reads the information into 'data' when not busy.
 309:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 310:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** XMC_ECAT_STATUS_t XMC_ECAT_ReadPhy(uint8_t phy_addr, uint8_t reg_addr, uint16_t *data);
 311:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 312:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 313:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param phy_addr PHY address
 314:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param reg_addr Register address
 315:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param data The data to write
 316:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return XMC_ECAT_STATUS_t EtherCAT Write PHY API return status
 317:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 318:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 319:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * Write a PHY register <br>
 320:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 321:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 322:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * The function reads a PHY register. It essentially writes the data and polls
 323:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * the busy bit until it is no longer busy.
 324:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 325:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** XMC_ECAT_STATUS_t XMC_ECAT_WritePhy(uint8_t phy_addr, uint8_t reg_addr, uint16_t data);
 326:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 327:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 328:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param port_ctrl Port control configuration
 329:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return None
 330:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 331:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 332:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * Set port control configuration <br>
 333:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 334:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 335:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * The function sets the port control by writing the configuration into the ECAT CON register.
 336:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 337:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 338:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** __STATIC_INLINE void XMC_ECAT_SetPortControl(const XMC_ECAT_PORT_CTRL_t port_ctrl)
 339:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** {
 340:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   ECAT0_CON->CON = (uint32_t)port_ctrl.common.raw;
 341:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   ECAT0_CON->CONP0 = (uint32_t)port_ctrl.port0.raw;
 342:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   ECAT0_CON->CONP1 = (uint32_t)port_ctrl.port1.raw;
 343:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** }
 344:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 345:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 346:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param event Single or logically OR'd events specified in the enum type @refXMC_ECAT_EVENT_t
 347:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return None
 348:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 349:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 350:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * Enable ECAT event(s) <br>
 351:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 352:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 353:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * The function can be used to enable ECAT event(s).
 354:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 355:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** void XMC_ECAT_EnableEvent(uint32_t event);
 356:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 357:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 358:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param event Single or logically OR'd events specified in the enum type @refXMC_ECAT_EVENT_t
 359:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return None
 360:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 361:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 362:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * Disable an ECAT event(s) <br>
 363:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 364:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 365:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * The function can be used to disable ECAT event(s).
 366:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 367:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** void XMC_ECAT_DisableEvent(uint32_t event);
 368:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 369:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 370:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param None
 371:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return uint32_t Event status
 372:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 373:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 374:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * Get event status <br>
 375:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 376:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 377:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * The function returns the ECAT status and interrupt status as a single word. The user
 378:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * can then check the status of the events by using an appropriate mask.
 379:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 380:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** uint32_t XMC_ECAT_GetEventStatus(void);
 381:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 382:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 383:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 384:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param channel SyncManager channel number.
 385:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return None
 386:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 387:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 388:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * Disables selected SyncManager channel <br>
 389:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 390:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 391:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * Sets bit 0 of the corresponding 0x807 register.
 392:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 393:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** void XMC_ECAT_DisableSyncManChannel(const uint8_t channel);
 394:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 395:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 396:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param channel SyncManager channel number.
 397:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return None
 398:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 399:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 400:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * Enables selected SyncManager channel <br>
 401:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 402:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 403:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * Resets bit 0 of the corresponding 0x807 register.
 404:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 405:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** void XMC_ECAT_EnableSyncManChannel(const uint8_t channel);
 406:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** 
 407:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** /**
 408:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @param None
 409:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * @return uint16_t Content of register 0x220-0x221
 410:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 411:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par<b>Description: </b><br>
 412:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * Get content of AL event register <br>
 413:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  *
 414:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * \par
 415:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  * Get the first two bytes of the AL Event register (0x220-0x221).
 416:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****  */
 417:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** __STATIC_INLINE uint16_t XMC_ECAT_GetALEventRegister(void)
 418:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** {
  27              	 .loc 1 418 0
  28              	 .cfi_startproc
  29              	 
  30              	 
  31              	 
  32 0000 80B4     	 push {r7}
  33              	.LCFI0:
  34              	 .cfi_def_cfa_offset 4
  35              	 .cfi_offset 7,-4
  36 0002 00AF     	 add r7,sp,#0
  37              	.LCFI1:
  38              	 .cfi_def_cfa_register 7
 419:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h ****   return ((uint16_t)ECAT0->AL_EVENT_REQ);
  39              	 .loc 1 419 0
  40 0004 044B     	 ldr r3,.L3
  41 0006 D3F82032 	 ldr r3,[r3,#544]
  42 000a 9BB2     	 uxth r3,r3
 420:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/XMCLib/inc\xmc_ecat.h **** }
  43              	 .loc 1 420 0
  44 000c 1846     	 mov r0,r3
  45 000e BD46     	 mov sp,r7
  46              	.LCFI2:
  47              	 .cfi_def_cfa_register 13
  48              	 
  49 0010 5DF8047B 	 ldr r7,[sp],#4
  50              	.LCFI3:
  51              	 .cfi_restore 7
  52              	 .cfi_def_cfa_offset 0
  53 0014 7047     	 bx lr
  54              	.L4:
  55 0016 00BF     	 .align 2
  56              	.L3:
  57 0018 00000154 	 .word 1409351680
  58              	 .cfi_endproc
  59              	.LFE134:
  61              	 .section .text.HW_EscRead,"ax",%progbits
  62              	 .align 2
  63              	 .thumb
  64              	 .thumb_func
  66              	HW_EscRead:
  67              	.LFB167:
  68              	 .file 2 "D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC/xmc_eschw.h"
   1:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** /**
   2:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @file xmc_eschw.h
   3:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @date 2018-01-24
   4:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
   5:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * NOTE:
   6:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * This file is copied by DAVE. Any manual modification done to this file will be lost when the cod
   7:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
   8:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @cond
   9:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  **************************************************************************************************
  10:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * ECAT_SSC v4.0.26 - ECAT_SSC APP initializes the XMC ESC and sets up the interface for Beckhoff E
  11:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  12:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * Copyright (c) 2016-2019, Infineon Technologies AG
  13:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * All rights reserved.
  14:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  15:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  16:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * following conditions are met:
  17:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  18:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *   Redistributions of source code must retain the above copyright notice, this list of conditions
  19:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *   disclaimer.
  20:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  21:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *   Redistributions in binary form must reproduce the above copyright notice, this list of conditi
  22:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *   disclaimer in the documentation and/or other materials provided with the distribution.
  23:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  24:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *   Neither the name of the copyright holders nor the names of its contributors may be used to end
  25:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *   products derived from this software without specific prior written permission.
  26:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  27:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  28:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  29:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  30:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  31:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  32:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  33:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  34:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  35:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  36:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * with Infineon Technologies AG (dave@infineon.com).
  37:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  **************************************************************************************************
  38:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  39:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * Change History
  40:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * --------------
  41:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  42:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * 2016-02-05:
  43:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *     - Initial version
  44:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  45:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * 2018-01-24:
  46:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *     - Added HW_ClearTimer()
  47:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  48:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @endcond
  49:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
  50:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  */
  51:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  52:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #ifndef XMC_ESCHW_H
  53:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define XMC_ESCHW_H
  54:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  55:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** /**************************************************************************************************
  56:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * HEADER FILES
  57:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  **************************************************************************************************
  58:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #include "SSC/Src/esc.h"
  59:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #include "xmc_ecat.h"
  60:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #include "E_EEPROM_XMC4/e_eeprom_xmc4.h"
  61:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  62:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  /*************************************************************************************************
  63:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****   * MACROS
  64:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****   *************************************************************************************************
  65:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  66:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define ECAT_TIMER_INC_P_MS (1U) /**< Timer increment value */
  67:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  68:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define pEsc ((uint8_t *)ECAT0)  /**< EtherCAT module address */
  69:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  70:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** extern uint8_t aEepromData[];
  71:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  72:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** /**************************************************************************************************
  73:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * API Prototypes
  74:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  **************************************************************************************************
  75:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  76:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #ifdef __cplusplus
  77:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** extern "C" {
  78:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #endif
  79:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  80:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** /**
  81:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @ingroup ECAT_SSC_apidoc
  82:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @{
  83:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  */
  84:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  85:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscReadDWord(DWordValue, Address)     ((DWordValue) = (UINT32)(((volatile UINT32 *)pEsc)
  86:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  87:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscReadDWordIsr(DWordValue, Address)  HW_EscReadDWord(DWordValue, Address)              
  88:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  89:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscReadWord(WordValue, Address)       ((WordValue) = (((volatile UINT16 *)pEsc)[((Addres
  90:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  91:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscReadWordIsr(WordValue, Address)    HW_EscReadWord(WordValue, Address)                
  92:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  93:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscReadByte(ByteValue, Address)       ((ByteValue) = (((volatile UINT8 *)pEsc)[(Address)
  94:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  95:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscReadByteIsr(ByteValue, Address)    HW_EscReadByte(ByteValue, Address)                
  96:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  97:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscWriteDWord(DWordValue, Address)    ((((volatile UINT32 *)pEsc)[(Address>>2)]) = (DWor
  98:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
  99:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscWriteDWordIsr(DWordValue, Address) HW_EscWriteWord(DWordValue, Address)              
 100:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
 101:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscWriteWord(WordValue, Address)      ((((volatile UINT16 *)pEsc)[((Address)>>1)]) = (Wo
 102:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
 103:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscWriteWordIsr(WordValue, Address)   HW_EscWriteWord(WordValue, Address)               
 104:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
 105:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscWriteByte(ByteValue, Address)      ((((volatile UINT8 *)pEsc)[(Address)]) = (ByteValu
 106:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
 107:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** #define HW_EscWriteByteIsr(ByteValue, Address)   HW_EscWriteByte(ByteValue, Address)               
 108:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
 109:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** /**
 110:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @brief 16Bit ESC read access
 111:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 112:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param pData Pointer to local destination buffer.
 113:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Address EtherCAT Slave Controller address. Specifies the offset within the ESC memory are
 114:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Len Access size in Bytes
 115:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 116:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @return None
 117:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * <BR>
 118:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 119:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * \par<b>Description:</b><br>
 120:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * Reads from the EtherCAT Slave Controller. This function is used to access ESC registers and the 
 121:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 122:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  */
 123:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** __STATIC_INLINE void HW_EscRead(MEM_ADDR *pData, UINT16 Address, UINT16 Len)
 124:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** {
  69              	 .loc 2 124 0
  70              	 .cfi_startproc
  71              	 
  72              	 
  73 0000 80B5     	 push {r7,lr}
  74              	.LCFI4:
  75              	 .cfi_def_cfa_offset 8
  76              	 .cfi_offset 7,-8
  77              	 .cfi_offset 14,-4
  78 0002 82B0     	 sub sp,sp,#8
  79              	.LCFI5:
  80              	 .cfi_def_cfa_offset 16
  81 0004 00AF     	 add r7,sp,#0
  82              	.LCFI6:
  83              	 .cfi_def_cfa_register 7
  84 0006 7860     	 str r0,[r7,#4]
  85 0008 0B46     	 mov r3,r1
  86 000a 7B80     	 strh r3,[r7,#2]
  87 000c 1346     	 mov r3,r2
  88 000e 3B80     	 strh r3,[r7]
 125:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****   memcpy(pData, &pEsc[Address], Len);
  89              	 .loc 2 125 0
  90 0010 7B88     	 ldrh r3,[r7,#2]
  91 0012 03F1A843 	 add r3,r3,#1409286144
  92 0016 03F58033 	 add r3,r3,#65536
  93 001a 3A88     	 ldrh r2,[r7]
  94 001c 7868     	 ldr r0,[r7,#4]
  95 001e 1946     	 mov r1,r3
  96 0020 FFF7FEFF 	 bl memcpy
 126:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** }
  97              	 .loc 2 126 0
  98 0024 0837     	 adds r7,r7,#8
  99              	.LCFI7:
 100              	 .cfi_def_cfa_offset 8
 101 0026 BD46     	 mov sp,r7
 102              	.LCFI8:
 103              	 .cfi_def_cfa_register 13
 104              	 
 105 0028 80BD     	 pop {r7,pc}
 106              	 .cfi_endproc
 107              	.LFE167:
 109 002a 00BF     	 .section .text.HW_GetALEventRegister,"ax",%progbits
 110              	 .align 2
 111              	 .thumb
 112              	 .thumb_func
 114              	HW_GetALEventRegister:
 115              	.LFB173:
 127:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
 128:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** /**
 129:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @brief Interrupt specific 16Bit ESC read access
 130:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 131:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param pData Pointer to local destination buffer.
 132:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Address EtherCAT Slave Controller address. Specifies the offset within the ESC memory are
 133:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Len Access size in Bytes
 134:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 135:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @return None
 136:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * <BR>
 137:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 138:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * \par<b>Description:</b><br>
 139:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * Reads from the EtherCAT Slave Controller. This function is used to access ESC registers and the 
 140:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 141:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  */
 142:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** __STATIC_INLINE void HW_EscReadIsr(MEM_ADDR *pData, UINT16 Address, UINT16 Len)
 143:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** {
 144:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****   HW_EscRead(pData, Address, Len);
 145:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** }
 146:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
 147:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** /**
 148:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @brief Reads data from the ESC and copies to slave mailbox memory.
 149:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 150:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param pData Pointer to local destination buffer.
 151:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Address EtherCAT Slave Controller address. Specifies the offset within the ESC memory are
 152:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Len Access size in Bytes
 153:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 154:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @return None
 155:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * <BR>
 156:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 157:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * \par<b>Description:</b><br>
 158:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * Reads data from the ESC and copies to slave mailbox memory. If the local mailbox memory is also 
 159:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * application memory this function is equal to HW_EscRead.
 160:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 161:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  */
 162:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** __STATIC_INLINE void HW_EscReadMbxMem(MEM_ADDR *pData, UINT16 Address, UINT16 Len)
 163:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** {
 164:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****   HW_EscRead(pData, Address, Len);
 165:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** }
 166:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
 167:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** /**
 168:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @brief 16Bit ESC write access
 169:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 170:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param pData Pointer to local source buffer.
 171:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Address EtherCAT Slave Controller address. Specifies the offset within the ESC memory are
 172:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Len Access size in Bytes
 173:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 174:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @return None
 175:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * <BR>
 176:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 177:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * \par<b>Description:</b><br>
 178:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * Writes from the EtherCAT Slave Controller. This function is used to access ESC registers and the
 179:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 180:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  */
 181:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** __STATIC_INLINE void HW_EscWrite(MEM_ADDR *pData, UINT16 Address, UINT16 Len)
 182:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** {
 183:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****   memcpy(&pEsc[Address], pData, Len);
 184:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** }
 185:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
 186:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** /**
 187:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @brief Interrupt specific 16Bit ESC write access
 188:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 189:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param pData Pointer to local source buffer.
 190:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Address EtherCAT Slave Controller address. Specifies the offset within the ESC memory are
 191:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Len Access size in Bytes
 192:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 193:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @return None
 194:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * <BR>
 195:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 196:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * \par<b>Description:</b><br>
 197:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * Writes from the EtherCAT Slave Controller. This function is used to access ESC registers and the
 198:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 199:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  */
 200:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** __STATIC_INLINE void HW_EscWriteIsr(MEM_ADDR *pData, UINT16 Address, UINT16 Len)
 201:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** {
 202:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****   HW_EscWrite(pData, Address, Len);
 203:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** }
 204:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
 205:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** /**
 206:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @brief Writes data from the slave mailbox memory to ESC memory.
 207:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 208:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param pData Pointer to local source mailbox buffer.
 209:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Address EtherCAT Slave Controller address. Specifies the offset within the ESC memory are
 210:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param Len Access size in Bytes
 211:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 212:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @return None
 213:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * <BR>
 214:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 215:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * \par<b>Description:</b><br>
 216:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * Writes data from the slave mailbox memory to ESC memory. If the local mailbox memory is also loc
 217:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * application memory this function is equal to HW_EscWrite.
 218:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 219:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  */
 220:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** __STATIC_INLINE void HW_EscWriteMbxMem(MEM_ADDR *pData, UINT16 Address, UINT16 Len)
 221:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** {
 222:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****   HW_EscWrite(pData, Address, Len);
 223:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** }
 224:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** 
 225:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** /**
 226:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @brief Get the first two bytes of the AL Event register
 227:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 228:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @param None
 229:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 230:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * @return Content of register 0x220-0x221
 231:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * <BR>
 232:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 233:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  * \par<b>Description:</b><br>
 234:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 235:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  *
 236:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****  */
 237:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** __STATIC_INLINE UINT16 HW_GetALEventRegister(void)
 238:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** {
 116              	 .loc 2 238 0
 117              	 .cfi_startproc
 118              	 
 119              	 
 120 0000 80B5     	 push {r7,lr}
 121              	.LCFI9:
 122              	 .cfi_def_cfa_offset 8
 123              	 .cfi_offset 7,-8
 124              	 .cfi_offset 14,-4
 125 0002 00AF     	 add r7,sp,#0
 126              	.LCFI10:
 127              	 .cfi_def_cfa_register 7
 239:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h ****   return XMC_ECAT_GetALEventRegister();
 128              	 .loc 2 239 0
 129 0004 FFF7FEFF 	 bl XMC_ECAT_GetALEventRegister
 130 0008 0346     	 mov r3,r0
 240:D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Dave/Generated/ECAT_SSC\xmc_eschw.h **** }
 131              	 .loc 2 240 0
 132 000a 1846     	 mov r0,r3
 133 000c 80BD     	 pop {r7,pc}
 134              	 .cfi_endproc
 135              	.LFE173:
 137              	 .comm bEcatOutputUpdateRunning,1,1
 138              	 .comm bEcatInputUpdateRunning,1,1
 139              	 .comm bEcatFirstOutputsReceived,1,1
 140              	 .comm bWdTrigger,1,1
 141              	 .comm bDcSyncActive,1,1
 142              	 .comm EsmTimeoutCounter,2,2
 143              	 .comm bDcRunning,1,1
 144              	 .comm u16SmSync0Counter,2,2
 145              	 .comm u16SmSync0Value,2,2
 146              	 .comm bSmSyncSequenceValid,1,1
 147              	 .comm i16WaitForPllRunningTimeout,2,2
 148              	 .comm i16WaitForPllRunningCnt,2,2
 149              	 .comm Sync0WdCounter,2,2
 150              	 .comm Sync0WdValue,2,2
 151              	 .comm Sync1WdCounter,2,2
 152              	 .comm Sync1WdValue,2,2
 153              	 .comm LatchInputSync0Value,2,2
 154              	 .comm LatchInputSync0Counter,2,2
 155              	 .comm b32BitDc,1,1
 156              	 .comm bEscIntEnabled,1,1
 157              	 .comm b3BufferMode,1,1
 158              	 .comm u16LocalErrorCode,2,2
 159              	 .comm u8LocalErrorState,1,1
 160              	 .comm bApplEsmPending,1,1
 161              	 .comm bEcatWaitForAlControlRes,1,1
 162              	 .comm nEcatStateTrans,2,2
 163              	 .comm u8EcatErrorLed,1,1
 164              	 .comm u8EcatRunLed,1,1
 165              	 .comm nPdInputSize,2,2
 166              	 .comm nPdOutputSize,2,2
 167              	 .comm nMaxSyncMan,1,1
 168              	 .comm nMaxEscAddress,2,2
 169              	 .comm nAlStatus,1,1
 170              	 .comm EcatWdValue,2,2
 171              	 .comm nEscAddrOutputData,2,2
 172              	 .comm nEscAddrInputData,2,2
 173              	 .comm u16ALEventMask,2,2
 174              	 .comm u8dummy,1,1
 175              	 .global SMActivate
 176 000e 00BF     	 .section .bss.SMActivate,"aw",%nobits
 179              	SMActivate:
 180 0000 00       	 .space 1
 181              	 .comm SyncManInfo,8,4
 182              	 .global EepromLoaded
 183              	 .section .bss.EepromLoaded,"aw",%nobits
 186              	EepromLoaded:
 187 0000 00       	 .space 1
 188              	 .section .text.ResetALEventMask,"ax",%progbits
 189              	 .align 2
 190              	 .global ResetALEventMask
 191              	 .thumb
 192              	 .thumb_func
 194              	ResetALEventMask:
 195              	.LFB175:
 196              	 .file 3 "../SSC/Src/ecatslv.c"
   1:../SSC/Src/ecatslv.c **** /*
   2:../SSC/Src/ecatslv.c **** * This source file is part of the EtherCAT Slave Stack Code licensed by Beckhoff Automation GmbH & 
   3:../SSC/Src/ecatslv.c **** * The corresponding license agreement applies. This hint shall not be removed.
   4:../SSC/Src/ecatslv.c **** * https://www.beckhoff.com/media/downloads/slave-stack-code/ethercat_ssc_license.pdf
   5:../SSC/Src/ecatslv.c **** */
   6:../SSC/Src/ecatslv.c **** 
   7:../SSC/Src/ecatslv.c **** /**
   8:../SSC/Src/ecatslv.c **** \addtogroup ESM EtherCAT State Machine
   9:../SSC/Src/ecatslv.c **** @{
  10:../SSC/Src/ecatslv.c **** */
  11:../SSC/Src/ecatslv.c **** 
  12:../SSC/Src/ecatslv.c **** /**
  13:../SSC/Src/ecatslv.c **** \file ecatslv.c
  14:../SSC/Src/ecatslv.c **** \author EthercatSSC@beckhoff.com
  15:../SSC/Src/ecatslv.c **** \brief Implementation
  16:../SSC/Src/ecatslv.c **** This file contains the EtherCAT State Machine.
  17:../SSC/Src/ecatslv.c **** 
  18:../SSC/Src/ecatslv.c **** \version 5.13
  19:../SSC/Src/ecatslv.c **** 
  20:../SSC/Src/ecatslv.c **** <br>Changes to version V5.12:<br>
  21:../SSC/Src/ecatslv.c **** V5.13 BOOT1: support Init-to-Init transition in bootloader application<br>
  22:../SSC/Src/ecatslv.c **** V5.13 CIA402 3: change define "CIA402_DEVICE" to "CiA402_SAMPLE_APPLICATION"<br>
  23:../SSC/Src/ecatslv.c **** V5.13 CIA402 4: decouple CIA402 state machine and application from ESM (according ETG.6010, clause 
  24:../SSC/Src/ecatslv.c **** V5.13 ECAT1: handle Sync mapped to AL Event<br>
  25:../SSC/Src/ecatslv.c **** V5.13 ECAT2: explicit device ID handling, the ID value shall only be latched on the rising edge of 
  26:../SSC/Src/ecatslv.c **** V5.13 ECAT3: reset local Error flag in case of two consecutive pending state response and the the f
  27:../SSC/Src/ecatslv.c **** V5.13 ESM1: local error handling update, ECAT_StateChange triggers only transitions from Op->Any or
  28:../SSC/Src/ecatslv.c **** V5.13 ESM2: support ErrorSafeOP to OP transition<br>
  29:../SSC/Src/ecatslv.c **** V5.13 ESM3: Safe-to-OP transition in DC mode, ack OP state if no error was detected<br>
  30:../SSC/Src/ecatslv.c **** V5.13 ESM4: implement disable sync error reaction 0x10F1.2 is set to 0<br>
  31:../SSC/Src/ecatslv.c **** V5.13 MBX1: change mbx_read flag handling to SM1 buffer state handling (required in case of a mbx r
  32:../SSC/Src/ecatslv.c **** <br>Changes to version V5.11:<br>
  33:../SSC/Src/ecatslv.c **** V5.12 BOOT1: add a bootloader sample application (only the ESM and FoE is supported)<br>
  34:../SSC/Src/ecatslv.c **** V5.12 ECAT1: update SM Parameter measurement (based on the system time), enhancement for input only
  35:../SSC/Src/ecatslv.c **** V5.12 ECAT4: update Sync1 watchdog calculation (in case of subordinated cycles take one addiitonal 
  36:../SSC/Src/ecatslv.c **** V5.12 ECAT5: update Sync error counter/flag handling,check enum memory alignment depending on the p
  37:../SSC/Src/ecatslv.c **** V5.12 ECAT7: set error single flash also in case of an application error<br>
  38:../SSC/Src/ecatslv.c **** V5.12 ESM1: overwrite the current error in case of a local error with a lower target state,Do not o
  39:../SSC/Src/ecatslv.c **** V5.12 ESM2: enable the PD SM in case of a clear error transition<br>
  40:../SSC/Src/ecatslv.c **** V5.12 ESM3: set internal ESM timeout to -10% of the configured value (to return an errorcode before
  41:../SSC/Src/ecatslv.c **** V5.12 ESM4: enable the AL Event mask in case of pending ESM transition<br>
  42:../SSC/Src/ecatslv.c **** V5.12 TEST2: add pending ESM test,trigger complete ESM transition from ecat main<br>
  43:../SSC/Src/ecatslv.c **** <br>Changes to version V5.10:<br>
  44:../SSC/Src/ecatslv.c **** V5.11 COE3: change 0x10F3.2 (Sync Error limit) from UINT32 to UINT16 (according to the ETG.1020)<br
  45:../SSC/Src/ecatslv.c **** V5.11 DIAG4: change parameter handling in DIAG_CreateNewMessage()<br>
  46:../SSC/Src/ecatslv.c **** V5.11 ECAT10: change PROTO handling to prevent compiler errors<br>
  47:../SSC/Src/ecatslv.c **** V5.11 ECAT4: enhance SM/Sync monitoring for input/output only slaves<br>
  48:../SSC/Src/ecatslv.c **** V5.11 ECAT5: "Add missing ""bEscIntEnabled"" initialization if ""AL_EVENT_ENBALED"" is 0"""<br>
  49:../SSC/Src/ecatslv.c **** V5.11 ECAT7: add missing big endian swapping<br>
  50:../SSC/Src/ecatslv.c **** V5.11 ESC1: update max address calculation<br>
  51:../SSC/Src/ecatslv.c **** V5.11 ESM1: update calculation of subordinated cycles<br>
  52:../SSC/Src/ecatslv.c **** V5.11 ESM2: DC_SUPPORTED, Sync0 is not supported and Sync0 is generated according register values t
  53:../SSC/Src/ecatslv.c **** V5.11 ESM3: update checking of the user configured sync type<br>
  54:../SSC/Src/ecatslv.c **** V5.11 ESM4: prevent to go from ErrSafeOP to OP without re enabling Sync0/1<br>
  55:../SSC/Src/ecatslv.c **** V5.11 ESM5: DPRAM range was double checked<br>
  56:../SSC/Src/ecatslv.c **** V5.11 ESM6: in the SO transition wait by default until the master has send process data<br>
  57:../SSC/Src/ecatslv.c **** V5.11 HW1: "move hardware independent functions ""HW_DisableSyncManChannel()"", ""HW_EnableSyncManC
  58:../SSC/Src/ecatslv.c **** V5.11 HW2: check during ESM handling if the SM address and length is aligned according the ESC acce
  59:../SSC/Src/ecatslv.c **** V5.11 TEST9: "add behaviour 0x2020.7 (SDO requests on 0x3006.0 are set to pending until an FoE read
  60:../SSC/Src/ecatslv.c **** <br>Changes to version V5.01:<br>
  61:../SSC/Src/ecatslv.c **** V5.10 COE1: Define one entry description for all 0x1C3x objects and change data type of SI11,12,13 
  62:../SSC/Src/ecatslv.c **** V5.10 DIAG1: Define diagmessage textIDs<br>
  63:../SSC/Src/ecatslv.c **** V5.10 ECAT13: Update Synchronisation handling (FreeRun,SM Sync, Sync0, Sync1)<br>
  64:../SSC/Src/ecatslv.c ****               Compare DC UINT configuration (by ESC Config data) vs. DC activation register setting
  65:../SSC/Src/ecatslv.c ****               Update 0x1C3x entries<br>
  66:../SSC/Src/ecatslv.c **** V5.10 ESC2: Check if defined SM settings do not exceed the available DPRAM range (in error case AL 
  67:../SSC/Src/ecatslv.c **** V5.10 ESC3: Handle DC cControl register values in case of 32Bit ESC access (a Sync activation mask 
  68:../SSC/Src/ecatslv.c **** V5.10 ESC4: Mask lower 4 Bit of AL status to get Run led value<br>
  69:../SSC/Src/ecatslv.c ****             Invalid RunLed code was calculated if ESC set ECAT Run Led<br>
  70:../SSC/Src/ecatslv.c **** V5.10 ESC5: Add missing swapping<br>
  71:../SSC/Src/ecatslv.c **** V5.10 ESM2: Update "bApplEsmPending" flag during a transition to a lower state<br>
  72:../SSC/Src/ecatslv.c **** V5.10 ESM3: Add "volatile" directive for ESM dummy variables<br>
  73:../SSC/Src/ecatslv.c **** V5.10 HW5: Block ESC interrupts during Timer ISR<br>
  74:../SSC/Src/ecatslv.c **** V5.10 TEST9: Add option to prevent SM3 unlock during PS<br>
  75:../SSC/Src/ecatslv.c **** <br>Changes to version V5.0:<br>
  76:../SSC/Src/ecatslv.c **** V5.01 APPL3: Include library demo application<br>
  77:../SSC/Src/ecatslv.c **** V5.01 ESC2: Add missed value swapping<br>
  78:../SSC/Src/ecatslv.c **** V5.01 ESM1: Don't overwrite the error reason in case of an failed PS transition<br>
  79:../SSC/Src/ecatslv.c **** V5.01 ESM2: Don't check the "appl trigger" flag in case on an regular transition to a lower state (
  80:../SSC/Src/ecatslv.c **** V5.01 ESM3: Call Error acknowledge indication only if error was acknowledged by the master<br>
  81:../SSC/Src/ecatslv.c **** V5.01 HW3: Update blink code of an SM watchdog error<br>
  82:../SSC/Src/ecatslv.c **** <br>Changes to version V4.42:<br>
  83:../SSC/Src/ecatslv.c **** V5.0 ECAT1: Support Explicit Device ID.<br>
  84:../SSC/Src/ecatslv.c **** V5.0 ECAT2: Application specific functions are moved to application files.<br>
  85:../SSC/Src/ecatslv.c **** V5.0 ECAT3: Global dummy variables used for dummy ESC operations.<br>
  86:../SSC/Src/ecatslv.c **** V5.0 ESC1: ESC 32Bit Access added.<br>
  87:../SSC/Src/ecatslv.c **** V5.0 ESC2: Support ESC EtherCAT LED Indication.<br>
  88:../SSC/Src/ecatslv.c **** V5.0 ESC3: Support EEPROM Emulation.<br>
  89:../SSC/Src/ecatslv.c **** V5.0 ESM1: Update "LocalErrorFlag" handling.<br>
  90:../SSC/Src/ecatslv.c **** V5.0 ESM2: Update Error Acknowledge by ALControl INIT (without error acknowledge)<br>
  91:../SSC/Src/ecatslv.c **** V5.0 ESM3: Handle pending ESM transition<br>
  92:../SSC/Src/ecatslv.c **** V5.0 ESM4: ECAT_StateChange() will only be called form application. In case of an communication err
  93:../SSC/Src/ecatslv.c **** V5.0 MBX1: Support configuration without mailbox protocol support.<br>
  94:../SSC/Src/ecatslv.c **** V5.0 TEST1: Add test application. See Application Note ET9300 for more details.<br>
  95:../SSC/Src/ecatslv.c **** <br>Changes to version V4.40:<br>
  96:../SSC/Src/ecatslv.c **** V4.42 ESM1: Reset local error flag if master set the acknowledge bit (0x120.4)<br>
  97:../SSC/Src/ecatslv.c **** <br>Changes to version V4.30:<br>
  98:../SSC/Src/ecatslv.c **** V4.40 ESM5: Enable output SyncManager if local error acknowledged<br>
  99:../SSC/Src/ecatslv.c **** V4.40 HW0: Use common hardware access functions<br>
 100:../SSC/Src/ecatslv.c **** V4.40 PDO3: Add support if only input process data is used<br>
 101:../SSC/Src/ecatslv.c **** V4.40 ECAT4: Add read SM activation register to acknowledge SM Change event<br>
 102:../SSC/Src/ecatslv.c **** V4.40 PDO2: Check if max process data size was exceed<br>
 103:../SSC/Src/ecatslv.c **** V4.40 DIAG1: add diagnosis message support<br>
 104:../SSC/Src/ecatslv.c **** V4.40 ESM4: Change Check WD setup; add define OP_PD_REQUIRED (defines if process data required in s
 105:../SSC/Src/ecatslv.c **** V4.40 WD1: change WD behaviour depending if process data required in OP state<br>
 106:../SSC/Src/ecatslv.c **** V4.40 MBX4: Change processing order of mailbox SyncManager flags<br>
 107:../SSC/Src/ecatslv.c **** V4.40 ECAT1: Merge content of HW_Main (spihw.c /mcihw.c) to ECAT_Main<br>
 108:../SSC/Src/ecatslv.c **** V4.40 ECAT2: Added CheckIfLocalError() to check local flags and set ALStatus /Al Status code if req
 109:../SSC/Src/ecatslv.c **** V4.40 ESM2: Add AL_ControlRes() to complete pending state requests. Change SafeOP to OP state respo
 110:../SSC/Src/ecatslv.c **** V4.40 ESM1: Prevent double call of StopOutputHandler()<br>
 111:../SSC/Src/ecatslv.c **** V4.40 BOOT1: Enable Mailbox SyncManger on state change to BOOT state (to enable FoE)<br>
 112:../SSC/Src/ecatslv.c **** V4.40 ESM3: Change State machine behaviour according to ETG.1000 V1.0.2 (state change #26)<br>
 113:../SSC/Src/ecatslv.c **** V4.40 LED1: Set error blink code<br>
 114:../SSC/Src/ecatslv.c **** V4.40 TIMER1: Added DC_CheckWatchdog() triggered from ECAT_CheckTimer(). Change local Sync0 watchdo
 115:../SSC/Src/ecatslv.c **** V4.40 WD1: Change check process data watchdog settings<br>
 116:../SSC/Src/ecatslv.c **** <br>Changes to version V4.20:<br>
 117:../SSC/Src/ecatslv.c **** V4.30 OBJ 3: initialize the object dictionary in state change INIT->PREOP; clear object dictionary 
 118:../SSC/Src/ecatslv.c **** V4.30 SYNC: add 0x1C32:10; 0x1C33:10 (Sync0 cycle), change synchronisation control functionality<br
 119:../SSC/Src/ecatslv.c **** V4.30 CiA402: add CiA402_Init() call in state change from PREOP to SAFEOP if DC synchronisation is 
 120:../SSC/Src/ecatslv.c ****                    else the Init function is called when bus cycle time is calculated [CalcSMCycleT
 121:../SSC/Src/ecatslv.c ****                    trigger error handling if the EtherCAT state machine gets a transition from OP t
 122:../SSC/Src/ecatslv.c **** V4.20 ECAT 1: add LEGACY_MODE behaviour in ECAT_CheckWatchdog()<br>
 123:../SSC/Src/ecatslv.c **** V4.20 DC 1: Add DC pending state machine handling and Dc watchdog functionality<br>
 124:../SSC/Src/ecatslv.c **** V4.20 ESM 2: Add State transition from BOOT to INIT<br>
 125:../SSC/Src/ecatslv.c **** V4.20 ESM 1: Non LEGACY_MODE State change handling<br>
 126:../SSC/Src/ecatslv.c **** V4.11 Renamed the function parameter "code" of Function "SendSmFailedEmergency() to avoid<br>
 127:../SSC/Src/ecatslv.c **** problems with some compilers"<br>
 128:../SSC/Src/ecatslv.c **** V4.11 ECAT 1: Fixed a possible problem with state change Init -> SafeOP. The output syncmanager<br>
 129:../SSC/Src/ecatslv.c **** was enabled by the state change-flag and not by the actual state<br>
 130:../SSC/Src/ecatslv.c **** V4.11 LED 1: Clear the error LED during error acknowledgement<br>
 131:../SSC/Src/ecatslv.c **** V4.11 ESC 1: fixed size of MBXHEADER in the TFOEMBX struct <br>
 132:../SSC/Src/ecatslv.c **** <br>Changes to version V4.08:<br>
 133:../SSC/Src/ecatslv.c **** V4.10 ECAT 1: clear bEcatOutputsReceived in startMailboxhandler()<br>
 134:../SSC/Src/ecatslv.c **** V4.10 ECAT 2: clear bEcatOutputsReceived in stopMailboxhandler()<br>
 135:../SSC/Src/ecatslv.c **** V4.10 ECAT 3: when switching from INIT to BOOT the SM settings shall be checked<br>
 136:../SSC/Src/ecatslv.c **** V4.10 ECAT 4: APPL_StartInputHandler shall always be called and bEcatInputUpdateRunning shall alway
 137:../SSC/Src/ecatslv.c ****               in StartInputHandler independent of the input size<br>
 138:../SSC/Src/ecatslv.c **** V4.10 ECAT 5: AL_ControlInd: the error acknowledge behaviour was changed<br>
 139:../SSC/Src/ecatslv.c ****               according to the protocol enhancements and the conformance test<br>
 140:../SSC/Src/ecatslv.c **** V4.10 ECAT 6: AL_ControlInd: if a state transitions failed the corresponding stop function is<br>
 141:../SSC/Src/ecatslv.c ****               called to get a consistent set of variables<br>
 142:../SSC/Src/ecatslv.c **** V4.10 ECAT 7: the local application requested to leave the state OP so we have to disable the SM2<b
 143:../SSC/Src/ecatslv.c ****                    and make the state change from OP to SAFEOP by calling StopOutputHandler<br>
 144:../SSC/Src/ecatslv.c **** V4.10 ECAT 8: the AL Status Code has to be reset if the error was acknowledged by the master<br>
 145:../SSC/Src/ecatslv.c **** V4.10 ECAT 9: ECAT_StateChange: when waiting for a State Change response from the application the<b
 146:../SSC/Src/ecatslv.c ****               AL Status shall only be written if the final state was reached<br>
 147:../SSC/Src/ecatslv.c **** <br>Changes to version V4.07:<br>
 148:../SSC/Src/ecatslv.c **** V4.08 ECAT 1: The watchdog value was not rounded up<br>
 149:../SSC/Src/ecatslv.c **** V4.08 ECAT 2: The value of u16WdValue was not set 0 if the register 0x420 is 0<br>
 150:../SSC/Src/ecatslv.c **** V4.08 ECAT 3: The AlStatusCode is changed as parameter of the function AL_ControlInd<br>
 151:../SSC/Src/ecatslv.c **** V4.08 ECAT 4: In a state transition OP2PREOP, SAFEOP2INIT or OP2INIT is requested,<br>
 152:../SSC/Src/ecatslv.c ****               this was not working correctly if one of the application functions<br>
 153:../SSC/Src/ecatslv.c ****               APPL_StopInputHandler or APPL_StopOutputHandler were returning NOERROR_INWORK<br>
 154:../SSC/Src/ecatslv.c ****               (because only the first state transition was made in that case)<br>
 155:../SSC/Src/ecatslv.c **** V4.08 AOE 1:    AoE was added<br>
 156:../SSC/Src/ecatslv.c **** <br>Changes to version V4.06:<br>
 157:../SSC/Src/ecatslv.c **** V4.07 ECAT 1: The sources for SPI and MCI were merged (in ecat_def.h<br>
 158:../SSC/Src/ecatslv.c ****                    set the switch MCI_HW to 1 when using the MCI,<br>
 159:../SSC/Src/ecatslv.c ****                    set the switch SPI_HW to 1 when using the SPI<br>
 160:../SSC/Src/ecatslv.c **** <br>Changes to version V4.00:<br>
 161:../SSC/Src/ecatslv.c **** V4.01 ECAT 1: The Output sync Manager was not disabled when the state OP was left<br>
 162:../SSC/Src/ecatslv.c ****               by a local request (watchdog or io error)<br>
 163:../SSC/Src/ecatslv.c **** V4.01 ECAT 2: APPL_StopOutputHandler returns an UINT16<br>
 164:../SSC/Src/ecatslv.c **** V4.01 ECAT 3: TwinCAT compatibility mode: The state transition to OP is allowed when the<br>
 165:../SSC/Src/ecatslv.c ****                     WD-Trigger-Bit of the SM2-Control-Byte (0x814.6) is FALSE, in that case the<br>
 166:../SSC/Src/ecatslv.c ****                     watchdog will not be started before the outputs were received the first time<br
 167:../SSC/Src/ecatslv.c **** V4.01 ECAT 4: "else" was too much<br>
 168:../SSC/Src/ecatslv.c **** <br>Changes to version V3.20:<br>
 169:../SSC/Src/ecatslv.c **** V4.00 ECAT 1: The handling of the Sync Manager Parameter was included according to<br>
 170:../SSC/Src/ecatslv.c ****               the EtherCAT Guidelines and Protocol Enhancements Specification<br>
 171:../SSC/Src/ecatslv.c **** V4.00 ECAT 2: The output sync manager is initialized during the state transition<br>
 172:../SSC/Src/ecatslv.c ****               from PREOP to SAFEOP that the master can check if the slave could update<br>
 173:../SSC/Src/ecatslv.c ****               inputs and outputs before switching the slave to OP<br>
 174:../SSC/Src/ecatslv.c ****               behaviour according to the EtherCAT Guidelines and Protocol Enhancements Specificatio
 175:../SSC/Src/ecatslv.c **** V4.00 ECAT 3: The watchdog will be enabled in SAFE-OP that it can be checked if the last SM event<b
 176:../SSC/Src/ecatslv.c ****               was received during the watchdog time before switching to OP<br>
 177:../SSC/Src/ecatslv.c **** V4.00 ECAT 4: The function CheckSmChannelParameters is included in the function<br>
 178:../SSC/Src/ecatslv.c ****               CheckSmSettings to get a better overview<br>
 179:../SSC/Src/ecatslv.c **** V4.00 ECAT 5: In synchronous mode the slave should support 1- and 3-buffer mode, 3-buffer mode<br>
 180:../SSC/Src/ecatslv.c ****               should be the standard setting, because the controlling if the process data was updat
 181:../SSC/Src/ecatslv.c ****               should be done with the TxPDO Toggle, but the 1-buffer mode should be setable too,<br
 182:../SSC/Src/ecatslv.c ****               that the master could easily check if all slaves are synchronous by checking the<br>
 183:../SSC/Src/ecatslv.c ****               the working counter (if the outputs were not read or the inputs were not written<br>
 184:../SSC/Src/ecatslv.c ****               the ESC of the slave would not increment the working counter with expected value<br>
 185:../SSC/Src/ecatslv.c ****               if the 1-buffer mode is running)<br>
 186:../SSC/Src/ecatslv.c **** V4.00 ECAT 6: The function ECAT_StateChange was added, which the application should call if a local
 187:../SSC/Src/ecatslv.c ****                    is detected (with the parameters alStatus = STATE_SAFEOP, alStatusCode = error c
 188:../SSC/Src/ecatslv.c ****                    or gone (with the parameters alStatus = STATE_OP, alStatusCode = 0)<br>
 189:../SSC/Src/ecatslv.c ****                    or if one of the functions APPL_StartMailboxHandler, APPL_StopMailboxHandler, AP
 190:../SSC/Src/ecatslv.c ****                    APPL_StopInputHandler, APPL_StartOutputHandler, APPL_StopOutputHandler has retur
 191:../SSC/Src/ecatslv.c ****                    to acknowledge the last state transition (with the parameters alStatus = new AL-
 192:../SSC/Src/ecatslv.c ****                    new AL-Status-Code)<br>
 193:../SSC/Src/ecatslv.c **** V4.00 ECAT 7: The return values for the AL-StatusCode were changed to UINT16
 194:../SSC/Src/ecatslv.c **** */
 195:../SSC/Src/ecatslv.c **** 
 196:../SSC/Src/ecatslv.c **** /*-----------------------------------------------------------------------------------------
 197:../SSC/Src/ecatslv.c **** ------
 198:../SSC/Src/ecatslv.c **** ------    Includes
 199:../SSC/Src/ecatslv.c **** ------
 200:../SSC/Src/ecatslv.c **** -----------------------------------------------------------------------------------------*/
 201:../SSC/Src/ecatslv.c **** 
 202:../SSC/Src/ecatslv.c **** #define    _ECATSLV_    1
 203:../SSC/Src/ecatslv.c **** #include "ecatslv.h"
 204:../SSC/Src/ecatslv.c **** #undef    _ECATSLV_
 205:../SSC/Src/ecatslv.c **** /*remove definition of _ECATSLV_ (#ifdef is used in ecatslv.h)*/
 206:../SSC/Src/ecatslv.c **** 
 207:../SSC/Src/ecatslv.c **** #include "ecatappl.h"
 208:../SSC/Src/ecatslv.c **** 
 209:../SSC/Src/ecatslv.c **** 
 210:../SSC/Src/ecatslv.c **** 
 211:../SSC/Src/ecatslv.c **** 
 212:../SSC/Src/ecatslv.c **** 
 213:../SSC/Src/ecatslv.c **** #include "mailbox.h"
 214:../SSC/Src/ecatslv.c **** 
 215:../SSC/Src/ecatslv.c **** #include "ecatcoe.h"
 216:../SSC/Src/ecatslv.c **** #include "objdef.h"
 217:../SSC/Src/ecatslv.c **** 
 218:../SSC/Src/ecatslv.c **** 
 219:../SSC/Src/ecatslv.c **** 
 220:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.13) CIA402 3*/
 221:../SSC/Src/ecatslv.c **** #include "ryhand.h"
 222:../SSC/Src/ecatslv.c **** 
 223:../SSC/Src/ecatslv.c **** /*--------------------------------------------------------------------------------------
 224:../SSC/Src/ecatslv.c **** ------
 225:../SSC/Src/ecatslv.c **** ------    local Types and Defines
 226:../SSC/Src/ecatslv.c **** ------
 227:../SSC/Src/ecatslv.c **** --------------------------------------------------------------------------------------*/
 228:../SSC/Src/ecatslv.c **** 
 229:../SSC/Src/ecatslv.c **** 
 230:../SSC/Src/ecatslv.c **** /*-----------------------------------------------------------------------------------------
 231:../SSC/Src/ecatslv.c **** ------
 232:../SSC/Src/ecatslv.c **** ------    local variables and constants
 233:../SSC/Src/ecatslv.c **** ------
 234:../SSC/Src/ecatslv.c **** -----------------------------------------------------------------------------------------*/
 235:../SSC/Src/ecatslv.c **** UINT16    u16ALEventMask;                      // Value which will be written to the 0x204 register
 236:../SSC/Src/ecatslv.c **** 
 237:../SSC/Src/ecatslv.c **** /*Dummy variable to trigger read or writes events in the ESC*/
 238:../SSC/Src/ecatslv.c ****     VARVOLATILE UINT8 u8dummy;
 239:../SSC/Src/ecatslv.c **** 
 240:../SSC/Src/ecatslv.c **** 
 241:../SSC/Src/ecatslv.c ****         VARVOLATILE UINT8 SMActivate = 0;
 242:../SSC/Src/ecatslv.c **** 
 243:../SSC/Src/ecatslv.c **** TSYNCMAN		SyncManInfo;
 244:../SSC/Src/ecatslv.c **** 
 245:../SSC/Src/ecatslv.c **** //indicates if the EEPORM was loaded correct
 246:../SSC/Src/ecatslv.c **** BOOL EepromLoaded = FALSE;
 247:../SSC/Src/ecatslv.c **** 
 248:../SSC/Src/ecatslv.c **** 
 249:../SSC/Src/ecatslv.c **** /*-----------------------------------------------------------------------------------------
 250:../SSC/Src/ecatslv.c **** ------
 251:../SSC/Src/ecatslv.c **** ------    local functions
 252:../SSC/Src/ecatslv.c **** ------
 253:../SSC/Src/ecatslv.c **** -----------------------------------------------------------------------------------------*/
 254:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.13) ECAT1*/
 255:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.13) ECAT1*/
 256:../SSC/Src/ecatslv.c **** void ResetALEventMask(UINT16 intMask);
 257:../SSC/Src/ecatslv.c **** 
 258:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 259:../SSC/Src/ecatslv.c **** /**
 260:../SSC/Src/ecatslv.c ****  \param    intMask        interrupt mask (disabled interrupt shall be zero)
 261:../SSC/Src/ecatslv.c **** 
 262:../SSC/Src/ecatslv.c ****  \brief    This function makes an logical and with the AL Event Mask register (0x204)
 263:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 264:../SSC/Src/ecatslv.c **** void ResetALEventMask(UINT16 intMask)
 265:../SSC/Src/ecatslv.c **** {
 197              	 .loc 3 265 0
 198              	 .cfi_startproc
 199              	 
 200              	 
 201 0000 80B5     	 push {r7,lr}
 202              	.LCFI11:
 203              	 .cfi_def_cfa_offset 8
 204              	 .cfi_offset 7,-8
 205              	 .cfi_offset 14,-4
 206 0002 84B0     	 sub sp,sp,#16
 207              	.LCFI12:
 208              	 .cfi_def_cfa_offset 24
 209 0004 00AF     	 add r7,sp,#0
 210              	.LCFI13:
 211              	 .cfi_def_cfa_register 7
 212 0006 0346     	 mov r3,r0
 213 0008 FB80     	 strh r3,[r7,#6]
 266:../SSC/Src/ecatslv.c ****     UINT16 mask;
 267:../SSC/Src/ecatslv.c ****     HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
 214              	 .loc 3 267 0
 215 000a 084B     	 ldr r3,.L9
 216 000c 1B88     	 ldrh r3,[r3]
 217 000e FB81     	 strh r3,[r7,#14]
 268:../SSC/Src/ecatslv.c ****     
 269:../SSC/Src/ecatslv.c ****     mask &= intMask;
 218              	 .loc 3 269 0
 219 0010 FA89     	 ldrh r2,[r7,#14]
 220 0012 FB88     	 ldrh r3,[r7,#6]
 221 0014 1340     	 ands r3,r3,r2
 222 0016 FB81     	 strh r3,[r7,#14]
 270:../SSC/Src/ecatslv.c **** 
 271:../SSC/Src/ecatslv.c **** 
 272:../SSC/Src/ecatslv.c ****     DISABLE_ESC_INT();
 223              	 .loc 3 272 0
 224 0018 FFF7FEFF 	 bl DISABLE_ESC_INT
 273:../SSC/Src/ecatslv.c **** 
 274:../SSC/Src/ecatslv.c **** 
 275:../SSC/Src/ecatslv.c ****     HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
 225              	 .loc 3 275 0
 226 001c 034A     	 ldr r2,.L9
 227 001e FB89     	 ldrh r3,[r7,#14]
 228 0020 1380     	 strh r3,[r2]
 276:../SSC/Src/ecatslv.c ****     ENABLE_ESC_INT();
 229              	 .loc 3 276 0
 230 0022 FFF7FEFF 	 bl ENABLE_ESC_INT
 277:../SSC/Src/ecatslv.c **** }
 231              	 .loc 3 277 0
 232 0026 1037     	 adds r7,r7,#16
 233              	.LCFI14:
 234              	 .cfi_def_cfa_offset 8
 235 0028 BD46     	 mov sp,r7
 236              	.LCFI15:
 237              	 .cfi_def_cfa_register 13
 238              	 
 239 002a 80BD     	 pop {r7,pc}
 240              	.L10:
 241              	 .align 2
 242              	.L9:
 243 002c 04020154 	 .word 1409352196
 244              	 .cfi_endproc
 245              	.LFE175:
 247              	 .section .text.SetALEventMask,"ax",%progbits
 248              	 .align 2
 249              	 .global SetALEventMask
 250              	 .thumb
 251              	 .thumb_func
 253              	SetALEventMask:
 254              	.LFB176:
 278:../SSC/Src/ecatslv.c **** 
 279:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 280:../SSC/Src/ecatslv.c **** /**
 281:../SSC/Src/ecatslv.c ****  \param    intMask        interrupt mask (enabled interrupt shall be one)
 282:../SSC/Src/ecatslv.c **** 
 283:../SSC/Src/ecatslv.c ****   \brief    This function makes an logical or with the AL Event Mask register (0x204)
 284:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 285:../SSC/Src/ecatslv.c **** void SetALEventMask(UINT16 intMask)
 286:../SSC/Src/ecatslv.c **** {
 255              	 .loc 3 286 0
 256              	 .cfi_startproc
 257              	 
 258              	 
 259 0000 80B5     	 push {r7,lr}
 260              	.LCFI16:
 261              	 .cfi_def_cfa_offset 8
 262              	 .cfi_offset 7,-8
 263              	 .cfi_offset 14,-4
 264 0002 84B0     	 sub sp,sp,#16
 265              	.LCFI17:
 266              	 .cfi_def_cfa_offset 24
 267 0004 00AF     	 add r7,sp,#0
 268              	.LCFI18:
 269              	 .cfi_def_cfa_register 7
 270 0006 0346     	 mov r3,r0
 271 0008 FB80     	 strh r3,[r7,#6]
 287:../SSC/Src/ecatslv.c ****     UINT16 mask;
 288:../SSC/Src/ecatslv.c ****     HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
 272              	 .loc 3 288 0
 273 000a 084B     	 ldr r3,.L12
 274 000c 1B88     	 ldrh r3,[r3]
 275 000e FB81     	 strh r3,[r7,#14]
 289:../SSC/Src/ecatslv.c ****     
 290:../SSC/Src/ecatslv.c **** 
 291:../SSC/Src/ecatslv.c ****     mask |= intMask;
 276              	 .loc 3 291 0
 277 0010 FA89     	 ldrh r2,[r7,#14]
 278 0012 FB88     	 ldrh r3,[r7,#6]
 279 0014 1343     	 orrs r3,r3,r2
 280 0016 FB81     	 strh r3,[r7,#14]
 292:../SSC/Src/ecatslv.c **** 
 293:../SSC/Src/ecatslv.c ****     DISABLE_ESC_INT();
 281              	 .loc 3 293 0
 282 0018 FFF7FEFF 	 bl DISABLE_ESC_INT
 294:../SSC/Src/ecatslv.c **** 
 295:../SSC/Src/ecatslv.c **** 
 296:../SSC/Src/ecatslv.c ****     HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
 283              	 .loc 3 296 0
 284 001c 034A     	 ldr r2,.L12
 285 001e FB89     	 ldrh r3,[r7,#14]
 286 0020 1380     	 strh r3,[r2]
 297:../SSC/Src/ecatslv.c ****     ENABLE_ESC_INT();
 287              	 .loc 3 297 0
 288 0022 FFF7FEFF 	 bl ENABLE_ESC_INT
 298:../SSC/Src/ecatslv.c **** }
 289              	 .loc 3 298 0
 290 0026 1037     	 adds r7,r7,#16
 291              	.LCFI19:
 292              	 .cfi_def_cfa_offset 8
 293 0028 BD46     	 mov sp,r7
 294              	.LCFI20:
 295              	 .cfi_def_cfa_register 13
 296              	 
 297 002a 80BD     	 pop {r7,pc}
 298              	.L13:
 299              	 .align 2
 300              	.L12:
 301 002c 04020154 	 .word 1409352196
 302              	 .cfi_endproc
 303              	.LFE176:
 305              	 .section .text.UpdateEEPROMLoadedState,"ax",%progbits
 306              	 .align 2
 307              	 .global UpdateEEPROMLoadedState
 308              	 .thumb
 309              	 .thumb_func
 311              	UpdateEEPROMLoadedState:
 312              	.LFB177:
 299:../SSC/Src/ecatslv.c **** 
 300:../SSC/Src/ecatslv.c **** 
 301:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 302:../SSC/Src/ecatslv.c **** /**
 303:../SSC/Src/ecatslv.c **** 
 304:../SSC/Src/ecatslv.c **** \brief    This function reads the EEPROM loaded state
 305:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 306:../SSC/Src/ecatslv.c **** void UpdateEEPROMLoadedState(void)
 307:../SSC/Src/ecatslv.c **** {
 313              	 .loc 3 307 0
 314              	 .cfi_startproc
 315              	 
 316              	 
 317              	 
 318 0000 80B4     	 push {r7}
 319              	.LCFI21:
 320              	 .cfi_def_cfa_offset 4
 321              	 .cfi_offset 7,-4
 322 0002 83B0     	 sub sp,sp,#12
 323              	.LCFI22:
 324              	 .cfi_def_cfa_offset 16
 325 0004 00AF     	 add r7,sp,#0
 326              	.LCFI23:
 327              	 .cfi_def_cfa_register 7
 308:../SSC/Src/ecatslv.c ****     UINT16 TmpVar = 0;
 328              	 .loc 3 308 0
 329 0006 0023     	 movs r3,#0
 330 0008 FB80     	 strh r3,[r7,#6]
 309:../SSC/Src/ecatslv.c ****     //read EEPROM loaded information
 310:../SSC/Src/ecatslv.c ****     HW_EscReadWord(TmpVar, ESC_EEPROM_CONTROL_OFFSET);
 331              	 .loc 3 310 0
 332 000a 0C4B     	 ldr r3,.L18
 333 000c 1B88     	 ldrh r3,[r3]
 334 000e FB80     	 strh r3,[r7,#6]
 311:../SSC/Src/ecatslv.c ****     TmpVar = SWAPWORD(TmpVar);
 312:../SSC/Src/ecatslv.c **** 
 313:../SSC/Src/ecatslv.c **** 
 314:../SSC/Src/ecatslv.c ****     if (((TmpVar & ESC_EEPROM_ERROR_CRC) > 0)
 335              	 .loc 3 314 0
 336 0010 FB88     	 ldrh r3,[r7,#6]
 337 0012 03F40063 	 and r3,r3,#2048
 338 0016 002B     	 cmp r3,#0
 339 0018 04DC     	 bgt .L15
 315:../SSC/Src/ecatslv.c ****         || ((TmpVar & ESC_EEPROM_ERROR_LOAD) > 0))
 340              	 .loc 3 315 0
 341 001a FB88     	 ldrh r3,[r7,#6]
 342 001c 03F48053 	 and r3,r3,#4096
 343 0020 002B     	 cmp r3,#0
 344 0022 03DD     	 ble .L16
 345              	.L15:
 316:../SSC/Src/ecatslv.c ****     {
 317:../SSC/Src/ecatslv.c ****         EepromLoaded = FALSE;
 346              	 .loc 3 317 0
 347 0024 064B     	 ldr r3,.L18+4
 348 0026 0022     	 movs r2,#0
 349 0028 1A70     	 strb r2,[r3]
 350 002a 02E0     	 b .L14
 351              	.L16:
 318:../SSC/Src/ecatslv.c ****     }
 319:../SSC/Src/ecatslv.c ****     else
 320:../SSC/Src/ecatslv.c ****     {
 321:../SSC/Src/ecatslv.c ****         EepromLoaded = TRUE;
 352              	 .loc 3 321 0
 353 002c 044B     	 ldr r3,.L18+4
 354 002e 0122     	 movs r2,#1
 355 0030 1A70     	 strb r2,[r3]
 356              	.L14:
 322:../SSC/Src/ecatslv.c ****     }
 323:../SSC/Src/ecatslv.c **** }
 357              	 .loc 3 323 0
 358 0032 0C37     	 adds r7,r7,#12
 359              	.LCFI24:
 360              	 .cfi_def_cfa_offset 4
 361 0034 BD46     	 mov sp,r7
 362              	.LCFI25:
 363              	 .cfi_def_cfa_register 13
 364              	 
 365 0036 5DF8047B 	 ldr r7,[sp],#4
 366              	.LCFI26:
 367              	 .cfi_restore 7
 368              	 .cfi_def_cfa_offset 0
 369 003a 7047     	 bx lr
 370              	.L19:
 371              	 .align 2
 372              	.L18:
 373 003c 02050154 	 .word 1409352962
 374 0040 00000000 	 .word EepromLoaded
 375              	 .cfi_endproc
 376              	.LFE177:
 378              	 .section .text.GetSyncMan,"ax",%progbits
 379              	 .align 2
 380              	 .global GetSyncMan
 381              	 .thumb
 382              	 .thumb_func
 384              	GetSyncMan:
 385              	.LFB178:
 324:../SSC/Src/ecatslv.c **** 
 325:../SSC/Src/ecatslv.c **** 
 326:../SSC/Src/ecatslv.c **** /*-----------------------------------------------------------------------------------------
 327:../SSC/Src/ecatslv.c **** ------
 328:../SSC/Src/ecatslv.c **** ------    functions
 329:../SSC/Src/ecatslv.c **** ------
 330:../SSC/Src/ecatslv.c **** -----------------------------------------------------------------------------------------*/
 331:../SSC/Src/ecatslv.c **** 
 332:../SSC/Src/ecatslv.c **** 
 333:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 334:../SSC/Src/ecatslv.c **** /**
 335:../SSC/Src/ecatslv.c ****  \param     channel        Sync Manager channel
 336:../SSC/Src/ecatslv.c **** 
 337:../SSC/Src/ecatslv.c ****  \return     pPdSyncMan        Pointer to the settings of requested SYNC Manager channel
 338:../SSC/Src/ecatslv.c **** 
 339:../SSC/Src/ecatslv.c ****  \brief    This function is called to read the SYNC Manager channel descriptions of the
 340:../SSC/Src/ecatslv.c ****              process data SYNC Managers.
 341:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 342:../SSC/Src/ecatslv.c **** 
 343:../SSC/Src/ecatslv.c **** TSYNCMAN ESCMEM * GetSyncMan( UINT8 channel )
 344:../SSC/Src/ecatslv.c **** {
 386              	 .loc 3 344 0
 387              	 .cfi_startproc
 388              	 
 389              	 
 390 0000 80B5     	 push {r7,lr}
 391              	.LCFI27:
 392              	 .cfi_def_cfa_offset 8
 393              	 .cfi_offset 7,-8
 394              	 .cfi_offset 14,-4
 395 0002 82B0     	 sub sp,sp,#8
 396              	.LCFI28:
 397              	 .cfi_def_cfa_offset 16
 398 0004 00AF     	 add r7,sp,#0
 399              	.LCFI29:
 400              	 .cfi_def_cfa_register 7
 401 0006 0346     	 mov r3,r0
 402 0008 FB71     	 strb r3,[r7,#7]
 345:../SSC/Src/ecatslv.c ****     HW_EscRead((MEM_ADDR *)&SyncManInfo, ESC_SYNCMAN_REG_OFFSET + (channel * SIZEOF_SM_REGISTER), S
 403              	 .loc 3 345 0
 404 000a FB79     	 ldrb r3,[r7,#7]
 405 000c 03F58073 	 add r3,r3,#256
 406 0010 9BB2     	 uxth r3,r3
 407 0012 DB00     	 lsls r3,r3,#3
 408 0014 9BB2     	 uxth r3,r3
 409 0016 0548     	 ldr r0,.L22
 410 0018 1946     	 mov r1,r3
 411 001a 0822     	 movs r2,#8
 412 001c FFF7FEFF 	 bl HW_EscRead
 346:../SSC/Src/ecatslv.c **** 
 347:../SSC/Src/ecatslv.c **** 
 348:../SSC/Src/ecatslv.c **** 
 349:../SSC/Src/ecatslv.c ****     return &SyncManInfo;
 413              	 .loc 3 349 0
 414 0020 024B     	 ldr r3,.L22
 350:../SSC/Src/ecatslv.c **** }
 415              	 .loc 3 350 0
 416 0022 1846     	 mov r0,r3
 417 0024 0837     	 adds r7,r7,#8
 418              	.LCFI30:
 419              	 .cfi_def_cfa_offset 8
 420 0026 BD46     	 mov sp,r7
 421              	.LCFI31:
 422              	 .cfi_def_cfa_register 13
 423              	 
 424 0028 80BD     	 pop {r7,pc}
 425              	.L23:
 426 002a 00BF     	 .align 2
 427              	.L22:
 428 002c 00000000 	 .word SyncManInfo
 429              	 .cfi_endproc
 430              	.LFE178:
 432              	 .section .text.DisableSyncManChannel,"ax",%progbits
 433              	 .align 2
 434              	 .global DisableSyncManChannel
 435              	 .thumb
 436              	 .thumb_func
 438              	DisableSyncManChannel:
 439              	.LFB179:
 351:../SSC/Src/ecatslv.c **** 
 352:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 353:../SSC/Src/ecatslv.c **** /**
 354:../SSC/Src/ecatslv.c ****  \param     channel        Sync Manager channel
 355:../SSC/Src/ecatslv.c **** 
 356:../SSC/Src/ecatslv.c ****  \brief    This function disables a Sync Manager channel
 357:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 358:../SSC/Src/ecatslv.c **** void DisableSyncManChannel(UINT8 channel)
 359:../SSC/Src/ecatslv.c **** {
 440              	 .loc 3 359 0
 441              	 .cfi_startproc
 442              	 
 443              	 
 444              	 
 445 0000 80B4     	 push {r7}
 446              	.LCFI32:
 447              	 .cfi_def_cfa_offset 4
 448              	 .cfi_offset 7,-4
 449 0002 85B0     	 sub sp,sp,#20
 450              	.LCFI33:
 451              	 .cfi_def_cfa_offset 24
 452 0004 00AF     	 add r7,sp,#0
 453              	.LCFI34:
 454              	 .cfi_def_cfa_register 7
 455 0006 0346     	 mov r3,r0
 456 0008 FB71     	 strb r3,[r7,#7]
 360:../SSC/Src/ecatslv.c ****     UINT16 Offset;
 361:../SSC/Src/ecatslv.c ****     VARVOLATILE UINT8 smStatus = SM_SETTING_PDI_DISABLE;
 457              	 .loc 3 361 0
 458 000a 0123     	 movs r3,#1
 459 000c 7B73     	 strb r3,[r7,#13]
 362:../SSC/Src/ecatslv.c ****     Offset = (ESC_SM_PDICONTROL_OFFSET + (SIZEOF_SM_REGISTER*channel));
 460              	 .loc 3 362 0
 461 000e FB79     	 ldrb r3,[r7,#7]
 462 0010 9BB2     	 uxth r3,r3
 463 0012 DB00     	 lsls r3,r3,#3
 464 0014 9BB2     	 uxth r3,r3
 465 0016 03F60703 	 addw r3,r3,#2055
 466 001a FB81     	 strh r3,[r7,#14]
 363:../SSC/Src/ecatslv.c **** 
 364:../SSC/Src/ecatslv.c ****     HW_EscWriteByte(smStatus,Offset);
 467              	 .loc 3 364 0
 468 001c FB89     	 ldrh r3,[r7,#14]
 469 001e 03F1A843 	 add r3,r3,#1409286144
 470 0022 03F58033 	 add r3,r3,#65536
 471 0026 7A7B     	 ldrb r2,[r7,#13]
 472 0028 D2B2     	 uxtb r2,r2
 473 002a 1A70     	 strb r2,[r3]
 474              	.L25:
 365:../SSC/Src/ecatslv.c ****     
 366:../SSC/Src/ecatslv.c ****     /*wait until SyncManager is disabled*/
 367:../SSC/Src/ecatslv.c ****     do
 368:../SSC/Src/ecatslv.c ****     {
 369:../SSC/Src/ecatslv.c ****         HW_EscReadByte(smStatus, Offset);
 475              	 .loc 3 369 0 discriminator 1
 476 002c FB89     	 ldrh r3,[r7,#14]
 477 002e 03F1A843 	 add r3,r3,#1409286144
 478 0032 03F58033 	 add r3,r3,#65536
 479 0036 1B78     	 ldrb r3,[r3]
 480 0038 DBB2     	 uxtb r3,r3
 481 003a 7B73     	 strb r3,[r7,#13]
 370:../SSC/Src/ecatslv.c ****     }while(!(smStatus & SM_SETTING_PDI_DISABLE));
 482              	 .loc 3 370 0 discriminator 1
 483 003c 7B7B     	 ldrb r3,[r7,#13]
 484 003e DBB2     	 uxtb r3,r3
 485 0040 03F00103 	 and r3,r3,#1
 486 0044 002B     	 cmp r3,#0
 487 0046 F1D0     	 beq .L25
 371:../SSC/Src/ecatslv.c **** }
 488              	 .loc 3 371 0
 489 0048 1437     	 adds r7,r7,#20
 490              	.LCFI35:
 491              	 .cfi_def_cfa_offset 4
 492 004a BD46     	 mov sp,r7
 493              	.LCFI36:
 494              	 .cfi_def_cfa_register 13
 495              	 
 496 004c 5DF8047B 	 ldr r7,[sp],#4
 497              	.LCFI37:
 498              	 .cfi_restore 7
 499              	 .cfi_def_cfa_offset 0
 500 0050 7047     	 bx lr
 501              	 .cfi_endproc
 502              	.LFE179:
 504 0052 00BF     	 .section .text.EnableSyncManChannel,"ax",%progbits
 505              	 .align 2
 506              	 .global EnableSyncManChannel
 507              	 .thumb
 508              	 .thumb_func
 510              	EnableSyncManChannel:
 511              	.LFB180:
 372:../SSC/Src/ecatslv.c **** 
 373:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 374:../SSC/Src/ecatslv.c **** /**
 375:../SSC/Src/ecatslv.c ****  \param     channel        Sync Manager channel
 376:../SSC/Src/ecatslv.c **** 
 377:../SSC/Src/ecatslv.c ****  \brief    This function enables a Sync Manager channel
 378:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 379:../SSC/Src/ecatslv.c **** void EnableSyncManChannel(UINT8 channel)
 380:../SSC/Src/ecatslv.c **** {
 512              	 .loc 3 380 0
 513              	 .cfi_startproc
 514              	 
 515              	 
 516              	 
 517 0000 80B4     	 push {r7}
 518              	.LCFI38:
 519              	 .cfi_def_cfa_offset 4
 520              	 .cfi_offset 7,-4
 521 0002 85B0     	 sub sp,sp,#20
 522              	.LCFI39:
 523              	 .cfi_def_cfa_offset 24
 524 0004 00AF     	 add r7,sp,#0
 525              	.LCFI40:
 526              	 .cfi_def_cfa_register 7
 527 0006 0346     	 mov r3,r0
 528 0008 FB71     	 strb r3,[r7,#7]
 381:../SSC/Src/ecatslv.c ****     UINT16 Offset;
 382:../SSC/Src/ecatslv.c ****     VARVOLATILE UINT8 smStatus = 0x00;
 529              	 .loc 3 382 0
 530 000a 0023     	 movs r3,#0
 531 000c 7B73     	 strb r3,[r7,#13]
 383:../SSC/Src/ecatslv.c ****     Offset = (ESC_SM_PDICONTROL_OFFSET + (SIZEOF_SM_REGISTER*channel));
 532              	 .loc 3 383 0
 533 000e FB79     	 ldrb r3,[r7,#7]
 534 0010 9BB2     	 uxth r3,r3
 535 0012 DB00     	 lsls r3,r3,#3
 536 0014 9BB2     	 uxth r3,r3
 537 0016 03F60703 	 addw r3,r3,#2055
 538 001a FB81     	 strh r3,[r7,#14]
 384:../SSC/Src/ecatslv.c **** 
 385:../SSC/Src/ecatslv.c ****     HW_EscWriteByte(smStatus,Offset);
 539              	 .loc 3 385 0
 540 001c FB89     	 ldrh r3,[r7,#14]
 541 001e 03F1A843 	 add r3,r3,#1409286144
 542 0022 03F58033 	 add r3,r3,#65536
 543 0026 7A7B     	 ldrb r2,[r7,#13]
 544 0028 D2B2     	 uxtb r2,r2
 545 002a 1A70     	 strb r2,[r3]
 546              	.L27:
 386:../SSC/Src/ecatslv.c ****     
 387:../SSC/Src/ecatslv.c ****     /*wait until SyncManager is enabled*/
 388:../SSC/Src/ecatslv.c ****     do
 389:../SSC/Src/ecatslv.c ****     {
 390:../SSC/Src/ecatslv.c ****         HW_EscReadByte(smStatus,Offset);
 547              	 .loc 3 390 0 discriminator 1
 548 002c FB89     	 ldrh r3,[r7,#14]
 549 002e 03F1A843 	 add r3,r3,#1409286144
 550 0032 03F58033 	 add r3,r3,#65536
 551 0036 1B78     	 ldrb r3,[r3]
 552 0038 DBB2     	 uxtb r3,r3
 553 003a 7B73     	 strb r3,[r7,#13]
 391:../SSC/Src/ecatslv.c ****     }while((smStatus & SM_SETTING_PDI_DISABLE));
 554              	 .loc 3 391 0 discriminator 1
 555 003c 7B7B     	 ldrb r3,[r7,#13]
 556 003e DBB2     	 uxtb r3,r3
 557 0040 03F00103 	 and r3,r3,#1
 558 0044 002B     	 cmp r3,#0
 559 0046 F1D1     	 bne .L27
 392:../SSC/Src/ecatslv.c **** }
 560              	 .loc 3 392 0
 561 0048 1437     	 adds r7,r7,#20
 562              	.LCFI41:
 563              	 .cfi_def_cfa_offset 4
 564 004a BD46     	 mov sp,r7
 565              	.LCFI42:
 566              	 .cfi_def_cfa_register 13
 567              	 
 568 004c 5DF8047B 	 ldr r7,[sp],#4
 569              	.LCFI43:
 570              	 .cfi_restore 7
 571              	 .cfi_def_cfa_offset 0
 572 0050 7047     	 bx lr
 573              	 .cfi_endproc
 574              	.LFE180:
 576 0052 00BF     	 .section .text.CheckSmSettings,"ax",%progbits
 577              	 .align 2
 578              	 .global CheckSmSettings
 579              	 .thumb
 580              	 .thumb_func
 582              	CheckSmSettings:
 583              	.LFB181:
 393:../SSC/Src/ecatslv.c **** 
 394:../SSC/Src/ecatslv.c **** 
 395:../SSC/Src/ecatslv.c **** 
 396:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 397:../SSC/Src/ecatslv.c **** /**
 398:../SSC/Src/ecatslv.c ****  \param  maxChannel    last SM channel which should be checked
 399:../SSC/Src/ecatslv.c **** 
 400:../SSC/Src/ecatslv.c ****  \return                 0: okay else AL Status Code
 401:../SSC/Src/ecatslv.c **** 
 402:../SSC/Src/ecatslv.c ****  \brief    This function checks all SM channels
 403:../SSC/Src/ecatslv.c **** 
 404:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 405:../SSC/Src/ecatslv.c **** 
 406:../SSC/Src/ecatslv.c **** UINT8    CheckSmSettings(UINT8 maxChannel)
 407:../SSC/Src/ecatslv.c **** {
 584              	 .loc 3 407 0
 585              	 .cfi_startproc
 586              	 
 587              	 
 588 0000 80B5     	 push {r7,lr}
 589              	.LCFI44:
 590              	 .cfi_def_cfa_offset 8
 591              	 .cfi_offset 7,-8
 592              	 .cfi_offset 14,-4
 593 0002 86B0     	 sub sp,sp,#24
 594              	.LCFI45:
 595              	 .cfi_def_cfa_offset 32
 596 0004 00AF     	 add r7,sp,#0
 597              	.LCFI46:
 598              	 .cfi_def_cfa_register 7
 599 0006 0346     	 mov r3,r0
 600 0008 FB71     	 strb r3,[r7,#7]
 408:../SSC/Src/ecatslv.c ****     UINT8 i;
 409:../SSC/Src/ecatslv.c ****     UINT8 result = 0;
 601              	 .loc 3 409 0
 602 000a 0023     	 movs r3,#0
 603 000c BB75     	 strb r3,[r7,#22]
 410:../SSC/Src/ecatslv.c ****     TSYNCMAN ESCMEM *pSyncMan;
 411:../SSC/Src/ecatslv.c ****     UINT16 SMLength = 0;
 604              	 .loc 3 411 0
 605 000e 0023     	 movs r3,#0
 606 0010 BB82     	 strh r3,[r7,#20]
 412:../SSC/Src/ecatslv.c ****     UINT16 SMAddress = 0;
 607              	 .loc 3 412 0
 608 0012 0023     	 movs r3,#0
 609 0014 7B82     	 strh r3,[r7,#18]
 413:../SSC/Src/ecatslv.c **** 
 414:../SSC/Src/ecatslv.c **** 
 415:../SSC/Src/ecatslv.c ****         //Check if max address defines are within the available ESC address range
 416:../SSC/Src/ecatslv.c ****         if ((nMaxEscAddress < MAX_PD_WRITE_ADDRESS)
 610              	 .loc 3 416 0
 611 0016 9F4B     	 ldr r3,.L79
 612 0018 1B88     	 ldrh r3,[r3]
 613 001a 42F6FE72 	 movw r2,#12286
 614 001e 9342     	 cmp r3,r2
 615 0020 11D9     	 bls .L29
 417:../SSC/Src/ecatslv.c ****             || (nMaxEscAddress < MAX_PD_READ_ADDRESS)
 616              	 .loc 3 417 0
 617 0022 9C4B     	 ldr r3,.L79
 618 0024 1B88     	 ldrh r3,[r3]
 619 0026 42F6FE72 	 movw r2,#12286
 620 002a 9342     	 cmp r3,r2
 621 002c 0BD9     	 bls .L29
 418:../SSC/Src/ecatslv.c ****             || (nMaxEscAddress < MAX_MBX_WRITE_ADDRESS)
 622              	 .loc 3 418 0
 623 002e 994B     	 ldr r3,.L79
 624 0030 1B88     	 ldrh r3,[r3]
 625 0032 42F6FE72 	 movw r2,#12286
 626 0036 9342     	 cmp r3,r2
 627 0038 05D9     	 bls .L29
 419:../SSC/Src/ecatslv.c ****             || (nMaxEscAddress < MAX_MBX_READ_ADDRESS))
 628              	 .loc 3 419 0
 629 003a 964B     	 ldr r3,.L79
 630 003c 1B88     	 ldrh r3,[r3]
 631 003e 42F6FE72 	 movw r2,#12286
 632 0042 9342     	 cmp r3,r2
 633 0044 01D8     	 bhi .L30
 634              	.L29:
 420:../SSC/Src/ecatslv.c ****         {
 421:../SSC/Src/ecatslv.c ****             /*The defines for maximum SM addresses are invalid for the used ESC (change the defines
 422:../SSC/Src/ecatslv.c ****             It may be also required to adapt the SM settings in the ESI file*/
 423:../SSC/Src/ecatslv.c **** 
 424:../SSC/Src/ecatslv.c **** 
 425:../SSC/Src/ecatslv.c ****                 return ALSTATUSCODE_NOVALIDFIRMWARE;
 635              	 .loc 3 425 0
 636 0046 1423     	 movs r3,#20
 637 0048 A5E1     	 b .L31
 638              	.L30:
 426:../SSC/Src/ecatslv.c ****         }
 427:../SSC/Src/ecatslv.c **** 
 428:../SSC/Src/ecatslv.c ****     /* check the Sync Manager Parameter for the Receive Mailbox (Sync Manager Channel 0) */
 429:../SSC/Src/ecatslv.c ****     pSyncMan = GetSyncMan(MAILBOX_WRITE);
 639              	 .loc 3 429 0
 640 004a 0020     	 movs r0,#0
 641 004c FFF7FEFF 	 bl GetSyncMan
 642 0050 F860     	 str r0,[r7,#12]
 430:../SSC/Src/ecatslv.c **** 
 431:../SSC/Src/ecatslv.c ****     SMLength = pSyncMan->Length;
 643              	 .loc 3 431 0
 644 0052 FB68     	 ldr r3,[r7,#12]
 645 0054 9A78     	 ldrb r2,[r3,#2]
 646 0056 DB78     	 ldrb r3,[r3,#3]
 647 0058 1B02     	 lsls r3,r3,#8
 648 005a 1343     	 orrs r3,r3,r2
 649 005c BB82     	 strh r3,[r7,#20]
 432:../SSC/Src/ecatslv.c ****     SMAddress = pSyncMan->PhysicalStartAddress;
 650              	 .loc 3 432 0
 651 005e FB68     	 ldr r3,[r7,#12]
 652 0060 1A78     	 ldrb r2,[r3]
 653 0062 5B78     	 ldrb r3,[r3,#1]
 654 0064 1B02     	 lsls r3,r3,#8
 655 0066 1343     	 orrs r3,r3,r2
 656 0068 7B82     	 strh r3,[r7,#18]
 433:../SSC/Src/ecatslv.c **** 
 434:../SSC/Src/ecatslv.c **** 
 435:../SSC/Src/ecatslv.c **** 
 436:../SSC/Src/ecatslv.c ****     if (!(pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE))
 657              	 .loc 3 436 0
 658 006a FB68     	 ldr r3,[r7,#12]
 659 006c 9B79     	 ldrb r3,[r3,#6]
 660 006e 03F00103 	 and r3,r3,#1
 661 0072 002B     	 cmp r3,#0
 662 0074 02D1     	 bne .L32
 437:../SSC/Src/ecatslv.c ****     {
 438:../SSC/Src/ecatslv.c ****         /* receive mailbox is not enabled */
 439:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 663              	 .loc 3 439 0
 664 0076 1623     	 movs r3,#22
 665 0078 BB75     	 strb r3,[r7,#22]
 666 007a 2AE0     	 b .L33
 667              	.L32:
 440:../SSC/Src/ecatslv.c ****     }
 441:../SSC/Src/ecatslv.c ****     else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) != SM_SETT
 668              	 .loc 3 441 0
 669 007c FB68     	 ldr r3,[r7,#12]
 670 007e 1B79     	 ldrb r3,[r3,#4]
 671 0080 03F00C03 	 and r3,r3,#12
 672 0084 042B     	 cmp r3,#4
 673 0086 02D0     	 beq .L34
 442:../SSC/Src/ecatslv.c ****     {
 443:../SSC/Src/ecatslv.c ****         /* receive mailbox is not writable by the master*/
 444:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 674              	 .loc 3 444 0
 675 0088 1623     	 movs r3,#22
 676 008a BB75     	 strb r3,[r7,#22]
 677 008c 21E0     	 b .L33
 678              	.L34:
 445:../SSC/Src/ecatslv.c ****     }
 446:../SSC/Src/ecatslv.c ****     else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) != SM_SETTING_M
 679              	 .loc 3 446 0
 680 008e FB68     	 ldr r3,[r7,#12]
 681 0090 1B79     	 ldrb r3,[r3,#4]
 682 0092 03F00203 	 and r3,r3,#2
 683 0096 002B     	 cmp r3,#0
 684 0098 02D1     	 bne .L35
 447:../SSC/Src/ecatslv.c ****     {
 448:../SSC/Src/ecatslv.c ****         /* receive mailbox is not in one buffer mode */
 449:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 685              	 .loc 3 449 0
 686 009a 1623     	 movs r3,#22
 687 009c BB75     	 strb r3,[r7,#22]
 688 009e 18E0     	 b .L33
 689              	.L35:
 450:../SSC/Src/ecatslv.c ****     }
 451:../SSC/Src/ecatslv.c ****     else if (SMLength < MIN_MBX_SIZE)
 690              	 .loc 3 451 0
 691 00a0 BB8A     	 ldrh r3,[r7,#20]
 692 00a2 232B     	 cmp r3,#35
 693 00a4 02D8     	 bhi .L36
 452:../SSC/Src/ecatslv.c ****     {
 453:../SSC/Src/ecatslv.c ****         /* receive mailbox size is too small */
 454:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 694              	 .loc 3 454 0
 695 00a6 1623     	 movs r3,#22
 696 00a8 BB75     	 strb r3,[r7,#22]
 697 00aa 12E0     	 b .L33
 698              	.L36:
 455:../SSC/Src/ecatslv.c ****     }
 456:../SSC/Src/ecatslv.c ****     else if (SMLength > MAX_MBX_SIZE)
 699              	 .loc 3 456 0
 700 00ac BB8A     	 ldrh r3,[r7,#20]
 701 00ae 802B     	 cmp r3,#128
 702 00b0 02D9     	 bls .L37
 457:../SSC/Src/ecatslv.c ****     {
 458:../SSC/Src/ecatslv.c ****         /* receive mailbox size is too great */
 459:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 703              	 .loc 3 459 0
 704 00b2 1623     	 movs r3,#22
 705 00b4 BB75     	 strb r3,[r7,#22]
 706 00b6 0CE0     	 b .L33
 707              	.L37:
 460:../SSC/Src/ecatslv.c ****     }
 461:../SSC/Src/ecatslv.c ****     else if (SMAddress < MIN_MBX_WRITE_ADDRESS)
 708              	 .loc 3 461 0
 709 00b8 7B8A     	 ldrh r3,[r7,#18]
 710 00ba B3F5805F 	 cmp r3,#4096
 711 00be 02D2     	 bcs .L38
 462:../SSC/Src/ecatslv.c ****     {
 463:../SSC/Src/ecatslv.c ****         /* receive mailbox address is too small */
 464:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 712              	 .loc 3 464 0
 713 00c0 1623     	 movs r3,#22
 714 00c2 BB75     	 strb r3,[r7,#22]
 715 00c4 05E0     	 b .L33
 716              	.L38:
 465:../SSC/Src/ecatslv.c ****     }
 466:../SSC/Src/ecatslv.c ****     else if (SMAddress > MAX_MBX_WRITE_ADDRESS)
 717              	 .loc 3 466 0
 718 00c6 7B8A     	 ldrh r3,[r7,#18]
 719 00c8 B3F5405F 	 cmp r3,#12288
 720 00cc 01D3     	 bcc .L33
 467:../SSC/Src/ecatslv.c ****     {
 468:../SSC/Src/ecatslv.c ****         /* receive mailbox address is too great */
 469:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 721              	 .loc 3 469 0
 722 00ce 1623     	 movs r3,#22
 723 00d0 BB75     	 strb r3,[r7,#22]
 724              	.L33:
 470:../SSC/Src/ecatslv.c ****     }
 471:../SSC/Src/ecatslv.c **** 
 472:../SSC/Src/ecatslv.c **** 
 473:../SSC/Src/ecatslv.c ****     if ( result == 0 )
 725              	 .loc 3 473 0
 726 00d2 BB7D     	 ldrb r3,[r7,#22]
 727 00d4 002B     	 cmp r3,#0
 728 00d6 43D1     	 bne .L39
 474:../SSC/Src/ecatslv.c ****     {
 475:../SSC/Src/ecatslv.c ****         /* check the Sync Manager Parameter for the Send Mailbox (Sync Manager Channel 1) */
 476:../SSC/Src/ecatslv.c ****         pSyncMan = GetSyncMan(MAILBOX_READ);
 729              	 .loc 3 476 0
 730 00d8 0120     	 movs r0,#1
 731 00da FFF7FEFF 	 bl GetSyncMan
 732 00de F860     	 str r0,[r7,#12]
 477:../SSC/Src/ecatslv.c **** 
 478:../SSC/Src/ecatslv.c ****     SMLength = pSyncMan->Length;
 733              	 .loc 3 478 0
 734 00e0 FB68     	 ldr r3,[r7,#12]
 735 00e2 9A78     	 ldrb r2,[r3,#2]
 736 00e4 DB78     	 ldrb r3,[r3,#3]
 737 00e6 1B02     	 lsls r3,r3,#8
 738 00e8 1343     	 orrs r3,r3,r2
 739 00ea BB82     	 strh r3,[r7,#20]
 479:../SSC/Src/ecatslv.c ****     SMAddress = pSyncMan->PhysicalStartAddress;
 740              	 .loc 3 479 0
 741 00ec FB68     	 ldr r3,[r7,#12]
 742 00ee 1A78     	 ldrb r2,[r3]
 743 00f0 5B78     	 ldrb r3,[r3,#1]
 744 00f2 1B02     	 lsls r3,r3,#8
 745 00f4 1343     	 orrs r3,r3,r2
 746 00f6 7B82     	 strh r3,[r7,#18]
 480:../SSC/Src/ecatslv.c **** 
 481:../SSC/Src/ecatslv.c **** 
 482:../SSC/Src/ecatslv.c ****     if (!(pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE))
 747              	 .loc 3 482 0
 748 00f8 FB68     	 ldr r3,[r7,#12]
 749 00fa 9B79     	 ldrb r3,[r3,#6]
 750 00fc 03F00103 	 and r3,r3,#1
 751 0100 002B     	 cmp r3,#0
 752 0102 02D1     	 bne .L40
 483:../SSC/Src/ecatslv.c ****     {
 484:../SSC/Src/ecatslv.c ****         /* send mailbox is not enabled */
 485:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 753              	 .loc 3 485 0
 754 0104 1623     	 movs r3,#22
 755 0106 BB75     	 strb r3,[r7,#22]
 756 0108 2AE0     	 b .L39
 757              	.L40:
 486:../SSC/Src/ecatslv.c ****     }
 487:../SSC/Src/ecatslv.c ****     else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) != SM_SETT
 758              	 .loc 3 487 0
 759 010a FB68     	 ldr r3,[r7,#12]
 760 010c 1B79     	 ldrb r3,[r3,#4]
 761 010e 03F00C03 	 and r3,r3,#12
 762 0112 002B     	 cmp r3,#0
 763 0114 02D0     	 beq .L41
 488:../SSC/Src/ecatslv.c ****     {
 489:../SSC/Src/ecatslv.c ****         /* receive mailbox is not readable by the master*/
 490:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 764              	 .loc 3 490 0
 765 0116 1623     	 movs r3,#22
 766 0118 BB75     	 strb r3,[r7,#22]
 767 011a 21E0     	 b .L39
 768              	.L41:
 491:../SSC/Src/ecatslv.c ****     }
 492:../SSC/Src/ecatslv.c ****     else if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) != SM_SETTING_M
 769              	 .loc 3 492 0
 770 011c FB68     	 ldr r3,[r7,#12]
 771 011e 1B79     	 ldrb r3,[r3,#4]
 772 0120 03F00203 	 and r3,r3,#2
 773 0124 002B     	 cmp r3,#0
 774 0126 02D1     	 bne .L42
 493:../SSC/Src/ecatslv.c ****     {
 494:../SSC/Src/ecatslv.c ****         /* receive mailbox is not in one buffer mode */
 495:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 775              	 .loc 3 495 0
 776 0128 1623     	 movs r3,#22
 777 012a BB75     	 strb r3,[r7,#22]
 778 012c 18E0     	 b .L39
 779              	.L42:
 496:../SSC/Src/ecatslv.c ****     }
 497:../SSC/Src/ecatslv.c ****     else if (SMLength < MIN_MBX_SIZE)
 780              	 .loc 3 497 0
 781 012e BB8A     	 ldrh r3,[r7,#20]
 782 0130 232B     	 cmp r3,#35
 783 0132 02D8     	 bhi .L43
 498:../SSC/Src/ecatslv.c ****     {
 499:../SSC/Src/ecatslv.c ****         /* send mailbox size is too small */
 500:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 784              	 .loc 3 500 0
 785 0134 1623     	 movs r3,#22
 786 0136 BB75     	 strb r3,[r7,#22]
 787 0138 12E0     	 b .L39
 788              	.L43:
 501:../SSC/Src/ecatslv.c ****     }
 502:../SSC/Src/ecatslv.c ****     else if (SMLength > MAX_MBX_SIZE)
 789              	 .loc 3 502 0
 790 013a BB8A     	 ldrh r3,[r7,#20]
 791 013c 802B     	 cmp r3,#128
 792 013e 02D9     	 bls .L44
 503:../SSC/Src/ecatslv.c ****     {
 504:../SSC/Src/ecatslv.c ****         /* send mailbox size is too great */
 505:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 793              	 .loc 3 505 0
 794 0140 1623     	 movs r3,#22
 795 0142 BB75     	 strb r3,[r7,#22]
 796 0144 0CE0     	 b .L39
 797              	.L44:
 506:../SSC/Src/ecatslv.c ****     }
 507:../SSC/Src/ecatslv.c ****     else if (SMAddress < MIN_MBX_READ_ADDRESS)
 798              	 .loc 3 507 0
 799 0146 7B8A     	 ldrh r3,[r7,#18]
 800 0148 B3F5805F 	 cmp r3,#4096
 801 014c 02D2     	 bcs .L45
 508:../SSC/Src/ecatslv.c ****     {
 509:../SSC/Src/ecatslv.c ****         /* send mailbox address is too small */
 510:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 802              	 .loc 3 510 0
 803 014e 1623     	 movs r3,#22
 804 0150 BB75     	 strb r3,[r7,#22]
 805 0152 05E0     	 b .L39
 806              	.L45:
 511:../SSC/Src/ecatslv.c ****     }
 512:../SSC/Src/ecatslv.c ****     else if (SMAddress > MAX_MBX_READ_ADDRESS)
 807              	 .loc 3 512 0
 808 0154 7B8A     	 ldrh r3,[r7,#18]
 809 0156 B3F5405F 	 cmp r3,#12288
 810 015a 01D3     	 bcc .L39
 513:../SSC/Src/ecatslv.c ****     {
 514:../SSC/Src/ecatslv.c ****         /* send mailbox address is too great */
 515:../SSC/Src/ecatslv.c ****         result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 811              	 .loc 3 515 0
 812 015c 1623     	 movs r3,#22
 813 015e BB75     	 strb r3,[r7,#22]
 814              	.L39:
 516:../SSC/Src/ecatslv.c ****     }
 517:../SSC/Src/ecatslv.c ****     }
 518:../SSC/Src/ecatslv.c **** 
 519:../SSC/Src/ecatslv.c ****     if ( result == 0 && maxChannel > PROCESS_DATA_IN )
 815              	 .loc 3 519 0
 816 0160 BB7D     	 ldrb r3,[r7,#22]
 817 0162 002B     	 cmp r3,#0
 818 0164 71D1     	 bne .L46
 819              	 .loc 3 519 0 is_stmt 0 discriminator 1
 820 0166 FB79     	 ldrb r3,[r7,#7]
 821 0168 032B     	 cmp r3,#3
 822 016a 6ED9     	 bls .L46
 520:../SSC/Src/ecatslv.c ****     {
 521:../SSC/Src/ecatslv.c ****         /* b3BufferMode is only set, if inputs and outputs are running in 3-Buffer-Mode when leavin
 522:../SSC/Src/ecatslv.c ****         b3BufferMode = TRUE;
 823              	 .loc 3 522 0 is_stmt 1
 824 016c 4A4B     	 ldr r3,.L79+4
 825 016e 0122     	 movs r2,#1
 826 0170 1A70     	 strb r2,[r3]
 523:../SSC/Src/ecatslv.c ****         /* check the Sync Manager Parameter for the Inputs (Sync Manager Channel 2 (0 in case if no
 524:../SSC/Src/ecatslv.c ****         pSyncMan = GetSyncMan(PROCESS_DATA_IN);
 827              	 .loc 3 524 0
 828 0172 0320     	 movs r0,#3
 829 0174 FFF7FEFF 	 bl GetSyncMan
 830 0178 F860     	 str r0,[r7,#12]
 525:../SSC/Src/ecatslv.c **** 
 526:../SSC/Src/ecatslv.c ****     SMLength = pSyncMan->Length;
 831              	 .loc 3 526 0
 832 017a FB68     	 ldr r3,[r7,#12]
 833 017c 9A78     	 ldrb r2,[r3,#2]
 834 017e DB78     	 ldrb r3,[r3,#3]
 835 0180 1B02     	 lsls r3,r3,#8
 836 0182 1343     	 orrs r3,r3,r2
 837 0184 BB82     	 strh r3,[r7,#20]
 527:../SSC/Src/ecatslv.c ****     SMAddress = pSyncMan->PhysicalStartAddress;
 838              	 .loc 3 527 0
 839 0186 FB68     	 ldr r3,[r7,#12]
 840 0188 1A78     	 ldrb r2,[r3]
 841 018a 5B78     	 ldrb r3,[r3,#1]
 842 018c 1B02     	 lsls r3,r3,#8
 843 018e 1343     	 orrs r3,r3,r2
 844 0190 7B82     	 strh r3,[r7,#18]
 528:../SSC/Src/ecatslv.c **** 
 529:../SSC/Src/ecatslv.c **** 
 530:../SSC/Src/ecatslv.c **** 
 531:../SSC/Src/ecatslv.c ****     if ((pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE) != 0 && SMLength
 845              	 .loc 3 531 0
 846 0192 FB68     	 ldr r3,[r7,#12]
 847 0194 9B79     	 ldrb r3,[r3,#6]
 848 0196 03F00103 	 and r3,r3,#1
 849 019a 002B     	 cmp r3,#0
 850 019c 05D0     	 beq .L47
 851              	 .loc 3 531 0 is_stmt 0 discriminator 1
 852 019e BB8A     	 ldrh r3,[r7,#20]
 853 01a0 002B     	 cmp r3,#0
 854 01a2 02D1     	 bne .L47
 532:../SSC/Src/ecatslv.c ****     {
 533:../SSC/Src/ecatslv.c ****         /* the SM3 size is 0 and the SM3 is active */
 534:../SSC/Src/ecatslv.c ****         result = SYNCMANCHSETTINGS + 1;
 855              	 .loc 3 534 0 is_stmt 1
 856 01a4 0323     	 movs r3,#3
 857 01a6 BB75     	 strb r3,[r7,#22]
 858 01a8 4AE0     	 b .L48
 859              	.L47:
 535:../SSC/Src/ecatslv.c ****     }
 536:../SSC/Src/ecatslv.c ****         else if (pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE)
 860              	 .loc 3 536 0
 861 01aa FB68     	 ldr r3,[r7,#12]
 862 01ac 9B79     	 ldrb r3,[r3,#6]
 863 01ae 03F00103 	 and r3,r3,#1
 864 01b2 002B     	 cmp r3,#0
 865 01b4 3BD0     	 beq .L49
 537:../SSC/Src/ecatslv.c ****         {
 538:../SSC/Src/ecatslv.c ****             /* Sync Manager Channel 3 is active, input size has to greater 0 */
 539:../SSC/Src/ecatslv.c ****                 if (SMLength != nPdInputSize || nPdInputSize == 0 || SMLength > MAX_PD_INPUT_SIZE)
 866              	 .loc 3 539 0
 867 01b6 394B     	 ldr r3,.L79+8
 868 01b8 1B88     	 ldrh r3,[r3]
 869 01ba BA8A     	 ldrh r2,[r7,#20]
 870 01bc 9A42     	 cmp r2,r3
 871 01be 06D1     	 bne .L50
 872              	 .loc 3 539 0 is_stmt 0 discriminator 1
 873 01c0 364B     	 ldr r3,.L79+8
 874 01c2 1B88     	 ldrh r3,[r3]
 875 01c4 002B     	 cmp r3,#0
 876 01c6 02D0     	 beq .L50
 877              	 .loc 3 539 0 discriminator 2
 878 01c8 BB8A     	 ldrh r3,[r7,#20]
 879 01ca 9C2B     	 cmp r3,#156
 880 01cc 02D9     	 bls .L51
 881              	.L50:
 540:../SSC/Src/ecatslv.c ****                 {
 541:../SSC/Src/ecatslv.c ****                     /* sizes don't match */
 542:../SSC/Src/ecatslv.c ****                     result = SYNCMANCHSIZE + 1;
 882              	 .loc 3 542 0 is_stmt 1
 883 01ce 0123     	 movs r3,#1
 884 01d0 BB75     	 strb r3,[r7,#22]
 885 01d2 35E0     	 b .L48
 886              	.L51:
 543:../SSC/Src/ecatslv.c ****                 }
 544:../SSC/Src/ecatslv.c ****                 else
 545:../SSC/Src/ecatslv.c ****                 {
 546:../SSC/Src/ecatslv.c ****                     /* sizes matches */
 547:../SSC/Src/ecatslv.c ****                     if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK)
 887              	 .loc 3 547 0
 888 01d4 FB68     	 ldr r3,[r7,#12]
 889 01d6 1B79     	 ldrb r3,[r3,#4]
 890 01d8 03F00C03 	 and r3,r3,#12
 891 01dc 002B     	 cmp r3,#0
 892 01de 23D1     	 bne .L53
 548:../SSC/Src/ecatslv.c ****                     {
 549:../SSC/Src/ecatslv.c ****                         /* settings match */
 550:../SSC/Src/ecatslv.c ****                         if (((nAlStatus == STATE_PREOP) && (SMAddress >= MIN_PD_READ_ADDRESS) && (S
 893              	 .loc 3 550 0
 894 01e0 2F4B     	 ldr r3,.L79+12
 895 01e2 1B78     	 ldrb r3,[r3]
 896 01e4 022B     	 cmp r3,#2
 897 01e6 07D1     	 bne .L54
 898              	 .loc 3 550 0 is_stmt 0 discriminator 1
 899 01e8 7B8A     	 ldrh r3,[r7,#18]
 900 01ea B3F5805F 	 cmp r3,#4096
 901 01ee 03D3     	 bcc .L54
 902              	 .loc 3 550 0 discriminator 2
 903 01f0 7B8A     	 ldrh r3,[r7,#18]
 904 01f2 B3F5405F 	 cmp r3,#12288
 905 01f6 08D3     	 bcc .L55
 906              	.L54:
 551:../SSC/Src/ecatslv.c ****                             || ((nAlStatus != STATE_PREOP) && (SMAddress == nEscAddrInputData))
 907              	 .loc 3 551 0 is_stmt 1
 908 01f8 294B     	 ldr r3,.L79+12
 909 01fa 1B78     	 ldrb r3,[r3]
 910 01fc 022B     	 cmp r3,#2
 911 01fe 0FD0     	 beq .L56
 912              	 .loc 3 551 0 is_stmt 0 discriminator 1
 913 0200 284B     	 ldr r3,.L79+16
 914 0202 1B88     	 ldrh r3,[r3]
 915 0204 7A8A     	 ldrh r2,[r7,#18]
 916 0206 9A42     	 cmp r2,r3
 917 0208 0AD1     	 bne .L56
 918              	.L55:
 552:../SSC/Src/ecatslv.c ****                             )
 553:../SSC/Src/ecatslv.c ****                         {
 554:../SSC/Src/ecatslv.c ****                             /* addresses match */
 555:../SSC/Src/ecatslv.c **** 
 556:../SSC/Src/ecatslv.c ****                                 if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MOD
 919              	 .loc 3 556 0 is_stmt 1
 920 020a FB68     	 ldr r3,[r7,#12]
 921 020c 1B79     	 ldrb r3,[r3,#4]
 922 020e 03F00203 	 and r3,r3,#2
 923 0212 002B     	 cmp r3,#0
 924 0214 03D0     	 beq .L57
 557:../SSC/Src/ecatslv.c ****                                 {
 558:../SSC/Src/ecatslv.c ****                                     /* inputs are running in 1-Buffer-Mode, reset flag b3BufferMode
 559:../SSC/Src/ecatslv.c ****                                     b3BufferMode = FALSE;
 925              	 .loc 3 559 0
 926 0216 204B     	 ldr r3,.L79+4
 927 0218 0022     	 movs r2,#0
 928 021a 1A70     	 strb r2,[r3]
 556:../SSC/Src/ecatslv.c ****                                 {
 929              	 .loc 3 556 0
 930 021c 03E0     	 b .L58
 931              	.L57:
 932 021e 02E0     	 b .L58
 933              	.L56:
 560:../SSC/Src/ecatslv.c ****                                 }
 561:../SSC/Src/ecatslv.c ****                         }
 562:../SSC/Src/ecatslv.c ****                         else
 563:../SSC/Src/ecatslv.c ****                         {
 564:../SSC/Src/ecatslv.c ****                             /* input address is out of the allowed area or has changed in SAFEOP or
 565:../SSC/Src/ecatslv.c ****                             result = SYNCMANCHADDRESS + 1;
 934              	 .loc 3 565 0
 935 0220 0223     	 movs r3,#2
 936 0222 BB75     	 strb r3,[r7,#22]
 937 0224 0CE0     	 b .L48
 938              	.L58:
 939 0226 0BE0     	 b .L48
 940              	.L53:
 566:../SSC/Src/ecatslv.c ****                         }
 567:../SSC/Src/ecatslv.c ****                     }
 568:../SSC/Src/ecatslv.c ****                     else
 569:../SSC/Src/ecatslv.c ****                     {
 570:../SSC/Src/ecatslv.c ****                         /* input settings do not match */
 571:../SSC/Src/ecatslv.c ****                         result = SYNCMANCHSETTINGS + 1;
 941              	 .loc 3 571 0
 942 0228 0323     	 movs r3,#3
 943 022a BB75     	 strb r3,[r7,#22]
 944 022c 08E0     	 b .L48
 945              	.L49:
 572:../SSC/Src/ecatslv.c ****                     }
 573:../SSC/Src/ecatslv.c ****                 }
 574:../SSC/Src/ecatslv.c ****         }
 575:../SSC/Src/ecatslv.c ****         else if (SMLength != 0 || nPdInputSize != 0)
 946              	 .loc 3 575 0
 947 022e BB8A     	 ldrh r3,[r7,#20]
 948 0230 002B     	 cmp r3,#0
 949 0232 03D1     	 bne .L59
 950              	 .loc 3 575 0 is_stmt 0 discriminator 1
 951 0234 194B     	 ldr r3,.L79+8
 952 0236 1B88     	 ldrh r3,[r3]
 953 0238 002B     	 cmp r3,#0
 954 023a 01D0     	 beq .L48
 955              	.L59:
 576:../SSC/Src/ecatslv.c ****         {
 577:../SSC/Src/ecatslv.c ****             /* input size is not zero although the SM3 channel is not enabled */
 578:../SSC/Src/ecatslv.c ****             result = SYNCMANCHSIZE + 1;
 956              	 .loc 3 578 0 is_stmt 1
 957 023c 0123     	 movs r3,#1
 958 023e BB75     	 strb r3,[r7,#22]
 959              	.L48:
 579:../SSC/Src/ecatslv.c ****         }
 580:../SSC/Src/ecatslv.c **** 
 581:../SSC/Src/ecatslv.c **** 
 582:../SSC/Src/ecatslv.c **** 
 583:../SSC/Src/ecatslv.c ****         if ( result != 0 )
 960              	 .loc 3 583 0
 961 0240 BB7D     	 ldrb r3,[r7,#22]
 962 0242 002B     	 cmp r3,#0
 963 0244 01D0     	 beq .L46
 584:../SSC/Src/ecatslv.c ****         {
 585:../SSC/Src/ecatslv.c ****             result = ALSTATUSCODE_INVALIDSMINCFG;
 964              	 .loc 3 585 0
 965 0246 1E23     	 movs r3,#30
 966 0248 BB75     	 strb r3,[r7,#22]
 967              	.L46:
 586:../SSC/Src/ecatslv.c ****         }
 587:../SSC/Src/ecatslv.c ****     }
 588:../SSC/Src/ecatslv.c **** 
 589:../SSC/Src/ecatslv.c **** 
 590:../SSC/Src/ecatslv.c **** //    else
 591:../SSC/Src/ecatslv.c ****     if (result == 0 && maxChannel > PROCESS_DATA_OUT)
 968              	 .loc 3 591 0
 969 024a BB7D     	 ldrb r3,[r7,#22]
 970 024c 002B     	 cmp r3,#0
 971 024e 40F08A80 	 bne .L60
 972              	 .loc 3 591 0 is_stmt 0 discriminator 1
 973 0252 FB79     	 ldrb r3,[r7,#7]
 974 0254 022B     	 cmp r3,#2
 975 0256 40F28680 	 bls .L60
 592:../SSC/Src/ecatslv.c ****     {
 593:../SSC/Src/ecatslv.c ****         /* check the Sync Manager Parameter for the Outputs (Sync Manager Channel 2) */
 594:../SSC/Src/ecatslv.c ****         pSyncMan = GetSyncMan(PROCESS_DATA_OUT);
 976              	 .loc 3 594 0 is_stmt 1
 977 025a 0220     	 movs r0,#2
 978 025c FFF7FEFF 	 bl GetSyncMan
 979 0260 F860     	 str r0,[r7,#12]
 595:../SSC/Src/ecatslv.c **** 
 596:../SSC/Src/ecatslv.c ****     SMLength = pSyncMan->Length;
 980              	 .loc 3 596 0
 981 0262 FB68     	 ldr r3,[r7,#12]
 982 0264 9A78     	 ldrb r2,[r3,#2]
 983 0266 DB78     	 ldrb r3,[r3,#3]
 984 0268 1B02     	 lsls r3,r3,#8
 985 026a 1343     	 orrs r3,r3,r2
 986 026c BB82     	 strh r3,[r7,#20]
 597:../SSC/Src/ecatslv.c ****     SMAddress = pSyncMan->PhysicalStartAddress;
 987              	 .loc 3 597 0
 988 026e FB68     	 ldr r3,[r7,#12]
 989 0270 1A78     	 ldrb r2,[r3]
 990 0272 5B78     	 ldrb r3,[r3,#1]
 991 0274 1B02     	 lsls r3,r3,#8
 992 0276 1343     	 orrs r3,r3,r2
 993 0278 7B82     	 strh r3,[r7,#18]
 598:../SSC/Src/ecatslv.c **** 
 599:../SSC/Src/ecatslv.c **** 
 600:../SSC/Src/ecatslv.c **** 
 601:../SSC/Src/ecatslv.c ****     if ((pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE) != 0 && SMLength
 994              	 .loc 3 601 0
 995 027a FB68     	 ldr r3,[r7,#12]
 996 027c 9B79     	 ldrb r3,[r3,#6]
 997 027e 03F00103 	 and r3,r3,#1
 998 0282 002B     	 cmp r3,#0
 999 0284 10D0     	 beq .L61
 1000              	 .loc 3 601 0 is_stmt 0 discriminator 1
 1001 0286 BB8A     	 ldrh r3,[r7,#20]
 1002 0288 002B     	 cmp r3,#0
 1003 028a 0DD1     	 bne .L61
 602:../SSC/Src/ecatslv.c ****     {
 603:../SSC/Src/ecatslv.c ****         /* the SM2 size is 0 and the SM2 is active */
 604:../SSC/Src/ecatslv.c ****         result = SYNCMANCHSETTINGS + 1;
 1004              	 .loc 3 604 0 is_stmt 1
 1005 028c 0323     	 movs r3,#3
 1006 028e BB75     	 strb r3,[r7,#22]
 1007 0290 64E0     	 b .L62
 1008              	.L80:
 1009 0292 00BF     	 .align 2
 1010              	.L79:
 1011 0294 00000000 	 .word nMaxEscAddress
 1012 0298 00000000 	 .word b3BufferMode
 1013 029c 00000000 	 .word nPdInputSize
 1014 02a0 00000000 	 .word nAlStatus
 1015 02a4 00000000 	 .word nEscAddrInputData
 1016              	.L61:
 605:../SSC/Src/ecatslv.c ****     }
 606:../SSC/Src/ecatslv.c ****         else if (pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE)
 1017              	 .loc 3 606 0
 1018 02a8 FB68     	 ldr r3,[r7,#12]
 1019 02aa 9B79     	 ldrb r3,[r3,#6]
 1020 02ac 03F00103 	 and r3,r3,#1
 1021 02b0 002B     	 cmp r3,#0
 1022 02b2 4AD0     	 beq .L63
 607:../SSC/Src/ecatslv.c ****         {
 608:../SSC/Src/ecatslv.c ****             /* Sync Manager Channel 2 is active, output size has to greater 0 */
 609:../SSC/Src/ecatslv.c ****             if ( SMLength == nPdOutputSize && nPdOutputSize != 0 && SMLength <= ((UINT16)MAX_PD_OUT
 1023              	 .loc 3 609 0
 1024 02b4 3A4B     	 ldr r3,.L81
 1025 02b6 1B88     	 ldrh r3,[r3]
 1026 02b8 BA8A     	 ldrh r2,[r7,#20]
 1027 02ba 9A42     	 cmp r2,r3
 1028 02bc 41D1     	 bne .L64
 1029              	 .loc 3 609 0 is_stmt 0 discriminator 1
 1030 02be 384B     	 ldr r3,.L81
 1031 02c0 1B88     	 ldrh r3,[r3]
 1032 02c2 002B     	 cmp r3,#0
 1033 02c4 3DD0     	 beq .L64
 1034              	 .loc 3 609 0 discriminator 2
 1035 02c6 BB8A     	 ldrh r3,[r7,#20]
 1036 02c8 9C2B     	 cmp r3,#156
 1037 02ca 3AD8     	 bhi .L64
 610:../SSC/Src/ecatslv.c ****             {
 611:../SSC/Src/ecatslv.c ****                 /* sizes match */
 612:../SSC/Src/ecatslv.c ****                 if ( (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) ==
 1038              	 .loc 3 612 0 is_stmt 1
 1039 02cc FB68     	 ldr r3,[r7,#12]
 1040 02ce 1B79     	 ldrb r3,[r3,#4]
 1041 02d0 03F00C03 	 and r3,r3,#12
 1042 02d4 042B     	 cmp r3,#4
 1043 02d6 30D1     	 bne .L65
 613:../SSC/Src/ecatslv.c ****                 {
 614:../SSC/Src/ecatslv.c ****                     /* settings match */
 615:../SSC/Src/ecatslv.c ****                     if ( ( ( nAlStatus == STATE_PREOP )&&( SMAddress >= MIN_PD_WRITE_ADDRESS )&&( S
 1044              	 .loc 3 615 0
 1045 02d8 324B     	 ldr r3,.L81+4
 1046 02da 1B78     	 ldrb r3,[r3]
 1047 02dc 022B     	 cmp r3,#2
 1048 02de 07D1     	 bne .L66
 1049              	 .loc 3 615 0 is_stmt 0 discriminator 1
 1050 02e0 7B8A     	 ldrh r3,[r7,#18]
 1051 02e2 B3F5805F 	 cmp r3,#4096
 1052 02e6 03D3     	 bcc .L66
 1053              	 .loc 3 615 0 discriminator 2
 1054 02e8 7B8A     	 ldrh r3,[r7,#18]
 1055 02ea B3F5405F 	 cmp r3,#12288
 1056 02ee 08D3     	 bcc .L67
 1057              	.L66:
 616:../SSC/Src/ecatslv.c ****                        ||( ( nAlStatus != STATE_PREOP )&&( SMAddress == nEscAddrOutputData ) )
 1058              	 .loc 3 616 0 is_stmt 1
 1059 02f0 2C4B     	 ldr r3,.L81+4
 1060 02f2 1B78     	 ldrb r3,[r3]
 1061 02f4 022B     	 cmp r3,#2
 1062 02f6 1CD0     	 beq .L68
 1063              	 .loc 3 616 0 is_stmt 0 discriminator 1
 1064 02f8 2B4B     	 ldr r3,.L81+8
 1065 02fa 1B88     	 ldrh r3,[r3]
 1066 02fc 7A8A     	 ldrh r2,[r7,#18]
 1067 02fe 9A42     	 cmp r2,r3
 1068 0300 17D1     	 bne .L68
 1069              	.L67:
 617:../SSC/Src/ecatslv.c ****                         )
 618:../SSC/Src/ecatslv.c ****                     {
 619:../SSC/Src/ecatslv.c ****                         /* addresses match */
 620:../SSC/Src/ecatslv.c ****                         {
 621:../SSC/Src/ecatslv.c ****                             /* check, if watchdog trigger is enabled */
 622:../SSC/Src/ecatslv.c ****                             if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_WATCHDOG
 1070              	 .loc 3 622 0 is_stmt 1
 1071 0302 FB68     	 ldr r3,[r7,#12]
 1072 0304 1B79     	 ldrb r3,[r3,#4]
 1073 0306 03F04003 	 and r3,r3,#64
 1074 030a 002B     	 cmp r3,#0
 1075 030c 03D0     	 beq .L69
 623:../SSC/Src/ecatslv.c ****                             {
 624:../SSC/Src/ecatslv.c ****                                 bWdTrigger = TRUE;
 1076              	 .loc 3 624 0
 1077 030e 274B     	 ldr r3,.L81+12
 1078 0310 0122     	 movs r2,#1
 1079 0312 1A70     	 strb r2,[r3]
 1080 0314 02E0     	 b .L70
 1081              	.L69:
 625:../SSC/Src/ecatslv.c ****                             }
 626:../SSC/Src/ecatslv.c ****                             else
 627:../SSC/Src/ecatslv.c ****                             {
 628:../SSC/Src/ecatslv.c ****                                 bWdTrigger = FALSE;
 1082              	 .loc 3 628 0
 1083 0316 254B     	 ldr r3,.L81+12
 1084 0318 0022     	 movs r2,#0
 1085 031a 1A70     	 strb r2,[r3]
 1086              	.L70:
 629:../SSC/Src/ecatslv.c ****                             }
 630:../SSC/Src/ecatslv.c **** 
 631:../SSC/Src/ecatslv.c ****                             if ((pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MA
 1087              	 .loc 3 631 0
 1088 031c FB68     	 ldr r3,[r7,#12]
 1089 031e 1B79     	 ldrb r3,[r3,#4]
 1090 0320 03F00203 	 and r3,r3,#2
 1091 0324 002B     	 cmp r3,#0
 1092 0326 03D0     	 beq .L71
 632:../SSC/Src/ecatslv.c ****                             {
 633:../SSC/Src/ecatslv.c ****                                 /* outputs are running in 1-Buffer-Mode, reset flag b3BufferMode */
 634:../SSC/Src/ecatslv.c ****                                 b3BufferMode = FALSE;
 1093              	 .loc 3 634 0
 1094 0328 214B     	 ldr r3,.L81+16
 1095 032a 0022     	 movs r2,#0
 1096 032c 1A70     	 strb r2,[r3]
 631:../SSC/Src/ecatslv.c ****                             {
 1097              	 .loc 3 631 0
 1098 032e 03E0     	 b .L72
 1099              	.L71:
 1100 0330 02E0     	 b .L72
 1101              	.L68:
 635:../SSC/Src/ecatslv.c ****                                 }
 636:../SSC/Src/ecatslv.c ****                         }
 637:../SSC/Src/ecatslv.c ****                     }
 638:../SSC/Src/ecatslv.c ****                     else
 639:../SSC/Src/ecatslv.c ****                     {
 640:../SSC/Src/ecatslv.c ****                         /* output address is out of the allowed area or has changed in SAFEOP or OP
 641:../SSC/Src/ecatslv.c ****                         result = SYNCMANCHADDRESS + 1;
 1102              	 .loc 3 641 0
 1103 0332 0223     	 movs r3,#2
 1104 0334 BB75     	 strb r3,[r7,#22]
 1105 0336 03E0     	 b .L73
 1106              	.L72:
 1107 0338 02E0     	 b .L73
 1108              	.L65:
 642:../SSC/Src/ecatslv.c ****                     }
 643:../SSC/Src/ecatslv.c ****                 }
 644:../SSC/Src/ecatslv.c ****                 else
 645:../SSC/Src/ecatslv.c ****                 {
 646:../SSC/Src/ecatslv.c ****                     /* output settings do not match */
 647:../SSC/Src/ecatslv.c ****                     result = SYNCMANCHSETTINGS + 1;
 1109              	 .loc 3 647 0
 1110 033a 0323     	 movs r3,#3
 1111 033c BB75     	 strb r3,[r7,#22]
 612:../SSC/Src/ecatslv.c ****                 {
 1112              	 .loc 3 612 0
 1113 033e 03E0     	 b .L74
 1114              	.L73:
 612:../SSC/Src/ecatslv.c ****                 {
 1115              	 .loc 3 612 0 is_stmt 0 discriminator 4
 1116 0340 02E0     	 b .L74
 1117              	.L64:
 648:../SSC/Src/ecatslv.c ****                 }
 649:../SSC/Src/ecatslv.c ****             }
 650:../SSC/Src/ecatslv.c ****             else
 651:../SSC/Src/ecatslv.c ****             {
 652:../SSC/Src/ecatslv.c ****                 /* output sizes don't match */
 653:../SSC/Src/ecatslv.c ****                 result = SYNCMANCHSIZE + 1;
 1118              	 .loc 3 653 0 is_stmt 1
 1119 0342 0123     	 movs r3,#1
 1120 0344 BB75     	 strb r3,[r7,#22]
 1121 0346 09E0     	 b .L62
 1122              	.L74:
 1123 0348 08E0     	 b .L62
 1124              	.L63:
 654:../SSC/Src/ecatslv.c ****             }
 655:../SSC/Src/ecatslv.c ****         }
 656:../SSC/Src/ecatslv.c ****         else if (SMLength != 0 || nPdOutputSize != 0)
 1125              	 .loc 3 656 0
 1126 034a BB8A     	 ldrh r3,[r7,#20]
 1127 034c 002B     	 cmp r3,#0
 1128 034e 03D1     	 bne .L75
 1129              	 .loc 3 656 0 is_stmt 0 discriminator 1
 1130 0350 134B     	 ldr r3,.L81
 1131 0352 1B88     	 ldrh r3,[r3]
 1132 0354 002B     	 cmp r3,#0
 1133 0356 01D0     	 beq .L62
 1134              	.L75:
 657:../SSC/Src/ecatslv.c ****         {
 658:../SSC/Src/ecatslv.c ****             /* output size is not zero although the SM2 channel is not enabled */
 659:../SSC/Src/ecatslv.c ****             result = SYNCMANCHSIZE + 1;
 1135              	 .loc 3 659 0 is_stmt 1
 1136 0358 0123     	 movs r3,#1
 1137 035a BB75     	 strb r3,[r7,#22]
 1138              	.L62:
 660:../SSC/Src/ecatslv.c ****         }
 661:../SSC/Src/ecatslv.c **** 
 662:../SSC/Src/ecatslv.c ****         if ( result != 0 )
 1139              	 .loc 3 662 0
 1140 035c BB7D     	 ldrb r3,[r7,#22]
 1141 035e 002B     	 cmp r3,#0
 1142 0360 01D0     	 beq .L60
 663:../SSC/Src/ecatslv.c ****         {
 664:../SSC/Src/ecatslv.c ****             result = ALSTATUSCODE_INVALIDSMOUTCFG;
 1143              	 .loc 3 664 0
 1144 0362 1D23     	 movs r3,#29
 1145 0364 BB75     	 strb r3,[r7,#22]
 1146              	.L60:
 665:../SSC/Src/ecatslv.c ****         }
 666:../SSC/Src/ecatslv.c ****     }
 667:../SSC/Src/ecatslv.c **** 
 668:../SSC/Src/ecatslv.c **** 
 669:../SSC/Src/ecatslv.c ****     if ( result == 0 )
 1147              	 .loc 3 669 0
 1148 0366 BB7D     	 ldrb r3,[r7,#22]
 1149 0368 002B     	 cmp r3,#0
 1150 036a 13D1     	 bne .L76
 670:../SSC/Src/ecatslv.c ****     {
 671:../SSC/Src/ecatslv.c ****         /* the Enable-Byte of the rest of the SM channels has to be read to acknowledge the SM-Chan
 672:../SSC/Src/ecatslv.c ****         for (i = maxChannel; i < nMaxSyncMan; i++)
 1151              	 .loc 3 672 0
 1152 036c FB79     	 ldrb r3,[r7,#7]
 1153 036e FB75     	 strb r3,[r7,#23]
 1154 0370 0BE0     	 b .L77
 1155              	.L78:
 673:../SSC/Src/ecatslv.c ****         {
 674:../SSC/Src/ecatslv.c ****             pSyncMan = GetSyncMan(i);
 1156              	 .loc 3 674 0 discriminator 3
 1157 0372 FB7D     	 ldrb r3,[r7,#23]
 1158 0374 1846     	 mov r0,r3
 1159 0376 FFF7FEFF 	 bl GetSyncMan
 1160 037a F860     	 str r0,[r7,#12]
 675:../SSC/Src/ecatslv.c ****             SMActivate = pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET];
 1161              	 .loc 3 675 0 discriminator 3
 1162 037c FB68     	 ldr r3,[r7,#12]
 1163 037e 9A79     	 ldrb r2,[r3,#6]
 1164 0380 0C4B     	 ldr r3,.L81+20
 1165 0382 1A70     	 strb r2,[r3]
 672:../SSC/Src/ecatslv.c ****         {
 1166              	 .loc 3 672 0 discriminator 3
 1167 0384 FB7D     	 ldrb r3,[r7,#23]
 1168 0386 0133     	 adds r3,r3,#1
 1169 0388 FB75     	 strb r3,[r7,#23]
 1170              	.L77:
 672:../SSC/Src/ecatslv.c ****         {
 1171              	 .loc 3 672 0 is_stmt 0 discriminator 1
 1172 038a 0B4B     	 ldr r3,.L81+24
 1173 038c 1B78     	 ldrb r3,[r3]
 1174 038e FA7D     	 ldrb r2,[r7,#23]
 1175 0390 9A42     	 cmp r2,r3
 1176 0392 EED3     	 bcc .L78
 1177              	.L76:
 676:../SSC/Src/ecatslv.c ****         }
 677:../SSC/Src/ecatslv.c ****     }
 678:../SSC/Src/ecatslv.c ****     return result;
 1178              	 .loc 3 678 0 is_stmt 1
 1179 0394 BB7D     	 ldrb r3,[r7,#22]
 1180              	.L31:
 679:../SSC/Src/ecatslv.c **** }
 1181              	 .loc 3 679 0
 1182 0396 1846     	 mov r0,r3
 1183 0398 1837     	 adds r7,r7,#24
 1184              	.LCFI47:
 1185              	 .cfi_def_cfa_offset 8
 1186 039a BD46     	 mov sp,r7
 1187              	.LCFI48:
 1188              	 .cfi_def_cfa_register 13
 1189              	 
 1190 039c 80BD     	 pop {r7,pc}
 1191              	.L82:
 1192 039e 00BF     	 .align 2
 1193              	.L81:
 1194 03a0 00000000 	 .word nPdOutputSize
 1195 03a4 00000000 	 .word nAlStatus
 1196 03a8 00000000 	 .word nEscAddrOutputData
 1197 03ac 00000000 	 .word bWdTrigger
 1198 03b0 00000000 	 .word b3BufferMode
 1199 03b4 00000000 	 .word SMActivate
 1200 03b8 00000000 	 .word nMaxSyncMan
 1201              	 .cfi_endproc
 1202              	.LFE181:
 1204              	 .section .text.StartInputHandler,"ax",%progbits
 1205              	 .align 2
 1206              	 .global StartInputHandler
 1207              	 .thumb
 1208              	 .thumb_func
 1210              	StartInputHandler:
 1211              	.LFB182:
 680:../SSC/Src/ecatslv.c **** 
 681:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 682:../SSC/Src/ecatslv.c **** /**
 683:../SSC/Src/ecatslv.c ****  \return    AL Status Code (see ecatslv.h ALSTATUSCODE_....)
 684:../SSC/Src/ecatslv.c **** 
 685:../SSC/Src/ecatslv.c ****  \brief    This function is called in case of the state transition from PREOP to SAFEOP.
 686:../SSC/Src/ecatslv.c ****  |brief  the areas of the Sync Managers will be checked for overlapping,
 687:../SSC/Src/ecatslv.c ****  \brief  the synchronization mode (Free Run, Synchron, Distributed Clocks) is selected,
 688:../SSC/Src/ecatslv.c ****  \brief  the requested cycle time will be checked, the watchdog is started
 689:../SSC/Src/ecatslv.c ****  \brief  and the AL Event Mask register will be set
 690:../SSC/Src/ecatslv.c **** 
 691:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 692:../SSC/Src/ecatslv.c **** 
 693:../SSC/Src/ecatslv.c **** UINT16 StartInputHandler(void)
 694:../SSC/Src/ecatslv.c **** {
 1212              	 .loc 3 694 0
 1213              	 .cfi_startproc
 1214              	 
 1215              	 
 1216 0000 80B5     	 push {r7,lr}
 1217              	.LCFI49:
 1218              	 .cfi_def_cfa_offset 8
 1219              	 .cfi_offset 7,-8
 1220              	 .cfi_offset 14,-4
 1221 0002 90B0     	 sub sp,sp,#64
 1222              	.LCFI50:
 1223              	 .cfi_def_cfa_offset 72
 1224 0004 00AF     	 add r7,sp,#0
 1225              	.LCFI51:
 1226              	 .cfi_def_cfa_register 7
 695:../SSC/Src/ecatslv.c ****     TSYNCMAN ESCMEM * pSyncMan;
 696:../SSC/Src/ecatslv.c **** 
 697:../SSC/Src/ecatslv.c ****     UINT8        dcControl;
 698:../SSC/Src/ecatslv.c **** 
 699:../SSC/Src/ecatslv.c ****     UINT16     wdiv = 0;
 1227              	 .loc 3 699 0
 1228 0006 0023     	 movs r3,#0
 1229 0008 BB86     	 strh r3,[r7,#52]
 700:../SSC/Src/ecatslv.c ****     UINT16     wd = 0;
 1230              	 .loc 3 700 0
 1231 000a 0023     	 movs r3,#0
 1232 000c 7B86     	 strh r3,[r7,#50]
 701:../SSC/Src/ecatslv.c ****     UINT32     cycleTimeSync0 = 0; /* Sync0 cycle time */
 1233              	 .loc 3 701 0
 1234 000e 0023     	 movs r3,#0
 1235 0010 FB62     	 str r3,[r7,#44]
 702:../SSC/Src/ecatslv.c ****     UINT32     shiftTimeSync1 = 0; /* Delay between the Sync0 and Sycn1 signal. A new Sync1 cycle s
 1236              	 .loc 3 702 0
 1237 0012 0023     	 movs r3,#0
 1238 0014 BB62     	 str r3,[r7,#40]
 703:../SSC/Src/ecatslv.c ****     BOOL bSubordinatedCycles = FALSE;
 1239              	 .loc 3 703 0
 1240 0016 0023     	 movs r3,#0
 1241 0018 87F83F30 	 strb r3,[r7,#63]
 704:../SSC/Src/ecatslv.c **** 
 705:../SSC/Src/ecatslv.c ****     UINT16    nPdInputBuffer = 3;
 1242              	 .loc 3 705 0
 1243 001c 0323     	 movs r3,#3
 1244 001e BB87     	 strh r3,[r7,#60]
 706:../SSC/Src/ecatslv.c **** 
 707:../SSC/Src/ecatslv.c ****     UINT16    nPdOutputBuffer = 3;
 1245              	 .loc 3 707 0
 1246 0020 0323     	 movs r3,#3
 1247 0022 7B87     	 strh r3,[r7,#58]
 708:../SSC/Src/ecatslv.c **** 
 709:../SSC/Src/ecatslv.c ****     UINT16 SyncType0x1C32 = 0; /* Helper variable for sync type for SM2 (required if no CoE is supp
 1248              	 .loc 3 709 0
 1249 0024 0023     	 movs r3,#0
 1250 0026 3B87     	 strh r3,[r7,#56]
 710:../SSC/Src/ecatslv.c ****     UINT16 SyncType0x1C33 = 0; /* Helper variable for sync type for SM3 (required if no CoE is supp
 1251              	 .loc 3 710 0
 1252 0028 0023     	 movs r3,#0
 1253 002a FB86     	 strh r3,[r7,#54]
 711:../SSC/Src/ecatslv.c **** 
 712:../SSC/Src/ecatslv.c ****     UINT16 u16MinSuppSyncType = 0xFFFF;  /* Minimum supported Sync Types */
 1254              	 .loc 3 712 0
 1255 002c 4FF6FF73 	 movw r3,#65535
 1256 0030 FB84     	 strh r3,[r7,#38]
 713:../SSC/Src/ecatslv.c **** 
 714:../SSC/Src/ecatslv.c ****     u16MinSuppSyncType &= sSyncManOutPar.u16SyncTypesSupported;
 1257              	 .loc 3 714 0
 1258 0032 9E4B     	 ldr r3,.L159
 1259 0034 9A89     	 ldrh r2,[r3,#12]
 1260 0036 FB8C     	 ldrh r3,[r7,#38]
 1261 0038 1340     	 ands r3,r3,r2
 1262 003a FB84     	 strh r3,[r7,#38]
 715:../SSC/Src/ecatslv.c ****     u16MinSuppSyncType &= sSyncManInPar.u16SyncTypesSupported;
 1263              	 .loc 3 715 0
 1264 003c 9C4B     	 ldr r3,.L159+4
 1265 003e 9A89     	 ldrh r2,[r3,#12]
 1266 0040 FB8C     	 ldrh r3,[r7,#38]
 1267 0042 1340     	 ands r3,r3,r2
 1268 0044 FB84     	 strh r3,[r7,#38]
 716:../SSC/Src/ecatslv.c **** 
 717:../SSC/Src/ecatslv.c ****     u16ALEventMask = 0;
 1269              	 .loc 3 717 0
 1270 0046 9B4B     	 ldr r3,.L159+8
 1271 0048 0022     	 movs r2,#0
 1272 004a 1A80     	 strh r2,[r3]
 718:../SSC/Src/ecatslv.c **** 
 719:../SSC/Src/ecatslv.c **** 
 720:../SSC/Src/ecatslv.c ****     /* 
 721:../SSC/Src/ecatslv.c ****         --- Check if SyncManager areas overlapping --- 
 722:../SSC/Src/ecatslv.c ****     */
 723:../SSC/Src/ecatslv.c ****     bEcatFirstOutputsReceived = FALSE;
 1273              	 .loc 3 723 0
 1274 004c 9A4B     	 ldr r3,.L159+12
 1275 004e 0022     	 movs r2,#0
 1276 0050 1A70     	 strb r2,[r3]
 724:../SSC/Src/ecatslv.c **** 
 725:../SSC/Src/ecatslv.c ****     /* get a pointer to the Sync Manager Channel 2 (Outputs) */
 726:../SSC/Src/ecatslv.c ****     pSyncMan = GetSyncMan(PROCESS_DATA_OUT);
 1277              	 .loc 3 726 0
 1278 0052 0220     	 movs r0,#2
 1279 0054 FFF7FEFF 	 bl GetSyncMan
 1280 0058 3862     	 str r0,[r7,#32]
 727:../SSC/Src/ecatslv.c ****     /* store the address of the Sync Manager Channel 2 (Outputs) */
 728:../SSC/Src/ecatslv.c ****     nEscAddrOutputData = pSyncMan->PhysicalStartAddress;
 1281              	 .loc 3 728 0
 1282 005a 3B6A     	 ldr r3,[r7,#32]
 1283 005c 1B88     	 ldrh r3,[r3]
 1284 005e 9AB2     	 uxth r2,r3
 1285 0060 964B     	 ldr r3,.L159+16
 1286 0062 1A80     	 strh r2,[r3]
 729:../SSC/Src/ecatslv.c ****     /* get the number of output buffer used for calculating the address areas */
 730:../SSC/Src/ecatslv.c ****     if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_ONE_BUFFER_VALUE)
 1287              	 .loc 3 730 0
 1288 0064 3B6A     	 ldr r3,[r7,#32]
 1289 0066 1B79     	 ldrb r3,[r3,#4]
 1290 0068 03F00203 	 and r3,r3,#2
 1291 006c 002B     	 cmp r3,#0
 1292 006e 01D0     	 beq .L84
 731:../SSC/Src/ecatslv.c ****     {
 732:../SSC/Src/ecatslv.c ****        nPdOutputBuffer = 1;
 1293              	 .loc 3 732 0
 1294 0070 0123     	 movs r3,#1
 1295 0072 7B87     	 strh r3,[r7,#58]
 1296              	.L84:
 733:../SSC/Src/ecatslv.c ****     }
 734:../SSC/Src/ecatslv.c **** 
 735:../SSC/Src/ecatslv.c **** 
 736:../SSC/Src/ecatslv.c ****     /* get a pointer to the Sync Manager Channel 3 (Inputs) */
 737:../SSC/Src/ecatslv.c ****     pSyncMan = GetSyncMan(PROCESS_DATA_IN);
 1297              	 .loc 3 737 0
 1298 0074 0320     	 movs r0,#3
 1299 0076 FFF7FEFF 	 bl GetSyncMan
 1300 007a 3862     	 str r0,[r7,#32]
 738:../SSC/Src/ecatslv.c ****     /* store the address of the Sync Manager Channel 3 (Inputs)*/
 739:../SSC/Src/ecatslv.c ****     nEscAddrInputData = pSyncMan->PhysicalStartAddress;
 1301              	 .loc 3 739 0
 1302 007c 3B6A     	 ldr r3,[r7,#32]
 1303 007e 1B88     	 ldrh r3,[r3]
 1304 0080 9AB2     	 uxth r2,r3
 1305 0082 8F4B     	 ldr r3,.L159+20
 1306 0084 1A80     	 strh r2,[r3]
 740:../SSC/Src/ecatslv.c **** 
 741:../SSC/Src/ecatslv.c **** 
 742:../SSC/Src/ecatslv.c ****     /* get the number of input buffer used for calculating the address areas */
 743:../SSC/Src/ecatslv.c ****     if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_ONE_BUFFER_VALUE)
 1307              	 .loc 3 743 0
 1308 0086 3B6A     	 ldr r3,[r7,#32]
 1309 0088 1B79     	 ldrb r3,[r3,#4]
 1310 008a 03F00203 	 and r3,r3,#2
 1311 008e 002B     	 cmp r3,#0
 1312 0090 01D0     	 beq .L85
 744:../SSC/Src/ecatslv.c ****     {
 745:../SSC/Src/ecatslv.c ****         nPdInputBuffer = 1;
 1313              	 .loc 3 745 0
 1314 0092 0123     	 movs r3,#1
 1315 0094 BB87     	 strh r3,[r7,#60]
 1316              	.L85:
 746:../SSC/Src/ecatslv.c ****     }
 747:../SSC/Src/ecatslv.c ****     /* it has be checked if the Sync Manager memory areas for Inputs and Outputs will not overlap
 748:../SSC/Src/ecatslv.c ****        the Sync Manager memory areas for the Mailbox */
 749:../SSC/Src/ecatslv.c **** 
 750:../SSC/Src/ecatslv.c ****     if (((nEscAddrInputData + nPdInputSize * nPdInputBuffer) > u16EscAddrSendMbx && (nEscAddrInputD
 1317              	 .loc 3 750 0
 1318 0096 8A4B     	 ldr r3,.L159+20
 1319 0098 1B88     	 ldrh r3,[r3]
 1320 009a 1A46     	 mov r2,r3
 1321 009c 894B     	 ldr r3,.L159+24
 1322 009e 1B88     	 ldrh r3,[r3]
 1323 00a0 1946     	 mov r1,r3
 1324 00a2 BB8F     	 ldrh r3,[r7,#60]
 1325 00a4 03FB01F3 	 mul r3,r3,r1
 1326 00a8 1344     	 add r3,r3,r2
 1327 00aa 874A     	 ldr r2,.L159+28
 1328 00ac 1288     	 ldrh r2,[r2]
 1329 00ae 9342     	 cmp r3,r2
 1330 00b0 0ADD     	 ble .L86
 1331              	 .loc 3 750 0 is_stmt 0 discriminator 1
 1332 00b2 834B     	 ldr r3,.L159+20
 1333 00b4 1B88     	 ldrh r3,[r3]
 1334 00b6 1A46     	 mov r2,r3
 1335 00b8 834B     	 ldr r3,.L159+28
 1336 00ba 1B88     	 ldrh r3,[r3]
 1337 00bc 1946     	 mov r1,r3
 1338 00be 834B     	 ldr r3,.L159+32
 1339 00c0 1B88     	 ldrh r3,[r3]
 1340 00c2 0B44     	 add r3,r3,r1
 1341 00c4 9A42     	 cmp r2,r3
 1342 00c6 18DB     	 blt .L87
 1343              	.L86:
 751:../SSC/Src/ecatslv.c ****        || ((nEscAddrInputData + nPdInputSize * nPdInputBuffer) > u16EscAddrReceiveMbx && (nEscAddrI
 1344              	 .loc 3 751 0 is_stmt 1
 1345 00c8 7D4B     	 ldr r3,.L159+20
 1346 00ca 1B88     	 ldrh r3,[r3]
 1347 00cc 1A46     	 mov r2,r3
 1348 00ce 7D4B     	 ldr r3,.L159+24
 1349 00d0 1B88     	 ldrh r3,[r3]
 1350 00d2 1946     	 mov r1,r3
 1351 00d4 BB8F     	 ldrh r3,[r7,#60]
 1352 00d6 03FB01F3 	 mul r3,r3,r1
 1353 00da 1344     	 add r3,r3,r2
 1354 00dc 7C4A     	 ldr r2,.L159+36
 1355 00de 1288     	 ldrh r2,[r2]
 1356 00e0 9342     	 cmp r3,r2
 1357 00e2 0CDD     	 ble .L88
 1358              	 .loc 3 751 0 is_stmt 0 discriminator 1
 1359 00e4 764B     	 ldr r3,.L159+20
 1360 00e6 1B88     	 ldrh r3,[r3]
 1361 00e8 1A46     	 mov r2,r3
 1362 00ea 794B     	 ldr r3,.L159+36
 1363 00ec 1B88     	 ldrh r3,[r3]
 1364 00ee 1946     	 mov r1,r3
 1365 00f0 784B     	 ldr r3,.L159+40
 1366 00f2 1B88     	 ldrh r3,[r3]
 1367 00f4 0B44     	 add r3,r3,r1
 1368 00f6 9A42     	 cmp r2,r3
 1369 00f8 01DA     	 bge .L88
 1370              	.L87:
 752:../SSC/Src/ecatslv.c ****         )
 753:../SSC/Src/ecatslv.c ****     {
 754:../SSC/Src/ecatslv.c ****         return ALSTATUSCODE_INVALIDSMINCFG;
 1371              	 .loc 3 754 0 is_stmt 1
 1372 00fa 1E23     	 movs r3,#30
 1373 00fc 42E3     	 b .L89
 1374              	.L88:
 755:../SSC/Src/ecatslv.c ****     }
 756:../SSC/Src/ecatslv.c **** 
 757:../SSC/Src/ecatslv.c ****     if (
 758:../SSC/Src/ecatslv.c ****         ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrSendMbx && (nEscAddrOut
 1375              	 .loc 3 758 0
 1376 00fe 6F4B     	 ldr r3,.L159+16
 1377 0100 1B88     	 ldrh r3,[r3]
 1378 0102 1A46     	 mov r2,r3
 1379 0104 744B     	 ldr r3,.L159+44
 1380 0106 1B88     	 ldrh r3,[r3]
 1381 0108 1946     	 mov r1,r3
 1382 010a 7B8F     	 ldrh r3,[r7,#58]
 1383 010c 03FB01F3 	 mul r3,r3,r1
 1384 0110 1344     	 add r3,r3,r2
 1385 0112 6D4A     	 ldr r2,.L159+28
 1386 0114 1288     	 ldrh r2,[r2]
 757:../SSC/Src/ecatslv.c ****         ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrSendMbx && (nEscAddrOut
 1387              	 .loc 3 757 0
 1388 0116 9342     	 cmp r3,r2
 1389 0118 0ADD     	 ble .L90
 1390              	 .loc 3 758 0
 1391 011a 684B     	 ldr r3,.L159+16
 1392 011c 1B88     	 ldrh r3,[r3]
 1393 011e 1A46     	 mov r2,r3
 1394 0120 694B     	 ldr r3,.L159+28
 1395 0122 1B88     	 ldrh r3,[r3]
 1396 0124 1946     	 mov r1,r3
 1397 0126 694B     	 ldr r3,.L159+32
 1398 0128 1B88     	 ldrh r3,[r3]
 1399 012a 0B44     	 add r3,r3,r1
 1400 012c 9A42     	 cmp r2,r3
 1401 012e 31DB     	 blt .L91
 1402              	.L90:
 759:../SSC/Src/ecatslv.c ****         ||((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrReceiveMbx && (nEscAd
 1403              	 .loc 3 759 0
 1404 0130 624B     	 ldr r3,.L159+16
 1405 0132 1B88     	 ldrh r3,[r3]
 1406 0134 1A46     	 mov r2,r3
 1407 0136 684B     	 ldr r3,.L159+44
 1408 0138 1B88     	 ldrh r3,[r3]
 1409 013a 1946     	 mov r1,r3
 1410 013c 7B8F     	 ldrh r3,[r7,#58]
 1411 013e 03FB01F3 	 mul r3,r3,r1
 1412 0142 1344     	 add r3,r3,r2
 1413 0144 624A     	 ldr r2,.L159+36
 1414 0146 1288     	 ldrh r2,[r2]
 1415 0148 9342     	 cmp r3,r2
 1416 014a 0ADD     	 ble .L92
 1417              	 .loc 3 759 0 is_stmt 0 discriminator 1
 1418 014c 5B4B     	 ldr r3,.L159+16
 1419 014e 1B88     	 ldrh r3,[r3]
 1420 0150 1A46     	 mov r2,r3
 1421 0152 5F4B     	 ldr r3,.L159+36
 1422 0154 1B88     	 ldrh r3,[r3]
 1423 0156 1946     	 mov r1,r3
 1424 0158 5E4B     	 ldr r3,.L159+40
 1425 015a 1B88     	 ldrh r3,[r3]
 1426 015c 0B44     	 add r3,r3,r1
 1427 015e 9A42     	 cmp r2,r3
 1428 0160 18DB     	 blt .L91
 1429              	.L92:
 760:../SSC/Src/ecatslv.c ****         ||
 761:../SSC/Src/ecatslv.c ****         ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > nEscAddrInputData && (nEscAddrOut
 1430              	 .loc 3 761 0 is_stmt 1
 1431 0162 564B     	 ldr r3,.L159+16
 1432 0164 1B88     	 ldrh r3,[r3]
 1433 0166 1A46     	 mov r2,r3
 1434 0168 5B4B     	 ldr r3,.L159+44
 1435 016a 1B88     	 ldrh r3,[r3]
 1436 016c 1946     	 mov r1,r3
 1437 016e 7B8F     	 ldrh r3,[r7,#58]
 1438 0170 03FB01F3 	 mul r3,r3,r1
 1439 0174 1344     	 add r3,r3,r2
 1440 0176 524A     	 ldr r2,.L159+20
 1441 0178 1288     	 ldrh r2,[r2]
 760:../SSC/Src/ecatslv.c ****         ||
 1442              	 .loc 3 760 0
 1443 017a 9342     	 cmp r3,r2
 1444 017c 0CDD     	 ble .L93
 1445              	 .loc 3 761 0
 1446 017e 4F4B     	 ldr r3,.L159+16
 1447 0180 1B88     	 ldrh r3,[r3]
 1448 0182 1A46     	 mov r2,r3
 1449 0184 4E4B     	 ldr r3,.L159+20
 1450 0186 1B88     	 ldrh r3,[r3]
 1451 0188 1946     	 mov r1,r3
 1452 018a 4E4B     	 ldr r3,.L159+24
 1453 018c 1B88     	 ldrh r3,[r3]
 1454 018e 0B44     	 add r3,r3,r1
 1455 0190 9A42     	 cmp r2,r3
 1456 0192 01DA     	 bge .L93
 1457              	.L91:
 762:../SSC/Src/ecatslv.c ****         )
 763:../SSC/Src/ecatslv.c ****     {
 764:../SSC/Src/ecatslv.c **** 
 765:../SSC/Src/ecatslv.c ****         /* Sync Manager Channel 2 memory area (Outputs) overlaps the Sync Manager memory areas for 
 766:../SSC/Src/ecatslv.c ****            or the Sync Manager Channel 3 memory area (Inputs) */
 767:../SSC/Src/ecatslv.c ****         return ALSTATUSCODE_INVALIDSMOUTCFG;
 1458              	 .loc 3 767 0
 1459 0194 1D23     	 movs r3,#29
 1460 0196 F5E2     	 b .L89
 1461              	.L93:
 768:../SSC/Src/ecatslv.c ****     }
 769:../SSC/Src/ecatslv.c **** 
 770:../SSC/Src/ecatslv.c ****     /* 
 771:../SSC/Src/ecatslv.c ****         --- Check configured synchronization ---
 772:../SSC/Src/ecatslv.c ****     */
 773:../SSC/Src/ecatslv.c **** 
 774:../SSC/Src/ecatslv.c ****     /* Get the DC Control/Activation register value*/
 775:../SSC/Src/ecatslv.c ****     /*Read register 0x981 (corresponding masks are adapted)*/
 776:../SSC/Src/ecatslv.c ****     HW_EscReadByte(dcControl, ESC_DC_SYNC_ACTIVATION_OFFSET);
 1462              	 .loc 3 776 0
 1463 0198 504B     	 ldr r3,.L159+48
 1464 019a 1B78     	 ldrb r3,[r3]
 1465 019c FB77     	 strb r3,[r7,#31]
 777:../SSC/Src/ecatslv.c **** 
 778:../SSC/Src/ecatslv.c ****     // Cycle time for Sync0
 779:../SSC/Src/ecatslv.c ****         HW_EscReadDWord(cycleTimeSync0, ESC_DC_SYNC0_CYCLETIME_OFFSET);
 1466              	 .loc 3 779 0
 1467 019e 504B     	 ldr r3,.L159+52
 1468 01a0 1B68     	 ldr r3,[r3]
 1469 01a2 FB62     	 str r3,[r7,#44]
 780:../SSC/Src/ecatslv.c ****         cycleTimeSync0 = SWAPDWORD(cycleTimeSync0);
 781:../SSC/Src/ecatslv.c **** 
 782:../SSC/Src/ecatslv.c ****     // Cycle time for Sync1
 783:../SSC/Src/ecatslv.c ****         HW_EscReadDWord(shiftTimeSync1, ESC_DC_SYNC1_CYCLETIME_OFFSET);
 1470              	 .loc 3 783 0
 1471 01a4 4F4B     	 ldr r3,.L159+56
 1472 01a6 1B68     	 ldr r3,[r3]
 1473 01a8 BB62     	 str r3,[r7,#40]
 784:../SSC/Src/ecatslv.c ****         shiftTimeSync1 = SWAPDWORD(shiftTimeSync1);
 785:../SSC/Src/ecatslv.c **** 
 786:../SSC/Src/ecatslv.c **** 
 787:../SSC/Src/ecatslv.c ****     SyncType0x1C32 = sSyncManOutPar.u16SyncType;
 1474              	 .loc 3 787 0
 1475 01aa 404B     	 ldr r3,.L159
 1476 01ac 5B88     	 ldrh r3,[r3,#2]
 1477 01ae 3B87     	 strh r3,[r7,#56]
 788:../SSC/Src/ecatslv.c ****     SyncType0x1C33 = sSyncManInPar.u16SyncType;
 1478              	 .loc 3 788 0
 1479 01b0 3F4B     	 ldr r3,.L159+4
 1480 01b2 5B88     	 ldrh r3,[r3,#2]
 1481 01b4 FB86     	 strh r3,[r7,#54]
 789:../SSC/Src/ecatslv.c **** 
 790:../SSC/Src/ecatslv.c **** 
 791:../SSC/Src/ecatslv.c **** 
 792:../SSC/Src/ecatslv.c ****     /* check general DC register plausibility and if configuration is supported
 793:../SSC/Src/ecatslv.c ****        - 0x981 DC Active
 794:../SSC/Src/ecatslv.c ****        - 0x9A0:0x9A3 Sync0 Cycle
 795:../SSC/Src/ecatslv.c ****        - 0x9A4:0x9A7 Sync1 Cycle
 796:../SSC/Src/ecatslv.c ****     */
 797:../SSC/Src/ecatslv.c ****     if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) != 0)
 1482              	 .loc 3 797 0
 1483 01b6 FB7F     	 ldrb r3,[r7,#31]
 1484 01b8 03F00903 	 and r3,r3,#9
 1485 01bc 002B     	 cmp r3,#0
 1486 01be 5CD0     	 beq .L94
 798:../SSC/Src/ecatslv.c ****     {
 799:../SSC/Src/ecatslv.c ****         /* DC unit is active at least one Sync signal shall be generated */
 800:../SSC/Src/ecatslv.c ****         if((dcControl & (ESC_DC_SYNC0_ACTIVE_MASK | ESC_DC_SYNC1_ACTIVE_MASK)) == 0)
 1487              	 .loc 3 800 0
 1488 01c0 FB7F     	 ldrb r3,[r7,#31]
 1489 01c2 03F00603 	 and r3,r3,#6
 1490 01c6 002B     	 cmp r3,#0
 1491 01c8 01D1     	 bne .L95
 801:../SSC/Src/ecatslv.c ****         {
 802:../SSC/Src/ecatslv.c ****             return ALSTATUSCODE_DCINVALIDSYNCCFG;
 1492              	 .loc 3 802 0
 1493 01ca 3023     	 movs r3,#48
 1494 01cc DAE2     	 b .L89
 1495              	.L95:
 803:../SSC/Src/ecatslv.c ****         }
 804:../SSC/Src/ecatslv.c **** 
 805:../SSC/Src/ecatslv.c ****         /* If Sync1 shall only be active if also Sync0 will be generated*/
 806:../SSC/Src/ecatslv.c ****         if(((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) == 0)
 1496              	 .loc 3 806 0
 1497 01ce FB7F     	 ldrb r3,[r7,#31]
 1498 01d0 03F00203 	 and r3,r3,#2
 1499 01d4 002B     	 cmp r3,#0
 1500 01d6 06D1     	 bne .L96
 807:../SSC/Src/ecatslv.c ****             && ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0))
 1501              	 .loc 3 807 0
 1502 01d8 FB7F     	 ldrb r3,[r7,#31]
 1503 01da 03F00403 	 and r3,r3,#4
 1504 01de 002B     	 cmp r3,#0
 1505 01e0 01D0     	 beq .L96
 808:../SSC/Src/ecatslv.c ****         {
 809:../SSC/Src/ecatslv.c ****             return ALSTATUSCODE_DCINVALIDSYNCCFG;
 1506              	 .loc 3 809 0
 1507 01e2 3023     	 movs r3,#48
 1508 01e4 CEE2     	 b .L89
 1509              	.L96:
 810:../SSC/Src/ecatslv.c ****         }
 811:../SSC/Src/ecatslv.c **** 
 812:../SSC/Src/ecatslv.c ****         if(u16MinSuppSyncType != 0)
 1510              	 .loc 3 812 0
 1511 01e6 FB8C     	 ldrh r3,[r7,#38]
 1512 01e8 002B     	 cmp r3,#0
 1513 01ea 15D0     	 beq .L97
 813:../SSC/Src/ecatslv.c ****         {
 814:../SSC/Src/ecatslv.c ****             if((((u16MinSuppSyncType & SYNCTYPE_DCSYNC0SUPP) == 0) && ((dcControl & ESC_DC_SYNC0_AC
 1514              	 .loc 3 814 0
 1515 01ec FB8C     	 ldrh r3,[r7,#38]
 1516 01ee 03F00403 	 and r3,r3,#4
 1517 01f2 002B     	 cmp r3,#0
 1518 01f4 04D1     	 bne .L98
 1519              	 .loc 3 814 0 is_stmt 0 discriminator 1
 1520 01f6 FB7F     	 ldrb r3,[r7,#31]
 1521 01f8 03F00203 	 and r3,r3,#2
 1522 01fc 002B     	 cmp r3,#0
 1523 01fe 09D1     	 bne .L99
 1524              	.L98:
 815:../SSC/Src/ecatslv.c ****                 ||(((u16MinSuppSyncType & SYNCTYPE_DCSYNC1SUPP) == 0) && ((dcControl & ESC_DC_SYNC1
 1525              	 .loc 3 815 0 is_stmt 1
 1526 0200 FB8C     	 ldrh r3,[r7,#38]
 1527 0202 03F00803 	 and r3,r3,#8
 1528 0206 002B     	 cmp r3,#0
 1529 0208 06D1     	 bne .L97
 1530              	 .loc 3 815 0 is_stmt 0 discriminator 1
 1531 020a FB7F     	 ldrb r3,[r7,#31]
 1532 020c 03F00403 	 and r3,r3,#4
 1533 0210 002B     	 cmp r3,#0
 1534 0212 01D0     	 beq .L97
 1535              	.L99:
 816:../SSC/Src/ecatslv.c ****             {
 817:../SSC/Src/ecatslv.c ****                 /* Sync0 is not supported but will be generated*/
 818:../SSC/Src/ecatslv.c ****                 return ALSTATUSCODE_DCINVALIDSYNCCFG;                   
 1536              	 .loc 3 818 0 is_stmt 1
 1537 0214 3023     	 movs r3,#48
 1538 0216 B5E2     	 b .L89
 1539              	.L97:
 1540              	.LBB2:
 819:../SSC/Src/ecatslv.c ****     }
 820:../SSC/Src/ecatslv.c ****         }
 821:../SSC/Src/ecatslv.c **** 
 822:../SSC/Src/ecatslv.c ****         {
 823:../SSC/Src/ecatslv.c ****             UINT32 curMinCycleTime = MIN_PD_CYCLE_TIME;
 1541              	 .loc 3 823 0
 1542 0218 334B     	 ldr r3,.L159+60
 1543 021a BB61     	 str r3,[r7,#24]
 824:../SSC/Src/ecatslv.c ****             curMinCycleTime = sSyncManOutPar.u32MinCycleTime;
 1544              	 .loc 3 824 0
 1545 021c 234B     	 ldr r3,.L159
 1546 021e 1B69     	 ldr r3,[r3,#16]
 1547 0220 BB61     	 str r3,[r7,#24]
 825:../SSC/Src/ecatslv.c **** 
 826:../SSC/Src/ecatslv.c ****             /*Check if Sync0 cycle time is supported*/
 827:../SSC/Src/ecatslv.c ****             if (cycleTimeSync0 != 0 && (cycleTimeSync0 < curMinCycleTime || cycleTimeSync0 > MAX_PD
 1548              	 .loc 3 827 0
 1549 0222 FB6A     	 ldr r3,[r7,#44]
 1550 0224 002B     	 cmp r3,#0
 1551 0226 09D0     	 beq .L100
 1552              	 .loc 3 827 0 is_stmt 0 discriminator 1
 1553 0228 FA6A     	 ldr r2,[r7,#44]
 1554 022a BB69     	 ldr r3,[r7,#24]
 1555 022c 9A42     	 cmp r2,r3
 1556 022e 03D3     	 bcc .L101
 1557              	 .loc 3 827 0 discriminator 2
 1558 0230 FB6A     	 ldr r3,[r7,#44]
 1559 0232 2E4A     	 ldr r2,.L159+64
 1560 0234 9342     	 cmp r3,r2
 1561 0236 01D9     	 bls .L100
 1562              	.L101:
 828:../SSC/Src/ecatslv.c ****             {
 829:../SSC/Src/ecatslv.c ****                     return ALSTATUSCODE_DCSYNC0CYCLETIME;
 1563              	 .loc 3 829 0 is_stmt 1
 1564 0238 3623     	 movs r3,#54
 1565 023a A3E2     	 b .L89
 1566              	.L100:
 1567              	.LBE2:
 830:../SSC/Src/ecatslv.c ****             }
 831:../SSC/Src/ecatslv.c ****         }
 832:../SSC/Src/ecatslv.c **** 
 833:../SSC/Src/ecatslv.c **** 
 834:../SSC/Src/ecatslv.c ****         /* Check if Subordinated cycles are configured */
 835:../SSC/Src/ecatslv.c ****         if(((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0) && ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK)
 1568              	 .loc 3 835 0
 1569 023c FB7F     	 ldrb r3,[r7,#31]
 1570 023e 03F00203 	 and r3,r3,#2
 1571 0242 002B     	 cmp r3,#0
 1572 0244 0ED0     	 beq .L102
 1573              	 .loc 3 835 0 is_stmt 0 discriminator 1
 1574 0246 FB7F     	 ldrb r3,[r7,#31]
 1575 0248 03F00403 	 and r3,r3,#4
 1576 024c 002B     	 cmp r3,#0
 1577 024e 09D0     	 beq .L102
 836:../SSC/Src/ecatslv.c ****         {
 837:../SSC/Src/ecatslv.c ****             /* For Subordinated cycles both Sync signals shall be active and Sync0 is not configure
 838:../SSC/Src/ecatslv.c ****             if((shiftTimeSync1 > 0) && (shiftTimeSync1 >= cycleTimeSync0))
 1578              	 .loc 3 838 0 is_stmt 1
 1579 0250 BB6A     	 ldr r3,[r7,#40]
 1580 0252 002B     	 cmp r3,#0
 1581 0254 06D0     	 beq .L102
 1582              	 .loc 3 838 0 is_stmt 0 discriminator 1
 1583 0256 BA6A     	 ldr r2,[r7,#40]
 1584 0258 FB6A     	 ldr r3,[r7,#44]
 1585 025a 9A42     	 cmp r2,r3
 1586 025c 02D3     	 bcc .L102
 839:../SSC/Src/ecatslv.c ****             {
 840:../SSC/Src/ecatslv.c ****                 bSubordinatedCycles = TRUE;
 1587              	 .loc 3 840 0 is_stmt 1
 1588 025e 0123     	 movs r3,#1
 1589 0260 87F83F30 	 strb r3,[r7,#63]
 1590              	.L102:
 841:../SSC/Src/ecatslv.c ****             }
 842:../SSC/Src/ecatslv.c ****         }
 843:../SSC/Src/ecatslv.c **** 
 844:../SSC/Src/ecatslv.c ****         /* Dump an error if subordinated cycles are configured but not supported */
 845:../SSC/Src/ecatslv.c ****         if(bSubordinatedCycles && ((u16MinSuppSyncType & SYNCTYPE_SUBCYCLESUPP) == 0))
 1591              	 .loc 3 845 0
 1592 0264 97F83F30 	 ldrb r3,[r7,#63]
 1593 0268 002B     	 cmp r3,#0
 1594 026a 06D0     	 beq .L94
 1595              	 .loc 3 845 0 is_stmt 0 discriminator 1
 1596 026c FB8C     	 ldrh r3,[r7,#38]
 1597 026e 03F01003 	 and r3,r3,#16
 1598 0272 002B     	 cmp r3,#0
 1599 0274 01D1     	 bne .L94
 846:../SSC/Src/ecatslv.c ****         {
 847:../SSC/Src/ecatslv.c ****              return ALSTATUSCODE_DCINVALIDSYNCCFG;
 1600              	 .loc 3 847 0 is_stmt 1
 1601 0276 3023     	 movs r3,#48
 1602 0278 84E2     	 b .L89
 1603              	.L94:
 848:../SSC/Src/ecatslv.c ****         }
 849:../SSC/Src/ecatslv.c ****     }
 850:../SSC/Src/ecatslv.c **** 
 851:../SSC/Src/ecatslv.c **** 
 852:../SSC/Src/ecatslv.c ****     /*
 853:../SSC/Src/ecatslv.c ****         Check if the user configured Sync Type matches the DC register values (if the Sync Type is 
 854:../SSC/Src/ecatslv.c ****     */
 855:../SSC/Src/ecatslv.c ****     if(bSyncSetByUser)
 1604              	 .loc 3 855 0
 1605 027a 1D4B     	 ldr r3,.L159+68
 1606 027c 1B78     	 ldrb r3,[r3]
 1607 027e 002B     	 cmp r3,#0
 1608 0280 52D0     	 beq .L103
 856:../SSC/Src/ecatslv.c ****     {
 857:../SSC/Src/ecatslv.c ****         if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) == 0)
 1609              	 .loc 3 857 0
 1610 0282 FB7F     	 ldrb r3,[r7,#31]
 1611 0284 03F00903 	 and r3,r3,#9
 1612 0288 002B     	 cmp r3,#0
 1613 028a 33D1     	 bne .L104
 858:../SSC/Src/ecatslv.c ****         {
 859:../SSC/Src/ecatslv.c ****             /* DC out unit not enabled => no DC mode shall be set */
 860:../SSC/Src/ecatslv.c ****             if((SyncType0x1C32 == SYNCTYPE_DCSYNC0) || (SyncType0x1C32 == SYNCTYPE_DCSYNC1)
 1614              	 .loc 3 860 0
 1615 028c 3B8F     	 ldrh r3,[r7,#56]
 1616 028e 022B     	 cmp r3,#2
 1617 0290 09D0     	 beq .L105
 1618              	 .loc 3 860 0 is_stmt 0 discriminator 1
 1619 0292 3B8F     	 ldrh r3,[r7,#56]
 1620 0294 032B     	 cmp r3,#3
 1621 0296 06D0     	 beq .L105
 861:../SSC/Src/ecatslv.c ****                 ||(SyncType0x1C33 == SYNCTYPE_DCSYNC0) || (SyncType0x1C33 == SYNCTYPE_DCSYNC1))
 1622              	 .loc 3 861 0 is_stmt 1
 1623 0298 FB8E     	 ldrh r3,[r7,#54]
 1624 029a 022B     	 cmp r3,#2
 1625 029c 03D0     	 beq .L105
 1626              	 .loc 3 861 0 is_stmt 0 discriminator 1
 1627 029e FB8E     	 ldrh r3,[r7,#54]
 1628 02a0 032B     	 cmp r3,#3
 1629 02a2 40F08580 	 bne .L106
 1630              	.L105:
 862:../SSC/Src/ecatslv.c ****             {
 863:../SSC/Src/ecatslv.c ****                 return ALSTATUSCODE_DCINVALIDSYNCCFG;
 1631              	 .loc 3 863 0 is_stmt 1
 1632 02a6 3023     	 movs r3,#48
 1633 02a8 6CE2     	 b .L89
 1634              	.L160:
 1635 02aa 00BF     	 .align 2
 1636              	.L159:
 1637 02ac 00000000 	 .word sSyncManOutPar
 1638 02b0 00000000 	 .word sSyncManInPar
 1639 02b4 00000000 	 .word u16ALEventMask
 1640 02b8 00000000 	 .word bEcatFirstOutputsReceived
 1641 02bc 00000000 	 .word nEscAddrOutputData
 1642 02c0 00000000 	 .word nEscAddrInputData
 1643 02c4 00000000 	 .word nPdInputSize
 1644 02c8 00000000 	 .word u16EscAddrSendMbx
 1645 02cc 00000000 	 .word u16SendMbxSize
 1646 02d0 00000000 	 .word u16EscAddrReceiveMbx
 1647 02d4 00000000 	 .word u16ReceiveMbxSize
 1648 02d8 00000000 	 .word nPdOutputSize
 1649 02dc 81090154 	 .word 1409354113
 1650 02e0 A0090154 	 .word 1409354144
 1651 02e4 A4090154 	 .word 1409354148
 1652 02e8 48E80100 	 .word 125000
 1653 02ec 000050C3 	 .word -1018167296
 1654 02f0 00000000 	 .word bSyncSetByUser
 1655              	.L104:
 864:../SSC/Src/ecatslv.c ****             }
 865:../SSC/Src/ecatslv.c ****         } //if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) == 
 866:../SSC/Src/ecatslv.c ****     else
 867:../SSC/Src/ecatslv.c ****     {
 868:../SSC/Src/ecatslv.c ****             if((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) == 0)
 1656              	 .loc 3 868 0
 1657 02f4 FB7F     	 ldrb r3,[r7,#31]
 1658 02f6 03F00403 	 and r3,r3,#4
 1659 02fa 002B     	 cmp r3,#0
 1660 02fc 07D1     	 bne .L107
 869:../SSC/Src/ecatslv.c ****             {
 870:../SSC/Src/ecatslv.c ****                 /* No Sync 1 is generated => No Sync1 Sync Type shall configured*/
 871:../SSC/Src/ecatslv.c ****                 if((SyncType0x1C32 == (UINT16)SYNCTYPE_DCSYNC1)
 1661              	 .loc 3 871 0
 1662 02fe 3B8F     	 ldrh r3,[r7,#56]
 1663 0300 032B     	 cmp r3,#3
 1664 0302 02D0     	 beq .L108
 872:../SSC/Src/ecatslv.c ****                     ||(SyncType0x1C33 == (UINT16)SYNCTYPE_DCSYNC1))
 1665              	 .loc 3 872 0
 1666 0304 FB8E     	 ldrh r3,[r7,#54]
 1667 0306 032B     	 cmp r3,#3
 1668 0308 01D1     	 bne .L107
 1669              	.L108:
 873:../SSC/Src/ecatslv.c ****                 {
 874:../SSC/Src/ecatslv.c ****                     return ALSTATUSCODE_DCINVALIDSYNCCFG;
 1670              	 .loc 3 874 0
 1671 030a 3023     	 movs r3,#48
 1672 030c 3AE2     	 b .L89
 1673              	.L107:
 875:../SSC/Src/ecatslv.c ****                 }
 876:../SSC/Src/ecatslv.c ****             } //if((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) == 0)
 877:../SSC/Src/ecatslv.c **** 
 878:../SSC/Src/ecatslv.c ****             if((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) == 0)
 1674              	 .loc 3 878 0
 1675 030e FB7F     	 ldrb r3,[r7,#31]
 1676 0310 03F00203 	 and r3,r3,#2
 1677 0314 002B     	 cmp r3,#0
 1678 0316 4BD1     	 bne .L106
 879:../SSC/Src/ecatslv.c ****             {
 880:../SSC/Src/ecatslv.c ****                 /* No Sync 0 is generated => No Sync0 Sync Type shall configured*/
 881:../SSC/Src/ecatslv.c ****                 if((SyncType0x1C32 == (UINT16)SYNCTYPE_DCSYNC0)
 1679              	 .loc 3 881 0
 1680 0318 3B8F     	 ldrh r3,[r7,#56]
 1681 031a 022B     	 cmp r3,#2
 1682 031c 02D0     	 beq .L109
 882:../SSC/Src/ecatslv.c ****                     ||(SyncType0x1C33 == (UINT16)SYNCTYPE_DCSYNC0))
 1683              	 .loc 3 882 0
 1684 031e FB8E     	 ldrh r3,[r7,#54]
 1685 0320 022B     	 cmp r3,#2
 1686 0322 45D1     	 bne .L106
 1687              	.L109:
 883:../SSC/Src/ecatslv.c ****                 {
 884:../SSC/Src/ecatslv.c ****                     return ALSTATUSCODE_DCINVALIDSYNCCFG;
 1688              	 .loc 3 884 0
 1689 0324 3023     	 movs r3,#48
 1690 0326 2DE2     	 b .L89
 1691              	.L103:
 885:../SSC/Src/ecatslv.c ****                 }
 886:../SSC/Src/ecatslv.c ****             } //if((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) == 0)
 887:../SSC/Src/ecatslv.c **** 
 888:../SSC/Src/ecatslv.c ****         }
 889:../SSC/Src/ecatslv.c ****     } //if(bSyncSetByUser)
 890:../SSC/Src/ecatslv.c ****     else
 891:../SSC/Src/ecatslv.c ****     {
 892:../SSC/Src/ecatslv.c ****         /* No Sync Type selected by user => Configure Sync Type based on DC register values*/
 893:../SSC/Src/ecatslv.c ****         if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) == 0)
 1692              	 .loc 3 893 0
 1693 0328 FB7F     	 ldrb r3,[r7,#31]
 1694 032a 03F00903 	 and r3,r3,#9
 1695 032e 002B     	 cmp r3,#0
 1696 0330 1DD1     	 bne .L110
 894:../SSC/Src/ecatslv.c ****         {
 895:../SSC/Src/ecatslv.c ****             /* Activation or auto activation of the Sync Out Unit is disabled => Free Run or SM Syn
 896:../SSC/Src/ecatslv.c **** 
 897:../SSC/Src/ecatslv.c ****             /* AL Event enabled => Configure SM Sync*/
 898:../SSC/Src/ecatslv.c ****             if (nPdOutputSize > 0)
 1697              	 .loc 3 898 0
 1698 0332 954B     	 ldr r3,.L161
 1699 0334 1B88     	 ldrh r3,[r3]
 1700 0336 002B     	 cmp r3,#0
 1701 0338 0BD0     	 beq .L111
 899:../SSC/Src/ecatslv.c ****             {
 900:../SSC/Src/ecatslv.c ****                 SyncType0x1C32 = SYNCTYPE_SM_SYNCHRON;
 1702              	 .loc 3 900 0
 1703 033a 0123     	 movs r3,#1
 1704 033c 3B87     	 strh r3,[r7,#56]
 901:../SSC/Src/ecatslv.c ****                 
 902:../SSC/Src/ecatslv.c ****                 if (nPdInputSize > 0)
 1705              	 .loc 3 902 0
 1706 033e 934B     	 ldr r3,.L161+4
 1707 0340 1B88     	 ldrh r3,[r3]
 1708 0342 002B     	 cmp r3,#0
 1709 0344 02D0     	 beq .L112
 903:../SSC/Src/ecatslv.c ****                 {
 904:../SSC/Src/ecatslv.c ****                     SyncType0x1C33 = SYNCTYPE_SM2_SYNCHRON;
 1710              	 .loc 3 904 0
 1711 0346 2223     	 movs r3,#34
 1712 0348 FB86     	 strh r3,[r7,#54]
 1713 034a 31E0     	 b .L106
 1714              	.L112:
 905:../SSC/Src/ecatslv.c ****                 }
 906:../SSC/Src/ecatslv.c ****                 else
 907:../SSC/Src/ecatslv.c ****                 {
 908:../SSC/Src/ecatslv.c ****                     SyncType0x1C33 = SYNCTYPE_FREERUN;
 1715              	 .loc 3 908 0
 1716 034c 0023     	 movs r3,#0
 1717 034e FB86     	 strh r3,[r7,#54]
 1718 0350 2EE0     	 b .L106
 1719              	.L111:
 909:../SSC/Src/ecatslv.c ****                 }
 910:../SSC/Src/ecatslv.c ****             }
 911:../SSC/Src/ecatslv.c ****             else if (nPdInputSize > 0)
 1720              	 .loc 3 911 0
 1721 0352 8E4B     	 ldr r3,.L161+4
 1722 0354 1B88     	 ldrh r3,[r3]
 1723 0356 002B     	 cmp r3,#0
 1724 0358 04D0     	 beq .L115
 912:../SSC/Src/ecatslv.c ****             {
 913:../SSC/Src/ecatslv.c ****                 SyncType0x1C32 = SYNCTYPE_FREERUN;
 1725              	 .loc 3 913 0
 1726 035a 0023     	 movs r3,#0
 1727 035c 3B87     	 strh r3,[r7,#56]
 914:../SSC/Src/ecatslv.c ****                 SyncType0x1C33 = SYNCTYPE_SM_SYNCHRON;
 1728              	 .loc 3 914 0
 1729 035e 0123     	 movs r3,#1
 1730 0360 FB86     	 strh r3,[r7,#54]
 1731 0362 25E0     	 b .L106
 1732              	.L115:
 915:../SSC/Src/ecatslv.c ****             }
 916:../SSC/Src/ecatslv.c ****             else
 917:../SSC/Src/ecatslv.c ****             {
 918:../SSC/Src/ecatslv.c ****                 SyncType0x1C32 = SYNCTYPE_FREERUN;
 1733              	 .loc 3 918 0
 1734 0364 0023     	 movs r3,#0
 1735 0366 3B87     	 strh r3,[r7,#56]
 919:../SSC/Src/ecatslv.c ****                 SyncType0x1C33 = SYNCTYPE_FREERUN;
 1736              	 .loc 3 919 0
 1737 0368 0023     	 movs r3,#0
 1738 036a FB86     	 strh r3,[r7,#54]
 1739 036c 20E0     	 b .L106
 1740              	.L110:
 920:../SSC/Src/ecatslv.c ****             }
 921:../SSC/Src/ecatslv.c **** 
 922:../SSC/Src/ecatslv.c ****         }
 923:../SSC/Src/ecatslv.c ****         else
 924:../SSC/Src/ecatslv.c ****         {
 925:../SSC/Src/ecatslv.c ****             if (nPdOutputSize > 0)
 1741              	 .loc 3 925 0
 1742 036e 864B     	 ldr r3,.L161
 1743 0370 1B88     	 ldrh r3,[r3]
 1744 0372 002B     	 cmp r3,#0
 1745 0374 09D0     	 beq .L116
 926:../SSC/Src/ecatslv.c ****             {
 927:../SSC/Src/ecatslv.c ****                 /* Sync Signal generation is active*/
 928:../SSC/Src/ecatslv.c ****                 if (bSubordinatedCycles)
 1746              	 .loc 3 928 0
 1747 0376 97F83F30 	 ldrb r3,[r7,#63]
 1748 037a 002B     	 cmp r3,#0
 1749 037c 02D0     	 beq .L117
 929:../SSC/Src/ecatslv.c ****                 {
 930:../SSC/Src/ecatslv.c ****                     SyncType0x1C32 = SYNCTYPE_DCSYNC1;
 1750              	 .loc 3 930 0
 1751 037e 0323     	 movs r3,#3
 1752 0380 3B87     	 strh r3,[r7,#56]
 1753 0382 04E0     	 b .L119
 1754              	.L117:
 931:../SSC/Src/ecatslv.c ****                 }
 932:../SSC/Src/ecatslv.c ****                 else
 933:../SSC/Src/ecatslv.c ****                 {
 934:../SSC/Src/ecatslv.c ****                     SyncType0x1C32 = SYNCTYPE_DCSYNC0;
 1755              	 .loc 3 934 0
 1756 0384 0223     	 movs r3,#2
 1757 0386 3B87     	 strh r3,[r7,#56]
 1758 0388 01E0     	 b .L119
 1759              	.L116:
 935:../SSC/Src/ecatslv.c ****                 }
 936:../SSC/Src/ecatslv.c ****             }
 937:../SSC/Src/ecatslv.c ****             else
 938:../SSC/Src/ecatslv.c ****             {
 939:../SSC/Src/ecatslv.c ****                 SyncType0x1C32 = SYNCTYPE_FREERUN;
 1760              	 .loc 3 939 0
 1761 038a 0023     	 movs r3,#0
 1762 038c 3B87     	 strh r3,[r7,#56]
 1763              	.L119:
 940:../SSC/Src/ecatslv.c ****             }
 941:../SSC/Src/ecatslv.c **** 
 942:../SSC/Src/ecatslv.c **** 
 943:../SSC/Src/ecatslv.c ****             if (nPdInputSize > 0)
 1764              	 .loc 3 943 0
 1765 038e 7F4B     	 ldr r3,.L161+4
 1766 0390 1B88     	 ldrh r3,[r3]
 1767 0392 002B     	 cmp r3,#0
 1768 0394 0AD0     	 beq .L120
 944:../SSC/Src/ecatslv.c ****             {
 945:../SSC/Src/ecatslv.c ****                 if ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)
 1769              	 .loc 3 945 0
 1770 0396 FB7F     	 ldrb r3,[r7,#31]
 1771 0398 03F00403 	 and r3,r3,#4
 1772 039c 002B     	 cmp r3,#0
 1773 039e 02D0     	 beq .L121
 946:../SSC/Src/ecatslv.c ****                 {
 947:../SSC/Src/ecatslv.c ****                     /* If Sync1 is available the inputs will always be mapped with Sync1 */
 948:../SSC/Src/ecatslv.c ****                     SyncType0x1C33 = SYNCTYPE_DCSYNC1;
 1774              	 .loc 3 948 0
 1775 03a0 0323     	 movs r3,#3
 1776 03a2 FB86     	 strh r3,[r7,#54]
 1777 03a4 04E0     	 b .L106
 1778              	.L121:
 949:../SSC/Src/ecatslv.c ****                 }
 950:../SSC/Src/ecatslv.c ****                 else
 951:../SSC/Src/ecatslv.c ****                 {
 952:../SSC/Src/ecatslv.c ****                     /* Map Inputs based on Sync0*/
 953:../SSC/Src/ecatslv.c ****                     SyncType0x1C33 = SYNCTYPE_DCSYNC0;
 1779              	 .loc 3 953 0
 1780 03a6 0223     	 movs r3,#2
 1781 03a8 FB86     	 strh r3,[r7,#54]
 1782 03aa 01E0     	 b .L106
 1783              	.L120:
 954:../SSC/Src/ecatslv.c ****                 }
 955:../SSC/Src/ecatslv.c ****             }
 956:../SSC/Src/ecatslv.c ****             else
 957:../SSC/Src/ecatslv.c ****             {
 958:../SSC/Src/ecatslv.c ****                 SyncType0x1C33 = SYNCTYPE_FREERUN;
 1784              	 .loc 3 958 0
 1785 03ac 0023     	 movs r3,#0
 1786 03ae FB86     	 strh r3,[r7,#54]
 1787              	.L106:
 959:../SSC/Src/ecatslv.c ****             }
 960:../SSC/Src/ecatslv.c ****         }
 961:../SSC/Src/ecatslv.c ****     }
 962:../SSC/Src/ecatslv.c **** 
 963:../SSC/Src/ecatslv.c ****     /* Update Cycle time entries if DC Sync Mode enabled */
 964:../SSC/Src/ecatslv.c ****     if(SyncType0x1C32 == SYNCTYPE_DCSYNC1)
 1788              	 .loc 3 964 0
 1789 03b0 3B8F     	 ldrh r3,[r7,#56]
 1790 03b2 032B     	 cmp r3,#3
 1791 03b4 0CD1     	 bne .L123
 965:../SSC/Src/ecatslv.c ****     {
 966:../SSC/Src/ecatslv.c ****         sSyncManOutPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
 1792              	 .loc 3 966 0
 1793 03b6 764A     	 ldr r2,.L161+8
 1794 03b8 FB6A     	 ldr r3,[r7,#44]
 1795 03ba 5362     	 str r3,[r2,#36]
 967:../SSC/Src/ecatslv.c ****         sSyncManOutPar.u32CycleTime = (UINT32)cycleTimeSync0;
 1796              	 .loc 3 967 0
 1797 03bc 744A     	 ldr r2,.L161+8
 1798 03be FB6A     	 ldr r3,[r7,#44]
 1799 03c0 5360     	 str r3,[r2,#4]
 968:../SSC/Src/ecatslv.c **** 
 969:../SSC/Src/ecatslv.c ****         sSyncManInPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
 1800              	 .loc 3 969 0
 1801 03c2 744A     	 ldr r2,.L161+12
 1802 03c4 FB6A     	 ldr r3,[r7,#44]
 1803 03c6 5362     	 str r3,[r2,#36]
 970:../SSC/Src/ecatslv.c ****         sSyncManInPar.u32CycleTime = (UINT32)cycleTimeSync0;
 1804              	 .loc 3 970 0
 1805 03c8 724A     	 ldr r2,.L161+12
 1806 03ca FB6A     	 ldr r3,[r7,#44]
 1807 03cc 5360     	 str r3,[r2,#4]
 1808 03ce 0EE0     	 b .L124
 1809              	.L123:
 971:../SSC/Src/ecatslv.c ****     }
 972:../SSC/Src/ecatslv.c ****     else if(SyncType0x1C32 == SYNCTYPE_DCSYNC0)
 1810              	 .loc 3 972 0
 1811 03d0 3B8F     	 ldrh r3,[r7,#56]
 1812 03d2 022B     	 cmp r3,#2
 1813 03d4 0BD1     	 bne .L124
 973:../SSC/Src/ecatslv.c ****     {
 974:../SSC/Src/ecatslv.c ****         sSyncManOutPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
 1814              	 .loc 3 974 0
 1815 03d6 6E4A     	 ldr r2,.L161+8
 1816 03d8 FB6A     	 ldr r3,[r7,#44]
 1817 03da 5362     	 str r3,[r2,#36]
 975:../SSC/Src/ecatslv.c ****         sSyncManOutPar.u32CycleTime = (UINT32)cycleTimeSync0;
 1818              	 .loc 3 975 0
 1819 03dc 6C4A     	 ldr r2,.L161+8
 1820 03de FB6A     	 ldr r3,[r7,#44]
 1821 03e0 5360     	 str r3,[r2,#4]
 976:../SSC/Src/ecatslv.c **** 
 977:../SSC/Src/ecatslv.c ****         sSyncManInPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
 1822              	 .loc 3 977 0
 1823 03e2 6C4A     	 ldr r2,.L161+12
 1824 03e4 FB6A     	 ldr r3,[r7,#44]
 1825 03e6 5362     	 str r3,[r2,#36]
 978:../SSC/Src/ecatslv.c ****         sSyncManInPar.u32CycleTime = (UINT32)cycleTimeSync0;
 1826              	 .loc 3 978 0
 1827 03e8 6A4A     	 ldr r2,.L161+12
 1828 03ea FB6A     	 ldr r3,[r7,#44]
 1829 03ec 5360     	 str r3,[r2,#4]
 1830              	.L124:
 979:../SSC/Src/ecatslv.c ****     }
 980:../SSC/Src/ecatslv.c **** 
 981:../SSC/Src/ecatslv.c ****     /* Set global flags based on Sync Type */
 982:../SSC/Src/ecatslv.c ****     if ( !b3BufferMode )
 1831              	 .loc 3 982 0
 1832 03ee 6A4B     	 ldr r3,.L161+16
 1833 03f0 1B78     	 ldrb r3,[r3]
 1834 03f2 83F00103 	 eor r3,r3,#1
 1835 03f6 DBB2     	 uxtb r3,r3
 1836 03f8 002B     	 cmp r3,#0
 1837 03fa 07D0     	 beq .L125
 983:../SSC/Src/ecatslv.c ****     {
 984:../SSC/Src/ecatslv.c ****         /* 1-Buffer-Mode configured => For free run it shall be 3Buffer mode*/
 985:../SSC/Src/ecatslv.c ****         if (( SyncType0x1C32 == SYNCTYPE_FREERUN ) || ( SyncType0x1C33 == SYNCTYPE_FREERUN ))
 1838              	 .loc 3 985 0
 1839 03fc 3B8F     	 ldrh r3,[r7,#56]
 1840 03fe 002B     	 cmp r3,#0
 1841 0400 02D0     	 beq .L126
 1842              	 .loc 3 985 0 is_stmt 0 discriminator 1
 1843 0402 FB8E     	 ldrh r3,[r7,#54]
 1844 0404 002B     	 cmp r3,#0
 1845 0406 01D1     	 bne .L125
 1846              	.L126:
 986:../SSC/Src/ecatslv.c ****         {
 987:../SSC/Src/ecatslv.c ****                 return ALSTATUSCODE_FREERUNNEEDS3BUFFERMODE;
 1847              	 .loc 3 987 0 is_stmt 1
 1848 0408 2923     	 movs r3,#41
 1849 040a BBE1     	 b .L89
 1850              	.L125:
 988:../SSC/Src/ecatslv.c ****         }
 989:../SSC/Src/ecatslv.c ****     }
 990:../SSC/Src/ecatslv.c **** 
 991:../SSC/Src/ecatslv.c ****     /* If no free run is supported the EscInt is always enabled*/
 992:../SSC/Src/ecatslv.c ****         if (( SyncType0x1C32 != SYNCTYPE_FREERUN ) || ( SyncType0x1C33 != SYNCTYPE_FREERUN ))
 1851              	 .loc 3 992 0
 1852 040c 3B8F     	 ldrh r3,[r7,#56]
 1853 040e 002B     	 cmp r3,#0
 1854 0410 02D1     	 bne .L127
 1855              	 .loc 3 992 0 is_stmt 0 discriminator 1
 1856 0412 FB8E     	 ldrh r3,[r7,#54]
 1857 0414 002B     	 cmp r3,#0
 1858 0416 02D0     	 beq .L128
 1859              	.L127:
 993:../SSC/Src/ecatslv.c ****         {
 994:../SSC/Src/ecatslv.c ****         /* ECAT Synchron Mode, the ESC interrupt is enabled */
 995:../SSC/Src/ecatslv.c ****         bEscIntEnabled = TRUE;
 1860              	 .loc 3 995 0 is_stmt 1
 1861 0418 604B     	 ldr r3,.L161+20
 1862 041a 0122     	 movs r2,#1
 1863 041c 1A70     	 strb r2,[r3]
 1864              	.L128:
 996:../SSC/Src/ecatslv.c ****     }
 997:../SSC/Src/ecatslv.c **** 
 998:../SSC/Src/ecatslv.c ****         /* Update value for AL Event Mask register (0x204) */
 999:../SSC/Src/ecatslv.c ****         if(bEscIntEnabled)
 1865              	 .loc 3 999 0
 1866 041e 5F4B     	 ldr r3,.L161+20
 1867 0420 1B78     	 ldrb r3,[r3]
 1868 0422 002B     	 cmp r3,#0
 1869 0424 10D0     	 beq .L129
1000:../SSC/Src/ecatslv.c ****         {
1001:../SSC/Src/ecatslv.c ****             if(nPdOutputSize > 0)
 1870              	 .loc 3 1001 0
 1871 0426 584B     	 ldr r3,.L161
 1872 0428 1B88     	 ldrh r3,[r3]
 1873 042a 002B     	 cmp r3,#0
 1874 042c 04D0     	 beq .L130
1002:../SSC/Src/ecatslv.c ****             {
1003:../SSC/Src/ecatslv.c ****                 u16ALEventMask = PROCESS_OUTPUT_EVENT;
 1875              	 .loc 3 1003 0
 1876 042e 5C4B     	 ldr r3,.L161+24
 1877 0430 4FF48062 	 mov r2,#1024
 1878 0434 1A80     	 strh r2,[r3]
 1879 0436 07E0     	 b .L129
 1880              	.L130:
1004:../SSC/Src/ecatslv.c ****             }
1005:../SSC/Src/ecatslv.c ****             else if(nPdInputSize > 0)
 1881              	 .loc 3 1005 0
 1882 0438 544B     	 ldr r3,.L161+4
 1883 043a 1B88     	 ldrh r3,[r3]
 1884 043c 002B     	 cmp r3,#0
 1885 043e 03D0     	 beq .L129
1006:../SSC/Src/ecatslv.c ****             {
1007:../SSC/Src/ecatslv.c ****                 u16ALEventMask = PROCESS_INPUT_EVENT;
 1886              	 .loc 3 1007 0
 1887 0440 574B     	 ldr r3,.L161+24
 1888 0442 4FF40062 	 mov r2,#2048
 1889 0446 1A80     	 strh r2,[r3]
 1890              	.L129:
1008:../SSC/Src/ecatslv.c ****             }
1009:../SSC/Src/ecatslv.c **** 
1010:../SSC/Src/ecatslv.c ****         }
1011:../SSC/Src/ecatslv.c **** 
1012:../SSC/Src/ecatslv.c ****         if ((SyncType0x1C32 == SYNCTYPE_DCSYNC0) || (SyncType0x1C32 == SYNCTYPE_DCSYNC1)
 1891              	 .loc 3 1012 0
 1892 0448 3B8F     	 ldrh r3,[r7,#56]
 1893 044a 022B     	 cmp r3,#2
 1894 044c 08D0     	 beq .L131
 1895              	 .loc 3 1012 0 is_stmt 0 discriminator 1
 1896 044e 3B8F     	 ldrh r3,[r7,#56]
 1897 0450 032B     	 cmp r3,#3
 1898 0452 05D0     	 beq .L131
1013:../SSC/Src/ecatslv.c ****             || (SyncType0x1C33 == SYNCTYPE_DCSYNC0) || (SyncType0x1C33 == SYNCTYPE_DCSYNC1))/* Sync
 1899              	 .loc 3 1013 0 is_stmt 1
 1900 0454 FB8E     	 ldrh r3,[r7,#54]
 1901 0456 022B     	 cmp r3,#2
 1902 0458 02D0     	 beq .L131
 1903              	 .loc 3 1013 0 is_stmt 0 discriminator 1
 1904 045a FB8E     	 ldrh r3,[r7,#54]
 1905 045c 032B     	 cmp r3,#3
 1906 045e 09D1     	 bne .L132
 1907              	.L131:
1014:../SSC/Src/ecatslv.c ****         {
1015:../SSC/Src/ecatslv.c ****             /* slave is running in DC-mode */
1016:../SSC/Src/ecatslv.c ****             bDcSyncActive = TRUE;
 1908              	 .loc 3 1016 0 is_stmt 1
 1909 0460 504B     	 ldr r3,.L161+28
 1910 0462 0122     	 movs r2,#1
 1911 0464 1A70     	 strb r2,[r3]
1017:../SSC/Src/ecatslv.c **** 
1018:../SSC/Src/ecatslv.c ****             /*In case of an Input only application with DC no PDI Isr handling is required*/
1019:../SSC/Src/ecatslv.c ****             if (nPdOutputSize == 0)
 1912              	 .loc 3 1019 0
 1913 0466 484B     	 ldr r3,.L161
 1914 0468 1B88     	 ldrh r3,[r3]
 1915 046a 002B     	 cmp r3,#0
 1916 046c 02D1     	 bne .L132
1020:../SSC/Src/ecatslv.c ****             {
1021:../SSC/Src/ecatslv.c ****                u16ALEventMask = 0;
 1917              	 .loc 3 1021 0
 1918 046e 4C4B     	 ldr r3,.L161+24
 1919 0470 0022     	 movs r2,#0
 1920 0472 1A80     	 strh r2,[r3]
 1921              	.L132:
1022:../SSC/Src/ecatslv.c ****             }
1023:../SSC/Src/ecatslv.c ****         }
1024:../SSC/Src/ecatslv.c **** 
1025:../SSC/Src/ecatslv.c **** 
1026:../SSC/Src/ecatslv.c **** 
1027:../SSC/Src/ecatslv.c ****     sSyncManOutPar.u16SyncType = SyncType0x1C32;
 1922              	 .loc 3 1027 0
 1923 0474 464A     	 ldr r2,.L161+8
 1924 0476 3B8F     	 ldrh r3,[r7,#56]
 1925 0478 5380     	 strh r3,[r2,#2]
1028:../SSC/Src/ecatslv.c ****     sSyncManInPar.u16SyncType = SyncType0x1C33;
 1926              	 .loc 3 1028 0
 1927 047a 464A     	 ldr r2,.L161+12
 1928 047c FB8E     	 ldrh r3,[r7,#54]
 1929 047e 5380     	 strh r3,[r2,#2]
1029:../SSC/Src/ecatslv.c **** 
1030:../SSC/Src/ecatslv.c ****     /* Calculate number of Sync0 events within one SM cycle and the Sync0 events on which the input
1031:../SSC/Src/ecatslv.c ****     LatchInputSync0Value = 0;
 1930              	 .loc 3 1031 0
 1931 0480 494B     	 ldr r3,.L161+32
 1932 0482 0022     	 movs r2,#0
 1933 0484 1A80     	 strh r2,[r3]
1032:../SSC/Src/ecatslv.c ****     LatchInputSync0Counter = 0;
 1934              	 .loc 3 1032 0
 1935 0486 494B     	 ldr r3,.L161+36
 1936 0488 0022     	 movs r2,#0
 1937 048a 1A80     	 strh r2,[r3]
1033:../SSC/Src/ecatslv.c ****     u16SmSync0Value = 0;
 1938              	 .loc 3 1033 0
 1939 048c 484B     	 ldr r3,.L161+40
 1940 048e 0022     	 movs r2,#0
 1941 0490 1A80     	 strh r2,[r3]
1034:../SSC/Src/ecatslv.c ****     u16SmSync0Counter = 0;
 1942              	 .loc 3 1034 0
 1943 0492 484B     	 ldr r3,.L161+44
 1944 0494 0022     	 movs r2,#0
 1945 0496 1A80     	 strh r2,[r3]
1035:../SSC/Src/ecatslv.c **** 
1036:../SSC/Src/ecatslv.c **** 
1037:../SSC/Src/ecatslv.c ****     if(bSubordinatedCycles == TRUE)
 1946              	 .loc 3 1037 0
 1947 0498 97F83F30 	 ldrb r3,[r7,#63]
 1948 049c 002B     	 cmp r3,#0
 1949 049e 3BD0     	 beq .L133
 1950              	.LBB3:
1038:../SSC/Src/ecatslv.c ****     {
1039:../SSC/Src/ecatslv.c ****         
1040:../SSC/Src/ecatslv.c ****         UINT32 cycleTimeSync1 = (shiftTimeSync1 + cycleTimeSync0);
 1951              	 .loc 3 1040 0
 1952 04a0 BA6A     	 ldr r2,[r7,#40]
 1953 04a2 FB6A     	 ldr r3,[r7,#44]
 1954 04a4 1344     	 add r3,r3,r2
 1955 04a6 7B61     	 str r3,[r7,#20]
1041:../SSC/Src/ecatslv.c **** 
1042:../SSC/Src/ecatslv.c **** 
1043:../SSC/Src/ecatslv.c ****         /* get the number of Sync0 event within on SM cycle */
1044:../SSC/Src/ecatslv.c ****         if(shiftTimeSync1 >= cycleTimeSync0)
 1956              	 .loc 3 1044 0
 1957 04a8 BA6A     	 ldr r2,[r7,#40]
 1958 04aa FB6A     	 ldr r3,[r7,#44]
 1959 04ac 9A42     	 cmp r2,r3
 1960 04ae 17D3     	 bcc .L134
1045:../SSC/Src/ecatslv.c ****         {
1046:../SSC/Src/ecatslv.c **** 
1047:../SSC/Src/ecatslv.c ****             u16SmSync0Value = (UINT16)(cycleTimeSync1 / cycleTimeSync0);
 1961              	 .loc 3 1047 0
 1962 04b0 7A69     	 ldr r2,[r7,#20]
 1963 04b2 FB6A     	 ldr r3,[r7,#44]
 1964 04b4 B2FBF3F3 	 udiv r3,r2,r3
 1965 04b8 9AB2     	 uxth r2,r3
 1966 04ba 3D4B     	 ldr r3,.L161+40
 1967 04bc 1A80     	 strh r2,[r3]
1048:../SSC/Src/ecatslv.c ****             
1049:../SSC/Src/ecatslv.c ****             if((cycleTimeSync1 % cycleTimeSync0) == 0)
 1968              	 .loc 3 1049 0
 1969 04be 7B69     	 ldr r3,[r7,#20]
 1970 04c0 FA6A     	 ldr r2,[r7,#44]
 1971 04c2 B3FBF2F2 	 udiv r2,r3,r2
 1972 04c6 F96A     	 ldr r1,[r7,#44]
 1973 04c8 01FB02F2 	 mul r2,r1,r2
 1974 04cc 9B1A     	 subs r3,r3,r2
 1975 04ce 002B     	 cmp r3,#0
 1976 04d0 09D1     	 bne .L136
1050:../SSC/Src/ecatslv.c ****             {
1051:../SSC/Src/ecatslv.c ****                 /* if the Sync1cycletime/Sync0cycletime ratio is even one additional tick */
1052:../SSC/Src/ecatslv.c ****                 u16SmSync0Value ++;
 1977              	 .loc 3 1052 0
 1978 04d2 374B     	 ldr r3,.L161+40
 1979 04d4 1B88     	 ldrh r3,[r3]
 1980 04d6 0133     	 adds r3,r3,#1
 1981 04d8 9AB2     	 uxth r2,r3
 1982 04da 354B     	 ldr r3,.L161+40
 1983 04dc 1A80     	 strh r2,[r3]
 1984 04de 02E0     	 b .L136
 1985              	.L134:
1053:../SSC/Src/ecatslv.c ****             }
1054:../SSC/Src/ecatslv.c ****         }
1055:../SSC/Src/ecatslv.c ****         else
1056:../SSC/Src/ecatslv.c ****         {
1057:../SSC/Src/ecatslv.c ****             u16SmSync0Value = 1;
 1986              	 .loc 3 1057 0
 1987 04e0 334B     	 ldr r3,.L161+40
 1988 04e2 0122     	 movs r2,#1
 1989 04e4 1A80     	 strh r2,[r3]
 1990              	.L136:
1058:../SSC/Src/ecatslv.c ****         }
1059:../SSC/Src/ecatslv.c **** 
1060:../SSC/Src/ecatslv.c ****         /* Calculate the Sync0 tick on which the inputs shall be latched (last Sync0 before the nex
1061:../SSC/Src/ecatslv.c ****         LatchInputSync0Value = (UINT16) (cycleTimeSync1 / cycleTimeSync0);
 1991              	 .loc 3 1061 0
 1992 04e6 7A69     	 ldr r2,[r7,#20]
 1993 04e8 FB6A     	 ldr r3,[r7,#44]
 1994 04ea B2FBF3F3 	 udiv r3,r2,r3
 1995 04ee 9AB2     	 uxth r2,r3
 1996 04f0 2D4B     	 ldr r3,.L161+32
 1997 04f2 1A80     	 strh r2,[r3]
1062:../SSC/Src/ecatslv.c **** 
1063:../SSC/Src/ecatslv.c ****         if ((cycleTimeSync1 % cycleTimeSync0) > 0)
 1998              	 .loc 3 1063 0
 1999 04f4 7B69     	 ldr r3,[r7,#20]
 2000 04f6 FA6A     	 ldr r2,[r7,#44]
 2001 04f8 B3FBF2F2 	 udiv r2,r3,r2
 2002 04fc F96A     	 ldr r1,[r7,#44]
 2003 04fe 01FB02F2 	 mul r2,r1,r2
 2004 0502 9B1A     	 subs r3,r3,r2
 2005 0504 002B     	 cmp r3,#0
 2006 0506 06D0     	 beq .L137
1064:../SSC/Src/ecatslv.c ****         {
1065:../SSC/Src/ecatslv.c ****             LatchInputSync0Value++;
 2007              	 .loc 3 1065 0
 2008 0508 274B     	 ldr r3,.L161+32
 2009 050a 1B88     	 ldrh r3,[r3]
 2010 050c 0133     	 adds r3,r3,#1
 2011 050e 9AB2     	 uxth r2,r3
 2012 0510 254B     	 ldr r3,.L161+32
 2013 0512 1A80     	 strh r2,[r3]
 2014              	.LBE3:
 2015 0514 0CE0     	 b .L138
 2016              	.L137:
 2017 0516 0BE0     	 b .L138
 2018              	.L133:
1066:../SSC/Src/ecatslv.c ****         }
1067:../SSC/Src/ecatslv.c **** 
1068:../SSC/Src/ecatslv.c ****     }
1069:../SSC/Src/ecatslv.c ****     else 
1070:../SSC/Src/ecatslv.c ****     {
1071:../SSC/Src/ecatslv.c ****         if(SyncType0x1C32 == SYNCTYPE_DCSYNC0)
 2019              	 .loc 3 1071 0
 2020 0518 3B8F     	 ldrh r3,[r7,#56]
 2021 051a 022B     	 cmp r3,#2
 2022 051c 02D1     	 bne .L139
1072:../SSC/Src/ecatslv.c ****         {
1073:../SSC/Src/ecatslv.c ****             /* if SyncType of 0x1C32 is 2 the Sync0 event is trigger once during a SM cycle */
1074:../SSC/Src/ecatslv.c ****             u16SmSync0Value = 1;
 2023              	 .loc 3 1074 0
 2024 051e 244B     	 ldr r3,.L161+40
 2025 0520 0122     	 movs r2,#1
 2026 0522 1A80     	 strh r2,[r3]
 2027              	.L139:
1075:../SSC/Src/ecatslv.c ****         }   
1076:../SSC/Src/ecatslv.c **** 
1077:../SSC/Src/ecatslv.c ****         if(SyncType0x1C33 != SYNCTYPE_DCSYNC1)
 2028              	 .loc 3 1077 0
 2029 0524 FB8E     	 ldrh r3,[r7,#54]
 2030 0526 032B     	 cmp r3,#3
 2031 0528 02D0     	 beq .L138
1078:../SSC/Src/ecatslv.c ****         {
1079:../SSC/Src/ecatslv.c ****             LatchInputSync0Value = 1;
 2032              	 .loc 3 1079 0
 2033 052a 1F4B     	 ldr r3,.L161+32
 2034 052c 0122     	 movs r2,#1
 2035 052e 1A80     	 strh r2,[r3]
 2036              	.L138:
1080:../SSC/Src/ecatslv.c ****         }
1081:../SSC/Src/ecatslv.c ****     }
1082:../SSC/Src/ecatslv.c **** 
1083:../SSC/Src/ecatslv.c **** 
1084:../SSC/Src/ecatslv.c **** 
1085:../SSC/Src/ecatslv.c ****     /* reset the error counter indicating synchronization problems */
1086:../SSC/Src/ecatslv.c ****     sCycleDiag.syncFailedCounter = 0;
 2037              	 .loc 3 1086 0
 2038 0530 214B     	 ldr r3,.L161+48
 2039 0532 0022     	 movs r2,#0
 2040 0534 1A80     	 strh r2,[r3]
1087:../SSC/Src/ecatslv.c **** 
1088:../SSC/Src/ecatslv.c **** 
1089:../SSC/Src/ecatslv.c ****     /*
1090:../SSC/Src/ecatslv.c ****         --- Check watchdog settings ---
1091:../SSC/Src/ecatslv.c ****     */
1092:../SSC/Src/ecatslv.c **** 
1093:../SSC/Src/ecatslv.c ****     /*get the watchdog time (register 0x420). if value is > 0 watchdog is active*/
1094:../SSC/Src/ecatslv.c ****     HW_EscReadWord(wd, ESC_PD_WD_TIME);
 2041              	 .loc 3 1094 0
 2042 0536 214B     	 ldr r3,.L161+52
 2043 0538 1B88     	 ldrh r3,[r3]
 2044 053a 7B86     	 strh r3,[r7,#50]
1095:../SSC/Src/ecatslv.c ****     wd = SWAPWORD(wd);
1096:../SSC/Src/ecatslv.c **** 
1097:../SSC/Src/ecatslv.c ****     if (nPdOutputSize > 0 &&  wd != 0 )
 2045              	 .loc 3 1097 0
 2046 053c 124B     	 ldr r3,.L161
 2047 053e 1B88     	 ldrh r3,[r3]
 2048 0540 002B     	 cmp r3,#0
 2049 0542 49D0     	 beq .L140
 2050              	 .loc 3 1097 0 is_stmt 0 discriminator 1
 2051 0544 7B8E     	 ldrh r3,[r7,#50]
 2052 0546 002B     	 cmp r3,#0
 2053 0548 46D0     	 beq .L140
1098:../SSC/Src/ecatslv.c ****     {
1099:../SSC/Src/ecatslv.c ****     /*get watchdog divider (register 0x400)*/
1100:../SSC/Src/ecatslv.c ****     HW_EscReadWord(wdiv, ESC_WD_DIVIDER_OFFSET);
 2054              	 .loc 3 1100 0 is_stmt 1
 2055 054a 1D4B     	 ldr r3,.L161+56
 2056 054c 1B88     	 ldrh r3,[r3]
 2057 054e BB86     	 strh r3,[r7,#52]
1101:../SSC/Src/ecatslv.c ****     wdiv = SWAPWORD(wdiv);
1102:../SSC/Src/ecatslv.c ****         if ( wdiv != 0 )
 2058              	 .loc 3 1102 0
 2059 0550 BB8E     	 ldrh r3,[r7,#52]
 2060 0552 002B     	 cmp r3,#0
 2061 0554 3AD0     	 beq .L141
 2062              	.LBB4:
1103:../SSC/Src/ecatslv.c ****         {
1104:../SSC/Src/ecatslv.c ****             /* the ESC subtracts 2 in register 0x400 so it has to be added here */
1105:../SSC/Src/ecatslv.c ****             UINT32 d = wdiv+2;
 2063              	 .loc 3 1105 0
 2064 0556 BB8E     	 ldrh r3,[r7,#52]
 2065 0558 0233     	 adds r3,r3,#2
 2066 055a 3B61     	 str r3,[r7,#16]
1106:../SSC/Src/ecatslv.c **** 
1107:../SSC/Src/ecatslv.c **** 
1108:../SSC/Src/ecatslv.c ****             d *= wd;
 2067              	 .loc 3 1108 0
 2068 055c 7A8E     	 ldrh r2,[r7,#50]
 2069 055e 3B69     	 ldr r3,[r7,#16]
 2070 0560 02FB03F3 	 mul r3,r2,r3
 2071 0564 3B61     	 str r3,[r7,#16]
1109:../SSC/Src/ecatslv.c ****             /* store watchdog in ms in variable EcatWdValue */
1110:../SSC/Src/ecatslv.c ****             /* watchdog value has to be rounded up */
1111:../SSC/Src/ecatslv.c ****             d = (INT32)(d + 24999);
 2072              	 .loc 3 1111 0
 2073 0566 3B69     	 ldr r3,[r7,#16]
 2074 0568 03F5C343 	 add r3,r3,#24960
 2075 056c 2733     	 adds r3,r3,#39
 2076 056e 3B61     	 str r3,[r7,#16]
1112:../SSC/Src/ecatslv.c ****             d /= 25000;
 2077              	 .loc 3 1112 0
 2078 0570 3B69     	 ldr r3,[r7,#16]
 2079 0572 DB08     	 lsrs r3,r3,#3
 2080 0574 134A     	 ldr r2,.L161+60
 2081 0576 A2FB0323 	 umull r2,r3,r2,r3
 2082 057a 1B0A     	 lsrs r3,r3,#8
 2083 057c 3B61     	 str r3,[r7,#16]
1113:../SSC/Src/ecatslv.c ****             EcatWdValue = (UINT16) d;
 2084              	 .loc 3 1113 0
 2085 057e 3B69     	 ldr r3,[r7,#16]
 2086 0580 9AB2     	 uxth r2,r3
 2087 0582 114B     	 ldr r3,.L161+64
 2088 0584 1A80     	 strh r2,[r3]
 2089              	.LBE4:
1102:../SSC/Src/ecatslv.c ****         {
 2090              	 .loc 3 1102 0
 2091 0586 2CE0     	 b .L143
 2092              	.L162:
 2093              	 .align 2
 2094              	.L161:
 2095 0588 00000000 	 .word nPdOutputSize
 2096 058c 00000000 	 .word nPdInputSize
 2097 0590 00000000 	 .word sSyncManOutPar
 2098 0594 00000000 	 .word sSyncManInPar
 2099 0598 00000000 	 .word b3BufferMode
 2100 059c 00000000 	 .word bEscIntEnabled
 2101 05a0 00000000 	 .word u16ALEventMask
 2102 05a4 00000000 	 .word bDcSyncActive
 2103 05a8 00000000 	 .word LatchInputSync0Value
 2104 05ac 00000000 	 .word LatchInputSync0Counter
 2105 05b0 00000000 	 .word u16SmSync0Value
 2106 05b4 00000000 	 .word u16SmSync0Counter
 2107 05b8 00000000 	 .word sCycleDiag
 2108 05bc 20040154 	 .word 1409352736
 2109 05c0 00040154 	 .word 1409352704
 2110 05c4 89B5F814 	 .word 351843721
 2111 05c8 00000000 	 .word EcatWdValue
 2112              	.L141:
1114:../SSC/Src/ecatslv.c ****         }
1115:../SSC/Src/ecatslv.c ****         else
1116:../SSC/Src/ecatslv.c ****         {
1117:../SSC/Src/ecatslv.c ****             wd = 0;
 2113              	 .loc 3 1117 0
 2114 05cc 0023     	 movs r3,#0
 2115 05ce 7B86     	 strh r3,[r7,#50]
1118:../SSC/Src/ecatslv.c ****             /* wd value has to be set to zero, if the wd is 0 */
1119:../SSC/Src/ecatslv.c ****             EcatWdValue = 0;
 2116              	 .loc 3 1119 0
 2117 05d0 6E4B     	 ldr r3,.L163
 2118 05d2 0022     	 movs r2,#0
 2119 05d4 1A80     	 strh r2,[r3]
1102:../SSC/Src/ecatslv.c ****         {
 2120              	 .loc 3 1102 0
 2121 05d6 04E0     	 b .L143
 2122              	.L140:
1120:../SSC/Src/ecatslv.c ****         }
1121:../SSC/Src/ecatslv.c ****     }
1122:../SSC/Src/ecatslv.c ****     else
1123:../SSC/Src/ecatslv.c ****     {
1124:../SSC/Src/ecatslv.c ****         /* the watchdog is deactivated or slave has no output process data*/
1125:../SSC/Src/ecatslv.c ****         wdiv = 0;
 2123              	 .loc 3 1125 0
 2124 05d8 0023     	 movs r3,#0
 2125 05da BB86     	 strh r3,[r7,#52]
1126:../SSC/Src/ecatslv.c ****         EcatWdValue = 0;
 2126              	 .loc 3 1126 0
 2127 05dc 6B4B     	 ldr r3,.L163
 2128 05de 0022     	 movs r2,#0
 2129 05e0 1A80     	 strh r2,[r3]
 2130              	.L143:
1127:../SSC/Src/ecatslv.c ****     }
1128:../SSC/Src/ecatslv.c **** 
1129:../SSC/Src/ecatslv.c ****     if((EcatWdValue == 0 && bWdTrigger) || (EcatWdValue != 0 && !bWdTrigger))
 2131              	 .loc 3 1129 0
 2132 05e2 6A4B     	 ldr r3,.L163
 2133 05e4 1B88     	 ldrh r3,[r3]
 2134 05e6 002B     	 cmp r3,#0
 2135 05e8 03D1     	 bne .L144
 2136              	 .loc 3 1129 0 is_stmt 0 discriminator 1
 2137 05ea 694B     	 ldr r3,.L163+4
 2138 05ec 1B78     	 ldrb r3,[r3]
 2139 05ee 002B     	 cmp r3,#0
 2140 05f0 0AD1     	 bne .L145
 2141              	.L144:
 2142              	 .loc 3 1129 0 discriminator 3
 2143 05f2 664B     	 ldr r3,.L163
 2144 05f4 1B88     	 ldrh r3,[r3]
 2145 05f6 002B     	 cmp r3,#0
 2146 05f8 08D0     	 beq .L146
 2147              	 .loc 3 1129 0 discriminator 4
 2148 05fa 654B     	 ldr r3,.L163+4
 2149 05fc 1B78     	 ldrb r3,[r3]
 2150 05fe 83F00103 	 eor r3,r3,#1
 2151 0602 DBB2     	 uxtb r3,r3
 2152 0604 002B     	 cmp r3,#0
 2153 0606 01D0     	 beq .L146
 2154              	.L145:
1130:../SSC/Src/ecatslv.c ****     {
1131:../SSC/Src/ecatslv.c ****         /* if the WD-Trigger in the Sync Manager Channel 2 Control-Byte is set (Bit 6 of Register 0
1132:../SSC/Src/ecatslv.c ****             an error has to be returned */
1133:../SSC/Src/ecatslv.c ****         return ALSTATUSCODE_INVALIDWDCFG;
 2155              	 .loc 3 1133 0 is_stmt 1
 2156 0608 1F23     	 movs r3,#31
 2157 060a BBE0     	 b .L89
 2158              	.L146:
1134:../SSC/Src/ecatslv.c ****     }
1135:../SSC/Src/ecatslv.c **** 
1136:../SSC/Src/ecatslv.c ****     if ( bEscIntEnabled && nPdOutputSize != 0 )
 2159              	 .loc 3 1136 0
 2160 060c 614B     	 ldr r3,.L163+8
 2161 060e 1B78     	 ldrb r3,[r3]
 2162 0610 002B     	 cmp r3,#0
 2163 0612 0AD0     	 beq .L147
 2164              	 .loc 3 1136 0 is_stmt 0 discriminator 1
 2165 0614 604B     	 ldr r3,.L163+12
 2166 0616 1B88     	 ldrh r3,[r3]
 2167 0618 002B     	 cmp r3,#0
 2168 061a 06D0     	 beq .L147
1137:../SSC/Src/ecatslv.c ****     {
1138:../SSC/Src/ecatslv.c ****         /* ECAT synchron Mode is active, the Sync Manager Channel 2 event
1139:../SSC/Src/ecatslv.c ****            has to activated in the AL-Event mask register */
1140:../SSC/Src/ecatslv.c ****         u16ALEventMask |= PROCESS_OUTPUT_EVENT;
 2169              	 .loc 3 1140 0 is_stmt 1
 2170 061c 5F4B     	 ldr r3,.L163+16
 2171 061e 1B88     	 ldrh r3,[r3]
 2172 0620 43F48063 	 orr r3,r3,#1024
 2173 0624 9AB2     	 uxth r2,r3
 2174 0626 5D4B     	 ldr r3,.L163+16
 2175 0628 1A80     	 strh r2,[r3]
 2176              	.L147:
1141:../SSC/Src/ecatslv.c ****     }
1142:../SSC/Src/ecatslv.c **** /*The application ESM function is separated from this function to handle pending transitions*/
1143:../SSC/Src/ecatslv.c **** 
1144:../SSC/Src/ecatslv.c ****     Sync0WdValue = 0;
 2177              	 .loc 3 1144 0
 2178 062a 5D4B     	 ldr r3,.L163+20
 2179 062c 0022     	 movs r2,#0
 2180 062e 1A80     	 strh r2,[r3]
1145:../SSC/Src/ecatslv.c ****     Sync0WdCounter = 0;
 2181              	 .loc 3 1145 0
 2182 0630 5C4B     	 ldr r3,.L163+24
 2183 0632 0022     	 movs r2,#0
 2184 0634 1A80     	 strh r2,[r3]
1146:../SSC/Src/ecatslv.c ****     Sync1WdCounter = 0;
 2185              	 .loc 3 1146 0
 2186 0636 5C4B     	 ldr r3,.L163+28
 2187 0638 0022     	 movs r2,#0
 2188 063a 1A80     	 strh r2,[r3]
1147:../SSC/Src/ecatslv.c ****     Sync1WdValue = 0;
 2189              	 .loc 3 1147 0
 2190 063c 5B4B     	 ldr r3,.L163+32
 2191 063e 0022     	 movs r2,#0
 2192 0640 1A80     	 strh r2,[r3]
1148:../SSC/Src/ecatslv.c ****     bDcRunning = FALSE;
 2193              	 .loc 3 1148 0
 2194 0642 5B4B     	 ldr r3,.L163+36
 2195 0644 0022     	 movs r2,#0
 2196 0646 1A70     	 strb r2,[r3]
1149:../SSC/Src/ecatslv.c ****     bSmSyncSequenceValid = FALSE;
 2197              	 .loc 3 1149 0
 2198 0648 5A4B     	 ldr r3,.L163+40
 2199 064a 0022     	 movs r2,#0
 2200 064c 1A70     	 strb r2,[r3]
1150:../SSC/Src/ecatslv.c ****     i16WaitForPllRunningTimeout = 0;
 2201              	 .loc 3 1150 0
 2202 064e 5A4B     	 ldr r3,.L163+44
 2203 0650 0022     	 movs r2,#0
 2204 0652 1A80     	 strh r2,[r3]
 2205              	.LBB5:
1151:../SSC/Src/ecatslv.c **** 
1152:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.13) ECAT1*/
1153:../SSC/Src/ecatslv.c ****     /*Get Sync mapped to AL Event indication*/
1154:../SSC/Src/ecatslv.c ****     {
1155:../SSC/Src/ecatslv.c ****         UINT8 u8TmpVar = 0;
 2206              	 .loc 3 1155 0
 2207 0654 0023     	 movs r3,#0
 2208 0656 FB73     	 strb r3,[r7,#15]
1156:../SSC/Src/ecatslv.c ****         HW_EscReadByte(u8TmpVar, ESC_PDI_CONFIGURATION);
 2209              	 .loc 3 1156 0
 2210 0658 584B     	 ldr r3,.L163+48
 2211 065a 1B78     	 ldrb r3,[r3]
 2212 065c FB73     	 strb r3,[r7,#15]
1157:../SSC/Src/ecatslv.c ****         if ((u8TmpVar & ESC_SYNC0_MAPPED_TO_ALEVENT) > 0)
 2213              	 .loc 3 1157 0
 2214 065e FB7B     	 ldrb r3,[r7,#15]
 2215 0660 03F00803 	 and r3,r3,#8
 2216 0664 002B     	 cmp r3,#0
 2217 0666 06DD     	 ble .L148
1158:../SSC/Src/ecatslv.c ****         {
1159:../SSC/Src/ecatslv.c ****             u16ALEventMask |= SYNC0_EVENT;
 2218              	 .loc 3 1159 0
 2219 0668 4C4B     	 ldr r3,.L163+16
 2220 066a 1B88     	 ldrh r3,[r3]
 2221 066c 43F00403 	 orr r3,r3,#4
 2222 0670 9AB2     	 uxth r2,r3
 2223 0672 4A4B     	 ldr r3,.L163+16
 2224 0674 1A80     	 strh r2,[r3]
 2225              	.L148:
1160:../SSC/Src/ecatslv.c ****         }
1161:../SSC/Src/ecatslv.c **** 
1162:../SSC/Src/ecatslv.c ****         if ((u8TmpVar & ESC_SYNC1_MAPPED_TO_ALEVENT) > 0)
 2226              	 .loc 3 1162 0
 2227 0676 FB7B     	 ldrb r3,[r7,#15]
 2228 0678 03F08003 	 and r3,r3,#128
 2229 067c 002B     	 cmp r3,#0
 2230 067e 06DD     	 ble .L149
1163:../SSC/Src/ecatslv.c ****         {
1164:../SSC/Src/ecatslv.c ****             u16ALEventMask |= SYNC1_EVENT;
 2231              	 .loc 3 1164 0
 2232 0680 464B     	 ldr r3,.L163+16
 2233 0682 1B88     	 ldrh r3,[r3]
 2234 0684 43F00803 	 orr r3,r3,#8
 2235 0688 9AB2     	 uxth r2,r3
 2236 068a 444B     	 ldr r3,.L163+16
 2237 068c 1A80     	 strh r2,[r3]
 2238              	.L149:
 2239              	.LBE5:
1165:../SSC/Src/ecatslv.c ****         }
1166:../SSC/Src/ecatslv.c ****     }
1167:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.13) ECAT1*/
1168:../SSC/Src/ecatslv.c ****     sSyncManInPar.u16SmEventMissedCounter = 0;
 2240              	 .loc 3 1168 0
 2241 068e 4C4B     	 ldr r3,.L163+52
 2242 0690 0022     	 movs r2,#0
 2243 0692 1A85     	 strh r2,[r3,#40]
1169:../SSC/Src/ecatslv.c ****     sSyncManInPar.u16CycleExceededCounter = 0;
 2244              	 .loc 3 1169 0
 2245 0694 4A4B     	 ldr r3,.L163+52
 2246 0696 0022     	 movs r2,#0
 2247 0698 5A85     	 strh r2,[r3,#42]
1170:../SSC/Src/ecatslv.c ****     sSyncManInPar.u8SyncError = 0;
 2248              	 .loc 3 1170 0
 2249 069a 494B     	 ldr r3,.L163+52
 2250 069c 0022     	 movs r2,#0
 2251 069e 83F84020 	 strb r2,[r3,#64]
1171:../SSC/Src/ecatslv.c **** 
1172:../SSC/Src/ecatslv.c **** 
1173:../SSC/Src/ecatslv.c ****     sSyncManOutPar.u16SmEventMissedCounter = 0;
 2252              	 .loc 3 1173 0
 2253 06a2 484B     	 ldr r3,.L163+56
 2254 06a4 0022     	 movs r2,#0
 2255 06a6 1A85     	 strh r2,[r3,#40]
1174:../SSC/Src/ecatslv.c ****     sSyncManOutPar.u16CycleExceededCounter = 0;
 2256              	 .loc 3 1174 0
 2257 06a8 464B     	 ldr r3,.L163+56
 2258 06aa 0022     	 movs r2,#0
 2259 06ac 5A85     	 strh r2,[r3,#42]
1175:../SSC/Src/ecatslv.c ****     sSyncManOutPar.u8SyncError = 0;
 2260              	 .loc 3 1175 0
 2261 06ae 454B     	 ldr r3,.L163+56
 2262 06b0 0022     	 movs r2,#0
 2263 06b2 83F84020 	 strb r2,[r3,#64]
1176:../SSC/Src/ecatslv.c **** 
1177:../SSC/Src/ecatslv.c ****     /* calculate the Sync0/Sync1 watchdog timeouts */
1178:../SSC/Src/ecatslv.c ****     if ( (dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0 )
 2264              	 .loc 3 1178 0
 2265 06b6 FB7F     	 ldrb r3,[r7,#31]
 2266 06b8 03F00203 	 and r3,r3,#2
 2267 06bc 002B     	 cmp r3,#0
 2268 06be 50D0     	 beq .L150
1179:../SSC/Src/ecatslv.c ****     {
1180:../SSC/Src/ecatslv.c ****         /*calculate the Sync0 Watchdog counter value the minimum value is 1 ms
1181:../SSC/Src/ecatslv.c ****             if the sync0 cycle is greater 500us the Sync0 Wd value is 2*Sycn0 cycle */
1182:../SSC/Src/ecatslv.c ****         if(cycleTimeSync0 == 0)
 2269              	 .loc 3 1182 0
 2270 06c0 FB6A     	 ldr r3,[r7,#44]
 2271 06c2 002B     	 cmp r3,#0
 2272 06c4 03D1     	 bne .L151
1183:../SSC/Src/ecatslv.c ****         {
1184:../SSC/Src/ecatslv.c ****             Sync0WdValue = 0;
 2273              	 .loc 3 1184 0
 2274 06c6 364B     	 ldr r3,.L163+20
 2275 06c8 0022     	 movs r2,#0
 2276 06ca 1A80     	 strh r2,[r3]
 2277 06cc 18E0     	 b .L152
 2278              	.L151:
 2279              	.LBB6:
1185:../SSC/Src/ecatslv.c ****         }
1186:../SSC/Src/ecatslv.c ****         else
1187:../SSC/Src/ecatslv.c ****         {
1188:../SSC/Src/ecatslv.c ****             UINT32 Sync0Cycle = cycleTimeSync0/100000;
 2280              	 .loc 3 1188 0
 2281 06ce FB6A     	 ldr r3,[r7,#44]
 2282 06d0 5B09     	 lsrs r3,r3,#5
 2283 06d2 3D4A     	 ldr r2,.L163+60
 2284 06d4 A2FB0323 	 umull r2,r3,r2,r3
 2285 06d8 DB09     	 lsrs r3,r3,#7
 2286 06da BB60     	 str r3,[r7,#8]
1189:../SSC/Src/ecatslv.c **** 
1190:../SSC/Src/ecatslv.c ****             if(Sync0Cycle < 5)
 2287              	 .loc 3 1190 0
 2288 06dc BB68     	 ldr r3,[r7,#8]
 2289 06de 042B     	 cmp r3,#4
 2290 06e0 03D8     	 bhi .L153
1191:../SSC/Src/ecatslv.c ****             {
1192:../SSC/Src/ecatslv.c ****                 /*Sync0 cycle less than 500us*/
1193:../SSC/Src/ecatslv.c ****                 Sync0WdValue = 1;
 2291              	 .loc 3 1193 0
 2292 06e2 2F4B     	 ldr r3,.L163+20
 2293 06e4 0122     	 movs r2,#1
 2294 06e6 1A80     	 strh r2,[r3]
 2295 06e8 0AE0     	 b .L152
 2296              	.L153:
1194:../SSC/Src/ecatslv.c ****             }
1195:../SSC/Src/ecatslv.c ****             else
1196:../SSC/Src/ecatslv.c ****             {
1197:../SSC/Src/ecatslv.c ****                 Sync0WdValue = (UINT16)(Sync0Cycle*2)/10;
 2297              	 .loc 3 1197 0
 2298 06ea BB68     	 ldr r3,[r7,#8]
 2299 06ec 9BB2     	 uxth r3,r3
 2300 06ee 5B00     	 lsls r3,r3,#1
 2301 06f0 9BB2     	 uxth r3,r3
 2302 06f2 364A     	 ldr r2,.L163+64
 2303 06f4 A2FB0323 	 umull r2,r3,r2,r3
 2304 06f8 DB08     	 lsrs r3,r3,#3
 2305 06fa 9AB2     	 uxth r2,r3
 2306 06fc 284B     	 ldr r3,.L163+20
 2307 06fe 1A80     	 strh r2,[r3]
 2308              	.L152:
 2309              	.LBE6:
1198:../SSC/Src/ecatslv.c ****             }
1199:../SSC/Src/ecatslv.c ****         }
1200:../SSC/Src/ecatslv.c **** 
1201:../SSC/Src/ecatslv.c ****         /* Calculate also the watchdog time for Sync1*/
1202:../SSC/Src/ecatslv.c ****         if ( (dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0 )
 2310              	 .loc 3 1202 0
 2311 0700 FB7F     	 ldrb r3,[r7,#31]
 2312 0702 03F00403 	 and r3,r3,#4
 2313 0706 002B     	 cmp r3,#0
 2314 0708 2BD0     	 beq .L150
1203:../SSC/Src/ecatslv.c ****         {
1204:../SSC/Src/ecatslv.c ****             if(shiftTimeSync1 < cycleTimeSync0)
 2315              	 .loc 3 1204 0
 2316 070a BA6A     	 ldr r2,[r7,#40]
 2317 070c FB6A     	 ldr r3,[r7,#44]
 2318 070e 9A42     	 cmp r2,r3
 2319 0710 04D2     	 bcs .L154
1205:../SSC/Src/ecatslv.c ****         {
1206:../SSC/Src/ecatslv.c ****                 /* Sync 1 has the same cycle time than Sync0 (maybe with a shift (shiftTimeSync1 > 
1207:../SSC/Src/ecatslv.c ****                 Sync1WdValue = Sync0WdValue;
 2320              	 .loc 3 1207 0
 2321 0712 234B     	 ldr r3,.L163+20
 2322 0714 1A88     	 ldrh r2,[r3]
 2323 0716 254B     	 ldr r3,.L163+32
 2324 0718 1A80     	 strh r2,[r3]
 2325 071a 22E0     	 b .L150
 2326              	.L154:
 2327              	.LBB7:
1208:../SSC/Src/ecatslv.c ****         }
1209:../SSC/Src/ecatslv.c ****         else
1210:../SSC/Src/ecatslv.c ****         {
1211:../SSC/Src/ecatslv.c ****                 /* Sync1 cycle is larger than Sync0 (e.g. subordinated Sync0 cycles) */
1212:../SSC/Src/ecatslv.c ****                 UINT32 Sync1Cycle = (shiftTimeSync1  + cycleTimeSync0 )/100000;
 2328              	 .loc 3 1212 0
 2329 071c BA6A     	 ldr r2,[r7,#40]
 2330 071e FB6A     	 ldr r3,[r7,#44]
 2331 0720 1344     	 add r3,r3,r2
 2332 0722 5B09     	 lsrs r3,r3,#5
 2333 0724 284A     	 ldr r2,.L163+60
 2334 0726 A2FB0323 	 umull r2,r3,r2,r3
 2335 072a DB09     	 lsrs r3,r3,#7
 2336 072c 7B60     	 str r3,[r7,#4]
1213:../SSC/Src/ecatslv.c ****                 if(Sync1Cycle < 5)
 2337              	 .loc 3 1213 0
 2338 072e 7B68     	 ldr r3,[r7,#4]
 2339 0730 042B     	 cmp r3,#4
 2340 0732 03D8     	 bhi .L155
1214:../SSC/Src/ecatslv.c ****                 {
1215:../SSC/Src/ecatslv.c ****                     /*Sync0 cycle less than 500us*/
1216:../SSC/Src/ecatslv.c ****                     Sync1WdValue = 1;
 2341              	 .loc 3 1216 0
 2342 0734 1D4B     	 ldr r3,.L163+32
 2343 0736 0122     	 movs r2,#1
 2344 0738 1A80     	 strh r2,[r3]
 2345 073a 08E0     	 b .L156
 2346              	.L155:
1217:../SSC/Src/ecatslv.c ****                 }
1218:../SSC/Src/ecatslv.c ****                 else
1219:../SSC/Src/ecatslv.c ****                 {
1220:../SSC/Src/ecatslv.c ****                     Sync1WdValue = (UINT16)((Sync1Cycle*2)/10);
 2347              	 .loc 3 1220 0
 2348 073c 7B68     	 ldr r3,[r7,#4]
 2349 073e 5B00     	 lsls r3,r3,#1
 2350 0740 224A     	 ldr r2,.L163+64
 2351 0742 A2FB0323 	 umull r2,r3,r2,r3
 2352 0746 DB08     	 lsrs r3,r3,#3
 2353 0748 9AB2     	 uxth r2,r3
 2354 074a 184B     	 ldr r3,.L163+32
 2355 074c 1A80     	 strh r2,[r3]
 2356              	.L156:
1221:../SSC/Src/ecatslv.c ****                 }
1222:../SSC/Src/ecatslv.c **** 
1223:../SSC/Src/ecatslv.c ****                 /* add one Sync0 cycle because the Sync1 cycle starts on the next Sync0 after the S
1224:../SSC/Src/ecatslv.c ****                 Sync1WdValue += Sync0WdValue/2;
 2357              	 .loc 3 1224 0
 2358 074e 144B     	 ldr r3,.L163+20
 2359 0750 1B88     	 ldrh r3,[r3]
 2360 0752 5B08     	 lsrs r3,r3,#1
 2361 0754 9AB2     	 uxth r2,r3
 2362 0756 154B     	 ldr r3,.L163+32
 2363 0758 1B88     	 ldrh r3,[r3]
 2364 075a 1344     	 add r3,r3,r2
 2365 075c 9AB2     	 uxth r2,r3
 2366 075e 134B     	 ldr r3,.L163+32
 2367 0760 1A80     	 strh r2,[r3]
 2368              	.L150:
 2369              	.LBE7:
1225:../SSC/Src/ecatslv.c ****             }
1226:../SSC/Src/ecatslv.c ****     }
1227:../SSC/Src/ecatslv.c ****     }
1228:../SSC/Src/ecatslv.c **** 
1229:../SSC/Src/ecatslv.c ****     if(nPdOutputSize > 0)
 2370              	 .loc 3 1229 0
 2371 0762 0D4B     	 ldr r3,.L163+12
 2372 0764 1B88     	 ldrh r3,[r3]
 2373 0766 002B     	 cmp r3,#0
 2374 0768 02D0     	 beq .L157
1230:../SSC/Src/ecatslv.c ****     {
1231:../SSC/Src/ecatslv.c ****         EnableSyncManChannel(PROCESS_DATA_OUT);
 2375              	 .loc 3 1231 0
 2376 076a 0220     	 movs r0,#2
 2377 076c FFF7FEFF 	 bl EnableSyncManChannel
 2378              	.L157:
1232:../SSC/Src/ecatslv.c ****     }
1233:../SSC/Src/ecatslv.c **** 
1234:../SSC/Src/ecatslv.c ****     if(nPdInputSize > 0)
 2379              	 .loc 3 1234 0
 2380 0770 174B     	 ldr r3,.L163+68
 2381 0772 1B88     	 ldrh r3,[r3]
 2382 0774 002B     	 cmp r3,#0
 2383 0776 02D0     	 beq .L158
1235:../SSC/Src/ecatslv.c ****     {
1236:../SSC/Src/ecatslv.c ****         EnableSyncManChannel(PROCESS_DATA_IN);
 2384              	 .loc 3 1236 0
 2385 0778 0320     	 movs r0,#3
 2386 077a FFF7FEFF 	 bl EnableSyncManChannel
 2387              	.L158:
1237:../SSC/Src/ecatslv.c ****     }
1238:../SSC/Src/ecatslv.c **** 
1239:../SSC/Src/ecatslv.c ****     /*write initial input data*/
1240:../SSC/Src/ecatslv.c ****     PDO_InputMapping();
 2388              	 .loc 3 1240 0
 2389 077e FFF7FEFF 	 bl PDO_InputMapping
1241:../SSC/Src/ecatslv.c **** 
1242:../SSC/Src/ecatslv.c ****     return ALSTATUSCODE_NOERROR;
 2390              	 .loc 3 1242 0
 2391 0782 0023     	 movs r3,#0
 2392              	.L89:
1243:../SSC/Src/ecatslv.c **** }
 2393              	 .loc 3 1243 0
 2394 0784 1846     	 mov r0,r3
 2395 0786 4037     	 adds r7,r7,#64
 2396              	.LCFI52:
 2397              	 .cfi_def_cfa_offset 8
 2398 0788 BD46     	 mov sp,r7
 2399              	.LCFI53:
 2400              	 .cfi_def_cfa_register 13
 2401              	 
 2402 078a 80BD     	 pop {r7,pc}
 2403              	.L164:
 2404              	 .align 2
 2405              	.L163:
 2406 078c 00000000 	 .word EcatWdValue
 2407 0790 00000000 	 .word bWdTrigger
 2408 0794 00000000 	 .word bEscIntEnabled
 2409 0798 00000000 	 .word nPdOutputSize
 2410 079c 00000000 	 .word u16ALEventMask
 2411 07a0 00000000 	 .word Sync0WdValue
 2412 07a4 00000000 	 .word Sync0WdCounter
 2413 07a8 00000000 	 .word Sync1WdCounter
 2414 07ac 00000000 	 .word Sync1WdValue
 2415 07b0 00000000 	 .word bDcRunning
 2416 07b4 00000000 	 .word bSmSyncSequenceValid
 2417 07b8 00000000 	 .word i16WaitForPllRunningTimeout
 2418 07bc 51010154 	 .word 1409352017
 2419 07c0 00000000 	 .word sSyncManInPar
 2420 07c4 00000000 	 .word sSyncManOutPar
 2421 07c8 C55A7C0A 	 .word 175921861
 2422 07cc CDCCCCCC 	 .word -858993459
 2423 07d0 00000000 	 .word nPdInputSize
 2424              	 .cfi_endproc
 2425              	.LFE182:
 2427              	 .section .text.StartOutputHandler,"ax",%progbits
 2428              	 .align 2
 2429              	 .global StartOutputHandler
 2430              	 .thumb
 2431              	 .thumb_func
 2433              	StartOutputHandler:
 2434              	.LFB183:
1244:../SSC/Src/ecatslv.c **** 
1245:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
1246:../SSC/Src/ecatslv.c **** /**
1247:../SSC/Src/ecatslv.c ****  \return    AL Status Code (see ecatslv.h ALSTATUSCODE_....)
1248:../SSC/Src/ecatslv.c **** 
1249:../SSC/Src/ecatslv.c ****  \brief    This function is called in case of the state transition from SAFEOP to OP.
1250:../SSC/Src/ecatslv.c ****  \brief  It will be checked if outputs had to be received before switching to OP
1251:../SSC/Src/ecatslv.c ****  \brief  and the state transition would be refused if outputs are missing
1252:../SSC/Src/ecatslv.c **** 
1253:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
1254:../SSC/Src/ecatslv.c **** 
1255:../SSC/Src/ecatslv.c **** UINT16 StartOutputHandler(void)
1256:../SSC/Src/ecatslv.c **** {
 2435              	 .loc 3 1256 0
 2436              	 .cfi_startproc
 2437              	 
 2438              	 
 2439              	 
 2440 0000 80B4     	 push {r7}
 2441              	.LCFI54:
 2442              	 .cfi_def_cfa_offset 4
 2443              	 .cfi_offset 7,-4
 2444 0002 83B0     	 sub sp,sp,#12
 2445              	.LCFI55:
 2446              	 .cfi_def_cfa_offset 16
 2447 0004 00AF     	 add r7,sp,#0
 2448              	.LCFI56:
 2449              	 .cfi_def_cfa_register 7
1257:../SSC/Src/ecatslv.c ****     /* by default the SO transition should be completed in AlControlRes().
1258:../SSC/Src/ecatslv.c ****        required to support also masters which starts to send process data after the SO transition w
1259:../SSC/Src/ecatslv.c ****        (if the master don't send process data within "SAFEOP2OPTIMEOUT" the transition is rejected)
1260:../SSC/Src/ecatslv.c ****     UINT16 result = NOERROR_INWORK;
 2450              	 .loc 3 1260 0
 2451 0006 FF23     	 movs r3,#255
 2452 0008 FB80     	 strh r3,[r7,#6]
1261:../SSC/Src/ecatslv.c ****     /*ECATCHANGE_START(V5.13) ESM1*/
1262:../SSC/Src/ecatslv.c ****     if(STATE_VALID(u8LocalErrorState))
 2453              	 .loc 3 1262 0
 2454 000a 1D4B     	 ldr r3,.L170
 2455 000c 1B78     	 ldrb r3,[r3]
 2456 000e 03F00F03 	 and r3,r3,#15
 2457 0012 012B     	 cmp r3,#1
 2458 0014 11D0     	 beq .L166
 2459              	 .loc 3 1262 0 is_stmt 0 discriminator 1
 2460 0016 1A4B     	 ldr r3,.L170
 2461 0018 1B78     	 ldrb r3,[r3]
 2462 001a 03F00F03 	 and r3,r3,#15
 2463 001e 022B     	 cmp r3,#2
 2464 0020 0BD0     	 beq .L166
 2465              	 .loc 3 1262 0 discriminator 2
 2466 0022 174B     	 ldr r3,.L170
 2467 0024 1B78     	 ldrb r3,[r3]
 2468 0026 03F00F03 	 and r3,r3,#15
 2469 002a 042B     	 cmp r3,#4
 2470 002c 05D0     	 beq .L166
 2471              	 .loc 3 1262 0 discriminator 3
 2472 002e 144B     	 ldr r3,.L170
 2473 0030 1B78     	 ldrb r3,[r3]
 2474 0032 03F00F03 	 and r3,r3,#15
 2475 0036 082B     	 cmp r3,#8
 2476 0038 02D1     	 bne .L167
 2477              	.L166:
1263:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.13) ESM1*/
1264:../SSC/Src/ecatslv.c ****     {
1265:../SSC/Src/ecatslv.c ****         /*Local error still exists => skip state request to OP and response with "u16LocalErrorCode
1266:../SSC/Src/ecatslv.c ****         return u16LocalErrorCode;
 2478              	 .loc 3 1266 0 is_stmt 1
 2479 003a 124B     	 ldr r3,.L170+4
 2480 003c 1B88     	 ldrh r3,[r3]
 2481 003e 18E0     	 b .L168
 2482              	.L167:
1267:../SSC/Src/ecatslv.c ****     }
1268:../SSC/Src/ecatslv.c **** /*The application ESM function is separated from this function to handle pending transitions*/
1269:../SSC/Src/ecatslv.c **** 
1270:../SSC/Src/ecatslv.c **** 
1271:../SSC/Src/ecatslv.c ****     /*DC synchronisation is active wait until pll is valid*/
1272:../SSC/Src/ecatslv.c ****     if(bDcSyncActive)
 2483              	 .loc 3 1272 0
 2484 0040 114B     	 ldr r3,.L170+8
 2485 0042 1B78     	 ldrb r3,[r3]
 2486 0044 002B     	 cmp r3,#0
 2487 0046 05D0     	 beq .L169
1273:../SSC/Src/ecatslv.c ****     {
1274:../SSC/Src/ecatslv.c ****         i16WaitForPllRunningTimeout = 200;
 2488              	 .loc 3 1274 0
 2489 0048 104B     	 ldr r3,.L170+12
 2490 004a C822     	 movs r2,#200
 2491 004c 1A80     	 strh r2,[r3]
1275:../SSC/Src/ecatslv.c **** 
1276:../SSC/Src/ecatslv.c ****         i16WaitForPllRunningCnt = 0;
 2492              	 .loc 3 1276 0
 2493 004e 104B     	 ldr r3,.L170+16
 2494 0050 0022     	 movs r2,#0
 2495 0052 1A80     	 strh r2,[r3]
 2496              	.L169:
1277:../SSC/Src/ecatslv.c ****     }
1278:../SSC/Src/ecatslv.c **** 
1279:../SSC/Src/ecatslv.c **** 
1280:../SSC/Src/ecatslv.c **** 
1281:../SSC/Src/ecatslv.c ****     sSyncManOutPar.u16SmEventMissedCounter = 0;
 2497              	 .loc 3 1281 0
 2498 0054 0F4B     	 ldr r3,.L170+20
 2499 0056 0022     	 movs r2,#0
 2500 0058 1A85     	 strh r2,[r3,#40]
1282:../SSC/Src/ecatslv.c ****     sSyncManOutPar.u8SyncError = 0;
 2501              	 .loc 3 1282 0
 2502 005a 0E4B     	 ldr r3,.L170+20
 2503 005c 0022     	 movs r2,#0
 2504 005e 83F84020 	 strb r2,[r3,#64]
1283:../SSC/Src/ecatslv.c **** 
1284:../SSC/Src/ecatslv.c **** 
1285:../SSC/Src/ecatslv.c ****     sSyncManInPar.u16SmEventMissedCounter = 0;
 2505              	 .loc 3 1285 0
 2506 0062 0D4B     	 ldr r3,.L170+24
 2507 0064 0022     	 movs r2,#0
 2508 0066 1A85     	 strh r2,[r3,#40]
1286:../SSC/Src/ecatslv.c ****     sSyncManInPar.u8SyncError = 0;
 2509              	 .loc 3 1286 0
 2510 0068 0B4B     	 ldr r3,.L170+24
 2511 006a 0022     	 movs r2,#0
 2512 006c 83F84020 	 strb r2,[r3,#64]
1287:../SSC/Src/ecatslv.c **** 
1288:../SSC/Src/ecatslv.c **** 
1289:../SSC/Src/ecatslv.c ****     return result;
 2513              	 .loc 3 1289 0
 2514 0070 FB88     	 ldrh r3,[r7,#6]
 2515              	.L168:
1290:../SSC/Src/ecatslv.c **** }
 2516              	 .loc 3 1290 0
 2517 0072 1846     	 mov r0,r3
 2518 0074 0C37     	 adds r7,r7,#12
 2519              	.LCFI57:
 2520              	 .cfi_def_cfa_offset 4
 2521 0076 BD46     	 mov sp,r7
 2522              	.LCFI58:
 2523              	 .cfi_def_cfa_register 13
 2524              	 
 2525 0078 5DF8047B 	 ldr r7,[sp],#4
 2526              	.LCFI59:
 2527              	 .cfi_restore 7
 2528              	 .cfi_def_cfa_offset 0
 2529 007c 7047     	 bx lr
 2530              	.L171:
 2531 007e 00BF     	 .align 2
 2532              	.L170:
 2533 0080 00000000 	 .word u8LocalErrorState
 2534 0084 00000000 	 .word u16LocalErrorCode
 2535 0088 00000000 	 .word bDcSyncActive
 2536 008c 00000000 	 .word i16WaitForPllRunningTimeout
 2537 0090 00000000 	 .word i16WaitForPllRunningCnt
 2538 0094 00000000 	 .word sSyncManOutPar
 2539 0098 00000000 	 .word sSyncManInPar
 2540              	 .cfi_endproc
 2541              	.LFE183:
 2543              	 .section .text.StopOutputHandler,"ax",%progbits
 2544              	 .align 2
 2545              	 .global StopOutputHandler
 2546              	 .thumb
 2547              	 .thumb_func
 2549              	StopOutputHandler:
 2550              	.LFB184:
1291:../SSC/Src/ecatslv.c **** 
1292:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
1293:../SSC/Src/ecatslv.c **** /**
1294:../SSC/Src/ecatslv.c ****  \brief    This function is called in case of the state transition from OP to SAFEOP
1295:../SSC/Src/ecatslv.c ****  \brief  the outputs can be set to an application specific safe state,
1296:../SSC/Src/ecatslv.c ****  \brief  the state transition can be delayed by returning NOERROR_INWORK
1297:../SSC/Src/ecatslv.c **** 
1298:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
1299:../SSC/Src/ecatslv.c **** 
1300:../SSC/Src/ecatslv.c **** void StopOutputHandler(void)
1301:../SSC/Src/ecatslv.c **** {
 2551              	 .loc 3 1301 0
 2552              	 .cfi_startproc
 2553              	 
 2554              	 
 2555              	 
 2556 0000 80B4     	 push {r7}
 2557              	.LCFI60:
 2558              	 .cfi_def_cfa_offset 4
 2559              	 .cfi_offset 7,-4
 2560 0002 00AF     	 add r7,sp,#0
 2561              	.LCFI61:
 2562              	 .cfi_def_cfa_register 7
1302:../SSC/Src/ecatslv.c ****     /* reset the flags that outputs were received and that the slave is in OP */
1303:../SSC/Src/ecatslv.c ****     bEcatFirstOutputsReceived = FALSE;
 2563              	 .loc 3 1303 0
 2564 0004 044B     	 ldr r3,.L173
 2565 0006 0022     	 movs r2,#0
 2566 0008 1A70     	 strb r2,[r3]
1304:../SSC/Src/ecatslv.c ****     bEcatOutputUpdateRunning = FALSE;
 2567              	 .loc 3 1304 0
 2568 000a 044B     	 ldr r3,.L173+4
 2569 000c 0022     	 movs r2,#0
 2570 000e 1A70     	 strb r2,[r3]
1305:../SSC/Src/ecatslv.c **** }
 2571              	 .loc 3 1305 0
 2572 0010 BD46     	 mov sp,r7
 2573              	.LCFI62:
 2574              	 .cfi_def_cfa_register 13
 2575              	 
 2576 0012 5DF8047B 	 ldr r7,[sp],#4
 2577              	.LCFI63:
 2578              	 .cfi_restore 7
 2579              	 .cfi_def_cfa_offset 0
 2580 0016 7047     	 bx lr
 2581              	.L174:
 2582              	 .align 2
 2583              	.L173:
 2584 0018 00000000 	 .word bEcatFirstOutputsReceived
 2585 001c 00000000 	 .word bEcatOutputUpdateRunning
 2586              	 .cfi_endproc
 2587              	.LFE184:
 2589              	 .section .text.StopInputHandler,"ax",%progbits
 2590              	 .align 2
 2591              	 .global StopInputHandler
 2592              	 .thumb
 2593              	 .thumb_func
 2595              	StopInputHandler:
 2596              	.LFB185:
1306:../SSC/Src/ecatslv.c **** 
1307:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
1308:../SSC/Src/ecatslv.c **** /**
1309:../SSC/Src/ecatslv.c ****   \brief    This function is called in case of the state transition from SAFEOP to PREOP
1310:../SSC/Src/ecatslv.c **** 
1311:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
1312:../SSC/Src/ecatslv.c **** 
1313:../SSC/Src/ecatslv.c **** void StopInputHandler(void)
1314:../SSC/Src/ecatslv.c **** {
 2597              	 .loc 3 1314 0
 2598              	 .cfi_startproc
 2599              	 
 2600              	 
 2601 0000 80B5     	 push {r7,lr}
 2602              	.LCFI64:
 2603              	 .cfi_def_cfa_offset 8
 2604              	 .cfi_offset 7,-8
 2605              	 .cfi_offset 14,-4
 2606 0002 82B0     	 sub sp,sp,#8
 2607              	.LCFI65:
 2608              	 .cfi_def_cfa_offset 16
 2609 0004 00AF     	 add r7,sp,#0
 2610              	.LCFI66:
 2611              	 .cfi_def_cfa_register 7
1315:../SSC/Src/ecatslv.c ****     if(nPdOutputSize > 0)
 2612              	 .loc 3 1315 0
 2613 0006 344B     	 ldr r3,.L178
 2614 0008 1B88     	 ldrh r3,[r3]
 2615 000a 002B     	 cmp r3,#0
 2616 000c 02D0     	 beq .L176
1316:../SSC/Src/ecatslv.c ****     {
1317:../SSC/Src/ecatslv.c ****         /* disable the Sync Manager Channel 2 (outputs) */
1318:../SSC/Src/ecatslv.c ****         DisableSyncManChannel(PROCESS_DATA_OUT);
 2617              	 .loc 3 1318 0
 2618 000e 0220     	 movs r0,#2
 2619 0010 FFF7FEFF 	 bl DisableSyncManChannel
 2620              	.L176:
1319:../SSC/Src/ecatslv.c ****     }
1320:../SSC/Src/ecatslv.c **** 
1321:../SSC/Src/ecatslv.c ****     if(nPdInputSize > 0)
 2621              	 .loc 3 1321 0
 2622 0014 314B     	 ldr r3,.L178+4
 2623 0016 1B88     	 ldrh r3,[r3]
 2624 0018 002B     	 cmp r3,#0
 2625 001a 02D0     	 beq .L177
1322:../SSC/Src/ecatslv.c ****     {
1323:../SSC/Src/ecatslv.c ****         /*disable Sync Manager 3 (inputs) if no outputs available*/
1324:../SSC/Src/ecatslv.c ****         DisableSyncManChannel(PROCESS_DATA_IN);
 2626              	 .loc 3 1324 0
 2627 001c 0320     	 movs r0,#3
 2628 001e FFF7FEFF 	 bl DisableSyncManChannel
 2629              	.L177:
 2630              	.LBB8:
1325:../SSC/Src/ecatslv.c ****     }
1326:../SSC/Src/ecatslv.c **** 
1327:../SSC/Src/ecatslv.c ****     /* reset the events in the AL Event mask register (0x204) */
1328:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.13) ECAT1*/
1329:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.13) ECAT1*/
1330:../SSC/Src/ecatslv.c ****     {
1331:../SSC/Src/ecatslv.c ****         UINT16 ResetMask = SYNC0_EVENT | SYNC1_EVENT;
 2631              	 .loc 3 1331 0
 2632 0022 0C23     	 movs r3,#12
 2633 0024 FB80     	 strh r3,[r7,#6]
1332:../SSC/Src/ecatslv.c ****         ResetMask |= PROCESS_OUTPUT_EVENT;
 2634              	 .loc 3 1332 0
 2635 0026 FB88     	 ldrh r3,[r7,#6]
 2636 0028 43F48063 	 orr r3,r3,#1024
 2637 002c FB80     	 strh r3,[r7,#6]
1333:../SSC/Src/ecatslv.c ****         ResetMask |= PROCESS_INPUT_EVENT;
 2638              	 .loc 3 1333 0
 2639 002e FB88     	 ldrh r3,[r7,#6]
 2640 0030 43F40063 	 orr r3,r3,#2048
 2641 0034 FB80     	 strh r3,[r7,#6]
1334:../SSC/Src/ecatslv.c **** 
1335:../SSC/Src/ecatslv.c ****     ResetALEventMask( ~(ResetMask) );
 2642              	 .loc 3 1335 0
 2643 0036 FB88     	 ldrh r3,[r7,#6]
 2644 0038 DB43     	 mvns r3,r3
 2645 003a 9BB2     	 uxth r3,r3
 2646 003c 1846     	 mov r0,r3
 2647 003e FFF7FEFF 	 bl ResetALEventMask
 2648              	.LBE8:
1336:../SSC/Src/ecatslv.c ****     }
1337:../SSC/Src/ecatslv.c ****     /* reset the flags */
1338:../SSC/Src/ecatslv.c ****     bEcatFirstOutputsReceived = FALSE;
 2649              	 .loc 3 1338 0
 2650 0042 274B     	 ldr r3,.L178+8
 2651 0044 0022     	 movs r2,#0
 2652 0046 1A70     	 strb r2,[r3]
1339:../SSC/Src/ecatslv.c ****     bEscIntEnabled = FALSE;
 2653              	 .loc 3 1339 0
 2654 0048 264B     	 ldr r3,.L178+12
 2655 004a 0022     	 movs r2,#0
 2656 004c 1A70     	 strb r2,[r3]
1340:../SSC/Src/ecatslv.c **** /*The application ESM function is separated from this function to handle pending transitions*/
1341:../SSC/Src/ecatslv.c **** 
1342:../SSC/Src/ecatslv.c ****     bDcSyncActive = FALSE;
 2657              	 .loc 3 1342 0
 2658 004e 264B     	 ldr r3,.L178+16
 2659 0050 0022     	 movs r2,#0
 2660 0052 1A70     	 strb r2,[r3]
1343:../SSC/Src/ecatslv.c ****     bDcRunning = FALSE;
 2661              	 .loc 3 1343 0
 2662 0054 254B     	 ldr r3,.L178+20
 2663 0056 0022     	 movs r2,#0
 2664 0058 1A70     	 strb r2,[r3]
1344:../SSC/Src/ecatslv.c ****     bSmSyncSequenceValid = FALSE;
 2665              	 .loc 3 1344 0
 2666 005a 254B     	 ldr r3,.L178+24
 2667 005c 0022     	 movs r2,#0
 2668 005e 1A70     	 strb r2,[r3]
1345:../SSC/Src/ecatslv.c ****     u16SmSync0Value = 0;
 2669              	 .loc 3 1345 0
 2670 0060 244B     	 ldr r3,.L178+28
 2671 0062 0022     	 movs r2,#0
 2672 0064 1A80     	 strh r2,[r3]
1346:../SSC/Src/ecatslv.c ****     u16SmSync0Counter = 0;
 2673              	 .loc 3 1346 0
 2674 0066 244B     	 ldr r3,.L178+32
 2675 0068 0022     	 movs r2,#0
 2676 006a 1A80     	 strh r2,[r3]
1347:../SSC/Src/ecatslv.c **** 
1348:../SSC/Src/ecatslv.c ****     Sync0WdValue = 0;
 2677              	 .loc 3 1348 0
 2678 006c 234B     	 ldr r3,.L178+36
 2679 006e 0022     	 movs r2,#0
 2680 0070 1A80     	 strh r2,[r3]
1349:../SSC/Src/ecatslv.c ****     Sync0WdCounter = 0;
 2681              	 .loc 3 1349 0
 2682 0072 234B     	 ldr r3,.L178+40
 2683 0074 0022     	 movs r2,#0
 2684 0076 1A80     	 strh r2,[r3]
1350:../SSC/Src/ecatslv.c ****     Sync1WdCounter = 0;
 2685              	 .loc 3 1350 0
 2686 0078 224B     	 ldr r3,.L178+44
 2687 007a 0022     	 movs r2,#0
 2688 007c 1A80     	 strh r2,[r3]
1351:../SSC/Src/ecatslv.c ****     Sync1WdValue = 0;
 2689              	 .loc 3 1351 0
 2690 007e 224B     	 ldr r3,.L178+48
 2691 0080 0022     	 movs r2,#0
 2692 0082 1A80     	 strh r2,[r3]
1352:../SSC/Src/ecatslv.c ****     LatchInputSync0Value = 0;
 2693              	 .loc 3 1352 0
 2694 0084 214B     	 ldr r3,.L178+52
 2695 0086 0022     	 movs r2,#0
 2696 0088 1A80     	 strh r2,[r3]
1353:../SSC/Src/ecatslv.c ****     LatchInputSync0Counter = 0;
 2697              	 .loc 3 1353 0
 2698 008a 214B     	 ldr r3,.L178+56
 2699 008c 0022     	 movs r2,#0
 2700 008e 1A80     	 strh r2,[r3]
1354:../SSC/Src/ecatslv.c **** 
1355:../SSC/Src/ecatslv.c **** 
1356:../SSC/Src/ecatslv.c ****     sSyncManOutPar.u16SmEventMissedCounter = 0;
 2701              	 .loc 3 1356 0
 2702 0090 204B     	 ldr r3,.L178+60
 2703 0092 0022     	 movs r2,#0
 2704 0094 1A85     	 strh r2,[r3,#40]
1357:../SSC/Src/ecatslv.c ****     sSyncManOutPar.u16CycleExceededCounter = 0;
 2705              	 .loc 3 1357 0
 2706 0096 1F4B     	 ldr r3,.L178+60
 2707 0098 0022     	 movs r2,#0
 2708 009a 5A85     	 strh r2,[r3,#42]
1358:../SSC/Src/ecatslv.c ****     sSyncManOutPar.u8SyncError = 0;
 2709              	 .loc 3 1358 0
 2710 009c 1D4B     	 ldr r3,.L178+60
 2711 009e 0022     	 movs r2,#0
 2712 00a0 83F84020 	 strb r2,[r3,#64]
1359:../SSC/Src/ecatslv.c **** 
1360:../SSC/Src/ecatslv.c **** 
1361:../SSC/Src/ecatslv.c ****     sSyncManInPar.u16SmEventMissedCounter = 0;
 2713              	 .loc 3 1361 0
 2714 00a4 1C4B     	 ldr r3,.L178+64
 2715 00a6 0022     	 movs r2,#0
 2716 00a8 1A85     	 strh r2,[r3,#40]
1362:../SSC/Src/ecatslv.c ****     sSyncManInPar.u16CycleExceededCounter = 0;
 2717              	 .loc 3 1362 0
 2718 00aa 1B4B     	 ldr r3,.L178+64
 2719 00ac 0022     	 movs r2,#0
 2720 00ae 5A85     	 strh r2,[r3,#42]
1363:../SSC/Src/ecatslv.c ****     sSyncManInPar.u8SyncError = 0;
 2721              	 .loc 3 1363 0
 2722 00b0 194B     	 ldr r3,.L178+64
 2723 00b2 0022     	 movs r2,#0
 2724 00b4 83F84020 	 strb r2,[r3,#64]
1364:../SSC/Src/ecatslv.c **** 
1365:../SSC/Src/ecatslv.c ****     i16WaitForPllRunningTimeout = 0;
 2725              	 .loc 3 1365 0
 2726 00b8 184B     	 ldr r3,.L178+68
 2727 00ba 0022     	 movs r2,#0
 2728 00bc 1A80     	 strh r2,[r3]
1366:../SSC/Src/ecatslv.c **** 
1367:../SSC/Src/ecatslv.c ****     bWdTrigger = FALSE;
 2729              	 .loc 3 1367 0
 2730 00be 184B     	 ldr r3,.L178+72
 2731 00c0 0022     	 movs r2,#0
 2732 00c2 1A70     	 strb r2,[r3]
1368:../SSC/Src/ecatslv.c ****     bEcatInputUpdateRunning = FALSE;
 2733              	 .loc 3 1368 0
 2734 00c4 174B     	 ldr r3,.L178+76
 2735 00c6 0022     	 movs r2,#0
 2736 00c8 1A70     	 strb r2,[r3]
1369:../SSC/Src/ecatslv.c **** 
1370:../SSC/Src/ecatslv.c ****     /*Indicate no user specified Sync mode*/
1371:../SSC/Src/ecatslv.c ****     bSyncSetByUser = FALSE;
 2737              	 .loc 3 1371 0
 2738 00ca 174B     	 ldr r3,.L178+80
 2739 00cc 0022     	 movs r2,#0
 2740 00ce 1A70     	 strb r2,[r3]
1372:../SSC/Src/ecatslv.c **** }
 2741              	 .loc 3 1372 0
 2742 00d0 0837     	 adds r7,r7,#8
 2743              	.LCFI67:
 2744              	 .cfi_def_cfa_offset 8
 2745 00d2 BD46     	 mov sp,r7
 2746              	.LCFI68:
 2747              	 .cfi_def_cfa_register 13
 2748              	 
 2749 00d4 80BD     	 pop {r7,pc}
 2750              	.L179:
 2751 00d6 00BF     	 .align 2
 2752              	.L178:
 2753 00d8 00000000 	 .word nPdOutputSize
 2754 00dc 00000000 	 .word nPdInputSize
 2755 00e0 00000000 	 .word bEcatFirstOutputsReceived
 2756 00e4 00000000 	 .word bEscIntEnabled
 2757 00e8 00000000 	 .word bDcSyncActive
 2758 00ec 00000000 	 .word bDcRunning
 2759 00f0 00000000 	 .word bSmSyncSequenceValid
 2760 00f4 00000000 	 .word u16SmSync0Value
 2761 00f8 00000000 	 .word u16SmSync0Counter
 2762 00fc 00000000 	 .word Sync0WdValue
 2763 0100 00000000 	 .word Sync0WdCounter
 2764 0104 00000000 	 .word Sync1WdCounter
 2765 0108 00000000 	 .word Sync1WdValue
 2766 010c 00000000 	 .word LatchInputSync0Value
 2767 0110 00000000 	 .word LatchInputSync0Counter
 2768 0114 00000000 	 .word sSyncManOutPar
 2769 0118 00000000 	 .word sSyncManInPar
 2770 011c 00000000 	 .word i16WaitForPllRunningTimeout
 2771 0120 00000000 	 .word bWdTrigger
 2772 0124 00000000 	 .word bEcatInputUpdateRunning
 2773 0128 00000000 	 .word bSyncSetByUser
 2774              	 .cfi_endproc
 2775              	.LFE185:
 2777              	 .section .text.BackToInitTransition,"ax",%progbits
 2778              	 .align 2
 2779              	 .global BackToInitTransition
 2780              	 .thumb
 2781              	 .thumb_func
 2783              	BackToInitTransition:
 2784              	.LFB186:
1373:../SSC/Src/ecatslv.c **** 
1374:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
1375:../SSC/Src/ecatslv.c **** /**
1376:../SSC/Src/ecatslv.c **** \brief    This function is called when a X to Init transition is completed
1377:../SSC/Src/ecatslv.c **** 
1378:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
1379:../SSC/Src/ecatslv.c **** 
1380:../SSC/Src/ecatslv.c **** void BackToInitTransition(void)
1381:../SSC/Src/ecatslv.c **** {
 2785              	 .loc 3 1381 0
 2786              	 .cfi_startproc
 2787              	 
 2788              	 
 2789              	 
 2790 0000 80B4     	 push {r7}
 2791              	.LCFI69:
 2792              	 .cfi_def_cfa_offset 4
 2793              	 .cfi_offset 7,-4
 2794 0002 00AF     	 add r7,sp,#0
 2795              	.LCFI70:
 2796              	 .cfi_def_cfa_register 7
1382:../SSC/Src/ecatslv.c ****     /* Reset indication that the user has written a sync mode*/
1383:../SSC/Src/ecatslv.c ****     bSyncSetByUser = FALSE;
 2797              	 .loc 3 1383 0
 2798 0004 034B     	 ldr r3,.L181
 2799 0006 0022     	 movs r2,#0
 2800 0008 1A70     	 strb r2,[r3]
1384:../SSC/Src/ecatslv.c **** }
 2801              	 .loc 3 1384 0
 2802 000a BD46     	 mov sp,r7
 2803              	.LCFI71:
 2804              	 .cfi_def_cfa_register 13
 2805              	 
 2806 000c 5DF8047B 	 ldr r7,[sp],#4
 2807              	.LCFI72:
 2808              	 .cfi_restore 7
 2809              	 .cfi_def_cfa_offset 0
 2810 0010 7047     	 bx lr
 2811              	.L182:
 2812 0012 00BF     	 .align 2
 2813              	.L181:
 2814 0014 00000000 	 .word bSyncSetByUser
 2815              	 .cfi_endproc
 2816              	.LFE186:
 2818              	 .section .text.SetALStatus,"ax",%progbits
 2819              	 .align 2
 2820              	 .global SetALStatus
 2821              	 .thumb
 2822              	 .thumb_func
 2824              	SetALStatus:
 2825              	.LFB187:
1385:../SSC/Src/ecatslv.c **** 
1386:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
1387:../SSC/Src/ecatslv.c **** /**
1388:../SSC/Src/ecatslv.c ****  \param alStatus        New AL Status (written to register 0x130)
1389:../SSC/Src/ecatslv.c ****  \param alStatusCode    New AL Status Code (written to register 0x134)
1390:../SSC/Src/ecatslv.c **** 
1391:../SSC/Src/ecatslv.c ****   \brief  The function changes the state of the EtherCAT ASIC to the requested.
1392:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
1393:../SSC/Src/ecatslv.c **** void SetALStatus(UINT8 alStatus, UINT16 alStatusCode)
1394:../SSC/Src/ecatslv.c **** {
 2826              	 .loc 3 1394 0
 2827              	 .cfi_startproc
 2828              	 
 2829              	 
 2830              	 
 2831 0000 80B4     	 push {r7}
 2832              	.LCFI73:
 2833              	 .cfi_def_cfa_offset 4
 2834              	 .cfi_offset 7,-4
 2835 0002 85B0     	 sub sp,sp,#20
 2836              	.LCFI74:
 2837              	 .cfi_def_cfa_offset 24
 2838 0004 00AF     	 add r7,sp,#0
 2839              	.LCFI75:
 2840              	 .cfi_def_cfa_register 7
 2841 0006 0346     	 mov r3,r0
 2842 0008 0A46     	 mov r2,r1
 2843 000a FB71     	 strb r3,[r7,#7]
 2844 000c 1346     	 mov r3,r2
 2845 000e BB80     	 strh r3,[r7,#4]
1395:../SSC/Src/ecatslv.c ****     UINT16 Value = alStatusCode;
 2846              	 .loc 3 1395 0
 2847 0010 BB88     	 ldrh r3,[r7,#4]
 2848 0012 FB81     	 strh r3,[r7,#14]
1396:../SSC/Src/ecatslv.c **** 
1397:../SSC/Src/ecatslv.c ****     /*update global status variable if required*/
1398:../SSC/Src/ecatslv.c ****     if(nAlStatus != alStatus)
 2849              	 .loc 3 1398 0
 2850 0014 264B     	 ldr r3,.L192
 2851 0016 1B78     	 ldrb r3,[r3]
 2852 0018 FA79     	 ldrb r2,[r7,#7]
 2853 001a 9A42     	 cmp r2,r3
 2854 001c 02D0     	 beq .L184
1399:../SSC/Src/ecatslv.c ****     {
1400:../SSC/Src/ecatslv.c ****         nAlStatus = alStatus;
 2855              	 .loc 3 1400 0
 2856 001e 244A     	 ldr r2,.L192
 2857 0020 FB79     	 ldrb r3,[r7,#7]
 2858 0022 1370     	 strb r3,[r2]
 2859              	.L184:
1401:../SSC/Src/ecatslv.c ****     }
1402:../SSC/Src/ecatslv.c **** 
1403:../SSC/Src/ecatslv.c **** 
1404:../SSC/Src/ecatslv.c ****     if (alStatusCode != 0xFFFF)
 2860              	 .loc 3 1404 0
 2861 0024 BB88     	 ldrh r3,[r7,#4]
 2862 0026 4FF6FF72 	 movw r2,#65535
 2863 002a 9342     	 cmp r3,r2
 2864 002c 02D0     	 beq .L185
1405:../SSC/Src/ecatslv.c ****     {
1406:../SSC/Src/ecatslv.c ****         Value = SWAPWORD(Value);
1407:../SSC/Src/ecatslv.c **** 
1408:../SSC/Src/ecatslv.c ****         HW_EscWriteWord(Value,ESC_AL_STATUS_CODE_OFFSET);
 2865              	 .loc 3 1408 0
 2866 002e 214A     	 ldr r2,.L192+4
 2867 0030 FB89     	 ldrh r3,[r7,#14]
 2868 0032 1380     	 strh r3,[r2]
 2869              	.L185:
1409:../SSC/Src/ecatslv.c ****     }
1410:../SSC/Src/ecatslv.c **** 
1411:../SSC/Src/ecatslv.c ****     Value = nAlStatus;
 2870              	 .loc 3 1411 0
 2871 0034 1E4B     	 ldr r3,.L192
 2872 0036 1B78     	 ldrb r3,[r3]
 2873 0038 FB81     	 strh r3,[r7,#14]
1412:../SSC/Src/ecatslv.c ****     Value = SWAPWORD(Value);
1413:../SSC/Src/ecatslv.c ****     HW_EscWriteWord(Value,ESC_AL_STATUS_OFFSET);
 2874              	 .loc 3 1413 0
 2875 003a 1F4A     	 ldr r2,.L192+8
 2876 003c FB89     	 ldrh r3,[r7,#14]
 2877 003e 1380     	 strh r3,[r2]
1414:../SSC/Src/ecatslv.c **** 
1415:../SSC/Src/ecatslv.c ****     /*The Run LED state is set in Set LED Indication, only the Error LED blink code is set here*/
1416:../SSC/Src/ecatslv.c **** 
1417:../SSC/Src/ecatslv.c ****     /*set Error blink code*/
1418:../SSC/Src/ecatslv.c ****     if(alStatusCode == 0x00 || !(alStatus & STATE_CHANGE))
 2878              	 .loc 3 1418 0
 2879 0040 BB88     	 ldrh r3,[r7,#4]
 2880 0042 002B     	 cmp r3,#0
 2881 0044 04D0     	 beq .L186
 2882              	 .loc 3 1418 0 is_stmt 0 discriminator 1
 2883 0046 FB79     	 ldrb r3,[r7,#7]
 2884 0048 03F01003 	 and r3,r3,#16
 2885 004c 002B     	 cmp r3,#0
 2886 004e 03D1     	 bne .L187
 2887              	.L186:
1419:../SSC/Src/ecatslv.c ****     {
1420:../SSC/Src/ecatslv.c ****         u8EcatErrorLed = LED_OFF;
 2888              	 .loc 3 1420 0 is_stmt 1
 2889 0050 1A4B     	 ldr r3,.L192+12
 2890 0052 0022     	 movs r2,#0
 2891 0054 1A70     	 strb r2,[r3]
 2892 0056 1AE0     	 b .L188
 2893              	.L187:
1421:../SSC/Src/ecatslv.c ****     }
1422:../SSC/Src/ecatslv.c ****     else if((alStatusCode == ALSTATUSCODE_NOSYNCERROR) ||
 2894              	 .loc 3 1422 0
 2895 0058 BB88     	 ldrh r3,[r7,#4]
 2896 005a 2D2B     	 cmp r3,#45
 2897 005c 09D0     	 beq .L189
 2898              	 .loc 3 1422 0 is_stmt 0 discriminator 1
 2899 005e BB88     	 ldrh r3,[r7,#4]
 2900 0060 1A2B     	 cmp r3,#26
 2901 0062 06D0     	 beq .L189
1423:../SSC/Src/ecatslv.c ****         (alStatusCode == ALSTATUSCODE_SYNCERROR) ||
 2902              	 .loc 3 1423 0 is_stmt 1
 2903 0064 BB88     	 ldrh r3,[r7,#4]
 2904 0066 322B     	 cmp r3,#50
 2905 0068 03D0     	 beq .L189
1424:../SSC/Src/ecatslv.c ****         (alStatusCode == ALSTATUSCODE_DCPLLSYNCERROR)
1425:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.13) ESM1*/
1426:../SSC/Src/ecatslv.c ****         || (u8LocalErrorState > 0))
 2906              	 .loc 3 1426 0
 2907 006a 154B     	 ldr r3,.L192+16
 2908 006c 1B78     	 ldrb r3,[r3]
 2909 006e 002B     	 cmp r3,#0
 2910 0070 03D0     	 beq .L190
 2911              	.L189:
1427:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.13) ESM1*/
1428:../SSC/Src/ecatslv.c ****     {
1429:../SSC/Src/ecatslv.c ****         u8EcatErrorLed = LED_SINGLEFLASH;
 2912              	 .loc 3 1429 0
 2913 0072 124B     	 ldr r3,.L192+12
 2914 0074 0122     	 movs r2,#1
 2915 0076 1A70     	 strb r2,[r3]
 2916 0078 09E0     	 b .L188
 2917              	.L190:
1430:../SSC/Src/ecatslv.c ****     }
1431:../SSC/Src/ecatslv.c ****     else if((alStatusCode == ALSTATUSCODE_SMWATCHDOG))
 2918              	 .loc 3 1431 0
 2919 007a BB88     	 ldrh r3,[r7,#4]
 2920 007c 1B2B     	 cmp r3,#27
 2921 007e 03D1     	 bne .L191
1432:../SSC/Src/ecatslv.c ****     {
1433:../SSC/Src/ecatslv.c ****         u8EcatErrorLed = LED_DOUBLEFLASH;
 2922              	 .loc 3 1433 0
 2923 0080 0E4B     	 ldr r3,.L192+12
 2924 0082 0222     	 movs r2,#2
 2925 0084 1A70     	 strb r2,[r3]
 2926 0086 02E0     	 b .L188
 2927              	.L191:
1434:../SSC/Src/ecatslv.c ****     }
1435:../SSC/Src/ecatslv.c ****     else
1436:../SSC/Src/ecatslv.c ****     {
1437:../SSC/Src/ecatslv.c ****         u8EcatErrorLed = LED_BLINKING;
 2928              	 .loc 3 1437 0
 2929 0088 0C4B     	 ldr r3,.L192+12
 2930 008a 0D22     	 movs r2,#13
 2931 008c 1A70     	 strb r2,[r3]
 2932              	.L188:
1438:../SSC/Src/ecatslv.c ****     }
1439:../SSC/Src/ecatslv.c ****     u8EcatErrorLed |= LED_OVERRIDE;
 2933              	 .loc 3 1439 0
 2934 008e 0B4B     	 ldr r3,.L192+12
 2935 0090 1B78     	 ldrb r3,[r3]
 2936 0092 43F01003 	 orr r3,r3,#16
 2937 0096 DAB2     	 uxtb r2,r3
 2938 0098 084B     	 ldr r3,.L192+12
 2939 009a 1A70     	 strb r2,[r3]
1440:../SSC/Src/ecatslv.c **** 
1441:../SSC/Src/ecatslv.c ****     HW_EscWriteByte(u8EcatErrorLed,ESC_ERROR_LED_OVERRIDE);
 2940              	 .loc 3 1441 0
 2941 009c 094B     	 ldr r3,.L192+20
 2942 009e 074A     	 ldr r2,.L192+12
 2943 00a0 1278     	 ldrb r2,[r2]
 2944 00a2 1A70     	 strb r2,[r3]
1442:../SSC/Src/ecatslv.c **** }
 2945              	 .loc 3 1442 0
 2946 00a4 1437     	 adds r7,r7,#20
 2947              	.LCFI76:
 2948              	 .cfi_def_cfa_offset 4
 2949 00a6 BD46     	 mov sp,r7
 2950              	.LCFI77:
 2951              	 .cfi_def_cfa_register 13
 2952              	 
 2953 00a8 5DF8047B 	 ldr r7,[sp],#4
 2954              	.LCFI78:
 2955              	 .cfi_restore 7
 2956              	 .cfi_def_cfa_offset 0
 2957 00ac 7047     	 bx lr
 2958              	.L193:
 2959 00ae 00BF     	 .align 2
 2960              	.L192:
 2961 00b0 00000000 	 .word nAlStatus
 2962 00b4 34010154 	 .word 1409351988
 2963 00b8 30010154 	 .word 1409351984
 2964 00bc 00000000 	 .word u8EcatErrorLed
 2965 00c0 00000000 	 .word u8LocalErrorState
 2966 00c4 39010154 	 .word 1409351993
 2967              	 .cfi_endproc
 2968              	.LFE187:
 2970              	 .section .text.AL_ControlInd,"ax",%progbits
 2971              	 .align 2
 2972              	 .global AL_ControlInd
 2973              	 .thumb
 2974              	 .thumb_func
 2976              	AL_ControlInd:
 2977              	.LFB188:
1443:../SSC/Src/ecatslv.c **** 
1444:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
1445:../SSC/Src/ecatslv.c **** /**
1446:../SSC/Src/ecatslv.c ****  \param    alControl        requested new state
1447:../SSC/Src/ecatslv.c ****  \param    alStatusCode     requested status code
1448:../SSC/Src/ecatslv.c **** 
1449:../SSC/Src/ecatslv.c ****  \brief    This function handles the EtherCAT State Machine. It is called
1450:../SSC/Src/ecatslv.c ****             * in case of an AL Control event (Bit 0 of AL-Event (Reg 0x220),
1451:../SSC/Src/ecatslv.c ****                when the Master has written the AL Control Register (from ECAT_Main),
1452:../SSC/Src/ecatslv.c ****               alControl contains the content of the AL Control (Reg 0x120)
1453:../SSC/Src/ecatslv.c ****             * in case of a SM-Change event (Bit 4 of AL-Event (Reg 0x220)),
1454:../SSC/Src/ecatslv.c ****               when an Activate SYNCM y register is written by the master (from ECAT_Main),
1455:../SSC/Src/ecatslv.c ****               alControl contains the actual state (Bit 0-3 of AL Status (Reg 0x130))
1456:../SSC/Src/ecatslv.c ****             * in case of a locally expired watchdog (from ECAT_Main),
1457:../SSC/Src/ecatslv.c ****               alControl contains the requested new state (SAFE_OP)
1458:../SSC/Src/ecatslv.c ****             * in case of an application specific event to change the EtherCAT state (from applicati
1459:../SSC/Src/ecatslv.c ****               alControl contains the requested new state (INIT, PRE_OP or SAFE_OP)
1460:../SSC/Src/ecatslv.c **** 
1461:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
1462:../SSC/Src/ecatslv.c **** 
1463:../SSC/Src/ecatslv.c **** void AL_ControlInd(UINT8 alControl, UINT16 alStatusCode)
1464:../SSC/Src/ecatslv.c **** {
 2978              	 .loc 3 1464 0
 2979              	 .cfi_startproc
 2980              	 
 2981              	 
 2982 0000 80B5     	 push {r7,lr}
 2983              	.LCFI79:
 2984              	 .cfi_def_cfa_offset 8
 2985              	 .cfi_offset 7,-8
 2986              	 .cfi_offset 14,-4
 2987 0002 84B0     	 sub sp,sp,#16
 2988              	.LCFI80:
 2989              	 .cfi_def_cfa_offset 24
 2990 0004 00AF     	 add r7,sp,#0
 2991              	.LCFI81:
 2992              	 .cfi_def_cfa_register 7
 2993 0006 0346     	 mov r3,r0
 2994 0008 0A46     	 mov r2,r1
 2995 000a FB71     	 strb r3,[r7,#7]
 2996 000c 1346     	 mov r3,r2
 2997 000e BB80     	 strh r3,[r7,#4]
1465:../SSC/Src/ecatslv.c ****     UINT16        result = 0;
 2998              	 .loc 3 1465 0
 2999 0010 0023     	 movs r3,#0
 3000 0012 FB81     	 strh r3,[r7,#14]
1466:../SSC/Src/ecatslv.c ****     UINT8            bErrAck = 0;
 3001              	 .loc 3 1466 0
 3002 0014 0023     	 movs r3,#0
 3003 0016 7B73     	 strb r3,[r7,#13]
1467:../SSC/Src/ecatslv.c ****     UINT8         stateTrans;
1468:../SSC/Src/ecatslv.c ****     /*deactivate ESM timeout counter*/
1469:../SSC/Src/ecatslv.c ****     EsmTimeoutCounter = -1;
 3004              	 .loc 3 1469 0
 3005 0018 D34B     	 ldr r3,.L263
 3006 001a 4FF6FF72 	 movw r2,#65535
 3007 001e 1A80     	 strh r2,[r3]
1470:../SSC/Src/ecatslv.c ****     bApplEsmPending = TRUE;
 3008              	 .loc 3 1470 0
 3009 0020 D24B     	 ldr r3,.L263+4
 3010 0022 0122     	 movs r2,#1
 3011 0024 1A70     	 strb r2,[r3]
1471:../SSC/Src/ecatslv.c **** 
1472:../SSC/Src/ecatslv.c ****     /* reset the Error Flag in case of acknowledge by the Master */
1473:../SSC/Src/ecatslv.c ****     if ( alControl & STATE_CHANGE )
 3012              	 .loc 3 1473 0
 3013 0026 FB79     	 ldrb r3,[r7,#7]
 3014 0028 03F01003 	 and r3,r3,#16
 3015 002c 002B     	 cmp r3,#0
 3016 002e 09D0     	 beq .L195
1474:../SSC/Src/ecatslv.c ****     {
1475:../SSC/Src/ecatslv.c ****         bErrAck = 1;
 3017              	 .loc 3 1475 0
 3018 0030 0123     	 movs r3,#1
 3019 0032 7B73     	 strb r3,[r7,#13]
1476:../SSC/Src/ecatslv.c ****         nAlStatus &= ~STATE_CHANGE;
 3020              	 .loc 3 1476 0
 3021 0034 CE4B     	 ldr r3,.L263+8
 3022 0036 1B78     	 ldrb r3,[r3]
 3023 0038 23F01003 	 bic r3,r3,#16
 3024 003c DAB2     	 uxtb r2,r3
 3025 003e CC4B     	 ldr r3,.L263+8
 3026 0040 1A70     	 strb r2,[r3]
 3027 0042 12E0     	 b .L196
 3028              	.L195:
1477:../SSC/Src/ecatslv.c ****         /*enable SM2 is moved to state transition block. First check SM Settings.*/
1478:../SSC/Src/ecatslv.c ****     }
1479:../SSC/Src/ecatslv.c ****     else if ((nAlStatus & STATE_CHANGE)
 3029              	 .loc 3 1479 0
 3030 0044 CA4B     	 ldr r3,.L263+8
 3031 0046 1B78     	 ldrb r3,[r3]
 3032 0048 03F01003 	 and r3,r3,#16
 3033 004c 002B     	 cmp r3,#0
 3034 004e 05D0     	 beq .L197
1480:../SSC/Src/ecatslv.c ****         // HBu 17.04.08: the error has to be acknowledged before when sending the same (or a higher
1481:../SSC/Src/ecatslv.c ****         //               (the error was acknowledged with the same state before independent of the 
1482:../SSC/Src/ecatslv.c ****         /*Error Acknowledge with 0xX1 is allowed*/
1483:../SSC/Src/ecatslv.c ****         && (alControl & STATE_MASK) != STATE_INIT)
 3035              	 .loc 3 1483 0
 3036 0050 FB79     	 ldrb r3,[r7,#7]
 3037 0052 03F00F03 	 and r3,r3,#15
 3038 0056 012B     	 cmp r3,#1
 3039 0058 00D0     	 beq .L197
1484:../SSC/Src/ecatslv.c ****     {
1485:../SSC/Src/ecatslv.c ****         /* the error flag (Bit 4) is set in the AL-Status and the ErrAck bit (Bit 4)
1486:../SSC/Src/ecatslv.c ****            is not set in the AL-Control, so the state cannot be set to a higher state
1487:../SSC/Src/ecatslv.c ****            and the new state request will be ignored */
1488:../SSC/Src/ecatslv.c ****         return;
 3040              	 .loc 3 1488 0
 3041 005a 40E3     	 b .L194
 3042              	.L197:
1489:../SSC/Src/ecatslv.c ****     }
1490:../SSC/Src/ecatslv.c ****     else
1491:../SSC/Src/ecatslv.c ****     {
1492:../SSC/Src/ecatslv.c ****         nAlStatus &= STATE_MASK;
 3043              	 .loc 3 1492 0
 3044 005c C44B     	 ldr r3,.L263+8
 3045 005e 1B78     	 ldrb r3,[r3]
 3046 0060 03F00F03 	 and r3,r3,#15
 3047 0064 DAB2     	 uxtb r2,r3
 3048 0066 C24B     	 ldr r3,.L263+8
 3049 0068 1A70     	 strb r2,[r3]
 3050              	.L196:
1493:../SSC/Src/ecatslv.c ****     }
1494:../SSC/Src/ecatslv.c **** 
1495:../SSC/Src/ecatslv.c ****     
1496:../SSC/Src/ecatslv.c **** 
1497:../SSC/Src/ecatslv.c ****     /* generate a variable for the state transition
1498:../SSC/Src/ecatslv.c ****       (Bit 0-3: new state (AL Control), Bit 4-7: old state (AL Status) */
1499:../SSC/Src/ecatslv.c ****     alControl &= STATE_MASK;
 3051              	 .loc 3 1499 0
 3052 006a FB79     	 ldrb r3,[r7,#7]
 3053 006c 03F00F03 	 and r3,r3,#15
 3054 0070 FB71     	 strb r3,[r7,#7]
1500:../SSC/Src/ecatslv.c ****     stateTrans = nAlStatus;
 3055              	 .loc 3 1500 0
 3056 0072 BF4B     	 ldr r3,.L263+8
 3057 0074 1B78     	 ldrb r3,[r3]
 3058 0076 3B73     	 strb r3,[r7,#12]
1501:../SSC/Src/ecatslv.c ****     stateTrans <<= 4;
 3059              	 .loc 3 1501 0
 3060 0078 3B7B     	 ldrb r3,[r7,#12]
 3061 007a 1B01     	 lsls r3,r3,#4
 3062 007c 3B73     	 strb r3,[r7,#12]
1502:../SSC/Src/ecatslv.c ****     stateTrans += alControl;
 3063              	 .loc 3 1502 0
 3064 007e 3A7B     	 ldrb r2,[r7,#12]
 3065 0080 FB79     	 ldrb r3,[r7,#7]
 3066 0082 1344     	 add r3,r3,r2
 3067 0084 3B73     	 strb r3,[r7,#12]
1503:../SSC/Src/ecatslv.c **** 
1504:../SSC/Src/ecatslv.c ****     /* check the SYNCM settings depending on the state transition */
1505:../SSC/Src/ecatslv.c ****     switch ( stateTrans )
 3068              	 .loc 3 1505 0
 3069 0086 3B7B     	 ldrb r3,[r7,#12]
 3070 0088 442B     	 cmp r3,#68
 3071 008a 29D0     	 beq .L200
 3072 008c 442B     	 cmp r3,#68
 3073 008e 0BDC     	 bgt .L201
 3074 0090 222B     	 cmp r3,#34
 3075 0092 15D0     	 beq .L202
 3076 0094 222B     	 cmp r3,#34
 3077 0096 02DC     	 bgt .L203
 3078 0098 122B     	 cmp r3,#18
 3079 009a 11D0     	 beq .L202
 3080 009c 28E0     	 b .L199
 3081              	.L203:
 3082 009e 242B     	 cmp r3,#36
 3083 00a0 14D0     	 beq .L204
 3084 00a2 422B     	 cmp r3,#66
 3085 00a4 0CD0     	 beq .L202
 3086 00a6 23E0     	 b .L199
 3087              	.L201:
 3088 00a8 822B     	 cmp r3,#130
 3089 00aa 09D0     	 beq .L202
 3090 00ac 822B     	 cmp r3,#130
 3091 00ae 02DC     	 bgt .L205
 3092 00b0 482B     	 cmp r3,#72
 3093 00b2 15D0     	 beq .L200
 3094 00b4 1CE0     	 b .L199
 3095              	.L205:
 3096 00b6 842B     	 cmp r3,#132
 3097 00b8 12D0     	 beq .L200
 3098 00ba 882B     	 cmp r3,#136
 3099 00bc 10D0     	 beq .L200
 3100 00be 17E0     	 b .L199
 3101              	.L202:
1506:../SSC/Src/ecatslv.c ****     {
1507:../SSC/Src/ecatslv.c ****     case INIT_2_PREOP:
1508:../SSC/Src/ecatslv.c ****     case OP_2_PREOP:
1509:../SSC/Src/ecatslv.c ****     case SAFEOP_2_PREOP:
1510:../SSC/Src/ecatslv.c ****     case PREOP_2_PREOP:
1511:../SSC/Src/ecatslv.c ****         /* in PREOP only the SYNCM settings for SYNCM0 and SYNCM1 (mailbox)
1512:../SSC/Src/ecatslv.c ****            are checked, if result is unequal 0, the slave will stay in or
1513:../SSC/Src/ecatslv.c ****            switch to INIT and set the ErrorInd Bit (bit 4) of the AL-Status */
1514:../SSC/Src/ecatslv.c ****         result = CheckSmSettings(MAILBOX_READ+1);
 3102              	 .loc 3 1514 0
 3103 00c0 0220     	 movs r0,#2
 3104 00c2 FFF7FEFF 	 bl CheckSmSettings
 3105 00c6 0346     	 mov r3,r0
 3106 00c8 FB81     	 strh r3,[r7,#14]
1515:../SSC/Src/ecatslv.c ****         break;
 3107              	 .loc 3 1515 0
 3108 00ca 11E0     	 b .L199
 3109              	.L204:
1516:../SSC/Src/ecatslv.c ****     case PREOP_2_SAFEOP:
1517:../SSC/Src/ecatslv.c ****         {
1518:../SSC/Src/ecatslv.c ****         /* before checking the SYNCM settings for SYNCM2 and SYNCM3 (process data)
1519:../SSC/Src/ecatslv.c ****            the expected length of input data (nPdInputSize) and output data (nPdOutputSize)
1520:../SSC/Src/ecatslv.c ****             could be adapted (changed by PDO-Assign and/or PDO-Mapping)
1521:../SSC/Src/ecatslv.c ****             if result is unequal 0, the slave will stay in PREOP and set
1522:../SSC/Src/ecatslv.c ****             the ErrorInd Bit (bit 4) of the AL-Status */
1523:../SSC/Src/ecatslv.c ****         result = APPL_GenerateMapping(&nPdInputSize,&nPdOutputSize);
 3110              	 .loc 3 1523 0
 3111 00cc A948     	 ldr r0,.L263+12
 3112 00ce AA49     	 ldr r1,.L263+16
 3113 00d0 FFF7FEFF 	 bl APPL_GenerateMapping
 3114 00d4 0346     	 mov r3,r0
 3115 00d6 FB81     	 strh r3,[r7,#14]
1524:../SSC/Src/ecatslv.c **** 
1525:../SSC/Src/ecatslv.c ****             if (result != 0)
 3116              	 .loc 3 1525 0
 3117 00d8 FB89     	 ldrh r3,[r7,#14]
 3118 00da 002B     	 cmp r3,#0
 3119 00dc 00D0     	 beq .L200
1526:../SSC/Src/ecatslv.c ****             {
1527:../SSC/Src/ecatslv.c ****                 break;
 3120              	 .loc 3 1527 0
 3121 00de 07E0     	 b .L199
 3122              	.L200:
1528:../SSC/Src/ecatslv.c ****             }
1529:../SSC/Src/ecatslv.c ****         }
1530:../SSC/Src/ecatslv.c ****     case SAFEOP_2_OP:
1531:../SSC/Src/ecatslv.c ****     case OP_2_SAFEOP:
1532:../SSC/Src/ecatslv.c ****     case SAFEOP_2_SAFEOP:
1533:../SSC/Src/ecatslv.c ****     case OP_2_OP:
1534:../SSC/Src/ecatslv.c ****         /* in SAFEOP or OP the SYNCM settings for all SYNCM are checked
1535:../SSC/Src/ecatslv.c ****            if result is unequal 0, the slave will stay in or
1536:../SSC/Src/ecatslv.c ****            switch to PREOP and set the ErrorInd Bit (bit 4) of the AL-Status */
1537:../SSC/Src/ecatslv.c ****         result = CheckSmSettings(nMaxSyncMan);
 3123              	 .loc 3 1537 0
 3124 00e0 A64B     	 ldr r3,.L263+20
 3125 00e2 1B78     	 ldrb r3,[r3]
 3126 00e4 1846     	 mov r0,r3
 3127 00e6 FFF7FEFF 	 bl CheckSmSettings
 3128 00ea 0346     	 mov r3,r0
 3129 00ec FB81     	 strh r3,[r7,#14]
1538:../SSC/Src/ecatslv.c ****         break;
 3130              	 .loc 3 1538 0
 3131 00ee 00BF     	 nop
 3132              	.L199:
1539:../SSC/Src/ecatslv.c **** 
1540:../SSC/Src/ecatslv.c ****     }
1541:../SSC/Src/ecatslv.c **** 
1542:../SSC/Src/ecatslv.c ****     if ( result == 0 )
 3133              	 .loc 3 1542 0
 3134 00f0 FB89     	 ldrh r3,[r7,#14]
 3135 00f2 002B     	 cmp r3,#0
 3136 00f4 40F02082 	 bne .L206
1543:../SSC/Src/ecatslv.c ****     {
1544:../SSC/Src/ecatslv.c ****         /* execute the corresponding local management service(s) depending on the state transition 
1545:../SSC/Src/ecatslv.c ****         nEcatStateTrans = 0;
 3137              	 .loc 3 1545 0
 3138 00f8 A14B     	 ldr r3,.L263+24
 3139 00fa 0022     	 movs r2,#0
 3140 00fc 1A80     	 strh r2,[r3]
1546:../SSC/Src/ecatslv.c ****         switch ( stateTrans )
 3141              	 .loc 3 1546 0
 3142 00fe 3B7B     	 ldrb r3,[r7,#12]
 3143 0100 113B     	 subs r3,r3,#17
 3144 0102 772B     	 cmp r3,#119
 3145 0104 00F21482 	 bhi .L207
 3146 0108 01A2     	 adr r2,.L209
 3147 010a 52F823F0 	 ldr pc,[r2,r3,lsl#2]
 3148 010e 00BF     	 .p2align 2
 3149              	.L209:
 3150 0110 E7040000 	 .word .L208+1
 3151 0114 01030000 	 .word .L210+1
 3152 0118 F1020000 	 .word .L211+1
 3153 011c 2B050000 	 .word .L212+1
 3154 0120 31050000 	 .word .L207+1
 3155 0124 31050000 	 .word .L207+1
 3156 0128 31050000 	 .word .L207+1
 3157 012c 2B050000 	 .word .L212+1
 3158 0130 31050000 	 .word .L207+1
 3159 0134 31050000 	 .word .L207+1
 3160 0138 31050000 	 .word .L207+1
 3161 013c 31050000 	 .word .L207+1
 3162 0140 31050000 	 .word .L207+1
 3163 0144 31050000 	 .word .L207+1
 3164 0148 31050000 	 .word .L207+1
 3165 014c 31050000 	 .word .L207+1
 3166 0150 D5040000 	 .word .L213+1
 3167 0154 EB040000 	 .word .L214+1
 3168 0158 2B050000 	 .word .L212+1
 3169 015c 8F030000 	 .word .L215+1
 3170 0160 31050000 	 .word .L207+1
 3171 0164 31050000 	 .word .L207+1
 3172 0168 31050000 	 .word .L207+1
 3173 016c 2B050000 	 .word .L212+1
 3174 0170 31050000 	 .word .L207+1
 3175 0174 31050000 	 .word .L207+1
 3176 0178 31050000 	 .word .L207+1
 3177 017c 31050000 	 .word .L207+1
 3178 0180 31050000 	 .word .L207+1
 3179 0184 31050000 	 .word .L207+1
 3180 0188 31050000 	 .word .L207+1
 3181 018c 31050000 	 .word .L207+1
 3182 0190 F7020000 	 .word .L216+1
 3183 0194 2B050000 	 .word .L212+1
 3184 0198 31050000 	 .word .L207+1
 3185 019c 2B050000 	 .word .L212+1
 3186 01a0 31050000 	 .word .L207+1
 3187 01a4 31050000 	 .word .L207+1
 3188 01a8 31050000 	 .word .L207+1
 3189 01ac 2B050000 	 .word .L212+1
 3190 01b0 31050000 	 .word .L207+1
 3191 01b4 31050000 	 .word .L207+1
 3192 01b8 31050000 	 .word .L207+1
 3193 01bc 31050000 	 .word .L207+1
 3194 01c0 31050000 	 .word .L207+1
 3195 01c4 31050000 	 .word .L207+1
 3196 01c8 31050000 	 .word .L207+1
 3197 01cc 31050000 	 .word .L207+1
 3198 01d0 B7040000 	 .word .L217+1
 3199 01d4 89040000 	 .word .L218+1
 3200 01d8 2B050000 	 .word .L212+1
 3201 01dc EB040000 	 .word .L214+1
 3202 01e0 31050000 	 .word .L207+1
 3203 01e4 31050000 	 .word .L207+1
 3204 01e8 31050000 	 .word .L207+1
 3205 01ec E9030000 	 .word .L219+1
 3206 01f0 31050000 	 .word .L207+1
 3207 01f4 31050000 	 .word .L207+1
 3208 01f8 31050000 	 .word .L207+1
 3209 01fc 31050000 	 .word .L207+1
 3210 0200 31050000 	 .word .L207+1
 3211 0204 31050000 	 .word .L207+1
 3212 0208 31050000 	 .word .L207+1
 3213 020c 31050000 	 .word .L207+1
 3214 0210 31050000 	 .word .L207+1
 3215 0214 31050000 	 .word .L207+1
 3216 0218 31050000 	 .word .L207+1
 3217 021c 31050000 	 .word .L207+1
 3218 0220 31050000 	 .word .L207+1
 3219 0224 31050000 	 .word .L207+1
 3220 0228 31050000 	 .word .L207+1
 3221 022c 31050000 	 .word .L207+1
 3222 0230 31050000 	 .word .L207+1
 3223 0234 31050000 	 .word .L207+1
 3224 0238 31050000 	 .word .L207+1
 3225 023c 31050000 	 .word .L207+1
 3226 0240 31050000 	 .word .L207+1
 3227 0244 31050000 	 .word .L207+1
 3228 0248 31050000 	 .word .L207+1
 3229 024c 31050000 	 .word .L207+1
 3230 0250 31050000 	 .word .L207+1
 3231 0254 31050000 	 .word .L207+1
 3232 0258 31050000 	 .word .L207+1
 3233 025c 31050000 	 .word .L207+1
 3234 0260 31050000 	 .word .L207+1
 3235 0264 31050000 	 .word .L207+1
 3236 0268 31050000 	 .word .L207+1
 3237 026c 31050000 	 .word .L207+1
 3238 0270 31050000 	 .word .L207+1
 3239 0274 31050000 	 .word .L207+1
 3240 0278 31050000 	 .word .L207+1
 3241 027c 31050000 	 .word .L207+1
 3242 0280 31050000 	 .word .L207+1
 3243 0284 31050000 	 .word .L207+1
 3244 0288 31050000 	 .word .L207+1
 3245 028c 31050000 	 .word .L207+1
 3246 0290 31050000 	 .word .L207+1
 3247 0294 31050000 	 .word .L207+1
 3248 0298 31050000 	 .word .L207+1
 3249 029c 31050000 	 .word .L207+1
 3250 02a0 31050000 	 .word .L207+1
 3251 02a4 31050000 	 .word .L207+1
 3252 02a8 31050000 	 .word .L207+1
 3253 02ac 31050000 	 .word .L207+1
 3254 02b0 31050000 	 .word .L207+1
 3255 02b4 31050000 	 .word .L207+1
 3256 02b8 31050000 	 .word .L207+1
 3257 02bc 31050000 	 .word .L207+1
 3258 02c0 31050000 	 .word .L207+1
 3259 02c4 31050000 	 .word .L207+1
 3260 02c8 31050000 	 .word .L207+1
 3261 02cc 31050000 	 .word .L207+1
 3262 02d0 99040000 	 .word .L220+1
 3263 02d4 6B040000 	 .word .L221+1
 3264 02d8 2B050000 	 .word .L212+1
 3265 02dc 5B040000 	 .word .L222+1
 3266 02e0 31050000 	 .word .L207+1
 3267 02e4 31050000 	 .word .L207+1
 3268 02e8 31050000 	 .word .L207+1
 3269 02ec EB040000 	 .word .L214+1
 3270              	 .p2align 1
 3271              	.L211:
1547:../SSC/Src/ecatslv.c ****         {
1548:../SSC/Src/ecatslv.c ****         case INIT_2_BOOT    :
1549:../SSC/Src/ecatslv.c ****             result = ALSTATUSCODE_BOOTNOTSUPP;
 3272              	 .loc 3 1549 0
 3273 02f0 1323     	 movs r3,#19
 3274 02f2 FB81     	 strh r3,[r7,#14]
1550:../SSC/Src/ecatslv.c **** 
1551:../SSC/Src/ecatslv.c **** 
1552:../SSC/Src/ecatslv.c **** 
1553:../SSC/Src/ecatslv.c ****             break;
 3275              	 .loc 3 1553 0
 3276 02f4 1FE1     	 b .L223
 3277              	.L216:
1554:../SSC/Src/ecatslv.c **** 
1555:../SSC/Src/ecatslv.c ****         case BOOT_2_INIT    :
1556:../SSC/Src/ecatslv.c ****             result = ALSTATUSCODE_BOOTNOTSUPP;
 3278              	 .loc 3 1556 0
 3279 02f6 1323     	 movs r3,#19
 3280 02f8 FB81     	 strh r3,[r7,#14]
1557:../SSC/Src/ecatslv.c **** 
1558:../SSC/Src/ecatslv.c ****             BackToInitTransition();
 3281              	 .loc 3 1558 0
 3282 02fa FFF7FEFF 	 bl BackToInitTransition
1559:../SSC/Src/ecatslv.c **** 
1560:../SSC/Src/ecatslv.c **** 
1561:../SSC/Src/ecatslv.c **** 
1562:../SSC/Src/ecatslv.c ****             break;
 3283              	 .loc 3 1562 0
 3284 02fe 1AE1     	 b .L223
 3285              	.L210:
1563:../SSC/Src/ecatslv.c ****         case INIT_2_PREOP :
1564:../SSC/Src/ecatslv.c **** 
1565:../SSC/Src/ecatslv.c ****            UpdateEEPROMLoadedState();
 3286              	 .loc 3 1565 0
 3287 0300 FFF7FEFF 	 bl UpdateEEPROMLoadedState
1566:../SSC/Src/ecatslv.c **** 
1567:../SSC/Src/ecatslv.c ****             if (EepromLoaded == FALSE)
 3288              	 .loc 3 1567 0
 3289 0304 1F4B     	 ldr r3,.L263+28
 3290 0306 1B78     	 ldrb r3,[r3]
 3291 0308 83F00103 	 eor r3,r3,#1
 3292 030c DBB2     	 uxtb r3,r3
 3293 030e 002B     	 cmp r3,#0
 3294 0310 01D0     	 beq .L224
1568:../SSC/Src/ecatslv.c ****             {
1569:../SSC/Src/ecatslv.c ****                 //return an error if the EEPROM was not loaded correct  (device restart is required
1570:../SSC/Src/ecatslv.c ****                 result = ALSTATUSCODE_EE_ERROR;
 3295              	 .loc 3 1570 0
 3296 0312 5123     	 movs r3,#81
 3297 0314 FB81     	 strh r3,[r7,#14]
 3298              	.L224:
1571:../SSC/Src/ecatslv.c ****             }
1572:../SSC/Src/ecatslv.c ****             if (result == 0)
 3299              	 .loc 3 1572 0
 3300 0316 FB89     	 ldrh r3,[r7,#14]
 3301 0318 002B     	 cmp r3,#0
 3302 031a 37D1     	 bne .L225
1573:../SSC/Src/ecatslv.c ****             {
1574:../SSC/Src/ecatslv.c ****             /* MBX_StartMailboxHandler (in mailbox.c) checks if the areas of the mailbox
1575:../SSC/Src/ecatslv.c ****                sync managers SYNCM0 and SYNCM1 overlap each other
1576:../SSC/Src/ecatslv.c ****               if result is unequal 0, the slave will stay in INIT
1577:../SSC/Src/ecatslv.c ****               and sets the ErrorInd Bit (bit 4) of the AL-Status */
1578:../SSC/Src/ecatslv.c ****             result = MBX_StartMailboxHandler();
 3303              	 .loc 3 1578 0
 3304 031c FFF7FEFF 	 bl MBX_StartMailboxHandler
 3305 0320 0346     	 mov r3,r0
 3306 0322 FB81     	 strh r3,[r7,#14]
1579:../SSC/Src/ecatslv.c ****             if (result == 0)
 3307              	 .loc 3 1579 0
 3308 0324 FB89     	 ldrh r3,[r7,#14]
 3309 0326 002B     	 cmp r3,#0
 3310 0328 0CD1     	 bne .L226
1580:../SSC/Src/ecatslv.c ****             {
1581:../SSC/Src/ecatslv.c ****                 bApplEsmPending = FALSE;
 3311              	 .loc 3 1581 0
 3312 032a 104B     	 ldr r3,.L263+4
 3313 032c 0022     	 movs r2,#0
 3314 032e 1A70     	 strb r2,[r3]
1582:../SSC/Src/ecatslv.c ****                 /* additionally there could be an application specific check (in ecatappl.c)
1583:../SSC/Src/ecatslv.c ****                    if the state transition from INIT to PREOP should be done
1584:../SSC/Src/ecatslv.c ****                  if result is unequal 0, the slave will stay in INIT
1585:../SSC/Src/ecatslv.c ****                  and sets the ErrorInd Bit (bit 4) of the AL-Status */
1586:../SSC/Src/ecatslv.c ****                 result = APPL_StartMailboxHandler();
 3315              	 .loc 3 1586 0
 3316 0330 FFF7FEFF 	 bl APPL_StartMailboxHandler
 3317 0334 0346     	 mov r3,r0
 3318 0336 FB81     	 strh r3,[r7,#14]
1587:../SSC/Src/ecatslv.c ****                 if ( result == 0 )
 3319              	 .loc 3 1587 0
 3320 0338 FB89     	 ldrh r3,[r7,#14]
 3321 033a 002B     	 cmp r3,#0
 3322 033c 02D1     	 bne .L226
1588:../SSC/Src/ecatslv.c ****                 {
1589:../SSC/Src/ecatslv.c ****                     bMbxRunning = TRUE;
 3323              	 .loc 3 1589 0
 3324 033e 124B     	 ldr r3,.L263+32
 3325 0340 0122     	 movs r2,#1
 3326 0342 1A70     	 strb r2,[r3]
 3327              	.L226:
1590:../SSC/Src/ecatslv.c ****                 }
1591:../SSC/Src/ecatslv.c ****             }
1592:../SSC/Src/ecatslv.c **** 
1593:../SSC/Src/ecatslv.c ****             if(result != 0 && result != NOERROR_INWORK)
 3328              	 .loc 3 1593 0
 3329 0344 FB89     	 ldrh r3,[r7,#14]
 3330 0346 002B     	 cmp r3,#0
 3331 0348 20D0     	 beq .L225
 3332              	 .loc 3 1593 0 is_stmt 0 discriminator 1
 3333 034a FB89     	 ldrh r3,[r7,#14]
 3334 034c FF2B     	 cmp r3,#255
 3335 034e 1DD0     	 beq .L225
1594:../SSC/Src/ecatslv.c ****             {
1595:../SSC/Src/ecatslv.c ****                 /*Stop APPL Mbx handler if APPL Start Mbx handler was called before*/
1596:../SSC/Src/ecatslv.c ****                     if (!bApplEsmPending)
 3336              	 .loc 3 1596 0 is_stmt 1
 3337 0350 064B     	 ldr r3,.L263+4
 3338 0352 1B78     	 ldrb r3,[r3]
 3339 0354 83F00103 	 eor r3,r3,#1
 3340 0358 DBB2     	 uxtb r3,r3
 3341 035a 002B     	 cmp r3,#0
 3342 035c 01D0     	 beq .L227
1597:../SSC/Src/ecatslv.c ****                     {
1598:../SSC/Src/ecatslv.c ****                         APPL_StopMailboxHandler();
 3343              	 .loc 3 1598 0
 3344 035e FFF7FEFF 	 bl APPL_StopMailboxHandler
 3345              	.L227:
1599:../SSC/Src/ecatslv.c ****                     }
1600:../SSC/Src/ecatslv.c **** 
1601:../SSC/Src/ecatslv.c ****                  MBX_StopMailboxHandler();
 3346              	 .loc 3 1601 0
 3347 0362 FFF7FEFF 	 bl MBX_StopMailboxHandler
1602:../SSC/Src/ecatslv.c ****             }
1603:../SSC/Src/ecatslv.c **** 
1604:../SSC/Src/ecatslv.c ****             }
1605:../SSC/Src/ecatslv.c ****             break;
 3348              	 .loc 3 1605 0
 3349 0366 E6E0     	 b .L223
 3350              	.L264:
 3351              	 .align 2
 3352              	.L263:
 3353 0368 00000000 	 .word EsmTimeoutCounter
 3354 036c 00000000 	 .word bApplEsmPending
 3355 0370 00000000 	 .word nAlStatus
 3356 0374 00000000 	 .word nPdInputSize
 3357 0378 00000000 	 .word nPdOutputSize
 3358 037c 00000000 	 .word nMaxSyncMan
 3359 0380 00000000 	 .word nEcatStateTrans
 3360 0384 00000000 	 .word EepromLoaded
 3361 0388 00000000 	 .word bMbxRunning
 3362              	.L225:
 3363 038c D3E0     	 b .L223
 3364              	.L215:
1606:../SSC/Src/ecatslv.c **** 
1607:../SSC/Src/ecatslv.c ****         case PREOP_2_SAFEOP:
1608:../SSC/Src/ecatslv.c ****             /* start the input handler (function is defined above) */
1609:../SSC/Src/ecatslv.c ****             result = StartInputHandler();
 3365              	 .loc 3 1609 0
 3366 038e FFF7FEFF 	 bl StartInputHandler
 3367 0392 0346     	 mov r3,r0
 3368 0394 FB81     	 strh r3,[r7,#14]
1610:../SSC/Src/ecatslv.c ****             if ( result == 0 )
 3369              	 .loc 3 1610 0
 3370 0396 FB89     	 ldrh r3,[r7,#14]
 3371 0398 002B     	 cmp r3,#0
 3372 039a 12D1     	 bne .L228
1611:../SSC/Src/ecatslv.c ****             {
1612:../SSC/Src/ecatslv.c ****                 bApplEsmPending = FALSE;
 3373              	 .loc 3 1612 0
 3374 039c A84B     	 ldr r3,.L265
 3375 039e 0022     	 movs r2,#0
 3376 03a0 1A70     	 strb r2,[r3]
1613:../SSC/Src/ecatslv.c ****                 result = APPL_StartInputHandler(&u16ALEventMask);
 3377              	 .loc 3 1613 0
 3378 03a2 A848     	 ldr r0,.L265+4
 3379 03a4 FFF7FEFF 	 bl APPL_StartInputHandler
 3380 03a8 0346     	 mov r3,r0
 3381 03aa FB81     	 strh r3,[r7,#14]
1614:../SSC/Src/ecatslv.c **** 
1615:../SSC/Src/ecatslv.c ****                 if(result == 0)
 3382              	 .loc 3 1615 0
 3383 03ac FB89     	 ldrh r3,[r7,#14]
 3384 03ae 002B     	 cmp r3,#0
 3385 03b0 07D1     	 bne .L228
1616:../SSC/Src/ecatslv.c ****                 {
1617:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.13) ECAT1*/
1618:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.13) ECAT1*/
1619:../SSC/Src/ecatslv.c ****                     /* initialize the AL Event Mask register (0x204) */
1620:../SSC/Src/ecatslv.c ****                     SetALEventMask( u16ALEventMask );
 3386              	 .loc 3 1620 0
 3387 03b2 A44B     	 ldr r3,.L265+4
 3388 03b4 1B88     	 ldrh r3,[r3]
 3389 03b6 1846     	 mov r0,r3
 3390 03b8 FFF7FEFF 	 bl SetALEventMask
1621:../SSC/Src/ecatslv.c **** 
1622:../SSC/Src/ecatslv.c ****                     bEcatInputUpdateRunning = TRUE;
 3391              	 .loc 3 1622 0
 3392 03bc A24B     	 ldr r3,.L265+8
 3393 03be 0122     	 movs r2,#1
 3394 03c0 1A70     	 strb r2,[r3]
 3395              	.L228:
1623:../SSC/Src/ecatslv.c ****                 }
1624:../SSC/Src/ecatslv.c ****             }
1625:../SSC/Src/ecatslv.c **** 
1626:../SSC/Src/ecatslv.c ****             /*if one start input handler returned an error stop the input handler*/
1627:../SSC/Src/ecatslv.c ****             if(result != 0 && result != NOERROR_INWORK)
 3396              	 .loc 3 1627 0
 3397 03c2 FB89     	 ldrh r3,[r7,#14]
 3398 03c4 002B     	 cmp r3,#0
 3399 03c6 0ED0     	 beq .L229
 3400              	 .loc 3 1627 0 is_stmt 0 discriminator 1
 3401 03c8 FB89     	 ldrh r3,[r7,#14]
 3402 03ca FF2B     	 cmp r3,#255
 3403 03cc 0BD0     	 beq .L229
1628:../SSC/Src/ecatslv.c ****             {
1629:../SSC/Src/ecatslv.c ****                 if(!bApplEsmPending)
 3404              	 .loc 3 1629 0 is_stmt 1
 3405 03ce 9C4B     	 ldr r3,.L265
 3406 03d0 1B78     	 ldrb r3,[r3]
 3407 03d2 83F00103 	 eor r3,r3,#1
 3408 03d6 DBB2     	 uxtb r3,r3
 3409 03d8 002B     	 cmp r3,#0
 3410 03da 01D0     	 beq .L230
1630:../SSC/Src/ecatslv.c ****                 {
1631:../SSC/Src/ecatslv.c ****                     /*Call only the APPL stop handler if the APPL start handler was called before*/
1632:../SSC/Src/ecatslv.c ****                     /*The application can react to the state transition in the function APPL_StopIn
1633:../SSC/Src/ecatslv.c ****                     APPL_StopInputHandler();
 3411              	 .loc 3 1633 0
 3412 03dc FFF7FEFF 	 bl APPL_StopInputHandler
 3413              	.L230:
1634:../SSC/Src/ecatslv.c ****                 }
1635:../SSC/Src/ecatslv.c **** 
1636:../SSC/Src/ecatslv.c ****                 StopInputHandler();
 3414              	 .loc 3 1636 0
 3415 03e0 FFF7FEFF 	 bl StopInputHandler
1637:../SSC/Src/ecatslv.c ****             }
1638:../SSC/Src/ecatslv.c ****             break;
 3416              	 .loc 3 1638 0
 3417 03e4 A7E0     	 b .L223
 3418              	.L229:
 3419              	 .loc 3 1638 0 is_stmt 0 discriminator 2
 3420 03e6 A6E0     	 b .L223
 3421              	.L219:
1639:../SSC/Src/ecatslv.c **** 
1640:../SSC/Src/ecatslv.c ****         case SAFEOP_2_OP:
1641:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.13) ESM2*/
1642:../SSC/Src/ecatslv.c ****             /*enable SM if error was acknowledged*/
1643:../SSC/Src/ecatslv.c ****             if (bErrAck)
 3422              	 .loc 3 1643 0 is_stmt 1
 3423 03e8 7B7B     	 ldrb r3,[r7,#13]
 3424 03ea 002B     	 cmp r3,#0
 3425 03ec 0ED0     	 beq .L231
1644:../SSC/Src/ecatslv.c ****             {
1645:../SSC/Src/ecatslv.c ****                 if (nPdOutputSize > 0)
 3426              	 .loc 3 1645 0
 3427 03ee 974B     	 ldr r3,.L265+12
 3428 03f0 1B88     	 ldrh r3,[r3]
 3429 03f2 002B     	 cmp r3,#0
 3430 03f4 03D0     	 beq .L232
1646:../SSC/Src/ecatslv.c ****                 {
1647:../SSC/Src/ecatslv.c ****                     EnableSyncManChannel(PROCESS_DATA_OUT);
 3431              	 .loc 3 1647 0
 3432 03f6 0220     	 movs r0,#2
 3433 03f8 FFF7FEFF 	 bl EnableSyncManChannel
 3434 03fc 06E0     	 b .L231
 3435              	.L232:
1648:../SSC/Src/ecatslv.c ****                 }
1649:../SSC/Src/ecatslv.c ****                 else
1650:../SSC/Src/ecatslv.c ****                     if (nPdInputSize > 0)
 3436              	 .loc 3 1650 0
 3437 03fe 944B     	 ldr r3,.L265+16
 3438 0400 1B88     	 ldrh r3,[r3]
 3439 0402 002B     	 cmp r3,#0
 3440 0404 02D0     	 beq .L231
1651:../SSC/Src/ecatslv.c ****                     {
1652:../SSC/Src/ecatslv.c ****                         EnableSyncManChannel(PROCESS_DATA_IN);
 3441              	 .loc 3 1652 0
 3442 0406 0320     	 movs r0,#3
 3443 0408 FFF7FEFF 	 bl EnableSyncManChannel
 3444              	.L231:
1653:../SSC/Src/ecatslv.c ****                     }
1654:../SSC/Src/ecatslv.c ****             }
1655:../SSC/Src/ecatslv.c ****             /*ECATCHANGE_END(V5.13) ESM2*/
1656:../SSC/Src/ecatslv.c **** 
1657:../SSC/Src/ecatslv.c ****             /* start the output handler (function is defined above) */
1658:../SSC/Src/ecatslv.c ****             result = StartOutputHandler();
 3445              	 .loc 3 1658 0
 3446 040c FFF7FEFF 	 bl StartOutputHandler
 3447 0410 0346     	 mov r3,r0
 3448 0412 FB81     	 strh r3,[r7,#14]
1659:../SSC/Src/ecatslv.c ****             if(result == 0)
 3449              	 .loc 3 1659 0
 3450 0414 FB89     	 ldrh r3,[r7,#14]
 3451 0416 002B     	 cmp r3,#0
 3452 0418 0CD1     	 bne .L233
1660:../SSC/Src/ecatslv.c ****             {
1661:../SSC/Src/ecatslv.c ****                 bApplEsmPending = FALSE;
 3453              	 .loc 3 1661 0
 3454 041a 894B     	 ldr r3,.L265
 3455 041c 0022     	 movs r2,#0
 3456 041e 1A70     	 strb r2,[r3]
1662:../SSC/Src/ecatslv.c ****                 result = APPL_StartOutputHandler();
 3457              	 .loc 3 1662 0
 3458 0420 FFF7FEFF 	 bl APPL_StartOutputHandler
 3459 0424 0346     	 mov r3,r0
 3460 0426 FB81     	 strh r3,[r7,#14]
1663:../SSC/Src/ecatslv.c **** 
1664:../SSC/Src/ecatslv.c ****                 if(result == 0)
 3461              	 .loc 3 1664 0
 3462 0428 FB89     	 ldrh r3,[r7,#14]
 3463 042a 002B     	 cmp r3,#0
 3464 042c 02D1     	 bne .L233
1665:../SSC/Src/ecatslv.c ****                 {
1666:../SSC/Src/ecatslv.c ****                     /*Device is in OPERATINAL*/
1667:../SSC/Src/ecatslv.c ****                     bEcatOutputUpdateRunning = TRUE;
 3465              	 .loc 3 1667 0
 3466 042e 894B     	 ldr r3,.L265+20
 3467 0430 0122     	 movs r2,#1
 3468 0432 1A70     	 strb r2,[r3]
 3469              	.L233:
1668:../SSC/Src/ecatslv.c ****                 }
1669:../SSC/Src/ecatslv.c **** 
1670:../SSC/Src/ecatslv.c ****             }
1671:../SSC/Src/ecatslv.c **** 
1672:../SSC/Src/ecatslv.c ****             if ( result != 0 && result != NOERROR_INWORK)
 3470              	 .loc 3 1672 0
 3471 0434 FB89     	 ldrh r3,[r7,#14]
 3472 0436 002B     	 cmp r3,#0
 3473 0438 0ED0     	 beq .L234
 3474              	 .loc 3 1672 0 is_stmt 0 discriminator 1
 3475 043a FB89     	 ldrh r3,[r7,#14]
 3476 043c FF2B     	 cmp r3,#255
 3477 043e 0BD0     	 beq .L234
1673:../SSC/Src/ecatslv.c ****             {
1674:../SSC/Src/ecatslv.c ****                     if (!bApplEsmPending)
 3478              	 .loc 3 1674 0 is_stmt 1
 3479 0440 7F4B     	 ldr r3,.L265
 3480 0442 1B78     	 ldrb r3,[r3]
 3481 0444 83F00103 	 eor r3,r3,#1
 3482 0448 DBB2     	 uxtb r3,r3
 3483 044a 002B     	 cmp r3,#0
 3484 044c 01D0     	 beq .L235
1675:../SSC/Src/ecatslv.c ****                     {
1676:../SSC/Src/ecatslv.c ****                         APPL_StopOutputHandler();
 3485              	 .loc 3 1676 0
 3486 044e FFF7FEFF 	 bl APPL_StopOutputHandler
 3487              	.L235:
1677:../SSC/Src/ecatslv.c ****                     }
1678:../SSC/Src/ecatslv.c **** 
1679:../SSC/Src/ecatslv.c ****                 StopOutputHandler();
 3488              	 .loc 3 1679 0
 3489 0452 FFF7FEFF 	 bl StopOutputHandler
1680:../SSC/Src/ecatslv.c ****             }
1681:../SSC/Src/ecatslv.c **** 
1682:../SSC/Src/ecatslv.c ****             break;
 3490              	 .loc 3 1682 0
 3491 0456 6EE0     	 b .L223
 3492              	.L234:
 3493              	 .loc 3 1682 0 is_stmt 0 discriminator 3
 3494 0458 6DE0     	 b .L223
 3495              	.L222:
1683:../SSC/Src/ecatslv.c **** 
1684:../SSC/Src/ecatslv.c ****         case OP_2_SAFEOP:
1685:../SSC/Src/ecatslv.c ****             /* stop the output handler (function is defined above) */
1686:../SSC/Src/ecatslv.c ****             APPL_StopOutputHandler();
 3496              	 .loc 3 1686 0 is_stmt 1
 3497 045a FFF7FEFF 	 bl APPL_StopOutputHandler
1687:../SSC/Src/ecatslv.c **** 
1688:../SSC/Src/ecatslv.c ****             StopOutputHandler();
 3498              	 .loc 3 1688 0
 3499 045e FFF7FEFF 	 bl StopOutputHandler
1689:../SSC/Src/ecatslv.c **** 
1690:../SSC/Src/ecatslv.c ****             bApplEsmPending = FALSE;
 3500              	 .loc 3 1690 0
 3501 0462 774B     	 ldr r3,.L265
 3502 0464 0022     	 movs r2,#0
 3503 0466 1A70     	 strb r2,[r3]
1691:../SSC/Src/ecatslv.c **** 
1692:../SSC/Src/ecatslv.c ****             break;
 3504              	 .loc 3 1692 0
 3505 0468 65E0     	 b .L223
 3506              	.L221:
1693:../SSC/Src/ecatslv.c **** 
1694:../SSC/Src/ecatslv.c ****         case OP_2_PREOP:
1695:../SSC/Src/ecatslv.c ****             /* stop the output handler (function is defined above) */
1696:../SSC/Src/ecatslv.c ****             result = APPL_StopOutputHandler();
 3507              	 .loc 3 1696 0
 3508 046a FFF7FEFF 	 bl APPL_StopOutputHandler
 3509 046e 0346     	 mov r3,r0
 3510 0470 FB81     	 strh r3,[r7,#14]
1697:../SSC/Src/ecatslv.c **** 
1698:../SSC/Src/ecatslv.c ****             StopOutputHandler();
 3511              	 .loc 3 1698 0
 3512 0472 FFF7FEFF 	 bl StopOutputHandler
1699:../SSC/Src/ecatslv.c **** 
1700:../SSC/Src/ecatslv.c ****             bApplEsmPending = FALSE;
 3513              	 .loc 3 1700 0
 3514 0476 724B     	 ldr r3,.L265
 3515 0478 0022     	 movs r2,#0
 3516 047a 1A70     	 strb r2,[r3]
1701:../SSC/Src/ecatslv.c **** 
1702:../SSC/Src/ecatslv.c ****             if (result != 0)
 3517              	 .loc 3 1702 0
 3518 047c FB89     	 ldrh r3,[r7,#14]
 3519 047e 002B     	 cmp r3,#0
 3520 0480 00D0     	 beq .L236
1703:../SSC/Src/ecatslv.c ****             {
1704:../SSC/Src/ecatslv.c ****                 break;
 3521              	 .loc 3 1704 0 discriminator 4
 3522 0482 58E0     	 b .L223
 3523              	.L236:
1705:../SSC/Src/ecatslv.c ****             }
1706:../SSC/Src/ecatslv.c **** 
1707:../SSC/Src/ecatslv.c ****             stateTrans = SAFEOP_2_PREOP;
 3524              	 .loc 3 1707 0
 3525 0484 4223     	 movs r3,#66
 3526 0486 3B73     	 strb r3,[r7,#12]
 3527              	.L218:
1708:../SSC/Src/ecatslv.c **** 
1709:../SSC/Src/ecatslv.c ****         case SAFEOP_2_PREOP:
1710:../SSC/Src/ecatslv.c ****             /* stop the input handler (function is defined above) */
1711:../SSC/Src/ecatslv.c ****             APPL_StopInputHandler();
 3528              	 .loc 3 1711 0
 3529 0488 FFF7FEFF 	 bl APPL_StopInputHandler
1712:../SSC/Src/ecatslv.c ****            
1713:../SSC/Src/ecatslv.c ****             StopInputHandler();
 3530              	 .loc 3 1713 0
 3531 048c FFF7FEFF 	 bl StopInputHandler
1714:../SSC/Src/ecatslv.c **** 
1715:../SSC/Src/ecatslv.c ****             bApplEsmPending = FALSE;
 3532              	 .loc 3 1715 0
 3533 0490 6B4B     	 ldr r3,.L265
 3534 0492 0022     	 movs r2,#0
 3535 0494 1A70     	 strb r2,[r3]
1716:../SSC/Src/ecatslv.c **** 
1717:../SSC/Src/ecatslv.c ****             break;
 3536              	 .loc 3 1717 0
 3537 0496 4EE0     	 b .L223
 3538              	.L220:
1718:../SSC/Src/ecatslv.c **** 
1719:../SSC/Src/ecatslv.c ****         case OP_2_INIT:
1720:../SSC/Src/ecatslv.c ****             /* stop the output handler (function is defined above) */
1721:../SSC/Src/ecatslv.c ****             result = APPL_StopOutputHandler();
 3539              	 .loc 3 1721 0
 3540 0498 FFF7FEFF 	 bl APPL_StopOutputHandler
 3541 049c 0346     	 mov r3,r0
 3542 049e FB81     	 strh r3,[r7,#14]
1722:../SSC/Src/ecatslv.c **** 
1723:../SSC/Src/ecatslv.c ****             StopOutputHandler();
 3543              	 .loc 3 1723 0
 3544 04a0 FFF7FEFF 	 bl StopOutputHandler
1724:../SSC/Src/ecatslv.c **** 
1725:../SSC/Src/ecatslv.c ****             bApplEsmPending = FALSE;
 3545              	 .loc 3 1725 0
 3546 04a4 664B     	 ldr r3,.L265
 3547 04a6 0022     	 movs r2,#0
 3548 04a8 1A70     	 strb r2,[r3]
1726:../SSC/Src/ecatslv.c **** 
1727:../SSC/Src/ecatslv.c ****             if (result != 0)
 3549              	 .loc 3 1727 0
 3550 04aa FB89     	 ldrh r3,[r7,#14]
 3551 04ac 002B     	 cmp r3,#0
 3552 04ae 00D0     	 beq .L237
1728:../SSC/Src/ecatslv.c ****             {
1729:../SSC/Src/ecatslv.c ****                 break;
 3553              	 .loc 3 1729 0 discriminator 5
 3554 04b0 41E0     	 b .L223
 3555              	.L237:
1730:../SSC/Src/ecatslv.c ****             }
1731:../SSC/Src/ecatslv.c ****             
1732:../SSC/Src/ecatslv.c ****             stateTrans = SAFEOP_2_INIT;
 3556              	 .loc 3 1732 0
 3557 04b2 4123     	 movs r3,#65
 3558 04b4 3B73     	 strb r3,[r7,#12]
 3559              	.L217:
1733:../SSC/Src/ecatslv.c **** 
1734:../SSC/Src/ecatslv.c ****         case SAFEOP_2_INIT:
1735:../SSC/Src/ecatslv.c ****             /* stop the input handler (function is defined above) */
1736:../SSC/Src/ecatslv.c ****             result = APPL_StopInputHandler();
 3560              	 .loc 3 1736 0
 3561 04b6 FFF7FEFF 	 bl APPL_StopInputHandler
 3562 04ba 0346     	 mov r3,r0
 3563 04bc FB81     	 strh r3,[r7,#14]
1737:../SSC/Src/ecatslv.c ****             
1738:../SSC/Src/ecatslv.c ****             StopInputHandler();
 3564              	 .loc 3 1738 0
 3565 04be FFF7FEFF 	 bl StopInputHandler
1739:../SSC/Src/ecatslv.c **** 
1740:../SSC/Src/ecatslv.c ****             bApplEsmPending = FALSE;
 3566              	 .loc 3 1740 0
 3567 04c2 5F4B     	 ldr r3,.L265
 3568 04c4 0022     	 movs r2,#0
 3569 04c6 1A70     	 strb r2,[r3]
1741:../SSC/Src/ecatslv.c **** 
1742:../SSC/Src/ecatslv.c ****             if (result != 0)
 3570              	 .loc 3 1742 0
 3571 04c8 FB89     	 ldrh r3,[r7,#14]
 3572 04ca 002B     	 cmp r3,#0
 3573 04cc 00D0     	 beq .L238
1743:../SSC/Src/ecatslv.c ****             {
1744:../SSC/Src/ecatslv.c ****                 break;
 3574              	 .loc 3 1744 0 discriminator 6
 3575 04ce 32E0     	 b .L223
 3576              	.L238:
1745:../SSC/Src/ecatslv.c ****             }
1746:../SSC/Src/ecatslv.c ****             stateTrans = PREOP_2_INIT;
 3577              	 .loc 3 1746 0
 3578 04d0 2123     	 movs r3,#33
 3579 04d2 3B73     	 strb r3,[r7,#12]
 3580              	.L213:
1747:../SSC/Src/ecatslv.c **** 
1748:../SSC/Src/ecatslv.c ****         case PREOP_2_INIT:
1749:../SSC/Src/ecatslv.c ****             MBX_StopMailboxHandler();
 3581              	 .loc 3 1749 0
 3582 04d4 FFF7FEFF 	 bl MBX_StopMailboxHandler
1750:../SSC/Src/ecatslv.c ****             result = APPL_StopMailboxHandler();
 3583              	 .loc 3 1750 0
 3584 04d8 FFF7FEFF 	 bl APPL_StopMailboxHandler
 3585 04dc 0346     	 mov r3,r0
 3586 04de FB81     	 strh r3,[r7,#14]
1751:../SSC/Src/ecatslv.c **** 
1752:../SSC/Src/ecatslv.c ****             BackToInitTransition();
 3587              	 .loc 3 1752 0
 3588 04e0 FFF7FEFF 	 bl BackToInitTransition
1753:../SSC/Src/ecatslv.c ****             break;
 3589              	 .loc 3 1753 0
 3590 04e4 27E0     	 b .L223
 3591              	.L208:
1754:../SSC/Src/ecatslv.c ****         case INIT_2_INIT:
1755:../SSC/Src/ecatslv.c ****             BackToInitTransition();
 3592              	 .loc 3 1755 0
 3593 04e6 FFF7FEFF 	 bl BackToInitTransition
 3594              	.L214:
1756:../SSC/Src/ecatslv.c ****         case PREOP_2_PREOP:
1757:../SSC/Src/ecatslv.c ****         case SAFEOP_2_SAFEOP:
1758:../SSC/Src/ecatslv.c ****         case OP_2_OP:
1759:../SSC/Src/ecatslv.c ****             if(bErrAck)
 3595              	 .loc 3 1759 0
 3596 04ea 7B7B     	 ldrb r3,[r7,#13]
 3597 04ec 002B     	 cmp r3,#0
 3598 04ee 04D0     	 beq .L239
1760:../SSC/Src/ecatslv.c ****             {
1761:../SSC/Src/ecatslv.c ****                 APPL_AckErrorInd(stateTrans);
 3599              	 .loc 3 1761 0
 3600 04f0 3B7B     	 ldrb r3,[r7,#12]
 3601 04f2 9BB2     	 uxth r3,r3
 3602 04f4 1846     	 mov r0,r3
 3603 04f6 FFF7FEFF 	 bl APPL_AckErrorInd
 3604              	.L239:
1762:../SSC/Src/ecatslv.c ****             }
1763:../SSC/Src/ecatslv.c **** 
1764:../SSC/Src/ecatslv.c **** 
1765:../SSC/Src/ecatslv.c ****                 /*no local error flag is currently active, enable SM*/
1766:../SSC/Src/ecatslv.c ****                 if ( nAlStatus & (STATE_SAFEOP | STATE_OP))
 3605              	 .loc 3 1766 0
 3606 04fa 574B     	 ldr r3,.L265+24
 3607 04fc 1B78     	 ldrb r3,[r3]
 3608 04fe 03F00C03 	 and r3,r3,#12
 3609 0502 002B     	 cmp r3,#0
 3610 0504 0ED0     	 beq .L240
1767:../SSC/Src/ecatslv.c ****                 {
1768:../SSC/Src/ecatslv.c ****                     if(nPdOutputSize > 0)
 3611              	 .loc 3 1768 0
 3612 0506 514B     	 ldr r3,.L265+12
 3613 0508 1B88     	 ldrh r3,[r3]
 3614 050a 002B     	 cmp r3,#0
 3615 050c 03D0     	 beq .L241
1769:../SSC/Src/ecatslv.c ****                     {
1770:../SSC/Src/ecatslv.c ****                         EnableSyncManChannel(PROCESS_DATA_OUT);
 3616              	 .loc 3 1770 0
 3617 050e 0220     	 movs r0,#2
 3618 0510 FFF7FEFF 	 bl EnableSyncManChannel
 3619 0514 06E0     	 b .L240
 3620              	.L241:
1771:../SSC/Src/ecatslv.c ****                     }
1772:../SSC/Src/ecatslv.c ****                     else 
1773:../SSC/Src/ecatslv.c ****                     if(nPdInputSize > 0)
 3621              	 .loc 3 1773 0
 3622 0516 4E4B     	 ldr r3,.L265+16
 3623 0518 1B88     	 ldrh r3,[r3]
 3624 051a 002B     	 cmp r3,#0
 3625 051c 02D0     	 beq .L240
1774:../SSC/Src/ecatslv.c ****                     {
1775:../SSC/Src/ecatslv.c ****                         EnableSyncManChannel(PROCESS_DATA_IN);
 3626              	 .loc 3 1775 0
 3627 051e 0320     	 movs r0,#3
 3628 0520 FFF7FEFF 	 bl EnableSyncManChannel
 3629              	.L240:
1776:../SSC/Src/ecatslv.c ****                     }
1777:../SSC/Src/ecatslv.c ****                 }
1778:../SSC/Src/ecatslv.c ****             
1779:../SSC/Src/ecatslv.c ****             result = NOERROR_NOSTATECHANGE;
 3630              	 .loc 3 1779 0
 3631 0524 FE23     	 movs r3,#254
 3632 0526 FB81     	 strh r3,[r7,#14]
1780:../SSC/Src/ecatslv.c ****             break;
 3633              	 .loc 3 1780 0
 3634 0528 05E0     	 b .L223
 3635              	.L212:
1781:../SSC/Src/ecatslv.c **** 
1782:../SSC/Src/ecatslv.c ****         case INIT_2_SAFEOP:
1783:../SSC/Src/ecatslv.c ****         case INIT_2_OP:
1784:../SSC/Src/ecatslv.c ****         case PREOP_2_OP:
1785:../SSC/Src/ecatslv.c ****         case PREOP_2_BOOT:
1786:../SSC/Src/ecatslv.c ****         case SAFEOP_2_BOOT:
1787:../SSC/Src/ecatslv.c ****         case OP_2_BOOT:
1788:../SSC/Src/ecatslv.c ****         case BOOT_2_PREOP:
1789:../SSC/Src/ecatslv.c ****         case BOOT_2_SAFEOP:
1790:../SSC/Src/ecatslv.c ****         case BOOT_2_OP:
1791:../SSC/Src/ecatslv.c ****             result = ALSTATUSCODE_INVALIDALCONTROL;
 3636              	 .loc 3 1791 0
 3637 052a 1123     	 movs r3,#17
 3638 052c FB81     	 strh r3,[r7,#14]
1792:../SSC/Src/ecatslv.c ****             break;
 3639              	 .loc 3 1792 0
 3640 052e 02E0     	 b .L223
 3641              	.L207:
1793:../SSC/Src/ecatslv.c **** 
1794:../SSC/Src/ecatslv.c ****         default:
1795:../SSC/Src/ecatslv.c ****             result = ALSTATUSCODE_UNKNOWNALCONTROL;
 3642              	 .loc 3 1795 0
 3643 0530 1223     	 movs r3,#18
 3644 0532 FB81     	 strh r3,[r7,#14]
1796:../SSC/Src/ecatslv.c ****             break;
 3645              	 .loc 3 1796 0
 3646 0534 00BF     	 nop
 3647              	.L223:
 3648 0536 24E0     	 b .L242
 3649              	.L206:
1797:../SSC/Src/ecatslv.c ****         }
1798:../SSC/Src/ecatslv.c ****     }
1799:../SSC/Src/ecatslv.c ****     else
1800:../SSC/Src/ecatslv.c ****     {
1801:../SSC/Src/ecatslv.c ****         /* the checking of the sync manager settings was not successful
1802:../SSC/Src/ecatslv.c ****             switch back the state to PREOP or INIT */
1803:../SSC/Src/ecatslv.c ****         switch (nAlStatus)
 3650              	 .loc 3 1803 0
 3651 0538 474B     	 ldr r3,.L265+24
 3652 053a 1B78     	 ldrb r3,[r3]
 3653 053c 042B     	 cmp r3,#4
 3654 053e 08D0     	 beq .L243
 3655 0540 082B     	 cmp r3,#8
 3656 0542 02D0     	 beq .L244
 3657 0544 022B     	 cmp r3,#2
 3658 0546 08D0     	 beq .L245
 3659 0548 1BE0     	 b .L242
 3660              	.L244:
1804:../SSC/Src/ecatslv.c ****         {
1805:../SSC/Src/ecatslv.c ****         case STATE_OP:
1806:../SSC/Src/ecatslv.c ****             /* stop the output handler (function is defined above) */
1807:../SSC/Src/ecatslv.c ****             APPL_StopOutputHandler();
 3661              	 .loc 3 1807 0
 3662 054a FFF7FEFF 	 bl APPL_StopOutputHandler
1808:../SSC/Src/ecatslv.c ****             StopOutputHandler();
 3663              	 .loc 3 1808 0
 3664 054e FFF7FEFF 	 bl StopOutputHandler
 3665              	.L243:
1809:../SSC/Src/ecatslv.c ****         case STATE_SAFEOP:
1810:../SSC/Src/ecatslv.c ****             /* stop the input handler (function is defined above) */
1811:../SSC/Src/ecatslv.c ****             APPL_StopInputHandler();
 3666              	 .loc 3 1811 0
 3667 0552 FFF7FEFF 	 bl APPL_StopInputHandler
1812:../SSC/Src/ecatslv.c **** 
1813:../SSC/Src/ecatslv.c ****             StopInputHandler();
 3668              	 .loc 3 1813 0
 3669 0556 FFF7FEFF 	 bl StopInputHandler
 3670              	.L245:
1814:../SSC/Src/ecatslv.c ****         case STATE_PREOP:
1815:../SSC/Src/ecatslv.c ****             if ( result == ALSTATUSCODE_INVALIDMBXCFGINPREOP )
 3671              	 .loc 3 1815 0
 3672 055a FB89     	 ldrh r3,[r7,#14]
 3673 055c 162B     	 cmp r3,#22
 3674 055e 0DD1     	 bne .L246
1816:../SSC/Src/ecatslv.c ****             {
1817:../SSC/Src/ecatslv.c ****                 /* the mailbox sync manager settings were wrong, switch back to INIT */
1818:../SSC/Src/ecatslv.c ****                 MBX_StopMailboxHandler();
 3675              	 .loc 3 1818 0
 3676 0560 FFF7FEFF 	 bl MBX_StopMailboxHandler
1819:../SSC/Src/ecatslv.c ****                 APPL_StopMailboxHandler();
 3677              	 .loc 3 1819 0
 3678 0564 FFF7FEFF 	 bl APPL_StopMailboxHandler
1820:../SSC/Src/ecatslv.c **** 
1821:../SSC/Src/ecatslv.c ****                 /*Disable SM0 (MBX Out)*/
1822:../SSC/Src/ecatslv.c ****                 DisableSyncManChannel(MAILBOX_WRITE);
 3679              	 .loc 3 1822 0
 3680 0568 0020     	 movs r0,#0
 3681 056a FFF7FEFF 	 bl DisableSyncManChannel
1823:../SSC/Src/ecatslv.c **** 
1824:../SSC/Src/ecatslv.c ****                 /*Disable SM1 (MBX In)*/
1825:../SSC/Src/ecatslv.c ****                 DisableSyncManChannel(MAILBOX_READ);
 3682              	 .loc 3 1825 0
 3683 056e 0120     	 movs r0,#1
 3684 0570 FFF7FEFF 	 bl DisableSyncManChannel
1826:../SSC/Src/ecatslv.c **** 
1827:../SSC/Src/ecatslv.c ****                 nAlStatus = STATE_INIT;
 3685              	 .loc 3 1827 0
 3686 0574 384B     	 ldr r3,.L265+24
 3687 0576 0122     	 movs r2,#1
 3688 0578 1A70     	 strb r2,[r3]
 3689 057a 02E0     	 b .L242
 3690              	.L246:
1828:../SSC/Src/ecatslv.c ****             }
1829:../SSC/Src/ecatslv.c ****             else
1830:../SSC/Src/ecatslv.c ****             {
1831:../SSC/Src/ecatslv.c ****                 nAlStatus = STATE_PREOP;
 3691              	 .loc 3 1831 0
 3692 057c 364B     	 ldr r3,.L265+24
 3693 057e 0222     	 movs r2,#2
 3694 0580 1A70     	 strb r2,[r3]
 3695              	.L242:
1832:../SSC/Src/ecatslv.c ****             }
1833:../SSC/Src/ecatslv.c ****         }
1834:../SSC/Src/ecatslv.c ****     }
1835:../SSC/Src/ecatslv.c **** 
1836:../SSC/Src/ecatslv.c ****     if ( result == NOERROR_INWORK )
 3696              	 .loc 3 1836 0
 3697 0582 FB89     	 ldrh r3,[r7,#14]
 3698 0584 FF2B     	 cmp r3,#255
 3699 0586 35D1     	 bne .L247
1837:../SSC/Src/ecatslv.c ****     {
1838:../SSC/Src/ecatslv.c ****         /* state transition is still in work
1839:../SSC/Src/ecatslv.c ****             ECAT_StateChange must be called from the application */
1840:../SSC/Src/ecatslv.c ****         bEcatWaitForAlControlRes = TRUE;
 3700              	 .loc 3 1840 0
 3701 0588 344B     	 ldr r3,.L265+28
 3702 058a 0122     	 movs r2,#1
 3703 058c 1A70     	 strb r2,[r3]
1841:../SSC/Src/ecatslv.c ****         /* state transition has to be stored */
1842:../SSC/Src/ecatslv.c ****         nEcatStateTrans = stateTrans;
 3704              	 .loc 3 1842 0
 3705 058e 3B7B     	 ldrb r3,[r7,#12]
 3706 0590 9AB2     	 uxth r2,r3
 3707 0592 334B     	 ldr r3,.L265+32
 3708 0594 1A80     	 strh r2,[r3]
1843:../SSC/Src/ecatslv.c **** 
1844:../SSC/Src/ecatslv.c ****         /*Init ESM timeout counter (will be decremented with the local 1ms timer)*/
1845:../SSC/Src/ecatslv.c ****         switch(nEcatStateTrans)
 3709              	 .loc 3 1845 0
 3710 0596 324B     	 ldr r3,.L265+32
 3711 0598 1B88     	 ldrh r3,[r3]
 3712 059a 242B     	 cmp r3,#36
 3713 059c 0DD0     	 beq .L249
 3714 059e 242B     	 cmp r3,#36
 3715 05a0 03DC     	 bgt .L250
 3716 05a2 123B     	 subs r3,r3,#18
 3717 05a4 012B     	 cmp r3,#1
 3718 05a6 0DD8     	 bhi .L248
 3719 05a8 02E0     	 b .L262
 3720              	.L250:
 3721 05aa 482B     	 cmp r3,#72
 3722 05ac 05D0     	 beq .L249
 3723 05ae 09E0     	 b .L248
 3724              	.L262:
1846:../SSC/Src/ecatslv.c ****         {
1847:../SSC/Src/ecatslv.c ****             case INIT_2_PREOP:
1848:../SSC/Src/ecatslv.c ****             case INIT_2_BOOT:
1849:../SSC/Src/ecatslv.c ****                 EsmTimeoutCounter = PREOPTIMEOUT;
 3725              	 .loc 3 1849 0
 3726 05b0 2C4B     	 ldr r3,.L265+36
 3727 05b2 4FF4FA62 	 mov r2,#2000
 3728 05b6 1A80     	 strh r2,[r3]
1850:../SSC/Src/ecatslv.c ****             break;
 3729              	 .loc 3 1850 0
 3730 05b8 08E0     	 b .L252
 3731              	.L249:
1851:../SSC/Src/ecatslv.c ****             case PREOP_2_SAFEOP:
1852:../SSC/Src/ecatslv.c ****             case SAFEOP_2_OP:
1853:../SSC/Src/ecatslv.c ****                 EsmTimeoutCounter = SAFEOP2OPTIMEOUT;
 3732              	 .loc 3 1853 0
 3733 05ba 2A4B     	 ldr r3,.L265+36
 3734 05bc 42F22832 	 movw r2,#9000
 3735 05c0 1A80     	 strh r2,[r3]
1854:../SSC/Src/ecatslv.c ****                 break;
 3736              	 .loc 3 1854 0
 3737 05c2 03E0     	 b .L252
 3738              	.L248:
1855:../SSC/Src/ecatslv.c ****            default:
1856:../SSC/Src/ecatslv.c ****                 EsmTimeoutCounter = 200; //Set default timeout value to 200ms
 3739              	 .loc 3 1856 0
 3740 05c4 274B     	 ldr r3,.L265+36
 3741 05c6 C822     	 movs r2,#200
 3742 05c8 1A80     	 strh r2,[r3]
1857:../SSC/Src/ecatslv.c ****                 break;
 3743              	 .loc 3 1857 0
 3744 05ca 00BF     	 nop
 3745              	.L252:
1858:../SSC/Src/ecatslv.c ****         }
1859:../SSC/Src/ecatslv.c ****         EsmTimeoutCounter -= (INT16) (EsmTimeoutCounter / 10); //subtract 10% from the timeout to r
 3746              	 .loc 3 1859 0
 3747 05cc 254B     	 ldr r3,.L265+36
 3748 05ce 1B88     	 ldrh r3,[r3]
 3749 05d0 9AB2     	 uxth r2,r3
 3750 05d2 244B     	 ldr r3,.L265+36
 3751 05d4 1B88     	 ldrh r3,[r3]
 3752 05d6 1BB2     	 sxth r3,r3
 3753 05d8 2349     	 ldr r1,.L265+40
 3754 05da 81FB0301 	 smull r0,r1,r1,r3
 3755 05de 8910     	 asrs r1,r1,#2
 3756 05e0 DB17     	 asrs r3,r3,#31
 3757 05e2 CB1A     	 subs r3,r1,r3
 3758 05e4 9BB2     	 uxth r3,r3
 3759 05e6 9BB2     	 uxth r3,r3
 3760 05e8 D31A     	 subs r3,r2,r3
 3761 05ea 9BB2     	 uxth r3,r3
 3762 05ec 9AB2     	 uxth r2,r3
 3763 05ee 1D4B     	 ldr r3,.L265+36
 3764 05f0 1A80     	 strh r2,[r3]
 3765 05f2 74E0     	 b .L194
 3766              	.L247:
1860:../SSC/Src/ecatslv.c **** 
1861:../SSC/Src/ecatslv.c ****     }
1862:../SSC/Src/ecatslv.c ****     else if ( alControl != (nAlStatus & STATE_MASK) )
 3767              	 .loc 3 1862 0
 3768 05f4 FA79     	 ldrb r2,[r7,#7]
 3769 05f6 184B     	 ldr r3,.L265+24
 3770 05f8 1B78     	 ldrb r3,[r3]
 3771 05fa 03F00F03 	 and r3,r3,#15
 3772 05fe 9A42     	 cmp r2,r3
 3773 0600 64D0     	 beq .L253
1863:../SSC/Src/ecatslv.c ****     {
1864:../SSC/Src/ecatslv.c ****         /* The slave state has changed */
1865:../SSC/Src/ecatslv.c **** 
1866:../SSC/Src/ecatslv.c ****         if ( (result != 0 || alStatusCode != 0) && ((alControl | nAlStatus) & STATE_OP) )
 3774              	 .loc 3 1866 0
 3775 0602 FB89     	 ldrh r3,[r7,#14]
 3776 0604 002B     	 cmp r3,#0
 3777 0606 02D1     	 bne .L254
 3778              	 .loc 3 1866 0 is_stmt 0 discriminator 2
 3779 0608 BB88     	 ldrh r3,[r7,#4]
 3780 060a 002B     	 cmp r3,#0
 3781 060c 35D0     	 beq .L255
 3782              	.L254:
 3783              	 .loc 3 1866 0 discriminator 3
 3784 060e 124B     	 ldr r3,.L265+24
 3785 0610 1A78     	 ldrb r2,[r3]
 3786 0612 FB79     	 ldrb r3,[r7,#7]
 3787 0614 1343     	 orrs r3,r3,r2
 3788 0616 DBB2     	 uxtb r3,r3
 3789 0618 03F00803 	 and r3,r3,#8
 3790 061c 002B     	 cmp r3,#0
 3791 061e 2CD0     	 beq .L255
1867:../SSC/Src/ecatslv.c ****         {
1868:../SSC/Src/ecatslv.c ****             /* the local application requested to leave the state OP so we have to disable the SM2
1869:../SSC/Src/ecatslv.c ****                and make the state change from OP to SAFEOP by calling StopOutputHandler */
1870:../SSC/Src/ecatslv.c **** 
1871:../SSC/Src/ecatslv.c ****             //only execute StopOutputHandler() if Output update is still running
1872:../SSC/Src/ecatslv.c ****             if(bEcatOutputUpdateRunning)
 3792              	 .loc 3 1872 0 is_stmt 1
 3793 0620 0C4B     	 ldr r3,.L265+20
 3794 0622 1B78     	 ldrb r3,[r3]
 3795 0624 002B     	 cmp r3,#0
 3796 0626 03D0     	 beq .L256
1873:../SSC/Src/ecatslv.c ****             {
1874:../SSC/Src/ecatslv.c ****                 APPL_StopOutputHandler();
 3797              	 .loc 3 1874 0
 3798 0628 FFF7FEFF 	 bl APPL_StopOutputHandler
1875:../SSC/Src/ecatslv.c **** 
1876:../SSC/Src/ecatslv.c ****                 StopOutputHandler();
 3799              	 .loc 3 1876 0
 3800 062c FFF7FEFF 	 bl StopOutputHandler
 3801              	.L256:
1877:../SSC/Src/ecatslv.c ****             }
1878:../SSC/Src/ecatslv.c **** 
1879:../SSC/Src/ecatslv.c ****             if(nPdOutputSize > 0)
 3802              	 .loc 3 1879 0
 3803 0630 064B     	 ldr r3,.L265+12
 3804 0632 1B88     	 ldrh r3,[r3]
 3805 0634 002B     	 cmp r3,#0
 3806 0636 19D0     	 beq .L257
1880:../SSC/Src/ecatslv.c ****             {
1881:../SSC/Src/ecatslv.c ****                 /* disable the Sync Manager Channel 2 (outputs) */
1882:../SSC/Src/ecatslv.c ****                 DisableSyncManChannel(PROCESS_DATA_OUT);
 3807              	 .loc 3 1882 0
 3808 0638 0220     	 movs r0,#2
 3809 063a FFF7FEFF 	 bl DisableSyncManChannel
 3810 063e 1CE0     	 b .L255
 3811              	.L266:
 3812              	 .align 2
 3813              	.L265:
 3814 0640 00000000 	 .word bApplEsmPending
 3815 0644 00000000 	 .word u16ALEventMask
 3816 0648 00000000 	 .word bEcatInputUpdateRunning
 3817 064c 00000000 	 .word nPdOutputSize
 3818 0650 00000000 	 .word nPdInputSize
 3819 0654 00000000 	 .word bEcatOutputUpdateRunning
 3820 0658 00000000 	 .word nAlStatus
 3821 065c 00000000 	 .word bEcatWaitForAlControlRes
 3822 0660 00000000 	 .word nEcatStateTrans
 3823 0664 00000000 	 .word EsmTimeoutCounter
 3824 0668 67666666 	 .word 1717986919
 3825              	.L257:
1883:../SSC/Src/ecatslv.c ****             }
1884:../SSC/Src/ecatslv.c ****             else
1885:../SSC/Src/ecatslv.c ****                 if(nPdInputSize > 0)
 3826              	 .loc 3 1885 0
 3827 066c 1D4B     	 ldr r3,.L267
 3828 066e 1B88     	 ldrh r3,[r3]
 3829 0670 002B     	 cmp r3,#0
 3830 0672 02D0     	 beq .L255
1886:../SSC/Src/ecatslv.c ****             {
1887:../SSC/Src/ecatslv.c ****                 /*disable Sync Manager 3 (inputs) if no outputs available*/
1888:../SSC/Src/ecatslv.c ****                 DisableSyncManChannel(PROCESS_DATA_IN);
 3831              	 .loc 3 1888 0
 3832 0674 0320     	 movs r0,#3
 3833 0676 FFF7FEFF 	 bl DisableSyncManChannel
 3834              	.L255:
1889:../SSC/Src/ecatslv.c ****             }
1890:../SSC/Src/ecatslv.c **** 
1891:../SSC/Src/ecatslv.c ****         }
1892:../SSC/Src/ecatslv.c ****         if ( result != 0 )
 3835              	 .loc 3 1892 0
 3836 067a FB89     	 ldrh r3,[r7,#14]
 3837 067c 002B     	 cmp r3,#0
 3838 067e 0ED0     	 beq .L258
1893:../SSC/Src/ecatslv.c ****         {
1894:../SSC/Src/ecatslv.c ****                 if (nAlStatus == STATE_OP)
 3839              	 .loc 3 1894 0
 3840 0680 194B     	 ldr r3,.L267+4
 3841 0682 1B78     	 ldrb r3,[r3]
 3842 0684 082B     	 cmp r3,#8
 3843 0686 02D1     	 bne .L259
1895:../SSC/Src/ecatslv.c ****                 {
1896:../SSC/Src/ecatslv.c ****                     nAlStatus = STATE_SAFEOP;
 3844              	 .loc 3 1896 0
 3845 0688 174B     	 ldr r3,.L267+4
 3846 068a 0422     	 movs r2,#4
 3847 068c 1A70     	 strb r2,[r3]
 3848              	.L259:
1897:../SSC/Src/ecatslv.c ****                 }
1898:../SSC/Src/ecatslv.c ****             /* save the failed status to be able to decide, if the AL Status Code shall be
1899:../SSC/Src/ecatslv.c ****                reset in case of a coming successful state transition */
1900:../SSC/Src/ecatslv.c ****             nAlStatus |= STATE_CHANGE;
 3849              	 .loc 3 1900 0
 3850 068e 164B     	 ldr r3,.L267+4
 3851 0690 1B78     	 ldrb r3,[r3]
 3852 0692 43F01003 	 orr r3,r3,#16
 3853 0696 DAB2     	 uxtb r2,r3
 3854 0698 134B     	 ldr r3,.L267+4
 3855 069a 1A70     	 strb r2,[r3]
 3856 069c 0BE0     	 b .L260
 3857              	.L258:
1901:../SSC/Src/ecatslv.c ****         }
1902:../SSC/Src/ecatslv.c ****         else
1903:../SSC/Src/ecatslv.c ****         {
1904:../SSC/Src/ecatslv.c ****             /* state transition was successful */
1905:../SSC/Src/ecatslv.c ****             if ( alStatusCode != 0 )
 3858              	 .loc 3 1905 0
 3859 069e BB88     	 ldrh r3,[r7,#4]
 3860 06a0 002B     	 cmp r3,#0
 3861 06a2 05D0     	 beq .L261
1906:../SSC/Src/ecatslv.c ****             {
1907:../SSC/Src/ecatslv.c ****                 /* state change request from the user */
1908:../SSC/Src/ecatslv.c ****                 result = alStatusCode;
 3862              	 .loc 3 1908 0
 3863 06a4 BB88     	 ldrh r3,[r7,#4]
 3864 06a6 FB81     	 strh r3,[r7,#14]
1909:../SSC/Src/ecatslv.c ****                 alControl |= STATE_CHANGE;
 3865              	 .loc 3 1909 0
 3866 06a8 FB79     	 ldrb r3,[r7,#7]
 3867 06aa 43F01003 	 orr r3,r3,#16
 3868 06ae FB71     	 strb r3,[r7,#7]
 3869              	.L261:
1910:../SSC/Src/ecatslv.c ****             }
1911:../SSC/Src/ecatslv.c ****             /* acknowledge the new state */
1912:../SSC/Src/ecatslv.c ****             nAlStatus = alControl;
 3870              	 .loc 3 1912 0
 3871 06b0 0D4A     	 ldr r2,.L267+4
 3872 06b2 FB79     	 ldrb r3,[r7,#7]
 3873 06b4 1370     	 strb r3,[r2]
 3874              	.L260:
1913:../SSC/Src/ecatslv.c ****         }
1914:../SSC/Src/ecatslv.c **** 
1915:../SSC/Src/ecatslv.c ****         bEcatWaitForAlControlRes = FALSE;
 3875              	 .loc 3 1915 0
 3876 06b6 0D4B     	 ldr r3,.L267+8
 3877 06b8 0022     	 movs r2,#0
 3878 06ba 1A70     	 strb r2,[r3]
1916:../SSC/Src/ecatslv.c **** 
1917:../SSC/Src/ecatslv.c ****         /* write the AL Status register */
1918:../SSC/Src/ecatslv.c ****         SetALStatus(nAlStatus, result);
 3879              	 .loc 3 1918 0
 3880 06bc 0A4B     	 ldr r3,.L267+4
 3881 06be 1A78     	 ldrb r2,[r3]
 3882 06c0 FB89     	 ldrh r3,[r7,#14]
 3883 06c2 1046     	 mov r0,r2
 3884 06c4 1946     	 mov r1,r3
 3885 06c6 FFF7FEFF 	 bl SetALStatus
 3886 06ca 08E0     	 b .L194
 3887              	.L253:
1919:../SSC/Src/ecatslv.c ****     }
1920:../SSC/Src/ecatslv.c ****     else
1921:../SSC/Src/ecatslv.c ****     {
1922:../SSC/Src/ecatslv.c ****         /* Error acknowledgement without a state transition */
1923:../SSC/Src/ecatslv.c **** 
1924:../SSC/Src/ecatslv.c ****          bEcatWaitForAlControlRes = FALSE;
 3888              	 .loc 3 1924 0
 3889 06cc 074B     	 ldr r3,.L267+8
 3890 06ce 0022     	 movs r2,#0
 3891 06d0 1A70     	 strb r2,[r3]
1925:../SSC/Src/ecatslv.c **** 
1926:../SSC/Src/ecatslv.c ****         /* AL-Status has to be updated and AL-Status-Code has to be reset
1927:../SSC/Src/ecatslv.c ****            if the the error bit was acknowledged */
1928:../SSC/Src/ecatslv.c ****         SetALStatus(nAlStatus, 0);
 3892              	 .loc 3 1928 0
 3893 06d2 054B     	 ldr r3,.L267+4
 3894 06d4 1B78     	 ldrb r3,[r3]
 3895 06d6 1846     	 mov r0,r3
 3896 06d8 0021     	 movs r1,#0
 3897 06da FFF7FEFF 	 bl SetALStatus
 3898              	.L194:
1929:../SSC/Src/ecatslv.c ****     }
1930:../SSC/Src/ecatslv.c ****     /*ECATCHANGE_START(V5.13) CIA402 4*/
1931:../SSC/Src/ecatslv.c ****     /*decouple CIA402 state machine from ESM*/
1932:../SSC/Src/ecatslv.c ****     /*ECATCHANGE_END(V5.13) CIA402 4*/
1933:../SSC/Src/ecatslv.c **** 
1934:../SSC/Src/ecatslv.c **** }
 3899              	 .loc 3 1934 0
 3900 06de 1037     	 adds r7,r7,#16
 3901              	.LCFI82:
 3902              	 .cfi_def_cfa_offset 8
 3903 06e0 BD46     	 mov sp,r7
 3904              	.LCFI83:
 3905              	 .cfi_def_cfa_register 13
 3906              	 
 3907 06e2 80BD     	 pop {r7,pc}
 3908              	.L268:
 3909              	 .align 2
 3910              	.L267:
 3911 06e4 00000000 	 .word nPdInputSize
 3912 06e8 00000000 	 .word nAlStatus
 3913 06ec 00000000 	 .word bEcatWaitForAlControlRes
 3914              	 .cfi_endproc
 3915              	.LFE188:
 3917              	 .section .text.AL_ControlRes,"ax",%progbits
 3918              	 .align 2
 3919              	 .global AL_ControlRes
 3920              	 .thumb
 3921              	 .thumb_func
 3923              	AL_ControlRes:
 3924              	.LFB189:
1935:../SSC/Src/ecatslv.c **** 
1936:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
1937:../SSC/Src/ecatslv.c **** /**
1938:../SSC/Src/ecatslv.c **** 
1939:../SSC/Src/ecatslv.c ****  \brief    This function is called cyclic if a state transition is pending (bEcatWaitForAlControlRe
1940:../SSC/Src/ecatslv.c ****  \brief    If the ESM timeout is expired the state transition will be rejected. Otherwise the appli
1941:../SSC/Src/ecatslv.c ****  \brief    If the pending state transition is triggered by the application the transition need to b
1942:../SSC/Src/ecatslv.c ****   *////////////////////////////////////////////////////////////////////////////////////////
1943:../SSC/Src/ecatslv.c **** void AL_ControlRes(void)
1944:../SSC/Src/ecatslv.c **** {
 3925              	 .loc 3 1944 0
 3926              	 .cfi_startproc
 3927              	 
 3928              	 
 3929 0000 80B5     	 push {r7,lr}
 3930              	.LCFI84:
 3931              	 .cfi_def_cfa_offset 8
 3932              	 .cfi_offset 7,-8
 3933              	 .cfi_offset 14,-4
 3934 0002 82B0     	 sub sp,sp,#8
 3935              	.LCFI85:
 3936              	 .cfi_def_cfa_offset 16
 3937 0004 00AF     	 add r7,sp,#0
 3938              	.LCFI86:
 3939              	 .cfi_def_cfa_register 7
1945:../SSC/Src/ecatslv.c ****     if(bEcatWaitForAlControlRes)
 3940              	 .loc 3 1945 0
 3941 0006 A54B     	 ldr r3,.L313
 3942 0008 1B78     	 ldrb r3,[r3]
 3943 000a 002B     	 cmp r3,#0
 3944 000c 00F07C81 	 beq .L269
 3945              	.LBB9:
1946:../SSC/Src/ecatslv.c ****     {
1947:../SSC/Src/ecatslv.c ****         UINT16 result = 0;
 3946              	 .loc 3 1947 0
 3947 0010 0023     	 movs r3,#0
 3948 0012 7B80     	 strh r3,[r7,#2]
1948:../SSC/Src/ecatslv.c ****         UINT8 Status = 0;
 3949              	 .loc 3 1948 0
 3950 0014 0023     	 movs r3,#0
 3951 0016 FB71     	 strb r3,[r7,#7]
1949:../SSC/Src/ecatslv.c ****         UINT16 StatusCode = 0;
 3952              	 .loc 3 1949 0
 3953 0018 0023     	 movs r3,#0
 3954 001a BB80     	 strh r3,[r7,#4]
1950:../SSC/Src/ecatslv.c **** 
1951:../SSC/Src/ecatslv.c ****         if(EsmTimeoutCounter == 0)
 3955              	 .loc 3 1951 0
 3956 001c A04B     	 ldr r3,.L313+4
 3957 001e 1B88     	 ldrh r3,[r3]
 3958 0020 002B     	 cmp r3,#0
 3959 0022 40F09A80 	 bne .L271
1952:../SSC/Src/ecatslv.c ****         {
1953:../SSC/Src/ecatslv.c ****             Status =  (UINT8)(nEcatStateTrans >> 4);
 3960              	 .loc 3 1953 0
 3961 0026 9F4B     	 ldr r3,.L313+8
 3962 0028 1B88     	 ldrh r3,[r3]
 3963 002a 1B09     	 lsrs r3,r3,#4
 3964 002c 9BB2     	 uxth r3,r3
 3965 002e FB71     	 strb r3,[r7,#7]
1954:../SSC/Src/ecatslv.c **** 
1955:../SSC/Src/ecatslv.c ****             /* ESM timeout expired*/
1956:../SSC/Src/ecatslv.c ****             switch(nEcatStateTrans)
 3966              	 .loc 3 1956 0
 3967 0030 9C4B     	 ldr r3,.L313+8
 3968 0032 1B88     	 ldrh r3,[r3]
 3969 0034 242B     	 cmp r3,#36
 3970 0036 21D0     	 beq .L273
 3971 0038 242B     	 cmp r3,#36
 3972 003a 04DC     	 bgt .L274
 3973 003c 123B     	 subs r3,r3,#18
 3974 003e 012B     	 cmp r3,#1
 3975 0040 00F24F81 	 bhi .L293
 3976 0044 02E0     	 b .L309
 3977              	.L274:
 3978 0046 482B     	 cmp r3,#72
 3979 0048 30D0     	 beq .L276
 3980 004a 4AE1     	 b .L293
 3981              	.L309:
1957:../SSC/Src/ecatslv.c ****             {
1958:../SSC/Src/ecatslv.c ****                 case INIT_2_PREOP:
1959:../SSC/Src/ecatslv.c ****                 case INIT_2_BOOT:
1960:../SSC/Src/ecatslv.c **** 
1961:../SSC/Src/ecatslv.c ****                         if (!bApplEsmPending)
 3982              	 .loc 3 1961 0
 3983 004c 964B     	 ldr r3,.L313+12
 3984 004e 1B78     	 ldrb r3,[r3]
 3985 0050 83F00103 	 eor r3,r3,#1
 3986 0054 DBB2     	 uxtb r3,r3
 3987 0056 002B     	 cmp r3,#0
 3988 0058 01D0     	 beq .L277
1962:../SSC/Src/ecatslv.c ****                         {
1963:../SSC/Src/ecatslv.c ****                             APPL_StopMailboxHandler();
 3989              	 .loc 3 1963 0
 3990 005a FFF7FEFF 	 bl APPL_StopMailboxHandler
 3991              	.L277:
1964:../SSC/Src/ecatslv.c ****                         }
1965:../SSC/Src/ecatslv.c **** 
1966:../SSC/Src/ecatslv.c ****                     MBX_StopMailboxHandler();
 3992              	 .loc 3 1966 0
 3993 005e FFF7FEFF 	 bl MBX_StopMailboxHandler
1967:../SSC/Src/ecatslv.c ****                     /*ECATCHANGE_START(V5.13) ESM1*/
1968:../SSC/Src/ecatslv.c ****                     if((u8LocalErrorState & STATE_MASK) == STATE_INIT)
 3994              	 .loc 3 1968 0
 3995 0062 924B     	 ldr r3,.L313+16
 3996 0064 1B78     	 ldrb r3,[r3]
 3997 0066 03F00F03 	 and r3,r3,#15
 3998 006a 012B     	 cmp r3,#1
 3999 006c 03D1     	 bne .L278
1969:../SSC/Src/ecatslv.c ****                         /*ECATCHANGE_END(V5.13) ESM1*/
1970:../SSC/Src/ecatslv.c ****                     {
1971:../SSC/Src/ecatslv.c ****                         /*Set application specified error*/
1972:../SSC/Src/ecatslv.c ****                         StatusCode = u16LocalErrorCode;
 4000              	 .loc 3 1972 0
 4001 006e 904B     	 ldr r3,.L313+20
 4002 0070 1B88     	 ldrh r3,[r3]
 4003 0072 BB80     	 strh r3,[r7,#4]
1973:../SSC/Src/ecatslv.c ****                     }
1974:../SSC/Src/ecatslv.c ****                     else
1975:../SSC/Src/ecatslv.c ****                     {
1976:../SSC/Src/ecatslv.c ****                         /*Set unspecified error*/
1977:../SSC/Src/ecatslv.c ****                         StatusCode = ALSTATUSCODE_UNSPECIFIEDERROR;
1978:../SSC/Src/ecatslv.c ****                     }
1979:../SSC/Src/ecatslv.c ****                 break;
 4004              	 .loc 3 1979 0
 4005 0074 70E0     	 b .L272
 4006              	.L278:
1977:../SSC/Src/ecatslv.c ****                     }
 4007              	 .loc 3 1977 0
 4008 0076 0123     	 movs r3,#1
 4009 0078 BB80     	 strh r3,[r7,#4]
 4010              	 .loc 3 1979 0
 4011 007a 6DE0     	 b .L272
 4012              	.L273:
1980:../SSC/Src/ecatslv.c ****                 case PREOP_2_SAFEOP:
1981:../SSC/Src/ecatslv.c **** 
1982:../SSC/Src/ecatslv.c ****                         if (!bApplEsmPending)
 4013              	 .loc 3 1982 0
 4014 007c 8A4B     	 ldr r3,.L313+12
 4015 007e 1B78     	 ldrb r3,[r3]
 4016 0080 83F00103 	 eor r3,r3,#1
 4017 0084 DBB2     	 uxtb r3,r3
 4018 0086 002B     	 cmp r3,#0
 4019 0088 01D0     	 beq .L280
1983:../SSC/Src/ecatslv.c ****                         {
1984:../SSC/Src/ecatslv.c ****                             APPL_StopInputHandler();
 4020              	 .loc 3 1984 0
 4021 008a FFF7FEFF 	 bl APPL_StopInputHandler
 4022              	.L280:
1985:../SSC/Src/ecatslv.c ****                         }
1986:../SSC/Src/ecatslv.c **** 
1987:../SSC/Src/ecatslv.c ****                     StopInputHandler();
 4023              	 .loc 3 1987 0
 4024 008e FFF7FEFF 	 bl StopInputHandler
1988:../SSC/Src/ecatslv.c ****                     
1989:../SSC/Src/ecatslv.c ****                     /*ECATCHANGE_START(V5.13) ESM1*/
1990:../SSC/Src/ecatslv.c ****                     if ((u8LocalErrorState & STATE_MASK) == STATE_PREOP)
 4025              	 .loc 3 1990 0
 4026 0092 864B     	 ldr r3,.L313+16
 4027 0094 1B78     	 ldrb r3,[r3]
 4028 0096 03F00F03 	 and r3,r3,#15
 4029 009a 022B     	 cmp r3,#2
 4030 009c 03D1     	 bne .L281
1991:../SSC/Src/ecatslv.c ****                         /*ECATCHANGE_END(V5.13) ESM1*/
1992:../SSC/Src/ecatslv.c ****                     {
1993:../SSC/Src/ecatslv.c ****                         /*Set application specified error*/
1994:../SSC/Src/ecatslv.c ****                         StatusCode = u16LocalErrorCode;
 4031              	 .loc 3 1994 0
 4032 009e 844B     	 ldr r3,.L313+20
 4033 00a0 1B88     	 ldrh r3,[r3]
 4034 00a2 BB80     	 strh r3,[r7,#4]
1995:../SSC/Src/ecatslv.c ****                     }
1996:../SSC/Src/ecatslv.c ****                     else
1997:../SSC/Src/ecatslv.c ****                     {
1998:../SSC/Src/ecatslv.c ****                         /*Set unspecified error*/
1999:../SSC/Src/ecatslv.c ****                         StatusCode = ALSTATUSCODE_UNSPECIFIEDERROR;
2000:../SSC/Src/ecatslv.c ****                     }
2001:../SSC/Src/ecatslv.c ****                 break;
 4035              	 .loc 3 2001 0
 4036 00a4 58E0     	 b .L272
 4037              	.L281:
1999:../SSC/Src/ecatslv.c ****                     }
 4038              	 .loc 3 1999 0
 4039 00a6 0123     	 movs r3,#1
 4040 00a8 BB80     	 strh r3,[r7,#4]
 4041              	 .loc 3 2001 0
 4042 00aa 55E0     	 b .L272
 4043              	.L276:
2002:../SSC/Src/ecatslv.c ****                 case SAFEOP_2_OP:
2003:../SSC/Src/ecatslv.c ****                     if(bDcSyncActive)
 4044              	 .loc 3 2003 0
 4045 00ac 814B     	 ldr r3,.L313+24
 4046 00ae 1B78     	 ldrb r3,[r3]
 4047 00b0 002B     	 cmp r3,#0
 4048 00b2 29D0     	 beq .L283
2004:../SSC/Src/ecatslv.c ****                     {
2005:../SSC/Src/ecatslv.c ****                         /*SafeOP to OP timeout expired check which AL status code need to be writte
2006:../SSC/Src/ecatslv.c ****                         if(!bDcRunning)
 4049              	 .loc 3 2006 0
 4050 00b4 804B     	 ldr r3,.L313+28
 4051 00b6 1B78     	 ldrb r3,[r3]
 4052 00b8 83F00103 	 eor r3,r3,#1
 4053 00bc DBB2     	 uxtb r3,r3
 4054 00be 002B     	 cmp r3,#0
 4055 00c0 02D0     	 beq .L284
2007:../SSC/Src/ecatslv.c ****                         {
2008:../SSC/Src/ecatslv.c ****                             /*no Sync0 signal received*/
2009:../SSC/Src/ecatslv.c ****                             StatusCode = ALSTATUSCODE_NOSYNCERROR;
 4056              	 .loc 3 2009 0
 4057 00c2 2D23     	 movs r3,#45
 4058 00c4 BB80     	 strh r3,[r7,#4]
 4059 00c6 37E0     	 b .L288
 4060              	.L284:
2010:../SSC/Src/ecatslv.c ****                         }
2011:../SSC/Src/ecatslv.c ****                         else if(!bEcatFirstOutputsReceived && (nPdOutputSize > 0))
 4061              	 .loc 3 2011 0
 4062 00c8 7C4B     	 ldr r3,.L313+32
 4063 00ca 1B78     	 ldrb r3,[r3]
 4064 00cc 83F00103 	 eor r3,r3,#1
 4065 00d0 DBB2     	 uxtb r3,r3
 4066 00d2 002B     	 cmp r3,#0
 4067 00d4 06D0     	 beq .L286
 4068              	 .loc 3 2011 0 is_stmt 0 discriminator 1
 4069 00d6 7A4B     	 ldr r3,.L313+36
 4070 00d8 1B88     	 ldrh r3,[r3]
 4071 00da 002B     	 cmp r3,#0
 4072 00dc 02D0     	 beq .L286
2012:../SSC/Src/ecatslv.c ****                         {
2013:../SSC/Src/ecatslv.c ****                             /*no process data received*/
2014:../SSC/Src/ecatslv.c ****                             StatusCode = ALSTATUSCODE_SMWATCHDOG;
 4073              	 .loc 3 2014 0 is_stmt 1
 4074 00de 1B23     	 movs r3,#27
 4075 00e0 BB80     	 strh r3,[r7,#4]
 4076 00e2 29E0     	 b .L288
 4077              	.L286:
2015:../SSC/Src/ecatslv.c ****                         }
2016:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.13) ESM3*/
2017:../SSC/Src/ecatslv.c ****                         else if (!bSmSyncSequenceValid)
 4078              	 .loc 3 2017 0
 4079 00e4 774B     	 ldr r3,.L313+40
 4080 00e6 1B78     	 ldrb r3,[r3]
 4081 00e8 83F00103 	 eor r3,r3,#1
 4082 00ec DBB2     	 uxtb r3,r3
 4083 00ee 002B     	 cmp r3,#0
 4084 00f0 02D0     	 beq .L287
2018:../SSC/Src/ecatslv.c ****                         {
2019:../SSC/Src/ecatslv.c ****                             /*SM/Sync Sequence is not valid*/
2020:../SSC/Src/ecatslv.c ****                             StatusCode = ALSTATUSCODE_SYNCERROR;
 4085              	 .loc 3 2020 0
 4086 00f2 1A23     	 movs r3,#26
 4087 00f4 BB80     	 strh r3,[r7,#4]
 4088 00f6 1FE0     	 b .L288
 4089              	.L287:
2021:../SSC/Src/ecatslv.c ****                         }
2022:../SSC/Src/ecatslv.c ****                         else
2023:../SSC/Src/ecatslv.c ****                         {
2024:../SSC/Src/ecatslv.c ****                             /*Set valid state transition even if timeout expired*/
2025:../SSC/Src/ecatslv.c ****                             Status = STATE_OP;
 4090              	 .loc 3 2025 0
 4091 00f8 0823     	 movs r3,#8
 4092 00fa FB71     	 strb r3,[r7,#7]
2026:../SSC/Src/ecatslv.c ****                             StatusCode = 0;
 4093              	 .loc 3 2026 0
 4094 00fc 0023     	 movs r3,#0
 4095 00fe BB80     	 strh r3,[r7,#4]
2027:../SSC/Src/ecatslv.c ****                             /* Slave is OPERATIONAL */
2028:../SSC/Src/ecatslv.c ****                             bEcatOutputUpdateRunning = TRUE;
 4096              	 .loc 3 2028 0
 4097 0100 714B     	 ldr r3,.L313+44
 4098 0102 0122     	 movs r2,#1
 4099 0104 1A70     	 strb r2,[r3]
 4100 0106 17E0     	 b .L288
 4101              	.L283:
2029:../SSC/Src/ecatslv.c ****                         }
2030:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.13) ESM3*/
2031:../SSC/Src/ecatslv.c ****                     }
2032:../SSC/Src/ecatslv.c ****                     else
2033:../SSC/Src/ecatslv.c ****                     {
2034:../SSC/Src/ecatslv.c ****                         if (nPdOutputSize > 0)
 4102              	 .loc 3 2034 0
 4103 0108 6D4B     	 ldr r3,.L313+36
 4104 010a 1B88     	 ldrh r3,[r3]
 4105 010c 002B     	 cmp r3,#0
 4106 010e 02D0     	 beq .L289
2035:../SSC/Src/ecatslv.c ****                         {
2036:../SSC/Src/ecatslv.c ****                             StatusCode = ALSTATUSCODE_SMWATCHDOG;
 4107              	 .loc 3 2036 0
 4108 0110 1B23     	 movs r3,#27
 4109 0112 BB80     	 strh r3,[r7,#4]
 4110 0114 10E0     	 b .L288
 4111              	.L289:
2037:../SSC/Src/ecatslv.c ****                         }
2038:../SSC/Src/ecatslv.c ****                         else
2039:../SSC/Src/ecatslv.c ****                         {
2040:../SSC/Src/ecatslv.c ****                             /*ECATCHANGE_START(V5.13) ESM1*/
2041:../SSC/Src/ecatslv.c ****                             if ((u8LocalErrorState & STATE_MASK) == STATE_SAFEOP)
 4112              	 .loc 3 2041 0
 4113 0116 654B     	 ldr r3,.L313+16
 4114 0118 1B78     	 ldrb r3,[r3]
 4115 011a 03F00F03 	 and r3,r3,#15
 4116 011e 042B     	 cmp r3,#4
 4117 0120 03D1     	 bne .L290
2042:../SSC/Src/ecatslv.c ****                             {
2043:../SSC/Src/ecatslv.c ****                                 /*Set application specified error*/
2044:../SSC/Src/ecatslv.c ****                                 StatusCode = u16LocalErrorCode;
 4118              	 .loc 3 2044 0
 4119 0122 634B     	 ldr r3,.L313+20
 4120 0124 1B88     	 ldrh r3,[r3]
 4121 0126 BB80     	 strh r3,[r7,#4]
 4122 0128 06E0     	 b .L288
 4123              	.L290:
2045:../SSC/Src/ecatslv.c ****                             }
2046:../SSC/Src/ecatslv.c ****                             else
2047:../SSC/Src/ecatslv.c ****                                 /*ECATCHANGE_END(V5.13) ESM1*/
2048:../SSC/Src/ecatslv.c ****                             {
2049:../SSC/Src/ecatslv.c ****                                 /*Set valid state transition even if timeout expired*/
2050:../SSC/Src/ecatslv.c ****                                 Status = STATE_OP;
 4124              	 .loc 3 2050 0
 4125 012a 0823     	 movs r3,#8
 4126 012c FB71     	 strb r3,[r7,#7]
2051:../SSC/Src/ecatslv.c ****                                 StatusCode = 0;
 4127              	 .loc 3 2051 0
 4128 012e 0023     	 movs r3,#0
 4129 0130 BB80     	 strh r3,[r7,#4]
2052:../SSC/Src/ecatslv.c ****                                 /* Slave is OPERATIONAL */
2053:../SSC/Src/ecatslv.c ****                                 bEcatOutputUpdateRunning = TRUE;
 4130              	 .loc 3 2053 0
 4131 0132 654B     	 ldr r3,.L313+44
 4132 0134 0122     	 movs r2,#1
 4133 0136 1A70     	 strb r2,[r3]
 4134              	.L288:
2054:../SSC/Src/ecatslv.c ****                             }
2055:../SSC/Src/ecatslv.c ****                         }
2056:../SSC/Src/ecatslv.c ****                     }
2057:../SSC/Src/ecatslv.c **** 
2058:../SSC/Src/ecatslv.c ****                     /*Stop handler on failed transition*/
2059:../SSC/Src/ecatslv.c ****                     if(StatusCode != 0)
 4135              	 .loc 3 2059 0
 4136 0138 BB88     	 ldrh r3,[r7,#4]
 4137 013a 002B     	 cmp r3,#0
 4138 013c 0BD0     	 beq .L291
2060:../SSC/Src/ecatslv.c ****                     {
2061:../SSC/Src/ecatslv.c ****                             if (!bApplEsmPending)
 4139              	 .loc 3 2061 0
 4140 013e 5A4B     	 ldr r3,.L313+12
 4141 0140 1B78     	 ldrb r3,[r3]
 4142 0142 83F00103 	 eor r3,r3,#1
 4143 0146 DBB2     	 uxtb r3,r3
 4144 0148 002B     	 cmp r3,#0
 4145 014a 01D0     	 beq .L292
2062:../SSC/Src/ecatslv.c ****                             {
2063:../SSC/Src/ecatslv.c ****                                 APPL_StopOutputHandler();
 4146              	 .loc 3 2063 0
 4147 014c FFF7FEFF 	 bl APPL_StopOutputHandler
 4148              	.L292:
2064:../SSC/Src/ecatslv.c ****                             }
2065:../SSC/Src/ecatslv.c **** 
2066:../SSC/Src/ecatslv.c ****                         StopOutputHandler();
 4149              	 .loc 3 2066 0
 4150 0150 FFF7FEFF 	 bl StopOutputHandler
2067:../SSC/Src/ecatslv.c ****                     }
2068:../SSC/Src/ecatslv.c ****                 break;
 4151              	 .loc 3 2068 0
 4152 0154 FFE7     	 b .L311
 4153              	.L291:
 4154              	.L311:
 4155 0156 00BF     	 nop
 4156              	.L272:
 4157 0158 C3E0     	 b .L293
 4158              	.L271:
2069:../SSC/Src/ecatslv.c ****             }
2070:../SSC/Src/ecatslv.c ****         } //ESM timeout
2071:../SSC/Src/ecatslv.c ****         else
2072:../SSC/Src/ecatslv.c ****         {
2073:../SSC/Src/ecatslv.c ****             /*Call application specific transition function and complete transition it the function
2074:../SSC/Src/ecatslv.c ****             switch(nEcatStateTrans)
 4159              	 .loc 3 2074 0
 4160 015a 524B     	 ldr r3,.L313+8
 4161 015c 1B88     	 ldrh r3,[r3]
 4162 015e 242B     	 cmp r3,#36
 4163 0160 2AD0     	 beq .L294
 4164 0162 242B     	 cmp r3,#36
 4165 0164 04DC     	 bgt .L295
 4166 0166 123B     	 subs r3,r3,#18
 4167 0168 012B     	 cmp r3,#1
 4168 016a 00F2BA80 	 bhi .L293
 4169 016e 02E0     	 b .L310
 4170              	.L295:
 4171 0170 482B     	 cmp r3,#72
 4172 0172 3FD0     	 beq .L297
 4173 0174 B5E0     	 b .L293
 4174              	.L310:
2075:../SSC/Src/ecatslv.c ****             {
2076:../SSC/Src/ecatslv.c ****                 case INIT_2_PREOP:
2077:../SSC/Src/ecatslv.c ****                 case INIT_2_BOOT:
2078:../SSC/Src/ecatslv.c ****                     if(bApplEsmPending)
 4175              	 .loc 3 2078 0
 4176 0176 4C4B     	 ldr r3,.L313+12
 4177 0178 1B78     	 ldrb r3,[r3]
 4178 017a 002B     	 cmp r3,#0
 4179 017c 1BD0     	 beq .L298
2079:../SSC/Src/ecatslv.c ****                     {
2080:../SSC/Src/ecatslv.c ****                         bApplEsmPending = FALSE;
 4180              	 .loc 3 2080 0
 4181 017e 4A4B     	 ldr r3,.L313+12
 4182 0180 0022     	 movs r2,#0
 4183 0182 1A70     	 strb r2,[r3]
2081:../SSC/Src/ecatslv.c ****                         /*APPL_StartMailboxHandler() need to be called*/
2082:../SSC/Src/ecatslv.c ****                         result = APPL_StartMailboxHandler();
 4184              	 .loc 3 2082 0
 4185 0184 FFF7FEFF 	 bl APPL_StartMailboxHandler
 4186 0188 0346     	 mov r3,r0
 4187 018a 7B80     	 strh r3,[r7,#2]
2083:../SSC/Src/ecatslv.c **** 
2084:../SSC/Src/ecatslv.c ****                         if(result == 0)
 4188              	 .loc 3 2084 0
 4189 018c 7B88     	 ldrh r3,[r7,#2]
 4190 018e 002B     	 cmp r3,#0
 4191 0190 09D1     	 bne .L299
2085:../SSC/Src/ecatslv.c ****                         {
2086:../SSC/Src/ecatslv.c ****                             /*The application specific transition was successful => set active mail
2087:../SSC/Src/ecatslv.c ****                             bMbxRunning = TRUE;
 4192              	 .loc 3 2087 0
 4193 0192 4E4B     	 ldr r3,.L313+48
 4194 0194 0122     	 movs r2,#1
 4195 0196 1A70     	 strb r2,[r3]
2088:../SSC/Src/ecatslv.c ****                             Status =  (UINT8)(nEcatStateTrans & STATE_MASK);
 4196              	 .loc 3 2088 0
 4197 0198 424B     	 ldr r3,.L313+8
 4198 019a 1B88     	 ldrh r3,[r3]
 4199 019c DBB2     	 uxtb r3,r3
 4200 019e 03F00F03 	 and r3,r3,#15
 4201 01a2 FB71     	 strb r3,[r7,#7]
 4202 01a4 07E0     	 b .L298
 4203              	.L299:
2089:../SSC/Src/ecatslv.c ****                         }
2090:../SSC/Src/ecatslv.c ****                         else
2091:../SSC/Src/ecatslv.c ****                         {
2092:../SSC/Src/ecatslv.c ****                             /*The application specific transition failed.
2093:../SSC/Src/ecatslv.c ****                             (In pending case the application need to complete the transition)*/
2094:../SSC/Src/ecatslv.c **** 
2095:../SSC/Src/ecatslv.c ****                             if(result != NOERROR_INWORK)
 4204              	 .loc 3 2095 0
 4205 01a6 7B88     	 ldrh r3,[r7,#2]
 4206 01a8 FF2B     	 cmp r3,#255
 4207 01aa 04D0     	 beq .L298
2096:../SSC/Src/ecatslv.c ****                             {
2097:../SSC/Src/ecatslv.c ****                                 APPL_StopMailboxHandler();
 4208              	 .loc 3 2097 0
 4209 01ac FFF7FEFF 	 bl APPL_StopMailboxHandler
2098:../SSC/Src/ecatslv.c ****                                 MBX_StopMailboxHandler();
 4210              	 .loc 3 2098 0
 4211 01b0 FFF7FEFF 	 bl MBX_StopMailboxHandler
2099:../SSC/Src/ecatslv.c ****                             }
2100:../SSC/Src/ecatslv.c ****                         }
2101:../SSC/Src/ecatslv.c ****                     }
2102:../SSC/Src/ecatslv.c ****                 break;
 4212              	 .loc 3 2102 0
 4213 01b4 95E0     	 b .L293
 4214              	.L298:
 4215 01b6 94E0     	 b .L293
 4216              	.L294:
2103:../SSC/Src/ecatslv.c ****                 case PREOP_2_SAFEOP:
2104:../SSC/Src/ecatslv.c ****                     if(bApplEsmPending)
 4217              	 .loc 3 2104 0
 4218 01b8 3B4B     	 ldr r3,.L313+12
 4219 01ba 1B78     	 ldrb r3,[r3]
 4220 01bc 002B     	 cmp r3,#0
 4221 01be 18D0     	 beq .L300
2105:../SSC/Src/ecatslv.c ****                     {
2106:../SSC/Src/ecatslv.c ****                         bApplEsmPending = FALSE;
 4222              	 .loc 3 2106 0
 4223 01c0 394B     	 ldr r3,.L313+12
 4224 01c2 0022     	 movs r2,#0
 4225 01c4 1A70     	 strb r2,[r3]
2107:../SSC/Src/ecatslv.c ****                         result = APPL_StartInputHandler(&u16ALEventMask);
 4226              	 .loc 3 2107 0
 4227 01c6 4248     	 ldr r0,.L313+52
 4228 01c8 FFF7FEFF 	 bl APPL_StartInputHandler
 4229 01cc 0346     	 mov r3,r0
 4230 01ce 7B80     	 strh r3,[r7,#2]
2108:../SSC/Src/ecatslv.c **** 
2109:../SSC/Src/ecatslv.c ****                         if(result == 0)
 4231              	 .loc 3 2109 0
 4232 01d0 7B88     	 ldrh r3,[r7,#2]
 4233 01d2 002B     	 cmp r3,#0
 4234 01d4 05D1     	 bne .L301
2110:../SSC/Src/ecatslv.c ****                         {
2111:../SSC/Src/ecatslv.c ****                             bEcatInputUpdateRunning = TRUE;
 4235              	 .loc 3 2111 0
 4236 01d6 3F4B     	 ldr r3,.L313+56
 4237 01d8 0122     	 movs r2,#1
 4238 01da 1A70     	 strb r2,[r3]
2112:../SSC/Src/ecatslv.c ****                             Status = STATE_SAFEOP;
 4239              	 .loc 3 2112 0
 4240 01dc 0423     	 movs r3,#4
 4241 01de FB71     	 strb r3,[r7,#7]
 4242 01e0 07E0     	 b .L300
 4243              	.L301:
2113:../SSC/Src/ecatslv.c ****                         }
2114:../SSC/Src/ecatslv.c ****                         else
2115:../SSC/Src/ecatslv.c ****                         {
2116:../SSC/Src/ecatslv.c ****                             /*The application specific transition failed.
2117:../SSC/Src/ecatslv.c ****                             (In pending case the application need to complete the transition)*/
2118:../SSC/Src/ecatslv.c **** 
2119:../SSC/Src/ecatslv.c ****                             if(result != NOERROR_INWORK)
 4244              	 .loc 3 2119 0
 4245 01e2 7B88     	 ldrh r3,[r7,#2]
 4246 01e4 FF2B     	 cmp r3,#255
 4247 01e6 04D0     	 beq .L300
2120:../SSC/Src/ecatslv.c ****                             {
2121:../SSC/Src/ecatslv.c ****                                 APPL_StopInputHandler();
 4248              	 .loc 3 2121 0
 4249 01e8 FFF7FEFF 	 bl APPL_StopInputHandler
2122:../SSC/Src/ecatslv.c ****                                 StopInputHandler();
 4250              	 .loc 3 2122 0
 4251 01ec FFF7FEFF 	 bl StopInputHandler
2123:../SSC/Src/ecatslv.c ****                             }
2124:../SSC/Src/ecatslv.c ****                         }
2125:../SSC/Src/ecatslv.c ****                     }
2126:../SSC/Src/ecatslv.c ****                 break;
 4252              	 .loc 3 2126 0
 4253 01f0 77E0     	 b .L293
 4254              	.L300:
 4255 01f2 76E0     	 b .L293
 4256              	.L297:
2127:../SSC/Src/ecatslv.c ****                 case SAFEOP_2_OP:
2128:../SSC/Src/ecatslv.c ****                    if(bApplEsmPending)
 4257              	 .loc 3 2128 0
 4258 01f4 2C4B     	 ldr r3,.L313+12
 4259 01f6 1B78     	 ldrb r3,[r3]
 4260 01f8 002B     	 cmp r3,#0
 4261 01fa 71D0     	 beq .L302
2129:../SSC/Src/ecatslv.c ****                     {
2130:../SSC/Src/ecatslv.c ****                         if(bDcSyncActive)
 4262              	 .loc 3 2130 0
 4263 01fc 2D4B     	 ldr r3,.L313+24
 4264 01fe 1B78     	 ldrb r3,[r3]
 4265 0200 002B     	 cmp r3,#0
 4266 0202 2AD0     	 beq .L303
2131:../SSC/Src/ecatslv.c ****                         {
2132:../SSC/Src/ecatslv.c ****                             if(i16WaitForPllRunningTimeout > 0 && i16WaitForPllRunningTimeout <= i1
 4267              	 .loc 3 2132 0
 4268 0204 344B     	 ldr r3,.L313+60
 4269 0206 1B88     	 ldrh r3,[r3]
 4270 0208 1BB2     	 sxth r3,r3
 4271 020a 002B     	 cmp r3,#0
 4272 020c 68DD     	 ble .L302
 4273              	 .loc 3 2132 0 is_stmt 0 discriminator 1
 4274 020e 324B     	 ldr r3,.L313+60
 4275 0210 1A88     	 ldrh r2,[r3]
 4276 0212 324B     	 ldr r3,.L313+64
 4277 0214 1B88     	 ldrh r3,[r3]
 4278 0216 12B2     	 sxth r2,r2
 4279 0218 1BB2     	 sxth r3,r3
 4280 021a 9A42     	 cmp r2,r3
 4281 021c 60DC     	 bgt .L302
2133:../SSC/Src/ecatslv.c ****                             {
2134:../SSC/Src/ecatslv.c ****                                 /*Pll sequence valid for 200ms (set in APPL_StartOutputHandler() )
2135:../SSC/Src/ecatslv.c ****                                 acknowledge state transition to OP */
2136:../SSC/Src/ecatslv.c **** 
2137:../SSC/Src/ecatslv.c ****                                 i16WaitForPllRunningTimeout = 0;
 4282              	 .loc 3 2137 0 is_stmt 1
 4283 021e 2E4B     	 ldr r3,.L313+60
 4284 0220 0022     	 movs r2,#0
 4285 0222 1A80     	 strh r2,[r3]
2138:../SSC/Src/ecatslv.c ****                                 i16WaitForPllRunningCnt = 0;
 4286              	 .loc 3 2138 0
 4287 0224 2D4B     	 ldr r3,.L313+64
 4288 0226 0022     	 movs r2,#0
 4289 0228 1A80     	 strh r2,[r3]
2139:../SSC/Src/ecatslv.c **** 
2140:../SSC/Src/ecatslv.c ****                                 bApplEsmPending = FALSE;
 4290              	 .loc 3 2140 0
 4291 022a 1F4B     	 ldr r3,.L313+12
 4292 022c 0022     	 movs r2,#0
 4293 022e 1A70     	 strb r2,[r3]
2141:../SSC/Src/ecatslv.c ****                                 result = APPL_StartOutputHandler();
 4294              	 .loc 3 2141 0
 4295 0230 FFF7FEFF 	 bl APPL_StartOutputHandler
 4296 0234 0346     	 mov r3,r0
 4297 0236 7B80     	 strh r3,[r7,#2]
2142:../SSC/Src/ecatslv.c **** 
2143:../SSC/Src/ecatslv.c ****                                 if(result == 0)
 4298              	 .loc 3 2143 0
 4299 0238 7B88     	 ldrh r3,[r7,#2]
 4300 023a 002B     	 cmp r3,#0
 4301 023c 05D1     	 bne .L305
2144:../SSC/Src/ecatslv.c ****                                 {
2145:../SSC/Src/ecatslv.c ****                                     /* Slave is OPERATIONAL */
2146:../SSC/Src/ecatslv.c ****                                     bEcatOutputUpdateRunning = TRUE;
 4302              	 .loc 3 2146 0
 4303 023e 224B     	 ldr r3,.L313+44
 4304 0240 0122     	 movs r2,#1
 4305 0242 1A70     	 strb r2,[r3]
2147:../SSC/Src/ecatslv.c ****                                     Status = STATE_OP;
 4306              	 .loc 3 2147 0
 4307 0244 0823     	 movs r3,#8
 4308 0246 FB71     	 strb r3,[r7,#7]
 4309 0248 4AE0     	 b .L302
 4310              	.L305:
2148:../SSC/Src/ecatslv.c ****                                 }
2149:../SSC/Src/ecatslv.c ****                                 else
2150:../SSC/Src/ecatslv.c ****                                 {
2151:../SSC/Src/ecatslv.c ****                                     if(result != NOERROR_INWORK)
 4311              	 .loc 3 2151 0
 4312 024a 7B88     	 ldrh r3,[r7,#2]
 4313 024c FF2B     	 cmp r3,#255
 4314 024e 47D0     	 beq .L302
2152:../SSC/Src/ecatslv.c ****                                     {
2153:../SSC/Src/ecatslv.c ****                                         APPL_StopOutputHandler();
 4315              	 .loc 3 2153 0
 4316 0250 FFF7FEFF 	 bl APPL_StopOutputHandler
2154:../SSC/Src/ecatslv.c ****                                         StopOutputHandler();
 4317              	 .loc 3 2154 0
 4318 0254 FFF7FEFF 	 bl StopOutputHandler
2155:../SSC/Src/ecatslv.c ****                                     }
2156:../SSC/Src/ecatslv.c ****                                 }
2157:../SSC/Src/ecatslv.c ****                             }
2158:../SSC/Src/ecatslv.c ****                         }
2159:../SSC/Src/ecatslv.c ****                         else
2160:../SSC/Src/ecatslv.c ****                         {
2161:../SSC/Src/ecatslv.c ****                             if(nPdOutputSize == 0 || bEcatFirstOutputsReceived)
2162:../SSC/Src/ecatslv.c ****                             {
2163:../SSC/Src/ecatslv.c ****                                 bApplEsmPending = FALSE;  
2164:../SSC/Src/ecatslv.c ****                                 result = APPL_StartOutputHandler();
2165:../SSC/Src/ecatslv.c **** 
2166:../SSC/Src/ecatslv.c ****                                 if(result == 0)
2167:../SSC/Src/ecatslv.c ****                                 {
2168:../SSC/Src/ecatslv.c ****                                     /* Slave is OPERATIONAL */
2169:../SSC/Src/ecatslv.c ****                                     bEcatOutputUpdateRunning = TRUE;
2170:../SSC/Src/ecatslv.c ****                                     Status = STATE_OP;
2171:../SSC/Src/ecatslv.c ****                                 }
2172:../SSC/Src/ecatslv.c ****                                 else
2173:../SSC/Src/ecatslv.c ****                                 {
2174:../SSC/Src/ecatslv.c ****                                     if(result != NOERROR_INWORK)
2175:../SSC/Src/ecatslv.c ****                                     {
2176:../SSC/Src/ecatslv.c ****                                         APPL_StopOutputHandler();
2177:../SSC/Src/ecatslv.c ****                                         StopOutputHandler();
2178:../SSC/Src/ecatslv.c ****                                     }
2179:../SSC/Src/ecatslv.c ****                                 }
2180:../SSC/Src/ecatslv.c ****                             }
2181:../SSC/Src/ecatslv.c ****                         }       
2182:../SSC/Src/ecatslv.c ****                     }             
2183:../SSC/Src/ecatslv.c ****                 break;
 4319              	 .loc 3 2183 0
 4320 0258 42E0     	 b .L312
 4321              	.L303:
2161:../SSC/Src/ecatslv.c ****                             {
 4322              	 .loc 3 2161 0
 4323 025a 194B     	 ldr r3,.L313+36
 4324 025c 1B88     	 ldrh r3,[r3]
 4325 025e 002B     	 cmp r3,#0
 4326 0260 03D0     	 beq .L306
2161:../SSC/Src/ecatslv.c ****                             {
 4327              	 .loc 3 2161 0 is_stmt 0 discriminator 1
 4328 0262 164B     	 ldr r3,.L313+32
 4329 0264 1B78     	 ldrb r3,[r3]
 4330 0266 002B     	 cmp r3,#0
 4331 0268 3AD0     	 beq .L302
 4332              	.L306:
2163:../SSC/Src/ecatslv.c ****                                 result = APPL_StartOutputHandler();
 4333              	 .loc 3 2163 0 is_stmt 1
 4334 026a 0F4B     	 ldr r3,.L313+12
 4335 026c 0022     	 movs r2,#0
 4336 026e 1A70     	 strb r2,[r3]
2164:../SSC/Src/ecatslv.c **** 
 4337              	 .loc 3 2164 0
 4338 0270 FFF7FEFF 	 bl APPL_StartOutputHandler
 4339 0274 0346     	 mov r3,r0
 4340 0276 7B80     	 strh r3,[r7,#2]
2166:../SSC/Src/ecatslv.c ****                                 {
 4341              	 .loc 3 2166 0
 4342 0278 7B88     	 ldrh r3,[r7,#2]
 4343 027a 002B     	 cmp r3,#0
 4344 027c 05D1     	 bne .L307
2169:../SSC/Src/ecatslv.c ****                                     Status = STATE_OP;
 4345              	 .loc 3 2169 0
 4346 027e 124B     	 ldr r3,.L313+44
 4347 0280 0122     	 movs r2,#1
 4348 0282 1A70     	 strb r2,[r3]
2170:../SSC/Src/ecatslv.c ****                                 }
 4349              	 .loc 3 2170 0
 4350 0284 0823     	 movs r3,#8
 4351 0286 FB71     	 strb r3,[r7,#7]
 4352 0288 2AE0     	 b .L302
 4353              	.L307:
2174:../SSC/Src/ecatslv.c ****                                     {
 4354              	 .loc 3 2174 0
 4355 028a 7B88     	 ldrh r3,[r7,#2]
 4356 028c FF2B     	 cmp r3,#255
 4357 028e 27D0     	 beq .L302
2176:../SSC/Src/ecatslv.c ****                                         StopOutputHandler();
 4358              	 .loc 3 2176 0
 4359 0290 FFF7FEFF 	 bl APPL_StopOutputHandler
2177:../SSC/Src/ecatslv.c ****                                     }
 4360              	 .loc 3 2177 0
 4361 0294 FFF7FEFF 	 bl StopOutputHandler
 4362              	 .loc 3 2183 0
 4363 0298 22E0     	 b .L312
 4364              	.L314:
 4365 029a 00BF     	 .align 2
 4366              	.L313:
 4367 029c 00000000 	 .word bEcatWaitForAlControlRes
 4368 02a0 00000000 	 .word EsmTimeoutCounter
 4369 02a4 00000000 	 .word nEcatStateTrans
 4370 02a8 00000000 	 .word bApplEsmPending
 4371 02ac 00000000 	 .word u8LocalErrorState
 4372 02b0 00000000 	 .word u16LocalErrorCode
 4373 02b4 00000000 	 .word bDcSyncActive
 4374 02b8 00000000 	 .word bDcRunning
 4375 02bc 00000000 	 .word bEcatFirstOutputsReceived
 4376 02c0 00000000 	 .word nPdOutputSize
 4377 02c4 00000000 	 .word bSmSyncSequenceValid
 4378 02c8 00000000 	 .word bEcatOutputUpdateRunning
 4379 02cc 00000000 	 .word bMbxRunning
 4380 02d0 00000000 	 .word u16ALEventMask
 4381 02d4 00000000 	 .word bEcatInputUpdateRunning
 4382 02d8 00000000 	 .word i16WaitForPllRunningTimeout
 4383 02dc 00000000 	 .word i16WaitForPllRunningCnt
 4384              	.L302:
 4385              	.L312:
 4386 02e0 00BF     	 nop
 4387              	.L293:
2184:../SSC/Src/ecatslv.c ****             }//Switch - transition
2185:../SSC/Src/ecatslv.c ****         }
2186:../SSC/Src/ecatslv.c **** 
2187:../SSC/Src/ecatslv.c ****         if(Status != 0)
 4388              	 .loc 3 2187 0
 4389 02e2 FB79     	 ldrb r3,[r7,#7]
 4390 02e4 002B     	 cmp r3,#0
 4391 02e6 0FD0     	 beq .L269
2188:../SSC/Src/ecatslv.c ****         {
2189:../SSC/Src/ecatslv.c ****             /*Pending state transition finished => write AL Status and AL Status Code*/
2190:../SSC/Src/ecatslv.c ****             bEcatWaitForAlControlRes = FALSE;
 4392              	 .loc 3 2190 0
 4393 02e8 094B     	 ldr r3,.L315
 4394 02ea 0022     	 movs r2,#0
 4395 02ec 1A70     	 strb r2,[r3]
2191:../SSC/Src/ecatslv.c **** 
2192:../SSC/Src/ecatslv.c ****             if (StatusCode != 0)
 4396              	 .loc 3 2192 0
 4397 02ee BB88     	 ldrh r3,[r7,#4]
 4398 02f0 002B     	 cmp r3,#0
 4399 02f2 03D0     	 beq .L308
2193:../SSC/Src/ecatslv.c ****             {
2194:../SSC/Src/ecatslv.c ****                 Status |= STATE_CHANGE;
 4400              	 .loc 3 2194 0
 4401 02f4 FB79     	 ldrb r3,[r7,#7]
 4402 02f6 43F01003 	 orr r3,r3,#16
 4403 02fa FB71     	 strb r3,[r7,#7]
 4404              	.L308:
2195:../SSC/Src/ecatslv.c ****             }
2196:../SSC/Src/ecatslv.c **** 
2197:../SSC/Src/ecatslv.c ****             SetALStatus(Status,StatusCode);
 4405              	 .loc 3 2197 0
 4406 02fc FA79     	 ldrb r2,[r7,#7]
 4407 02fe BB88     	 ldrh r3,[r7,#4]
 4408 0300 1046     	 mov r0,r2
 4409 0302 1946     	 mov r1,r3
 4410 0304 FFF7FEFF 	 bl SetALStatus
 4411              	.L269:
 4412              	.LBE9:
2198:../SSC/Src/ecatslv.c ****         }
2199:../SSC/Src/ecatslv.c ****     }// Pending state transition (bEcatWaitForAlControlRes == true)
2200:../SSC/Src/ecatslv.c **** }
 4413              	 .loc 3 2200 0
 4414 0308 0837     	 adds r7,r7,#8
 4415              	.LCFI87:
 4416              	 .cfi_def_cfa_offset 8
 4417 030a BD46     	 mov sp,r7
 4418              	.LCFI88:
 4419              	 .cfi_def_cfa_register 13
 4420              	 
 4421 030c 80BD     	 pop {r7,pc}
 4422              	.L316:
 4423 030e 00BF     	 .align 2
 4424              	.L315:
 4425 0310 00000000 	 .word bEcatWaitForAlControlRes
 4426              	 .cfi_endproc
 4427              	.LFE189:
 4429              	 .section .text.DC_CheckWatchdog,"ax",%progbits
 4430              	 .align 2
 4431              	 .global DC_CheckWatchdog
 4432              	 .thumb
 4433              	 .thumb_func
 4435              	DC_CheckWatchdog:
 4436              	.LFB190:
2201:../SSC/Src/ecatslv.c **** 
2202:../SSC/Src/ecatslv.c **** 
2203:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
2204:../SSC/Src/ecatslv.c **** /**
2205:../SSC/Src/ecatslv.c **** 
2206:../SSC/Src/ecatslv.c ****  \brief    This function checks the current Sync state and set the local flags
2207:../SSC/Src/ecatslv.c ****  The analyse of the local flags is handled in "CheckIfEcatError"
2208:../SSC/Src/ecatslv.c **** 
2209:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
2210:../SSC/Src/ecatslv.c **** void DC_CheckWatchdog(void)
2211:../SSC/Src/ecatslv.c **** {
 4437              	 .loc 3 2211 0
 4438              	 .cfi_startproc
 4439              	 
 4440              	 
 4441              	 
 4442 0000 80B4     	 push {r7}
 4443              	.LCFI89:
 4444              	 .cfi_def_cfa_offset 4
 4445              	 .cfi_offset 7,-4
 4446 0002 00AF     	 add r7,sp,#0
 4447              	.LCFI90:
 4448              	 .cfi_def_cfa_register 7
2212:../SSC/Src/ecatslv.c **** 
2213:../SSC/Src/ecatslv.c ****     if(bDcSyncActive && bEcatInputUpdateRunning)
 4449              	 .loc 3 2213 0
 4450 0004 3C4B     	 ldr r3,.L329
 4451 0006 1B78     	 ldrb r3,[r3]
 4452 0008 002B     	 cmp r3,#0
 4453 000a 71D0     	 beq .L317
 4454              	 .loc 3 2213 0 is_stmt 0 discriminator 1
 4455 000c 3B4B     	 ldr r3,.L329+4
 4456 000e 1B78     	 ldrb r3,[r3]
 4457 0010 002B     	 cmp r3,#0
 4458 0012 6DD0     	 beq .L317
2214:../SSC/Src/ecatslv.c ****     {
2215:../SSC/Src/ecatslv.c ****         /*If Sync0 watchdog is enabled and expired*/
2216:../SSC/Src/ecatslv.c ****         if((Sync0WdValue > 0) && (Sync0WdCounter >= Sync0WdValue))
 4459              	 .loc 3 2216 0 is_stmt 1
 4460 0014 3A4B     	 ldr r3,.L329+8
 4461 0016 1B88     	 ldrh r3,[r3]
 4462 0018 002B     	 cmp r3,#0
 4463 001a 09D0     	 beq .L319
 4464              	 .loc 3 2216 0 is_stmt 0 discriminator 1
 4465 001c 394B     	 ldr r3,.L329+12
 4466 001e 1A88     	 ldrh r2,[r3]
 4467 0020 374B     	 ldr r3,.L329+8
 4468 0022 1B88     	 ldrh r3,[r3]
 4469 0024 9A42     	 cmp r2,r3
 4470 0026 03D3     	 bcc .L319
2217:../SSC/Src/ecatslv.c ****         {
2218:../SSC/Src/ecatslv.c ****                 /*Sync0 watchdog expired*/
2219:../SSC/Src/ecatslv.c ****                 bDcRunning = FALSE;        
 4471              	 .loc 3 2219 0 is_stmt 1
 4472 0028 374B     	 ldr r3,.L329+16
 4473 002a 0022     	 movs r2,#0
 4474 002c 1A70     	 strb r2,[r3]
 4475 002e 0EE0     	 b .L320
 4476              	.L319:
2220:../SSC/Src/ecatslv.c ****         }
2221:../SSC/Src/ecatslv.c ****         else
2222:../SSC/Src/ecatslv.c ****         {
2223:../SSC/Src/ecatslv.c ****             if(Sync0WdCounter < Sync0WdValue)
 4477              	 .loc 3 2223 0
 4478 0030 344B     	 ldr r3,.L329+12
 4479 0032 1A88     	 ldrh r2,[r3]
 4480 0034 324B     	 ldr r3,.L329+8
 4481 0036 1B88     	 ldrh r3,[r3]
 4482 0038 9A42     	 cmp r2,r3
 4483 003a 05D2     	 bcs .L321
2224:../SSC/Src/ecatslv.c ****             {
2225:../SSC/Src/ecatslv.c ****                 Sync0WdCounter ++;
 4484              	 .loc 3 2225 0
 4485 003c 314B     	 ldr r3,.L329+12
 4486 003e 1B88     	 ldrh r3,[r3]
 4487 0040 0133     	 adds r3,r3,#1
 4488 0042 9AB2     	 uxth r2,r3
 4489 0044 2F4B     	 ldr r3,.L329+12
 4490 0046 1A80     	 strh r2,[r3]
 4491              	.L321:
2226:../SSC/Src/ecatslv.c ****             }
2227:../SSC/Src/ecatslv.c **** 
2228:../SSC/Src/ecatslv.c ****             bDcRunning = TRUE;
 4492              	 .loc 3 2228 0
 4493 0048 2F4B     	 ldr r3,.L329+16
 4494 004a 0122     	 movs r2,#1
 4495 004c 1A70     	 strb r2,[r3]
 4496              	.L320:
2229:../SSC/Src/ecatslv.c ****         }
2230:../SSC/Src/ecatslv.c **** 
2231:../SSC/Src/ecatslv.c ****         if(bDcRunning)
 4497              	 .loc 3 2231 0
 4498 004e 2E4B     	 ldr r3,.L329+16
 4499 0050 1B78     	 ldrb r3,[r3]
 4500 0052 002B     	 cmp r3,#0
 4501 0054 13D0     	 beq .L322
2232:../SSC/Src/ecatslv.c ****         {
2233:../SSC/Src/ecatslv.c ****             /*Check the Sync1 cycle if Sync1 Wd is enabled*/
2234:../SSC/Src/ecatslv.c ****             if(Sync1WdValue > 0)
 4502              	 .loc 3 2234 0
 4503 0056 2D4B     	 ldr r3,.L329+20
 4504 0058 1B88     	 ldrh r3,[r3]
 4505 005a 002B     	 cmp r3,#0
 4506 005c 0FD0     	 beq .L322
2235:../SSC/Src/ecatslv.c ****             {
2236:../SSC/Src/ecatslv.c ****                 if(Sync1WdCounter < Sync1WdValue)
 4507              	 .loc 3 2236 0
 4508 005e 2C4B     	 ldr r3,.L329+24
 4509 0060 1A88     	 ldrh r2,[r3]
 4510 0062 2A4B     	 ldr r3,.L329+20
 4511 0064 1B88     	 ldrh r3,[r3]
 4512 0066 9A42     	 cmp r2,r3
 4513 0068 06D2     	 bcs .L323
2237:../SSC/Src/ecatslv.c ****                 {
2238:../SSC/Src/ecatslv.c ****                     Sync1WdCounter ++;
 4514              	 .loc 3 2238 0
 4515 006a 294B     	 ldr r3,.L329+24
 4516 006c 1B88     	 ldrh r3,[r3]
 4517 006e 0133     	 adds r3,r3,#1
 4518 0070 9AB2     	 uxth r2,r3
 4519 0072 274B     	 ldr r3,.L329+24
 4520 0074 1A80     	 strh r2,[r3]
 4521 0076 02E0     	 b .L322
 4522              	.L323:
2239:../SSC/Src/ecatslv.c ****                 }
2240:../SSC/Src/ecatslv.c ****                 else
2241:../SSC/Src/ecatslv.c ****                 {
2242:../SSC/Src/ecatslv.c ****                     /*Sync1 watchdog expired*/
2243:../SSC/Src/ecatslv.c ****                     bDcRunning = FALSE;
 4523              	 .loc 3 2243 0
 4524 0078 234B     	 ldr r3,.L329+16
 4525 007a 0022     	 movs r2,#0
 4526 007c 1A70     	 strb r2,[r3]
 4527              	.L322:
2244:../SSC/Src/ecatslv.c ****                 }
2245:../SSC/Src/ecatslv.c ****             }
2246:../SSC/Src/ecatslv.c ****         }
2247:../SSC/Src/ecatslv.c ****         if(bDcRunning)
 4528              	 .loc 3 2247 0
 4529 007e 224B     	 ldr r3,.L329+16
 4530 0080 1B78     	 ldrb r3,[r3]
 4531 0082 002B     	 cmp r3,#0
 4532 0084 2DD0     	 beq .L324
2248:../SSC/Src/ecatslv.c ****         {
2249:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.13) ESM4*/
2250:../SSC/Src/ecatslv.c ****            if((sErrorSettings.u16SyncErrorCounterLimit == 0) || (sSyncManOutPar.u16SmEventMissedCou
 4533              	 .loc 3 2250 0
 4534 0086 234B     	 ldr r3,.L329+28
 4535 0088 1B89     	 ldrh r3,[r3,#8]
 4536 008a 002B     	 cmp r3,#0
 4537 008c 05D0     	 beq .L325
 4538              	 .loc 3 2250 0 is_stmt 0 discriminator 1
 4539 008e 224B     	 ldr r3,.L329+32
 4540 0090 1A8D     	 ldrh r2,[r3,#40]
 4541 0092 204B     	 ldr r3,.L329+28
 4542 0094 1B89     	 ldrh r3,[r3,#8]
 4543 0096 9A42     	 cmp r2,r3
 4544 0098 12D2     	 bcs .L326
 4545              	.L325:
2251:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.13) ESM4*/
2252:../SSC/Src/ecatslv.c ****             {
2253:../SSC/Src/ecatslv.c ****                 bSmSyncSequenceValid = TRUE;
 4546              	 .loc 3 2253 0 is_stmt 1
 4547 009a 204B     	 ldr r3,.L329+36
 4548 009c 0122     	 movs r2,#1
 4549 009e 1A70     	 strb r2,[r3]
2254:../SSC/Src/ecatslv.c **** 
2255:../SSC/Src/ecatslv.c ****                 /*Wait for PLL is active increment the Pll valid counter*/
2256:../SSC/Src/ecatslv.c ****                 if (i16WaitForPllRunningTimeout > 0)
 4550              	 .loc 3 2256 0
 4551 00a0 1F4B     	 ldr r3,.L329+40
 4552 00a2 1B88     	 ldrh r3,[r3]
 4553 00a4 1BB2     	 sxth r3,r3
 4554 00a6 002B     	 cmp r3,#0
 4555 00a8 09DD     	 ble .L327
2257:../SSC/Src/ecatslv.c ****                 {
2258:../SSC/Src/ecatslv.c ****                     i16WaitForPllRunningCnt++;
 4556              	 .loc 3 2258 0
 4557 00aa 1E4B     	 ldr r3,.L329+44
 4558 00ac 1B88     	 ldrh r3,[r3]
 4559 00ae 9BB2     	 uxth r3,r3
 4560 00b0 9BB2     	 uxth r3,r3
 4561 00b2 0133     	 adds r3,r3,#1
 4562 00b4 9BB2     	 uxth r3,r3
 4563 00b6 9AB2     	 uxth r2,r3
 4564 00b8 1A4B     	 ldr r3,.L329+44
 4565 00ba 1A80     	 strh r2,[r3]
2256:../SSC/Src/ecatslv.c ****                 {
 4566              	 .loc 3 2256 0
 4567 00bc 10E0     	 b .L328
 4568              	.L327:
 4569 00be 0FE0     	 b .L328
 4570              	.L326:
2259:../SSC/Src/ecatslv.c ****                 }
2260:../SSC/Src/ecatslv.c ****             }
2261:../SSC/Src/ecatslv.c ****             else if (bSmSyncSequenceValid)
 4571              	 .loc 3 2261 0
 4572 00c0 164B     	 ldr r3,.L329+36
 4573 00c2 1B78     	 ldrb r3,[r3]
 4574 00c4 002B     	 cmp r3,#0
 4575 00c6 13D0     	 beq .L317
2262:../SSC/Src/ecatslv.c ****             {
2263:../SSC/Src/ecatslv.c ****                     bSmSyncSequenceValid = FALSE;
 4576              	 .loc 3 2263 0
 4577 00c8 144B     	 ldr r3,.L329+36
 4578 00ca 0022     	 movs r2,#0
 4579 00cc 1A70     	 strb r2,[r3]
2264:../SSC/Src/ecatslv.c **** 
2265:../SSC/Src/ecatslv.c ****                 /*Wait for PLL is active reset the Pll valid counter*/
2266:../SSC/Src/ecatslv.c ****                 if (i16WaitForPllRunningTimeout > 0)
 4580              	 .loc 3 2266 0
 4581 00ce 144B     	 ldr r3,.L329+40
 4582 00d0 1B88     	 ldrh r3,[r3]
 4583 00d2 1BB2     	 sxth r3,r3
 4584 00d4 002B     	 cmp r3,#0
 4585 00d6 0BDD     	 ble .L317
2267:../SSC/Src/ecatslv.c ****                 {
2268:../SSC/Src/ecatslv.c ****                     i16WaitForPllRunningCnt = 0;
 4586              	 .loc 3 2268 0
 4587 00d8 124B     	 ldr r3,.L329+44
 4588 00da 0022     	 movs r2,#0
 4589 00dc 1A80     	 strh r2,[r3]
 4590 00de 07E0     	 b .L317
 4591              	.L328:
 4592 00e0 06E0     	 b .L317
 4593              	.L324:
2269:../SSC/Src/ecatslv.c ****                 }
2270:../SSC/Src/ecatslv.c ****             }
2271:../SSC/Src/ecatslv.c ****         }
2272:../SSC/Src/ecatslv.c ****         else if(bSmSyncSequenceValid)
 4594              	 .loc 3 2272 0
 4595 00e2 0E4B     	 ldr r3,.L329+36
 4596 00e4 1B78     	 ldrb r3,[r3]
 4597 00e6 002B     	 cmp r3,#0
 4598 00e8 02D0     	 beq .L317
2273:../SSC/Src/ecatslv.c ****         {
2274:../SSC/Src/ecatslv.c ****            bSmSyncSequenceValid = FALSE;
 4599              	 .loc 3 2274 0
 4600 00ea 0C4B     	 ldr r3,.L329+36
 4601 00ec 0022     	 movs r2,#0
 4602 00ee 1A70     	 strb r2,[r3]
 4603              	.L317:
2275:../SSC/Src/ecatslv.c ****         }
2276:../SSC/Src/ecatslv.c ****     }
2277:../SSC/Src/ecatslv.c **** }
 4604              	 .loc 3 2277 0
 4605 00f0 BD46     	 mov sp,r7
 4606              	.LCFI91:
 4607              	 .cfi_def_cfa_register 13
 4608              	 
 4609 00f2 5DF8047B 	 ldr r7,[sp],#4
 4610              	.LCFI92:
 4611              	 .cfi_restore 7
 4612              	 .cfi_def_cfa_offset 0
 4613 00f6 7047     	 bx lr
 4614              	.L330:
 4615              	 .align 2
 4616              	.L329:
 4617 00f8 00000000 	 .word bDcSyncActive
 4618 00fc 00000000 	 .word bEcatInputUpdateRunning
 4619 0100 00000000 	 .word Sync0WdValue
 4620 0104 00000000 	 .word Sync0WdCounter
 4621 0108 00000000 	 .word bDcRunning
 4622 010c 00000000 	 .word Sync1WdValue
 4623 0110 00000000 	 .word Sync1WdCounter
 4624 0114 00000000 	 .word sErrorSettings
 4625 0118 00000000 	 .word sSyncManOutPar
 4626 011c 00000000 	 .word bSmSyncSequenceValid
 4627 0120 00000000 	 .word i16WaitForPllRunningTimeout
 4628 0124 00000000 	 .word i16WaitForPllRunningCnt
 4629              	 .cfi_endproc
 4630              	.LFE190:
 4632              	 .section .text.CheckIfEcatError,"ax",%progbits
 4633              	 .align 2
 4634              	 .global CheckIfEcatError
 4635              	 .thumb
 4636              	 .thumb_func
 4638              	CheckIfEcatError:
 4639              	.LFB191:
2278:../SSC/Src/ecatslv.c **** 
2279:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
2280:../SSC/Src/ecatslv.c **** /**
2281:../SSC/Src/ecatslv.c **** 
2282:../SSC/Src/ecatslv.c ****  \brief    Checks communication and synchronisation variables and update AL status / AL status code
2283:../SSC/Src/ecatslv.c **** 
2284:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
2285:../SSC/Src/ecatslv.c **** void CheckIfEcatError(void)
2286:../SSC/Src/ecatslv.c **** {
 4640              	 .loc 3 2286 0
 4641              	 .cfi_startproc
 4642              	 
 4643              	 
 4644 0000 80B5     	 push {r7,lr}
 4645              	.LCFI93:
 4646              	 .cfi_def_cfa_offset 8
 4647              	 .cfi_offset 7,-8
 4648              	 .cfi_offset 14,-4
 4649 0002 82B0     	 sub sp,sp,#8
 4650              	.LCFI94:
 4651              	 .cfi_def_cfa_offset 16
 4652 0004 00AF     	 add r7,sp,#0
 4653              	.LCFI95:
 4654              	 .cfi_def_cfa_register 7
2287:../SSC/Src/ecatslv.c ****    /*if the watchdog is enabled check the process data watchdog in the ESC
2288:../SSC/Src/ecatslv.c ****    and set the AL status code 0x1B if the watchdog expired*/
2289:../SSC/Src/ecatslv.c ****    if (EcatWdValue != 0)
 4655              	 .loc 3 2289 0
 4656 0006 204B     	 ldr r3,.L336
 4657 0008 1B88     	 ldrh r3,[r3]
 4658 000a 002B     	 cmp r3,#0
 4659 000c 19D0     	 beq .L332
 4660              	.LBB10:
2290:../SSC/Src/ecatslv.c ****    {
2291:../SSC/Src/ecatslv.c ****       /*watchdog time is set => watchdog is active*/
2292:../SSC/Src/ecatslv.c ****       UINT16 WdStatusOK = 0;
 4661              	 .loc 3 2292 0
 4662 000e 0023     	 movs r3,#0
 4663 0010 FB80     	 strh r3,[r7,#6]
2293:../SSC/Src/ecatslv.c **** 
2294:../SSC/Src/ecatslv.c ****       HW_EscReadWord(WdStatusOK, ESC_PD_WD_STATE);
 4664              	 .loc 3 2294 0
 4665 0012 1E4B     	 ldr r3,.L336+4
 4666 0014 1B88     	 ldrh r3,[r3]
 4667 0016 FB80     	 strh r3,[r7,#6]
2295:../SSC/Src/ecatslv.c ****       WdStatusOK = SWAPWORD(WdStatusOK);
2296:../SSC/Src/ecatslv.c **** 
2297:../SSC/Src/ecatslv.c ****       if (!(WdStatusOK & ESC_PD_WD_TRIGGER_MASK) && (nPdOutputSize > 0))
 4668              	 .loc 3 2297 0
 4669 0018 FB88     	 ldrh r3,[r7,#6]
 4670 001a 03F00103 	 and r3,r3,#1
 4671 001e 002B     	 cmp r3,#0
 4672 0020 0FD1     	 bne .L332
 4673              	 .loc 3 2297 0 is_stmt 0 discriminator 1
 4674 0022 1B4B     	 ldr r3,.L336+8
 4675 0024 1B88     	 ldrh r3,[r3]
 4676 0026 002B     	 cmp r3,#0
 4677 0028 0BD0     	 beq .L332
2298:../SSC/Src/ecatslv.c ****       {
2299:../SSC/Src/ecatslv.c ****          /*The device is in OP state*/
2300:../SSC/Src/ecatslv.c **** 
2301:../SSC/Src/ecatslv.c ****          if (bEcatOutputUpdateRunning
 4678              	 .loc 3 2301 0 is_stmt 1
 4679 002a 1A4B     	 ldr r3,.L336+12
 4680 002c 1B78     	 ldrb r3,[r3]
 4681 002e 002B     	 cmp r3,#0
 4682 0030 04D0     	 beq .L333
2302:../SSC/Src/ecatslv.c ****             )
2303:../SSC/Src/ecatslv.c ****          {
2304:../SSC/Src/ecatslv.c ****             AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_SMWATCHDOG);
 4683              	 .loc 3 2304 0
 4684 0032 0420     	 movs r0,#4
 4685 0034 1B21     	 movs r1,#27
 4686 0036 FFF7FEFF 	 bl AL_ControlInd
2305:../SSC/Src/ecatslv.c ****             return;
 4687              	 .loc 3 2305 0
 4688 003a 22E0     	 b .L331
 4689              	.L333:
2306:../SSC/Src/ecatslv.c ****          }
2307:../SSC/Src/ecatslv.c **** 
2308:../SSC/Src/ecatslv.c ****          else
2309:../SSC/Src/ecatslv.c ****          {
2310:../SSC/Src/ecatslv.c ****             bEcatFirstOutputsReceived = FALSE;
 4690              	 .loc 3 2310 0
 4691 003c 164B     	 ldr r3,.L336+16
 4692 003e 0022     	 movs r2,#0
 4693 0040 1A70     	 strb r2,[r3]
 4694              	.L332:
 4695              	.LBE10:
2311:../SSC/Src/ecatslv.c ****          }
2312:../SSC/Src/ecatslv.c ****       }
2313:../SSC/Src/ecatslv.c ****    }
2314:../SSC/Src/ecatslv.c **** 
2315:../SSC/Src/ecatslv.c ****    if(bDcSyncActive)
 4696              	 .loc 3 2315 0
 4697 0042 164B     	 ldr r3,.L336+20
 4698 0044 1B78     	 ldrb r3,[r3]
 4699 0046 002B     	 cmp r3,#0
 4700 0048 1BD0     	 beq .L331
2316:../SSC/Src/ecatslv.c ****    {
2317:../SSC/Src/ecatslv.c ****        if(bEcatOutputUpdateRunning)
 4701              	 .loc 3 2317 0
 4702 004a 124B     	 ldr r3,.L336+12
 4703 004c 1B78     	 ldrb r3,[r3]
 4704 004e 002B     	 cmp r3,#0
 4705 0050 17D0     	 beq .L331
2318:../SSC/Src/ecatslv.c ****        {
2319:../SSC/Src/ecatslv.c ****            /*Slave is in OP state*/
2320:../SSC/Src/ecatslv.c ****            if(!bDcRunning)
 4706              	 .loc 3 2320 0
 4707 0052 134B     	 ldr r3,.L336+24
 4708 0054 1B78     	 ldrb r3,[r3]
 4709 0056 83F00103 	 eor r3,r3,#1
 4710 005a DBB2     	 uxtb r3,r3
 4711 005c 002B     	 cmp r3,#0
 4712 005e 04D0     	 beq .L335
2321:../SSC/Src/ecatslv.c ****            {
2322:../SSC/Src/ecatslv.c ****                AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_FATALSYNCERROR);
 4713              	 .loc 3 2322 0
 4714 0060 0420     	 movs r0,#4
 4715 0062 2C21     	 movs r1,#44
 4716 0064 FFF7FEFF 	 bl AL_ControlInd
2323:../SSC/Src/ecatslv.c ****                return;
 4717              	 .loc 3 2323 0
 4718 0068 0BE0     	 b .L331
 4719              	.L335:
2324:../SSC/Src/ecatslv.c ****            }
2325:../SSC/Src/ecatslv.c ****            else if(!bSmSyncSequenceValid)
 4720              	 .loc 3 2325 0
 4721 006a 0E4B     	 ldr r3,.L336+28
 4722 006c 1B78     	 ldrb r3,[r3]
 4723 006e 83F00103 	 eor r3,r3,#1
 4724 0072 DBB2     	 uxtb r3,r3
 4725 0074 002B     	 cmp r3,#0
 4726 0076 04D0     	 beq .L331
2326:../SSC/Src/ecatslv.c ****            {
2327:../SSC/Src/ecatslv.c ****                AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_SYNCERROR);
 4727              	 .loc 3 2327 0
 4728 0078 0420     	 movs r0,#4
 4729 007a 1A21     	 movs r1,#26
 4730 007c FFF7FEFF 	 bl AL_ControlInd
2328:../SSC/Src/ecatslv.c ****                return;
 4731              	 .loc 3 2328 0
 4732 0080 00BF     	 nop
 4733              	.L331:
2329:../SSC/Src/ecatslv.c ****            }
2330:../SSC/Src/ecatslv.c ****         
2331:../SSC/Src/ecatslv.c ****        }
2332:../SSC/Src/ecatslv.c ****    }
2333:../SSC/Src/ecatslv.c **** }
 4734              	 .loc 3 2333 0
 4735 0082 0837     	 adds r7,r7,#8
 4736              	.LCFI96:
 4737              	 .cfi_def_cfa_offset 8
 4738 0084 BD46     	 mov sp,r7
 4739              	.LCFI97:
 4740              	 .cfi_def_cfa_register 13
 4741              	 
 4742 0086 80BD     	 pop {r7,pc}
 4743              	.L337:
 4744              	 .align 2
 4745              	.L336:
 4746 0088 00000000 	 .word EcatWdValue
 4747 008c 40040154 	 .word 1409352768
 4748 0090 00000000 	 .word nPdOutputSize
 4749 0094 00000000 	 .word bEcatOutputUpdateRunning
 4750 0098 00000000 	 .word bEcatFirstOutputsReceived
 4751 009c 00000000 	 .word bDcSyncActive
 4752 00a0 00000000 	 .word bDcRunning
 4753 00a4 00000000 	 .word bSmSyncSequenceValid
 4754              	 .cfi_endproc
 4755              	.LFE191:
 4757              	 .section .text.ECAT_StateChange,"ax",%progbits
 4758              	 .align 2
 4759              	 .global ECAT_StateChange
 4760              	 .thumb
 4761              	 .thumb_func
 4763              	ECAT_StateChange:
 4764              	.LFB192:
2334:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
2335:../SSC/Src/ecatslv.c **** /**
2336:../SSC/Src/ecatslv.c ****  \param    alStatus: requested state (ignored if the "alStatusCode" is 0)
2337:../SSC/Src/ecatslv.c ****  \param    alStatusCode: value for the AL-Status register
2338:../SSC/Src/ecatslv.c ****  
2339:../SSC/Src/ecatslv.c ****  \brief    This function changes the state of the EtherCAT slave if the requested state
2340:../SSC/Src/ecatslv.c ****              is lower than the actual state, otherwise the error condition will be reset.
2341:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
2342:../SSC/Src/ecatslv.c **** 
2343:../SSC/Src/ecatslv.c **** void ECAT_StateChange(UINT8 alStatus, UINT16 alStatusCode)
2344:../SSC/Src/ecatslv.c **** {
 4765              	 .loc 3 2344 0
 4766              	 .cfi_startproc
 4767              	 
 4768              	 
 4769 0000 80B5     	 push {r7,lr}
 4770              	.LCFI98:
 4771              	 .cfi_def_cfa_offset 8
 4772              	 .cfi_offset 7,-8
 4773              	 .cfi_offset 14,-4
 4774 0002 84B0     	 sub sp,sp,#16
 4775              	.LCFI99:
 4776              	 .cfi_def_cfa_offset 24
 4777 0004 00AF     	 add r7,sp,#0
 4778              	.LCFI100:
 4779              	 .cfi_def_cfa_register 7
 4780 0006 0346     	 mov r3,r0
 4781 0008 0A46     	 mov r2,r1
 4782 000a FB71     	 strb r3,[r7,#7]
 4783 000c 1346     	 mov r3,r2
 4784 000e BB80     	 strh r3,[r7,#4]
2345:../SSC/Src/ecatslv.c ****     UINT8 Status = alStatus;
 4785              	 .loc 3 2345 0
 4786 0010 FB79     	 ldrb r3,[r7,#7]
 4787 0012 FB73     	 strb r3,[r7,#15]
2346:../SSC/Src/ecatslv.c **** 
2347:../SSC/Src/ecatslv.c ****     /*ECATCHANGE_START(V5.13) ESM1*/
2348:../SSC/Src/ecatslv.c ****     /*return in case of invalid parameters*/
2349:../SSC/Src/ecatslv.c ****     if (alStatusCode != 0 && !STATE_VALID(alStatus))
 4788              	 .loc 3 2349 0
 4789 0014 BB88     	 ldrh r3,[r7,#4]
 4790 0016 002B     	 cmp r3,#0
 4791 0018 14D0     	 beq .L339
 4792              	 .loc 3 2349 0 is_stmt 0 discriminator 1
 4793 001a FB79     	 ldrb r3,[r7,#7]
 4794 001c 03F00F03 	 and r3,r3,#15
 4795 0020 012B     	 cmp r3,#1
 4796 0022 0FD0     	 beq .L339
 4797              	 .loc 3 2349 0 discriminator 2
 4798 0024 FB79     	 ldrb r3,[r7,#7]
 4799 0026 03F00F03 	 and r3,r3,#15
 4800 002a 022B     	 cmp r3,#2
 4801 002c 0AD0     	 beq .L339
 4802              	 .loc 3 2349 0 discriminator 3
 4803 002e FB79     	 ldrb r3,[r7,#7]
 4804 0030 03F00F03 	 and r3,r3,#15
 4805 0034 042B     	 cmp r3,#4
 4806 0036 05D0     	 beq .L339
 4807              	 .loc 3 2349 0 discriminator 4
 4808 0038 FB79     	 ldrb r3,[r7,#7]
 4809 003a 03F00F03 	 and r3,r3,#15
 4810 003e 082B     	 cmp r3,#8
 4811 0040 00D0     	 beq .L339
2350:../SSC/Src/ecatslv.c ****     {
2351:../SSC/Src/ecatslv.c ****         return;
 4812              	 .loc 3 2351 0 is_stmt 1
 4813 0042 DCE0     	 b .L338
 4814              	.L339:
2352:../SSC/Src/ecatslv.c ****     }
2353:../SSC/Src/ecatslv.c **** 
2354:../SSC/Src/ecatslv.c ****     /* call the application requested state transition only once*/
2355:../SSC/Src/ecatslv.c ****     if (bEcatWaitForAlControlRes == FALSE && u8LocalErrorState == alStatus && u16LocalErrorCode == 
 4815              	 .loc 3 2355 0
 4816 0044 6F4B     	 ldr r3,.L366
 4817 0046 1B78     	 ldrb r3,[r3]
 4818 0048 83F00103 	 eor r3,r3,#1
 4819 004c DBB2     	 uxtb r3,r3
 4820 004e 002B     	 cmp r3,#0
 4821 0050 0AD0     	 beq .L341
 4822              	 .loc 3 2355 0 is_stmt 0 discriminator 1
 4823 0052 6D4B     	 ldr r3,.L366+4
 4824 0054 1B78     	 ldrb r3,[r3]
 4825 0056 FA79     	 ldrb r2,[r7,#7]
 4826 0058 9A42     	 cmp r2,r3
 4827 005a 05D1     	 bne .L341
 4828              	 .loc 3 2355 0 discriminator 2
 4829 005c 6B4B     	 ldr r3,.L366+8
 4830 005e 1B88     	 ldrh r3,[r3]
 4831 0060 BA88     	 ldrh r2,[r7,#4]
 4832 0062 9A42     	 cmp r2,r3
 4833 0064 00D1     	 bne .L341
2356:../SSC/Src/ecatslv.c ****     {
2357:../SSC/Src/ecatslv.c ****         return;
 4834              	 .loc 3 2357 0 is_stmt 1 discriminator 2
 4835 0066 CAE0     	 b .L338
 4836              	.L341:
2358:../SSC/Src/ecatslv.c ****     }
2359:../SSC/Src/ecatslv.c ****     /*ECATCHANGE_END(V5.13) ESM1*/
2360:../SSC/Src/ecatslv.c **** 
2361:../SSC/Src/ecatslv.c **** 
2362:../SSC/Src/ecatslv.c ****     if(bEcatWaitForAlControlRes)
 4837              	 .loc 3 2362 0
 4838 0068 664B     	 ldr r3,.L366
 4839 006a 1B78     	 ldrb r3,[r3]
 4840 006c 002B     	 cmp r3,#0
 4841 006e 00F08980 	 beq .L342
2363:../SSC/Src/ecatslv.c ****     {
2364:../SSC/Src/ecatslv.c ****         /*State transition is pending*/
2365:../SSC/Src/ecatslv.c **** 
2366:../SSC/Src/ecatslv.c ****         if(bApplEsmPending)
 4842              	 .loc 3 2366 0
 4843 0072 674B     	 ldr r3,.L366+12
 4844 0074 1B78     	 ldrb r3,[r3]
 4845 0076 002B     	 cmp r3,#0
 4846 0078 16D0     	 beq .L343
2367:../SSC/Src/ecatslv.c ****         {
2368:../SSC/Src/ecatslv.c ****             /*The generic stack has currently control of the state transition.
2369:../SSC/Src/ecatslv.c ****             In case on an local error force ESM timeout*/
2370:../SSC/Src/ecatslv.c ****             if(alStatusCode != 0)
 4847              	 .loc 3 2370 0
 4848 007a BB88     	 ldrh r3,[r7,#4]
 4849 007c 002B     	 cmp r3,#0
 4850 007e 0CD0     	 beq .L344
2371:../SSC/Src/ecatslv.c ****             {
2372:../SSC/Src/ecatslv.c ****                 /*ECATCHANGE_START(V5.13) ESM1*/
2373:../SSC/Src/ecatslv.c ****                 u8LocalErrorState = (alStatus & STATE_MASK);
 4851              	 .loc 3 2373 0
 4852 0080 FB79     	 ldrb r3,[r7,#7]
 4853 0082 03F00F03 	 and r3,r3,#15
 4854 0086 DAB2     	 uxtb r2,r3
 4855 0088 5F4B     	 ldr r3,.L366+4
 4856 008a 1A70     	 strb r2,[r3]
2374:../SSC/Src/ecatslv.c ****                 /*ECATCHANGE_END(V5.13) ESM1*/
2375:../SSC/Src/ecatslv.c ****                 u16LocalErrorCode = alStatusCode;
 4857              	 .loc 3 2375 0
 4858 008c 5F4A     	 ldr r2,.L366+8
 4859 008e BB88     	 ldrh r3,[r7,#4]
 4860 0090 1380     	 strh r3,[r2]
2376:../SSC/Src/ecatslv.c ****                 EsmTimeoutCounter = 0;
 4861              	 .loc 3 2376 0
 4862 0092 604B     	 ldr r3,.L366+16
 4863 0094 0022     	 movs r2,#0
 4864 0096 1A80     	 strh r2,[r3]
 4865 0098 B1E0     	 b .L338
 4866              	.L344:
2377:../SSC/Src/ecatslv.c ****             }
2378:../SSC/Src/ecatslv.c ****             else
2379:../SSC/Src/ecatslv.c ****             { 
2380:../SSC/Src/ecatslv.c ****                 u8LocalErrorState = 0;
 4867              	 .loc 3 2380 0
 4868 009a 5B4B     	 ldr r3,.L366+4
 4869 009c 0022     	 movs r2,#0
 4870 009e 1A70     	 strb r2,[r3]
2381:../SSC/Src/ecatslv.c ****                 u16LocalErrorCode = alStatusCode;
 4871              	 .loc 3 2381 0
 4872 00a0 5A4A     	 ldr r2,.L366+8
 4873 00a2 BB88     	 ldrh r3,[r7,#4]
 4874 00a4 1380     	 strh r3,[r2]
 4875 00a6 AAE0     	 b .L338
 4876              	.L343:
2382:../SSC/Src/ecatslv.c ****             }
2383:../SSC/Src/ecatslv.c ****         }
2384:../SSC/Src/ecatslv.c ****         else
2385:../SSC/Src/ecatslv.c ****         {
2386:../SSC/Src/ecatslv.c ****             /*complete the state transition*/
2387:../SSC/Src/ecatslv.c **** 
2388:../SSC/Src/ecatslv.c ****             if(alStatusCode != 0)
 4877              	 .loc 3 2388 0
 4878 00a8 BB88     	 ldrh r3,[r7,#4]
 4879 00aa 002B     	 cmp r3,#0
 4880 00ac 2AD0     	 beq .L347
2389:../SSC/Src/ecatslv.c ****             {
2390:../SSC/Src/ecatslv.c ****                 /*ECATCHANGE_START(V5.13) ESM1*/
2391:../SSC/Src/ecatslv.c ****                 u8LocalErrorState = (alStatus & STATE_MASK);
 4881              	 .loc 3 2391 0
 4882 00ae FB79     	 ldrb r3,[r7,#7]
 4883 00b0 03F00F03 	 and r3,r3,#15
 4884 00b4 DAB2     	 uxtb r2,r3
 4885 00b6 544B     	 ldr r3,.L366+4
 4886 00b8 1A70     	 strb r2,[r3]
2392:../SSC/Src/ecatslv.c ****                 /*ECATCHANGE_END(V5.13) ESM1*/
2393:../SSC/Src/ecatslv.c ****                 u16LocalErrorCode = alStatusCode;
 4887              	 .loc 3 2393 0
 4888 00ba 544A     	 ldr r2,.L366+8
 4889 00bc BB88     	 ldrh r3,[r7,#4]
 4890 00be 1380     	 strh r3,[r2]
2394:../SSC/Src/ecatslv.c **** 
2395:../SSC/Src/ecatslv.c ****                 /*State transition failed due to local application reasons*/
2396:../SSC/Src/ecatslv.c ****                 switch(nEcatStateTrans)
 4891              	 .loc 3 2396 0
 4892 00c0 554B     	 ldr r3,.L366+20
 4893 00c2 1B88     	 ldrh r3,[r3]
 4894 00c4 242B     	 cmp r3,#36
 4895 00c6 0DD0     	 beq .L349
 4896 00c8 242B     	 cmp r3,#36
 4897 00ca 03DC     	 bgt .L350
 4898 00cc 123B     	 subs r3,r3,#18
 4899 00ce 012B     	 cmp r3,#1
 4900 00d0 12D8     	 bhi .L348
 4901 00d2 02E0     	 b .L364
 4902              	.L350:
 4903 00d4 482B     	 cmp r3,#72
 4904 00d6 0AD0     	 beq .L352
 4905 00d8 0EE0     	 b .L348
 4906              	.L364:
2397:../SSC/Src/ecatslv.c ****                 {
2398:../SSC/Src/ecatslv.c ****                     case INIT_2_PREOP:
2399:../SSC/Src/ecatslv.c ****                     case INIT_2_BOOT:
2400:../SSC/Src/ecatslv.c ****                      
2401:../SSC/Src/ecatslv.c ****                           APPL_StopMailboxHandler();
 4907              	 .loc 3 2401 0
 4908 00da FFF7FEFF 	 bl APPL_StopMailboxHandler
2402:../SSC/Src/ecatslv.c ****                           MBX_StopMailboxHandler();
 4909              	 .loc 3 2402 0
 4910 00de FFF7FEFF 	 bl MBX_StopMailboxHandler
2403:../SSC/Src/ecatslv.c ****                     break;
 4911              	 .loc 3 2403 0
 4912 00e2 09E0     	 b .L348
 4913              	.L349:
2404:../SSC/Src/ecatslv.c ****                     case PREOP_2_SAFEOP:
2405:../SSC/Src/ecatslv.c ****                           APPL_StopInputHandler();
 4914              	 .loc 3 2405 0
 4915 00e4 FFF7FEFF 	 bl APPL_StopInputHandler
2406:../SSC/Src/ecatslv.c ****                           StopInputHandler();
 4916              	 .loc 3 2406 0
 4917 00e8 FFF7FEFF 	 bl StopInputHandler
2407:../SSC/Src/ecatslv.c ****                     break;
 4918              	 .loc 3 2407 0
 4919 00ec 04E0     	 b .L348
 4920              	.L352:
2408:../SSC/Src/ecatslv.c ****                     case SAFEOP_2_OP:
2409:../SSC/Src/ecatslv.c ****                           APPL_StopOutputHandler();
 4921              	 .loc 3 2409 0
 4922 00ee FFF7FEFF 	 bl APPL_StopOutputHandler
2410:../SSC/Src/ecatslv.c ****                           StopOutputHandler();
 4923              	 .loc 3 2410 0
 4924 00f2 FFF7FEFF 	 bl StopOutputHandler
2411:../SSC/Src/ecatslv.c ****                     break;
 4925              	 .loc 3 2411 0
 4926 00f6 00BF     	 nop
 4927              	.L348:
2412:../SSC/Src/ecatslv.c ****                 }
2413:../SSC/Src/ecatslv.c **** 
2414:../SSC/Src/ecatslv.c ****                 /*In case of a failed state transition the */
2415:../SSC/Src/ecatslv.c ****                 Status =  (UINT8)(nEcatStateTrans >> 4);
 4928              	 .loc 3 2415 0
 4929 00f8 474B     	 ldr r3,.L366+20
 4930 00fa 1B88     	 ldrh r3,[r3]
 4931 00fc 1B09     	 lsrs r3,r3,#4
 4932 00fe 9BB2     	 uxth r3,r3
 4933 0100 FB73     	 strb r3,[r7,#15]
 4934 0102 23E0     	 b .L353
 4935              	.L347:
2416:../SSC/Src/ecatslv.c ****             }
2417:../SSC/Src/ecatslv.c ****             else
2418:../SSC/Src/ecatslv.c ****             {
2419:../SSC/Src/ecatslv.c ****                 /*State transition succeed*/
2420:../SSC/Src/ecatslv.c ****                  
2421:../SSC/Src/ecatslv.c ****                 switch(nEcatStateTrans)
 4936              	 .loc 3 2421 0
 4937 0104 444B     	 ldr r3,.L366+20
 4938 0106 1B88     	 ldrh r3,[r3]
 4939 0108 242B     	 cmp r3,#36
 4940 010a 0CD0     	 beq .L355
 4941 010c 242B     	 cmp r3,#36
 4942 010e 03DC     	 bgt .L356
 4943 0110 123B     	 subs r3,r3,#18
 4944 0112 012B     	 cmp r3,#1
 4945 0114 14D8     	 bhi .L354
 4946 0116 02E0     	 b .L365
 4947              	.L356:
 4948 0118 482B     	 cmp r3,#72
 4949 011a 0DD0     	 beq .L358
 4950 011c 10E0     	 b .L354
 4951              	.L365:
2422:../SSC/Src/ecatslv.c ****                 {
2423:../SSC/Src/ecatslv.c ****                     case INIT_2_PREOP:
2424:../SSC/Src/ecatslv.c ****                     case INIT_2_BOOT:
2425:../SSC/Src/ecatslv.c ****                         bMbxRunning = TRUE;
 4952              	 .loc 3 2425 0
 4953 011e 3F4B     	 ldr r3,.L366+24
 4954 0120 0122     	 movs r2,#1
 4955 0122 1A70     	 strb r2,[r3]
2426:../SSC/Src/ecatslv.c ****                     break;
 4956              	 .loc 3 2426 0
 4957 0124 0CE0     	 b .L354
 4958              	.L355:
2427:../SSC/Src/ecatslv.c ****                     case PREOP_2_SAFEOP:
2428:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.13) ECAT1*/
2429:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.13) ECAT1*/
2430:../SSC/Src/ecatslv.c ****                         /* initialize the AL Event Mask register (0x204) */
2431:../SSC/Src/ecatslv.c ****                         SetALEventMask(u16ALEventMask);
 4959              	 .loc 3 2431 0
 4960 0126 3E4B     	 ldr r3,.L366+28
 4961 0128 1B88     	 ldrh r3,[r3]
 4962 012a 1846     	 mov r0,r3
 4963 012c FFF7FEFF 	 bl SetALEventMask
2432:../SSC/Src/ecatslv.c ****                         bEcatInputUpdateRunning = TRUE;
 4964              	 .loc 3 2432 0
 4965 0130 3C4B     	 ldr r3,.L366+32
 4966 0132 0122     	 movs r2,#1
 4967 0134 1A70     	 strb r2,[r3]
2433:../SSC/Src/ecatslv.c ****                     break;
 4968              	 .loc 3 2433 0
 4969 0136 03E0     	 b .L354
 4970              	.L358:
2434:../SSC/Src/ecatslv.c ****                     case SAFEOP_2_OP:
2435:../SSC/Src/ecatslv.c ****                           bEcatOutputUpdateRunning = TRUE;
 4971              	 .loc 3 2435 0
 4972 0138 3B4B     	 ldr r3,.L366+36
 4973 013a 0122     	 movs r2,#1
 4974 013c 1A70     	 strb r2,[r3]
2436:../SSC/Src/ecatslv.c ****                     break;
 4975              	 .loc 3 2436 0
 4976 013e 00BF     	 nop
 4977              	.L354:
2437:../SSC/Src/ecatslv.c ****                 }
2438:../SSC/Src/ecatslv.c **** 
2439:../SSC/Src/ecatslv.c **** 
2440:../SSC/Src/ecatslv.c **** 
2441:../SSC/Src/ecatslv.c ****                 Status =  (UINT8)(nEcatStateTrans & STATE_MASK);
 4978              	 .loc 3 2441 0
 4979 0140 354B     	 ldr r3,.L366+20
 4980 0142 1B88     	 ldrh r3,[r3]
 4981 0144 DBB2     	 uxtb r3,r3
 4982 0146 03F00F03 	 and r3,r3,#15
 4983 014a FB73     	 strb r3,[r7,#15]
 4984              	.L353:
2442:../SSC/Src/ecatslv.c ****             }
2443:../SSC/Src/ecatslv.c ****                 /*Pending state transition finished => write AL Status and AL Status Code*/
2444:../SSC/Src/ecatslv.c ****                 bEcatWaitForAlControlRes = FALSE;
 4985              	 .loc 3 2444 0
 4986 014c 2D4B     	 ldr r3,.L366
 4987 014e 0022     	 movs r2,#0
 4988 0150 1A70     	 strb r2,[r3]
2445:../SSC/Src/ecatslv.c **** 
2446:../SSC/Src/ecatslv.c ****                 if (alStatusCode != 0)
 4989              	 .loc 3 2446 0
 4990 0152 BB88     	 ldrh r3,[r7,#4]
 4991 0154 002B     	 cmp r3,#0
 4992 0156 04D0     	 beq .L359
2447:../SSC/Src/ecatslv.c ****                 {
2448:../SSC/Src/ecatslv.c ****                     Status |= STATE_CHANGE;
 4993              	 .loc 3 2448 0
 4994 0158 FB7B     	 ldrb r3,[r7,#15]
 4995 015a 43F01003 	 orr r3,r3,#16
 4996 015e FB73     	 strb r3,[r7,#15]
 4997 0160 09E0     	 b .L360
 4998              	.L359:
2449:../SSC/Src/ecatslv.c ****                 }
2450:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.13) ECAT3*/
2451:../SSC/Src/ecatslv.c ****                 else if (u8LocalErrorState != 0)
 4999              	 .loc 3 2451 0
 5000 0162 294B     	 ldr r3,.L366+4
 5001 0164 1B78     	 ldrb r3,[r3]
 5002 0166 002B     	 cmp r3,#0
 5003 0168 05D0     	 beq .L360
2452:../SSC/Src/ecatslv.c ****                 {
2453:../SSC/Src/ecatslv.c ****                     /*a local error is cleared*/
2454:../SSC/Src/ecatslv.c ****                     /*ECATCHANGE_START(V5.13) ESM1*/
2455:../SSC/Src/ecatslv.c ****                     u8LocalErrorState = 0;
 5004              	 .loc 3 2455 0
 5005 016a 274B     	 ldr r3,.L366+4
 5006 016c 0022     	 movs r2,#0
 5007 016e 1A70     	 strb r2,[r3]
2456:../SSC/Src/ecatslv.c ****                     /*ECATCHANGE_END(V5.13) ESM1*/
2457:../SSC/Src/ecatslv.c ****                     u16LocalErrorCode = 0x00;
 5008              	 .loc 3 2457 0
 5009 0170 264B     	 ldr r3,.L366+8
 5010 0172 0022     	 movs r2,#0
 5011 0174 1A80     	 strh r2,[r3]
 5012              	.L360:
2458:../SSC/Src/ecatslv.c ****                 }
2459:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.13) ECAT3*/
2460:../SSC/Src/ecatslv.c **** 
2461:../SSC/Src/ecatslv.c ****                 SetALStatus(Status,alStatusCode);
 5013              	 .loc 3 2461 0
 5014 0176 FA7B     	 ldrb r2,[r7,#15]
 5015 0178 BB88     	 ldrh r3,[r7,#4]
 5016 017a 1046     	 mov r0,r2
 5017 017c 1946     	 mov r1,r3
 5018 017e FFF7FEFF 	 bl SetALStatus
 5019 0182 3CE0     	 b .L338
 5020              	.L342:
2462:../SSC/Src/ecatslv.c **** 
2463:../SSC/Src/ecatslv.c ****         }/*state transition need to be completed by the local application*/
2464:../SSC/Src/ecatslv.c ****     }/*State transition pending*/
2465:../SSC/Src/ecatslv.c ****     else
2466:../SSC/Src/ecatslv.c ****     {
2467:../SSC/Src/ecatslv.c ****         /*ECATCHANGE_START(V5.13) ESM1*/
2468:../SSC/Src/ecatslv.c ****         if ( alStatusCode != 0 && ((alStatus & STATE_MASK) != STATE_OP) && STATE_VALID(alStatus))
 5021              	 .loc 3 2468 0
 5022 0184 BB88     	 ldrh r3,[r7,#4]
 5023 0186 002B     	 cmp r3,#0
 5024 0188 2FD0     	 beq .L361
 5025              	 .loc 3 2468 0 is_stmt 0 discriminator 1
 5026 018a FB79     	 ldrb r3,[r7,#7]
 5027 018c 03F00F03 	 and r3,r3,#15
 5028 0190 082B     	 cmp r3,#8
 5029 0192 2AD0     	 beq .L361
 5030              	 .loc 3 2468 0 discriminator 2
 5031 0194 FB79     	 ldrb r3,[r7,#7]
 5032 0196 03F00F03 	 and r3,r3,#15
 5033 019a 012B     	 cmp r3,#1
 5034 019c 0ED0     	 beq .L362
 5035              	 .loc 3 2468 0 discriminator 3
 5036 019e FB79     	 ldrb r3,[r7,#7]
 5037 01a0 03F00F03 	 and r3,r3,#15
 5038 01a4 022B     	 cmp r3,#2
 5039 01a6 09D0     	 beq .L362
 5040              	 .loc 3 2468 0 discriminator 4
 5041 01a8 FB79     	 ldrb r3,[r7,#7]
 5042 01aa 03F00F03 	 and r3,r3,#15
 5043 01ae 042B     	 cmp r3,#4
 5044 01b0 04D0     	 beq .L362
 5045              	 .loc 3 2468 0 discriminator 5
 5046 01b2 FB79     	 ldrb r3,[r7,#7]
 5047 01b4 03F00F03 	 and r3,r3,#15
 5048 01b8 082B     	 cmp r3,#8
 5049 01ba 16D1     	 bne .L361
 5050              	.L362:
2469:../SSC/Src/ecatslv.c ****         {
2470:../SSC/Src/ecatslv.c ****             u8LocalErrorState = (alStatus & STATE_MASK);
 5051              	 .loc 3 2470 0 is_stmt 1
 5052 01bc FB79     	 ldrb r3,[r7,#7]
 5053 01be 03F00F03 	 and r3,r3,#15
 5054 01c2 DAB2     	 uxtb r2,r3
 5055 01c4 104B     	 ldr r3,.L366+4
 5056 01c6 1A70     	 strb r2,[r3]
2471:../SSC/Src/ecatslv.c ****             /*ECATCHANGE_END(V5.13) ESM1*/
2472:../SSC/Src/ecatslv.c ****             u16LocalErrorCode = alStatusCode;
 5057              	 .loc 3 2472 0
 5058 01c8 104A     	 ldr r2,.L366+8
 5059 01ca BB88     	 ldrh r3,[r7,#4]
 5060 01cc 1380     	 strh r3,[r2]
2473:../SSC/Src/ecatslv.c **** 
2474:../SSC/Src/ecatslv.c ****             /*trigger state transition only state transition from OP to lower state (for all other 
2475:../SSC/Src/ecatslv.c ****             if ((nAlStatus & STATE_MASK) == STATE_OP)
 5061              	 .loc 3 2475 0
 5062 01ce 174B     	 ldr r3,.L366+40
 5063 01d0 1B78     	 ldrb r3,[r3]
 5064 01d2 03F00F03 	 and r3,r3,#15
 5065 01d6 082B     	 cmp r3,#8
 5066 01d8 06D1     	 bne .L363
2476:../SSC/Src/ecatslv.c ****             {
2477:../SSC/Src/ecatslv.c ****                /* no error pending and the target state is lower than the current one*/
2478:../SSC/Src/ecatslv.c ****                 AL_ControlInd(alStatus, alStatusCode);
 5067              	 .loc 3 2478 0
 5068 01da FA79     	 ldrb r2,[r7,#7]
 5069 01dc BB88     	 ldrh r3,[r7,#4]
 5070 01de 1046     	 mov r0,r2
 5071 01e0 1946     	 mov r1,r3
 5072 01e2 FFF7FEFF 	 bl AL_ControlInd
2475:../SSC/Src/ecatslv.c ****             {
 5073              	 .loc 3 2475 0
 5074 01e6 0AE0     	 b .L338
 5075              	.L363:
2475:../SSC/Src/ecatslv.c ****             {
 5076              	 .loc 3 2475 0 is_stmt 0 discriminator 5
 5077 01e8 09E0     	 b .L338
 5078              	.L361:
2479:../SSC/Src/ecatslv.c ****             }
2480:../SSC/Src/ecatslv.c ****         }
2481:../SSC/Src/ecatslv.c ****         /*ECATCHANGE_START(V5.13) ESM1*/
2482:../SSC/Src/ecatslv.c ****         else if (u8LocalErrorState != 0)
 5079              	 .loc 3 2482 0 is_stmt 1
 5080 01ea 074B     	 ldr r3,.L366+4
 5081 01ec 1B78     	 ldrb r3,[r3]
 5082 01ee 002B     	 cmp r3,#0
 5083 01f0 05D0     	 beq .L338
2483:../SSC/Src/ecatslv.c ****         {
2484:../SSC/Src/ecatslv.c ****             /*a local error is gone*/
2485:../SSC/Src/ecatslv.c ****             u8LocalErrorState = 0;
 5084              	 .loc 3 2485 0
 5085 01f2 054B     	 ldr r3,.L366+4
 5086 01f4 0022     	 movs r2,#0
 5087 01f6 1A70     	 strb r2,[r3]
2486:../SSC/Src/ecatslv.c ****             u16LocalErrorCode = 0x00;
 5088              	 .loc 3 2486 0
 5089 01f8 044B     	 ldr r3,.L366+8
 5090 01fa 0022     	 movs r2,#0
 5091 01fc 1A80     	 strh r2,[r3]
 5092              	.L338:
2487:../SSC/Src/ecatslv.c ****         }
2488:../SSC/Src/ecatslv.c ****         /*ECATCHANGE_END(V5.13) ESM1*/
2489:../SSC/Src/ecatslv.c ****     }
2490:../SSC/Src/ecatslv.c **** }
 5093              	 .loc 3 2490 0
 5094 01fe 1037     	 adds r7,r7,#16
 5095              	.LCFI101:
 5096              	 .cfi_def_cfa_offset 8
 5097 0200 BD46     	 mov sp,r7
 5098              	.LCFI102:
 5099              	 .cfi_def_cfa_register 13
 5100              	 
 5101 0202 80BD     	 pop {r7,pc}
 5102              	.L367:
 5103              	 .align 2
 5104              	.L366:
 5105 0204 00000000 	 .word bEcatWaitForAlControlRes
 5106 0208 00000000 	 .word u8LocalErrorState
 5107 020c 00000000 	 .word u16LocalErrorCode
 5108 0210 00000000 	 .word bApplEsmPending
 5109 0214 00000000 	 .word EsmTimeoutCounter
 5110 0218 00000000 	 .word nEcatStateTrans
 5111 021c 00000000 	 .word bMbxRunning
 5112 0220 00000000 	 .word u16ALEventMask
 5113 0224 00000000 	 .word bEcatInputUpdateRunning
 5114 0228 00000000 	 .word bEcatOutputUpdateRunning
 5115 022c 00000000 	 .word nAlStatus
 5116              	 .cfi_endproc
 5117              	.LFE192:
 5119              	 .section .text.ECAT_Init,"ax",%progbits
 5120              	 .align 2
 5121              	 .global ECAT_Init
 5122              	 .thumb
 5123              	 .thumb_func
 5125              	ECAT_Init:
 5126              	.LFB193:
2491:../SSC/Src/ecatslv.c **** 
2492:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
2493:../SSC/Src/ecatslv.c **** /**
2494:../SSC/Src/ecatslv.c **** 
2495:../SSC/Src/ecatslv.c ****  \brief    This function initialize the EtherCAT Slave Interface.
2496:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
2497:../SSC/Src/ecatslv.c **** 
2498:../SSC/Src/ecatslv.c **** void ECAT_Init(void)
2499:../SSC/Src/ecatslv.c **** {
 5127              	 .loc 3 2499 0
 5128              	 .cfi_startproc
 5129              	 
 5130              	 
 5131 0000 80B5     	 push {r7,lr}
 5132              	.LCFI103:
 5133              	 .cfi_def_cfa_offset 8
 5134              	 .cfi_offset 7,-8
 5135              	 .cfi_offset 14,-4
 5136 0002 82B0     	 sub sp,sp,#8
 5137              	.LCFI104:
 5138              	 .cfi_def_cfa_offset 16
 5139 0004 00AF     	 add r7,sp,#0
 5140              	.LCFI105:
 5141              	 .cfi_def_cfa_register 7
2500:../SSC/Src/ecatslv.c ****     UINT8 i;
2501:../SSC/Src/ecatslv.c ****     /*Get Maximum Number of SyncManagers and supported DPRAM size*/
2502:../SSC/Src/ecatslv.c ****     HW_EscReadByte(nMaxSyncMan, ESC_SM_CHANNELS_OFFSET);
 5142              	 .loc 3 2502 0
 5143 0006 394B     	 ldr r3,.L371
 5144 0008 1B78     	 ldrb r3,[r3]
 5145 000a DAB2     	 uxtb r2,r3
 5146 000c 384B     	 ldr r3,.L371+4
 5147 000e 1A70     	 strb r2,[r3]
2503:../SSC/Src/ecatslv.c **** 
2504:../SSC/Src/ecatslv.c ****     HW_EscReadWord(nMaxEscAddress, ESC_DPRAM_SIZE_OFFSET);
 5148              	 .loc 3 2504 0
 5149 0010 384B     	 ldr r3,.L371+8
 5150 0012 1B88     	 ldrh r3,[r3]
 5151 0014 9AB2     	 uxth r2,r3
 5152 0016 384B     	 ldr r3,.L371+12
 5153 0018 1A80     	 strh r2,[r3]
2505:../SSC/Src/ecatslv.c ****     //get max address (register + DPRAM size in Byte (in the register it is stored in KB))
2506:../SSC/Src/ecatslv.c ****     nMaxEscAddress = (nMaxEscAddress << 10) + 0xFFF;
 5154              	 .loc 3 2506 0
 5155 001a 374B     	 ldr r3,.L371+12
 5156 001c 1B88     	 ldrh r3,[r3]
 5157 001e 9B02     	 lsls r3,r3,#10
 5158 0020 9BB2     	 uxth r3,r3
 5159 0022 03F6FF73 	 addw r3,r3,#4095
 5160 0026 9AB2     	 uxth r2,r3
 5161 0028 334B     	 ldr r3,.L371+12
 5162 002a 1A80     	 strh r2,[r3]
2507:../SSC/Src/ecatslv.c **** 
2508:../SSC/Src/ecatslv.c **** 
2509:../SSC/Src/ecatslv.c ****     /* Get EEPROM loaded information */
2510:../SSC/Src/ecatslv.c ****     UpdateEEPROMLoadedState();
 5163              	 .loc 3 2510 0
 5164 002c FFF7FEFF 	 bl UpdateEEPROMLoadedState
2511:../SSC/Src/ecatslv.c **** 
2512:../SSC/Src/ecatslv.c ****     /* disable all Sync Manager channels */
2513:../SSC/Src/ecatslv.c ****     for (i = 0; i < nMaxSyncMan; i++)
 5165              	 .loc 3 2513 0
 5166 0030 0023     	 movs r3,#0
 5167 0032 FB71     	 strb r3,[r7,#7]
 5168 0034 06E0     	 b .L369
 5169              	.L370:
2514:../SSC/Src/ecatslv.c ****     {
2515:../SSC/Src/ecatslv.c ****         DisableSyncManChannel(i);
 5170              	 .loc 3 2515 0 discriminator 3
 5171 0036 FB79     	 ldrb r3,[r7,#7]
 5172 0038 1846     	 mov r0,r3
 5173 003a FFF7FEFF 	 bl DisableSyncManChannel
2513:../SSC/Src/ecatslv.c ****     {
 5174              	 .loc 3 2513 0 discriminator 3
 5175 003e FB79     	 ldrb r3,[r7,#7]
 5176 0040 0133     	 adds r3,r3,#1
 5177 0042 FB71     	 strb r3,[r7,#7]
 5178              	.L369:
2513:../SSC/Src/ecatslv.c ****     {
 5179              	 .loc 3 2513 0 is_stmt 0 discriminator 1
 5180 0044 2A4B     	 ldr r3,.L371+4
 5181 0046 1B78     	 ldrb r3,[r3]
 5182 0048 FA79     	 ldrb r2,[r7,#7]
 5183 004a 9A42     	 cmp r2,r3
 5184 004c F3D3     	 bcc .L370
2516:../SSC/Src/ecatslv.c ****     }
2517:../SSC/Src/ecatslv.c **** 
2518:../SSC/Src/ecatslv.c ****     /* initialize the mailbox handler */
2519:../SSC/Src/ecatslv.c ****     MBX_Init();
 5185              	 .loc 3 2519 0 is_stmt 1
 5186 004e FFF7FEFF 	 bl MBX_Init
2520:../SSC/Src/ecatslv.c **** 
2521:../SSC/Src/ecatslv.c ****     /* initialize variables */
2522:../SSC/Src/ecatslv.c ****     bApplEsmPending = FALSE;
 5187              	 .loc 3 2522 0
 5188 0052 2A4B     	 ldr r3,.L371+16
 5189 0054 0022     	 movs r2,#0
 5190 0056 1A70     	 strb r2,[r3]
2523:../SSC/Src/ecatslv.c ****     bEcatWaitForAlControlRes = FALSE;
 5191              	 .loc 3 2523 0
 5192 0058 294B     	 ldr r3,.L371+20
 5193 005a 0022     	 movs r2,#0
 5194 005c 1A70     	 strb r2,[r3]
2524:../SSC/Src/ecatslv.c ****     bEcatFirstOutputsReceived = FALSE;
 5195              	 .loc 3 2524 0
 5196 005e 294B     	 ldr r3,.L371+24
 5197 0060 0022     	 movs r2,#0
 5198 0062 1A70     	 strb r2,[r3]
2525:../SSC/Src/ecatslv.c ****      bEcatOutputUpdateRunning = FALSE;
 5199              	 .loc 3 2525 0
 5200 0064 284B     	 ldr r3,.L371+28
 5201 0066 0022     	 movs r2,#0
 5202 0068 1A70     	 strb r2,[r3]
2526:../SSC/Src/ecatslv.c ****      bEcatInputUpdateRunning = FALSE;
 5203              	 .loc 3 2526 0
 5204 006a 284B     	 ldr r3,.L371+32
 5205 006c 0022     	 movs r2,#0
 5206 006e 1A70     	 strb r2,[r3]
2527:../SSC/Src/ecatslv.c ****     bWdTrigger = FALSE;
 5207              	 .loc 3 2527 0
 5208 0070 274B     	 ldr r3,.L371+36
 5209 0072 0022     	 movs r2,#0
 5210 0074 1A70     	 strb r2,[r3]
2528:../SSC/Src/ecatslv.c ****     EcatWdValue = 0;
 5211              	 .loc 3 2528 0
 5212 0076 274B     	 ldr r3,.L371+40
 5213 0078 0022     	 movs r2,#0
 5214 007a 1A80     	 strh r2,[r3]
2529:../SSC/Src/ecatslv.c ****     Sync0WdCounter = 0;
 5215              	 .loc 3 2529 0
 5216 007c 264B     	 ldr r3,.L371+44
 5217 007e 0022     	 movs r2,#0
 5218 0080 1A80     	 strh r2,[r3]
2530:../SSC/Src/ecatslv.c ****     Sync0WdValue = 0;
 5219              	 .loc 3 2530 0
 5220 0082 264B     	 ldr r3,.L371+48
 5221 0084 0022     	 movs r2,#0
 5222 0086 1A80     	 strh r2,[r3]
2531:../SSC/Src/ecatslv.c ****     Sync1WdCounter = 0;
 5223              	 .loc 3 2531 0
 5224 0088 254B     	 ldr r3,.L371+52
 5225 008a 0022     	 movs r2,#0
 5226 008c 1A80     	 strh r2,[r3]
2532:../SSC/Src/ecatslv.c ****     Sync1WdValue = 0;
 5227              	 .loc 3 2532 0
 5228 008e 254B     	 ldr r3,.L371+56
 5229 0090 0022     	 movs r2,#0
 5230 0092 1A80     	 strh r2,[r3]
2533:../SSC/Src/ecatslv.c ****     bDcSyncActive = FALSE;
 5231              	 .loc 3 2533 0
 5232 0094 244B     	 ldr r3,.L371+60
 5233 0096 0022     	 movs r2,#0
 5234 0098 1A70     	 strb r2,[r3]
2534:../SSC/Src/ecatslv.c **** 
2535:../SSC/Src/ecatslv.c ****     /*ECATCHANGE_START(V5.13) ESM1*/
2536:../SSC/Src/ecatslv.c ****     u8LocalErrorState = 0;
 5235              	 .loc 3 2536 0
 5236 009a 244B     	 ldr r3,.L371+64
 5237 009c 0022     	 movs r2,#0
 5238 009e 1A70     	 strb r2,[r3]
2537:../SSC/Src/ecatslv.c ****     /*ECATCHANGE_END(V5.13) ESM1*/
2538:../SSC/Src/ecatslv.c ****     u16LocalErrorCode = 0x00;
 5239              	 .loc 3 2538 0
 5240 00a0 234B     	 ldr r3,.L371+68
 5241 00a2 0022     	 movs r2,#0
 5242 00a4 1A80     	 strh r2,[r3]
2539:../SSC/Src/ecatslv.c **** 
2540:../SSC/Src/ecatslv.c ****     u16ALEventMask = 0;
 5243              	 .loc 3 2540 0
 5244 00a6 234B     	 ldr r3,.L371+72
 5245 00a8 0022     	 movs r2,#0
 5246 00aa 1A80     	 strh r2,[r3]
2541:../SSC/Src/ecatslv.c ****     nPdOutputSize = 0;
 5247              	 .loc 3 2541 0
 5248 00ac 224B     	 ldr r3,.L371+76
 5249 00ae 0022     	 movs r2,#0
 5250 00b0 1A80     	 strh r2,[r3]
2542:../SSC/Src/ecatslv.c ****     nPdInputSize = 0;
 5251              	 .loc 3 2542 0
 5252 00b2 224B     	 ldr r3,.L371+80
 5253 00b4 0022     	 movs r2,#0
 5254 00b6 1A80     	 strh r2,[r3]
2543:../SSC/Src/ecatslv.c **** 
2544:../SSC/Src/ecatslv.c ****     /* initialize the AL Status register */
2545:../SSC/Src/ecatslv.c ****     nAlStatus    = STATE_INIT;
 5255              	 .loc 3 2545 0
 5256 00b8 214B     	 ldr r3,.L371+84
 5257 00ba 0122     	 movs r2,#1
 5258 00bc 1A70     	 strb r2,[r3]
2546:../SSC/Src/ecatslv.c ****     SetALStatus(nAlStatus, 0);
 5259              	 .loc 3 2546 0
 5260 00be 204B     	 ldr r3,.L371+84
 5261 00c0 1B78     	 ldrb r3,[r3]
 5262 00c2 1846     	 mov r0,r3
 5263 00c4 0021     	 movs r1,#0
 5264 00c6 FFF7FEFF 	 bl SetALStatus
2547:../SSC/Src/ecatslv.c ****     nEcatStateTrans = 0;
 5265              	 .loc 3 2547 0
 5266 00ca 1E4B     	 ldr r3,.L371+88
 5267 00cc 0022     	 movs r2,#0
 5268 00ce 1A80     	 strh r2,[r3]
2548:../SSC/Src/ecatslv.c ****     u8EcatErrorLed = LED_OFF;
 5269              	 .loc 3 2548 0
 5270 00d0 1D4B     	 ldr r3,.L371+92
 5271 00d2 0022     	 movs r2,#0
 5272 00d4 1A70     	 strb r2,[r3]
2549:../SSC/Src/ecatslv.c **** 
2550:../SSC/Src/ecatslv.c ****     bEscIntEnabled = FALSE;
 5273              	 .loc 3 2550 0
 5274 00d6 1D4B     	 ldr r3,.L371+96
 5275 00d8 0022     	 movs r2,#0
 5276 00da 1A70     	 strb r2,[r3]
2551:../SSC/Src/ecatslv.c **** 
2552:../SSC/Src/ecatslv.c ****     /* initialize the COE part */
2553:../SSC/Src/ecatslv.c ****     COE_Init();
 5277              	 .loc 3 2553 0
 5278 00dc FFF7FEFF 	 bl COE_Init
2554:../SSC/Src/ecatslv.c **** 
2555:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.13) ECAT1*/
2556:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.13) ECAT1*/
2557:../SSC/Src/ecatslv.c ****     /*reset AL event mask*/
2558:../SSC/Src/ecatslv.c ****     ResetALEventMask(0);
 5279              	 .loc 3 2558 0
 5280 00e0 0020     	 movs r0,#0
 5281 00e2 FFF7FEFF 	 bl ResetALEventMask
2559:../SSC/Src/ecatslv.c **** }
 5282              	 .loc 3 2559 0
 5283 00e6 0837     	 adds r7,r7,#8
 5284              	.LCFI106:
 5285              	 .cfi_def_cfa_offset 8
 5286 00e8 BD46     	 mov sp,r7
 5287              	.LCFI107:
 5288              	 .cfi_def_cfa_register 13
 5289              	 
 5290 00ea 80BD     	 pop {r7,pc}
 5291              	.L372:
 5292              	 .align 2
 5293              	.L371:
 5294 00ec 05000154 	 .word 1409351685
 5295 00f0 00000000 	 .word nMaxSyncMan
 5296 00f4 06000154 	 .word 1409351686
 5297 00f8 00000000 	 .word nMaxEscAddress
 5298 00fc 00000000 	 .word bApplEsmPending
 5299 0100 00000000 	 .word bEcatWaitForAlControlRes
 5300 0104 00000000 	 .word bEcatFirstOutputsReceived
 5301 0108 00000000 	 .word bEcatOutputUpdateRunning
 5302 010c 00000000 	 .word bEcatInputUpdateRunning
 5303 0110 00000000 	 .word bWdTrigger
 5304 0114 00000000 	 .word EcatWdValue
 5305 0118 00000000 	 .word Sync0WdCounter
 5306 011c 00000000 	 .word Sync0WdValue
 5307 0120 00000000 	 .word Sync1WdCounter
 5308 0124 00000000 	 .word Sync1WdValue
 5309 0128 00000000 	 .word bDcSyncActive
 5310 012c 00000000 	 .word u8LocalErrorState
 5311 0130 00000000 	 .word u16LocalErrorCode
 5312 0134 00000000 	 .word u16ALEventMask
 5313 0138 00000000 	 .word nPdOutputSize
 5314 013c 00000000 	 .word nPdInputSize
 5315 0140 00000000 	 .word nAlStatus
 5316 0144 00000000 	 .word nEcatStateTrans
 5317 0148 00000000 	 .word u8EcatErrorLed
 5318 014c 00000000 	 .word bEscIntEnabled
 5319              	 .cfi_endproc
 5320              	.LFE193:
 5322              	 .section .text.ECAT_Main,"ax",%progbits
 5323              	 .align 2
 5324              	 .global ECAT_Main
 5325              	 .thumb
 5326              	 .thumb_func
 5328              	ECAT_Main:
 5329              	.LFB194:
2560:../SSC/Src/ecatslv.c **** 
2561:../SSC/Src/ecatslv.c **** /////////////////////////////////////////////////////////////////////////////////////////
2562:../SSC/Src/ecatslv.c **** /**
2563:../SSC/Src/ecatslv.c ****  \brief        This function has to be called cyclically.
2564:../SSC/Src/ecatslv.c **** *////////////////////////////////////////////////////////////////////////////////////////
2565:../SSC/Src/ecatslv.c **** 
2566:../SSC/Src/ecatslv.c **** void ECAT_Main(void)
2567:../SSC/Src/ecatslv.c **** {
 5330              	 .loc 3 2567 0
 5331              	 .cfi_startproc
 5332              	 
 5333              	 
 5334 0000 80B5     	 push {r7,lr}
 5335              	.LCFI108:
 5336              	 .cfi_def_cfa_offset 8
 5337              	 .cfi_offset 7,-8
 5338              	 .cfi_offset 14,-4
 5339 0002 82B0     	 sub sp,sp,#8
 5340              	.LCFI109:
 5341              	 .cfi_def_cfa_offset 16
 5342 0004 00AF     	 add r7,sp,#0
 5343              	.LCFI110:
 5344              	 .cfi_def_cfa_register 7
2568:../SSC/Src/ecatslv.c ****     UINT16 ALEventReg;
2569:../SSC/Src/ecatslv.c ****     UINT16 EscAlControl = 0x0000;
 5345              	 .loc 3 2569 0
 5346 0006 0023     	 movs r3,#0
 5347 0008 7B80     	 strh r3,[r7,#2]
2570:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.13) MBX1*/
2571:../SSC/Src/ecatslv.c ****     UINT8 sm1Activate = SM_SETTING_ENABLE_VALUE;
 5348              	 .loc 3 2571 0
 5349 000a 0123     	 movs r3,#1
 5350 000c 7B71     	 strb r3,[r7,#5]
2572:../SSC/Src/ecatslv.c ****     UINT8 sm1Status = 0; /*SM1 status need to be read (not MBX_READ_EVENT) to handle readframes wit
 5351              	 .loc 3 2572 0
 5352 000e 0023     	 movs r3,#0
 5353 0010 3B71     	 strb r3,[r7,#4]
2573:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.13) MBX1*/
2574:../SSC/Src/ecatslv.c **** 
2575:../SSC/Src/ecatslv.c **** 
2576:../SSC/Src/ecatslv.c ****     /* check if services are stored in the mailbox */
2577:../SSC/Src/ecatslv.c ****     MBX_Main();
 5354              	 .loc 3 2577 0
 5355 0012 FFF7FEFF 	 bl MBX_Main
2578:../SSC/Src/ecatslv.c **** 
2579:../SSC/Src/ecatslv.c **** 
2580:../SSC/Src/ecatslv.c ****     if ( bMbxRunning )
 5356              	 .loc 3 2580 0
 5357 0016 5C4B     	 ldr r3,.L385
 5358 0018 1B78     	 ldrb r3,[r3]
 5359 001a 002B     	 cmp r3,#0
 5360 001c 05D0     	 beq .L374
2581:../SSC/Src/ecatslv.c ****     {
2582:../SSC/Src/ecatslv.c ****         /* Slave is at least in PREOP, Mailbox is running */
2583:../SSC/Src/ecatslv.c **** 
2584:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.13) MBX1*/
2585:../SSC/Src/ecatslv.c ****         /* get the Activate-Byte of SM 1 (Register 0x80E) to check if a mailbox repeat request was 
2586:../SSC/Src/ecatslv.c ****         HW_EscReadByte(sm1Activate,(ESC_SYNCMAN_ACTIVE_OFFSET + SIZEOF_SM_REGISTER));
 5361              	 .loc 3 2586 0
 5362 001e 5B4B     	 ldr r3,.L385+4
 5363 0020 1B78     	 ldrb r3,[r3]
 5364 0022 7B71     	 strb r3,[r7,#5]
2587:../SSC/Src/ecatslv.c **** 
2588:../SSC/Src/ecatslv.c ****         HW_EscReadByte(sm1Status, (ESC_SYNCMAN_STATUS_OFFSET + SIZEOF_SM_REGISTER));
 5365              	 .loc 3 2588 0
 5366 0024 5A4B     	 ldr r3,.L385+8
 5367 0026 1B78     	 ldrb r3,[r3]
 5368 0028 3B71     	 strb r3,[r7,#4]
 5369              	.L374:
2589:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.13) MBX1*/
2590:../SSC/Src/ecatslv.c ****     }
2591:../SSC/Src/ecatslv.c **** 
2592:../SSC/Src/ecatslv.c ****     /* Read AL Event-Register from ESC */
2593:../SSC/Src/ecatslv.c ****     ALEventReg = HW_GetALEventRegister();
 5370              	 .loc 3 2593 0
 5371 002a FFF7FEFF 	 bl HW_GetALEventRegister
 5372 002e 0346     	 mov r3,r0
 5373 0030 FB80     	 strh r3,[r7,#6]
2594:../SSC/Src/ecatslv.c ****     ALEventReg = SWAPWORD(ALEventReg);
2595:../SSC/Src/ecatslv.c **** 
2596:../SSC/Src/ecatslv.c ****     if ((ALEventReg & EEPROM_CMD_PENDING)) 
 5374              	 .loc 3 2596 0
 5375 0032 FB88     	 ldrh r3,[r7,#6]
 5376 0034 03F02003 	 and r3,r3,#32
 5377 0038 002B     	 cmp r3,#0
 5378 003a 01D0     	 beq .L375
2597:../SSC/Src/ecatslv.c ****     {
2598:../SSC/Src/ecatslv.c ****         EEPROM_CommandHandler();
 5379              	 .loc 3 2598 0
 5380 003c FFF7FEFF 	 bl EEPROM_CommandHandler
 5381              	.L375:
2599:../SSC/Src/ecatslv.c ****     }
2600:../SSC/Src/ecatslv.c **** 
2601:../SSC/Src/ecatslv.c ****     if ((ALEventReg & AL_CONTROL_EVENT) && !bEcatWaitForAlControlRes)
 5382              	 .loc 3 2601 0
 5383 0040 FB88     	 ldrh r3,[r7,#6]
 5384 0042 03F00103 	 and r3,r3,#1
 5385 0046 002B     	 cmp r3,#0
 5386 0048 14D0     	 beq .L376
 5387              	 .loc 3 2601 0 is_stmt 0 discriminator 1
 5388 004a 524B     	 ldr r3,.L385+12
 5389 004c 1B78     	 ldrb r3,[r3]
 5390 004e 83F00103 	 eor r3,r3,#1
 5391 0052 DBB2     	 uxtb r3,r3
 5392 0054 002B     	 cmp r3,#0
 5393 0056 0DD0     	 beq .L376
2602:../SSC/Src/ecatslv.c ****     {
2603:../SSC/Src/ecatslv.c ****         /* AL Control event is set, get the AL Control register sent by the Master to acknowledge t
2604:../SSC/Src/ecatslv.c ****           (that the corresponding bit in the AL Event register will be reset) */
2605:../SSC/Src/ecatslv.c **** 
2606:../SSC/Src/ecatslv.c ****         HW_EscReadByte( EscAlControl, ESC_AL_CONTROL_OFFSET);
 5394              	 .loc 3 2606 0 is_stmt 1
 5395 0058 4F4B     	 ldr r3,.L385+16
 5396 005a 1B78     	 ldrb r3,[r3]
 5397 005c DBB2     	 uxtb r3,r3
 5398 005e 7B80     	 strh r3,[r7,#2]
2607:../SSC/Src/ecatslv.c ****         EscAlControl = SWAPWORD(EscAlControl);
2608:../SSC/Src/ecatslv.c **** 
2609:../SSC/Src/ecatslv.c **** 
2610:../SSC/Src/ecatslv.c **** 
2611:../SSC/Src/ecatslv.c ****         /* reset AL Control event and the SM Change event (because the Sync Manager settings will b
2612:../SSC/Src/ecatslv.c ****            in AL_ControlInd, too)*/
2613:../SSC/Src/ecatslv.c ****             ALEventReg &= ~((AL_CONTROL_EVENT) | (SM_CHANGE_EVENT));
 5399              	 .loc 3 2613 0
 5400 0060 FB88     	 ldrh r3,[r7,#6]
 5401 0062 23F01103 	 bic r3,r3,#17
 5402 0066 FB80     	 strh r3,[r7,#6]
2614:../SSC/Src/ecatslv.c **** 
2615:../SSC/Src/ecatslv.c ****             AL_ControlInd((UINT8)EscAlControl, 0); /* in AL_ControlInd the state transition will be
 5403              	 .loc 3 2615 0
 5404 0068 7B88     	 ldrh r3,[r7,#2]
 5405 006a DBB2     	 uxtb r3,r3
 5406 006c 1846     	 mov r0,r3
 5407 006e 0021     	 movs r1,#0
 5408 0070 FFF7FEFF 	 bl AL_ControlInd
 5409              	.L376:
2616:../SSC/Src/ecatslv.c **** 
2617:../SSC/Src/ecatslv.c ****             /* SM-Change-Event was handled too */
2618:../SSC/Src/ecatslv.c **** 
2619:../SSC/Src/ecatslv.c ****     }
2620:../SSC/Src/ecatslv.c **** 
2621:../SSC/Src/ecatslv.c ****     if ( (ALEventReg & SM_CHANGE_EVENT) && !bEcatWaitForAlControlRes && (nAlStatus & STATE_CHANGE) 
 5410              	 .loc 3 2621 0
 5411 0074 FB88     	 ldrh r3,[r7,#6]
 5412 0076 03F01003 	 and r3,r3,#16
 5413 007a 002B     	 cmp r3,#0
 5414 007c 1FD0     	 beq .L377
 5415              	 .loc 3 2621 0 is_stmt 0 discriminator 1
 5416 007e 454B     	 ldr r3,.L385+12
 5417 0080 1B78     	 ldrb r3,[r3]
 5418 0082 83F00103 	 eor r3,r3,#1
 5419 0086 DBB2     	 uxtb r3,r3
 5420 0088 002B     	 cmp r3,#0
 5421 008a 18D0     	 beq .L377
 5422              	 .loc 3 2621 0 discriminator 2
 5423 008c 434B     	 ldr r3,.L385+20
 5424 008e 1B78     	 ldrb r3,[r3]
 5425 0090 03F01003 	 and r3,r3,#16
 5426 0094 002B     	 cmp r3,#0
 5427 0096 12D1     	 bne .L377
 5428              	 .loc 3 2621 0 discriminator 3
 5429 0098 404B     	 ldr r3,.L385+20
 5430 009a 1B78     	 ldrb r3,[r3]
 5431 009c 23F01003 	 bic r3,r3,#16
 5432 00a0 012B     	 cmp r3,#1
 5433 00a2 0CD0     	 beq .L377
2622:../SSC/Src/ecatslv.c ****     {
2623:../SSC/Src/ecatslv.c ****         /* the SM Change event is set (Bit 4 of Register 0x220), when the Byte 6 (Enable, Lo-Byte o
2624:../SSC/Src/ecatslv.c ****            of a Sync Manager channel was written */
2625:../SSC/Src/ecatslv.c ****         ALEventReg &= ~(SM_CHANGE_EVENT);
 5434              	 .loc 3 2625 0 is_stmt 1
 5435 00a4 FB88     	 ldrh r3,[r7,#6]
 5436 00a6 23F01003 	 bic r3,r3,#16
 5437 00aa FB80     	 strh r3,[r7,#6]
2626:../SSC/Src/ecatslv.c **** 
2627:../SSC/Src/ecatslv.c ****         /* AL_ControlInd is called with the actual state, so that the correct SM settings will be c
2628:../SSC/Src/ecatslv.c ****         AL_ControlInd(nAlStatus & STATE_MASK, 0);
 5438              	 .loc 3 2628 0
 5439 00ac 3B4B     	 ldr r3,.L385+20
 5440 00ae 1B78     	 ldrb r3,[r3]
 5441 00b0 03F00F03 	 and r3,r3,#15
 5442 00b4 DBB2     	 uxtb r3,r3
 5443 00b6 1846     	 mov r0,r3
 5444 00b8 0021     	 movs r1,#0
 5445 00ba FFF7FEFF 	 bl AL_ControlInd
 5446              	.L377:
2629:../SSC/Src/ecatslv.c ****     }
2630:../SSC/Src/ecatslv.c **** 
2631:../SSC/Src/ecatslv.c ****     if(bEcatWaitForAlControlRes)
 5447              	 .loc 3 2631 0
 5448 00be 354B     	 ldr r3,.L385+12
 5449 00c0 1B78     	 ldrb r3,[r3]
 5450 00c2 002B     	 cmp r3,#0
 5451 00c4 01D0     	 beq .L378
2632:../SSC/Src/ecatslv.c ****     {
2633:../SSC/Src/ecatslv.c ****         AL_ControlRes();
 5452              	 .loc 3 2633 0
 5453 00c6 FFF7FEFF 	 bl AL_ControlRes
 5454              	.L378:
2634:../SSC/Src/ecatslv.c ****     }
2635:../SSC/Src/ecatslv.c ****     /*The order of mailbox event processing was changed to prevent race condition errors.
2636:../SSC/Src/ecatslv.c ****         The SM1 activate Byte (Register 0x80E) was read before reading AL Event register.
2637:../SSC/Src/ecatslv.c ****         1. Handle Mailbox Read event
2638:../SSC/Src/ecatslv.c ****         2. Handle repeat toggle request
2639:../SSC/Src/ecatslv.c ****         3. Handle Mailbox write event
2640:../SSC/Src/ecatslv.c ****     */
2641:../SSC/Src/ecatslv.c ****     if ( bMbxRunning )
 5455              	 .loc 3 2641 0
 5456 00ca 2F4B     	 ldr r3,.L385
 5457 00cc 1B78     	 ldrb r3,[r3]
 5458 00ce 002B     	 cmp r3,#0
 5459 00d0 56D0     	 beq .L373
2642:../SSC/Src/ecatslv.c ****     {
2643:../SSC/Src/ecatslv.c ****         /*SnycManger change event (0x220:4) could be acknowledged by reading the SM1 control regist
2644:../SSC/Src/ecatslv.c ****         => check if the SyncManger 1 is still enabled*/
2645:../SSC/Src/ecatslv.c ****             if (!(sm1Activate & SM_SETTING_ENABLE_VALUE))
 5460              	 .loc 3 2645 0
 5461 00d2 7B79     	 ldrb r3,[r7,#5]
 5462 00d4 03F00103 	 and r3,r3,#1
 5463 00d8 002B     	 cmp r3,#0
 5464 00da 08D1     	 bne .L380
2646:../SSC/Src/ecatslv.c ****             {
2647:../SSC/Src/ecatslv.c ****                 AL_ControlInd(nAlStatus & STATE_MASK, 0);
 5465              	 .loc 3 2647 0
 5466 00dc 2F4B     	 ldr r3,.L385+20
 5467 00de 1B78     	 ldrb r3,[r3]
 5468 00e0 03F00F03 	 and r3,r3,#15
 5469 00e4 DBB2     	 uxtb r3,r3
 5470 00e6 1846     	 mov r0,r3
 5471 00e8 0021     	 movs r1,#0
 5472 00ea FFF7FEFF 	 bl AL_ControlInd
 5473              	.L380:
2648:../SSC/Src/ecatslv.c ****             }
2649:../SSC/Src/ecatslv.c **** 
2650:../SSC/Src/ecatslv.c **** /*ECATCHANGE_START(V5.13) MBX1*/
2651:../SSC/Src/ecatslv.c ****         if (((sm1Status & SM_STATUS_MBX_BUFFER_FULL) == 0)
 5474              	 .loc 3 2651 0
 5475 00ee 3B79     	 ldrb r3,[r7,#4]
 5476 00f0 03F00803 	 and r3,r3,#8
 5477 00f4 002B     	 cmp r3,#0
 5478 00f6 16D1     	 bne .L381
2652:../SSC/Src/ecatslv.c ****             && bSendMbxIsFull) 
 5479              	 .loc 3 2652 0
 5480 00f8 294B     	 ldr r3,.L385+24
 5481 00fa 1B78     	 ldrb r3,[r3]
 5482 00fc 002B     	 cmp r3,#0
 5483 00fe 12D0     	 beq .L381
2653:../SSC/Src/ecatslv.c **** /*ECATCHANGE_END(V5.13) MBX1*/
2654:../SSC/Src/ecatslv.c ****         {
2655:../SSC/Src/ecatslv.c ****             /* SM 1 (Mailbox Read) event is set, when the mailbox was read from the master,
2656:../SSC/Src/ecatslv.c ****                to acknowledge the event the first byte of the mailbox has to be written,
2657:../SSC/Src/ecatslv.c ****                by writing the first byte the mailbox is locked, too */
2658:../SSC/Src/ecatslv.c ****             u8dummy = 0;
 5484              	 .loc 3 2658 0
 5485 0100 284B     	 ldr r3,.L385+28
 5486 0102 0022     	 movs r2,#0
 5487 0104 1A70     	 strb r2,[r3]
2659:../SSC/Src/ecatslv.c ****             HW_EscWriteByte(u8dummy,u16EscAddrSendMbx);
 5488              	 .loc 3 2659 0
 5489 0106 284B     	 ldr r3,.L385+32
 5490 0108 1B88     	 ldrh r3,[r3]
 5491 010a 03F1A843 	 add r3,r3,#1409286144
 5492 010e 03F58033 	 add r3,r3,#65536
 5493 0112 244A     	 ldr r2,.L385+28
 5494 0114 1278     	 ldrb r2,[r2]
 5495 0116 D2B2     	 uxtb r2,r2
 5496 0118 1A70     	 strb r2,[r3]
2660:../SSC/Src/ecatslv.c **** 
2661:../SSC/Src/ecatslv.c ****             /* the Mailbox Read event in the variable ALEventReg shall be reset before calling
2662:../SSC/Src/ecatslv.c ****                MBX_MailboxReadInd, where a new mailbox datagram (if available) could be stored in t
2663:../SSC/Src/ecatslv.c ****             ALEventReg &= ~(MAILBOX_READ_EVENT);
 5497              	 .loc 3 2663 0
 5498 011a FB88     	 ldrh r3,[r7,#6]
 5499 011c 23F40073 	 bic r3,r3,#512
 5500 0120 FB80     	 strh r3,[r7,#6]
2664:../SSC/Src/ecatslv.c ****             MBX_MailboxReadInd();
 5501              	 .loc 3 2664 0
 5502 0122 FFF7FEFF 	 bl MBX_MailboxReadInd
 5503              	.L381:
2665:../SSC/Src/ecatslv.c ****         }
2666:../SSC/Src/ecatslv.c **** 
2667:../SSC/Src/ecatslv.c ****             /* bMbxRepeatToggle holds the last state of the Repeat Bit (Bit 1) */
2668:../SSC/Src/ecatslv.c **** 
2669:../SSC/Src/ecatslv.c ****             if (((sm1Activate & SM_SETTING_REPAET_REQ_MASK) && !bMbxRepeatToggle)
 5504              	 .loc 3 2669 0
 5505 0126 7B79     	 ldrb r3,[r7,#5]
 5506 0128 03F00203 	 and r3,r3,#2
 5507 012c 002B     	 cmp r3,#0
 5508 012e 06D0     	 beq .L382
 5509              	 .loc 3 2669 0 is_stmt 0 discriminator 1
 5510 0130 1E4B     	 ldr r3,.L385+36
 5511 0132 1B78     	 ldrb r3,[r3]
 5512 0134 83F00103 	 eor r3,r3,#1
 5513 0138 DBB2     	 uxtb r3,r3
 5514 013a 002B     	 cmp r3,#0
 5515 013c 08D1     	 bne .L383
 5516              	.L382:
2670:../SSC/Src/ecatslv.c ****                 || (!(sm1Activate & SM_SETTING_REPAET_REQ_MASK) && bMbxRepeatToggle))
 5517              	 .loc 3 2670 0 is_stmt 1
 5518 013e 7B79     	 ldrb r3,[r7,#5]
 5519 0140 03F00203 	 and r3,r3,#2
 5520 0144 002B     	 cmp r3,#0
 5521 0146 0CD1     	 bne .L384
 5522              	 .loc 3 2670 0 is_stmt 0 discriminator 1
 5523 0148 184B     	 ldr r3,.L385+36
 5524 014a 1B78     	 ldrb r3,[r3]
 5525 014c 002B     	 cmp r3,#0
 5526 014e 08D0     	 beq .L384
 5527              	.L383:
2671:../SSC/Src/ecatslv.c ****             {
2672:../SSC/Src/ecatslv.c ****                 /* Repeat Bit (Bit 1) has toggled, there is a repeat request, in MBX_MailboxRepeatR
2673:../SSC/Src/ecatslv.c ****                    response will put in the send mailbox again */
2674:../SSC/Src/ecatslv.c ****                 MBX_MailboxRepeatReq();
 5528              	 .loc 3 2674 0 is_stmt 1
 5529 0150 FFF7FEFF 	 bl MBX_MailboxRepeatReq
2675:../SSC/Src/ecatslv.c ****                 /* acknowledge the repeat request after the send mailbox was updated by writing the
2676:../SSC/Src/ecatslv.c ****                    in the Repeat Ack Bit (Bit 1) of the PDI Ctrl-Byte of SM 1 (Register 0x80F) */
2677:../SSC/Src/ecatslv.c ****                 sm1Activate &= SM_SETTING_REPEAT_ACK;
 5530              	 .loc 3 2677 0
 5531 0154 7B79     	 ldrb r3,[r7,#5]
 5532 0156 03F00203 	 and r3,r3,#2
 5533 015a 7B71     	 strb r3,[r7,#5]
2678:../SSC/Src/ecatslv.c ****                 HW_EscWriteByte(sm1Activate, (ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
 5534              	 .loc 3 2678 0
 5535 015c 144A     	 ldr r2,.L385+40
 5536 015e 7B79     	 ldrb r3,[r7,#5]
 5537 0160 1370     	 strb r3,[r2]
 5538              	.L384:
2679:../SSC/Src/ecatslv.c ****             }
2680:../SSC/Src/ecatslv.c **** 
2681:../SSC/Src/ecatslv.c **** 
2682:../SSC/Src/ecatslv.c ****         /* Reload the AlEvent because it may be changed due to a SM disable, enable in case of an r
2683:../SSC/Src/ecatslv.c ****         ALEventReg = HW_GetALEventRegister();
 5539              	 .loc 3 2683 0
 5540 0162 FFF7FEFF 	 bl HW_GetALEventRegister
 5541 0166 0346     	 mov r3,r0
 5542 0168 FB80     	 strh r3,[r7,#6]
2684:../SSC/Src/ecatslv.c ****         ALEventReg = SWAPWORD(ALEventReg);
2685:../SSC/Src/ecatslv.c **** 
2686:../SSC/Src/ecatslv.c ****         if ( ALEventReg & (MAILBOX_WRITE_EVENT) )
 5543              	 .loc 3 2686 0
 5544 016a FB88     	 ldrh r3,[r7,#6]
 5545 016c 03F48073 	 and r3,r3,#256
 5546 0170 002B     	 cmp r3,#0
 5547 0172 05D0     	 beq .L373
2687:../SSC/Src/ecatslv.c ****         {
2688:../SSC/Src/ecatslv.c ****             /* SM 0 (Mailbox Write) event is set, when the mailbox was written from the master,
2689:../SSC/Src/ecatslv.c ****                to acknowledge the event the first byte of the mailbox has to be read,
2690:../SSC/Src/ecatslv.c ****                which will be done in MBX_CheckAndCopyMailbox */
2691:../SSC/Src/ecatslv.c ****             /* the Mailbox Write event in the variable ALEventReg shall be reset before calling
2692:../SSC/Src/ecatslv.c ****                MBX_CheckAndCopyMailbox, where the received mailbox datagram will be processed */
2693:../SSC/Src/ecatslv.c ****             ALEventReg &= ~(MAILBOX_WRITE_EVENT);
 5548              	 .loc 3 2693 0
 5549 0174 FB88     	 ldrh r3,[r7,#6]
 5550 0176 23F48073 	 bic r3,r3,#256
 5551 017a FB80     	 strh r3,[r7,#6]
2694:../SSC/Src/ecatslv.c ****             MBX_CheckAndCopyMailbox();
 5552              	 .loc 3 2694 0
 5553 017c FFF7FEFF 	 bl MBX_CheckAndCopyMailbox
 5554              	.L373:
2695:../SSC/Src/ecatslv.c **** 
2696:../SSC/Src/ecatslv.c ****         }
2697:../SSC/Src/ecatslv.c ****     }
2698:../SSC/Src/ecatslv.c **** }
 5555              	 .loc 3 2698 0
 5556 0180 0837     	 adds r7,r7,#8
 5557              	.LCFI111:
 5558              	 .cfi_def_cfa_offset 8
 5559 0182 BD46     	 mov sp,r7
 5560              	.LCFI112:
 5561              	 .cfi_def_cfa_register 13
 5562              	 
 5563 0184 80BD     	 pop {r7,pc}
 5564              	.L386:
 5565 0186 00BF     	 .align 2
 5566              	.L385:
 5567 0188 00000000 	 .word bMbxRunning
 5568 018c 0E080154 	 .word 1409353742
 5569 0190 0D080154 	 .word 1409353741
 5570 0194 00000000 	 .word bEcatWaitForAlControlRes
 5571 0198 20010154 	 .word 1409351968
 5572 019c 00000000 	 .word nAlStatus
 5573 01a0 00000000 	 .word bSendMbxIsFull
 5574 01a4 00000000 	 .word u8dummy
 5575 01a8 00000000 	 .word u16EscAddrSendMbx
 5576 01ac 00000000 	 .word bMbxRepeatToggle
 5577 01b0 0F080154 	 .word 1409353743
 5578              	 .cfi_endproc
 5579              	.LFE194:
 5581              	 .text
 5582              	.Letext0:
 5583              	 .file 4 "d:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 5584              	 .file 5 "d:\\infineon\\tools\\dave ide\\4.5.0.202105191637\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 5585              	 .file 6 "D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/CMSIS/Infineon/XMC4300_series/Include/XMC4300.h"
 5586              	 .file 7 "../SSC/Src/esc.h"
 5587              	 .file 8 "../SSC/Src/objdef.h"
 5588              	 .file 9 "D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/CMSIS/Include/cmsis_gcc.h"
 5589              	 .file 10 "D:/Infineon/Tools/DAVE IDE/4.5.0.202105191637/eclipse/workspace/LED_test/Libraries/CMSIS/Include/core_cm4.h"
 5590              	 .file 11 "../SSC/Src/ecatslv.h"
 5591              	 .file 12 "../SSC/Src/mailbox.h"
DEFINED SYMBOLS
                            *ABS*:00000000 ecatslv.c
    {standard input}:20     .text.XMC_ECAT_GetALEventRegister:00000000 $t
    {standard input}:24     .text.XMC_ECAT_GetALEventRegister:00000000 XMC_ECAT_GetALEventRegister
    {standard input}:57     .text.XMC_ECAT_GetALEventRegister:00000018 $d
    {standard input}:62     .text.HW_EscRead:00000000 $t
    {standard input}:66     .text.HW_EscRead:00000000 HW_EscRead
    {standard input}:110    .text.HW_GetALEventRegister:00000000 $t
    {standard input}:114    .text.HW_GetALEventRegister:00000000 HW_GetALEventRegister
                            *COM*:00000001 bEcatOutputUpdateRunning
                            *COM*:00000001 bEcatInputUpdateRunning
                            *COM*:00000001 bEcatFirstOutputsReceived
                            *COM*:00000001 bWdTrigger
                            *COM*:00000001 bDcSyncActive
                            *COM*:00000002 EsmTimeoutCounter
                            *COM*:00000001 bDcRunning
                            *COM*:00000002 u16SmSync0Counter
                            *COM*:00000002 u16SmSync0Value
                            *COM*:00000001 bSmSyncSequenceValid
                            *COM*:00000002 i16WaitForPllRunningTimeout
                            *COM*:00000002 i16WaitForPllRunningCnt
                            *COM*:00000002 Sync0WdCounter
                            *COM*:00000002 Sync0WdValue
                            *COM*:00000002 Sync1WdCounter
                            *COM*:00000002 Sync1WdValue
                            *COM*:00000002 LatchInputSync0Value
                            *COM*:00000002 LatchInputSync0Counter
                            *COM*:00000001 b32BitDc
                            *COM*:00000001 bEscIntEnabled
                            *COM*:00000001 b3BufferMode
                            *COM*:00000002 u16LocalErrorCode
                            *COM*:00000001 u8LocalErrorState
                            *COM*:00000001 bApplEsmPending
                            *COM*:00000001 bEcatWaitForAlControlRes
                            *COM*:00000002 nEcatStateTrans
                            *COM*:00000001 u8EcatErrorLed
                            *COM*:00000001 u8EcatRunLed
                            *COM*:00000002 nPdInputSize
                            *COM*:00000002 nPdOutputSize
                            *COM*:00000001 nMaxSyncMan
                            *COM*:00000002 nMaxEscAddress
                            *COM*:00000001 nAlStatus
                            *COM*:00000002 EcatWdValue
                            *COM*:00000002 nEscAddrOutputData
                            *COM*:00000002 nEscAddrInputData
                            *COM*:00000002 u16ALEventMask
                            *COM*:00000001 u8dummy
    {standard input}:179    .bss.SMActivate:00000000 SMActivate
    {standard input}:180    .bss.SMActivate:00000000 $d
                            *COM*:00000008 SyncManInfo
    {standard input}:186    .bss.EepromLoaded:00000000 EepromLoaded
    {standard input}:187    .bss.EepromLoaded:00000000 $d
    {standard input}:189    .text.ResetALEventMask:00000000 $t
    {standard input}:194    .text.ResetALEventMask:00000000 ResetALEventMask
    {standard input}:243    .text.ResetALEventMask:0000002c $d
    {standard input}:248    .text.SetALEventMask:00000000 $t
    {standard input}:253    .text.SetALEventMask:00000000 SetALEventMask
    {standard input}:301    .text.SetALEventMask:0000002c $d
    {standard input}:306    .text.UpdateEEPROMLoadedState:00000000 $t
    {standard input}:311    .text.UpdateEEPROMLoadedState:00000000 UpdateEEPROMLoadedState
    {standard input}:373    .text.UpdateEEPROMLoadedState:0000003c $d
    {standard input}:379    .text.GetSyncMan:00000000 $t
    {standard input}:384    .text.GetSyncMan:00000000 GetSyncMan
    {standard input}:428    .text.GetSyncMan:0000002c $d
    {standard input}:433    .text.DisableSyncManChannel:00000000 $t
    {standard input}:438    .text.DisableSyncManChannel:00000000 DisableSyncManChannel
    {standard input}:505    .text.EnableSyncManChannel:00000000 $t
    {standard input}:510    .text.EnableSyncManChannel:00000000 EnableSyncManChannel
    {standard input}:577    .text.CheckSmSettings:00000000 $t
    {standard input}:582    .text.CheckSmSettings:00000000 CheckSmSettings
    {standard input}:1011   .text.CheckSmSettings:00000294 $d
    {standard input}:1018   .text.CheckSmSettings:000002a8 $t
    {standard input}:1194   .text.CheckSmSettings:000003a0 $d
    {standard input}:1205   .text.StartInputHandler:00000000 $t
    {standard input}:1210   .text.StartInputHandler:00000000 StartInputHandler
    {standard input}:1637   .text.StartInputHandler:000002ac $d
    {standard input}:1657   .text.StartInputHandler:000002f4 $t
    {standard input}:2095   .text.StartInputHandler:00000588 $d
    {standard input}:2114   .text.StartInputHandler:000005cc $t
    {standard input}:2406   .text.StartInputHandler:0000078c $d
    {standard input}:2428   .text.StartOutputHandler:00000000 $t
    {standard input}:2433   .text.StartOutputHandler:00000000 StartOutputHandler
    {standard input}:2533   .text.StartOutputHandler:00000080 $d
    {standard input}:2544   .text.StopOutputHandler:00000000 $t
    {standard input}:2549   .text.StopOutputHandler:00000000 StopOutputHandler
    {standard input}:2584   .text.StopOutputHandler:00000018 $d
    {standard input}:2590   .text.StopInputHandler:00000000 $t
    {standard input}:2595   .text.StopInputHandler:00000000 StopInputHandler
    {standard input}:2753   .text.StopInputHandler:000000d8 $d
    {standard input}:2778   .text.BackToInitTransition:00000000 $t
    {standard input}:2783   .text.BackToInitTransition:00000000 BackToInitTransition
    {standard input}:2814   .text.BackToInitTransition:00000014 $d
    {standard input}:2819   .text.SetALStatus:00000000 $t
    {standard input}:2824   .text.SetALStatus:00000000 SetALStatus
    {standard input}:2961   .text.SetALStatus:000000b0 $d
    {standard input}:2971   .text.AL_ControlInd:00000000 $t
    {standard input}:2976   .text.AL_ControlInd:00000000 AL_ControlInd
    {standard input}:3150   .text.AL_ControlInd:00000110 $d
    {standard input}:3270   .text.AL_ControlInd:000002f0 $t
    {standard input}:3353   .text.AL_ControlInd:00000368 $d
    {standard input}:3363   .text.AL_ControlInd:0000038c $t
    {standard input}:3814   .text.AL_ControlInd:00000640 $d
    {standard input}:3827   .text.AL_ControlInd:0000066c $t
    {standard input}:3911   .text.AL_ControlInd:000006e4 $d
    {standard input}:3918   .text.AL_ControlRes:00000000 $t
    {standard input}:3923   .text.AL_ControlRes:00000000 AL_ControlRes
    {standard input}:4367   .text.AL_ControlRes:0000029c $d
    {standard input}:4386   .text.AL_ControlRes:000002e0 $t
    {standard input}:4425   .text.AL_ControlRes:00000310 $d
    {standard input}:4430   .text.DC_CheckWatchdog:00000000 $t
    {standard input}:4435   .text.DC_CheckWatchdog:00000000 DC_CheckWatchdog
    {standard input}:4617   .text.DC_CheckWatchdog:000000f8 $d
    {standard input}:4633   .text.CheckIfEcatError:00000000 $t
    {standard input}:4638   .text.CheckIfEcatError:00000000 CheckIfEcatError
    {standard input}:4746   .text.CheckIfEcatError:00000088 $d
    {standard input}:4758   .text.ECAT_StateChange:00000000 $t
    {standard input}:4763   .text.ECAT_StateChange:00000000 ECAT_StateChange
    {standard input}:5105   .text.ECAT_StateChange:00000204 $d
    {standard input}:5120   .text.ECAT_Init:00000000 $t
    {standard input}:5125   .text.ECAT_Init:00000000 ECAT_Init
    {standard input}:5294   .text.ECAT_Init:000000ec $d
    {standard input}:5323   .text.ECAT_Main:00000000 $t
    {standard input}:5328   .text.ECAT_Main:00000000 ECAT_Main
    {standard input}:5567   .text.ECAT_Main:00000188 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
memcpy
DISABLE_ESC_INT
ENABLE_ESC_INT
sSyncManOutPar
sSyncManInPar
u16EscAddrSendMbx
u16SendMbxSize
u16EscAddrReceiveMbx
u16ReceiveMbxSize
bSyncSetByUser
sCycleDiag
PDO_InputMapping
APPL_GenerateMapping
MBX_StartMailboxHandler
APPL_StartMailboxHandler
APPL_StopMailboxHandler
MBX_StopMailboxHandler
bMbxRunning
APPL_StartInputHandler
APPL_StopInputHandler
APPL_StartOutputHandler
APPL_StopOutputHandler
APPL_AckErrorInd
sErrorSettings
MBX_Init
COE_Init
MBX_Main
EEPROM_CommandHandler
MBX_MailboxReadInd
MBX_MailboxRepeatReq
MBX_CheckAndCopyMailbox
bSendMbxIsFull
bMbxRepeatToggle
