
LED_test.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00000300  08000000  0c000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00005c70  08020000  0c020000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 Stack         00000800  1fff0000  1fff0000  00020000  2**0
                  ALLOC
  3 .data         00000fe0  1fff0800  0c025c70  00018800  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          00001390  1fff17e0  0c026c50  000197e0  2**3
                  ALLOC
  5 .no_init      00000014  2000ffc0  2000ffc0  0001ffc0  2**2
                  ALLOC
  6 .debug_aranges 00001550  00000000  00000000  000197e0  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000257b0  00000000  00000000  0001ad30  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000530e  00000000  00000000  000404e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000be64  00000000  00000000  000457ee  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00005718  00000000  00000000  00051654  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000d718  00000000  00000000  00056d6c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000b1f5  00000000  00000000  00064484  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00001290  00000000  00000000  0006f679  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .build_attributes 000009c1  00000000  00000000  00070909  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

08020000 <SystemInit>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

__WEAK void SystemInit(void)
{
 8020000:	b598      	push	{r3, r4, r7, lr}
 8020002:	af00      	add	r7, sp, #0
  memcpy(g_chipid, CHIPID_LOC, 16);
 8020004:	4a05      	ldr	r2, [pc, #20]	; (802001c <SystemInit+0x1c>)
 8020006:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
 802000a:	4614      	mov	r4, r2
 802000c:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 802000e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

  SystemCoreSetup();
 8020012:	f004 fe15 	bl	8024c40 <SystemCoreSetup>
  SystemCoreClockSetup();
 8020016:	f004 fe91 	bl	8024d3c <SystemCoreClockSetup>
}
 802001a:	bd98      	pop	{r3, r4, r7, pc}
 802001c:	2000ffc4 	.word	0x2000ffc4

08020020 <SystemCoreClockUpdate>:

  SystemCoreClockUpdate();
}

__WEAK void SystemCoreClockUpdate(void)
{
 8020020:	b580      	push	{r7, lr}
 8020022:	b084      	sub	sp, #16
 8020024:	af00      	add	r7, sp, #0
  uint32_t pdiv;
  uint32_t ndiv;
  uint32_t kdiv;
  uint32_t temp;

  if (SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSSEL_Msk)
 8020026:	4b2f      	ldr	r3, [pc, #188]	; (80200e4 <SystemCoreClockUpdate+0xc4>)
 8020028:	68db      	ldr	r3, [r3, #12]
 802002a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 802002e:	2b00      	cmp	r3, #0
 8020030:	d03e      	beq.n	80200b0 <SystemCoreClockUpdate+0x90>
  {
    /* fPLL is clock source for fSYS */
    if(SCU_PLL->PLLCON2 & SCU_PLL_PLLCON2_PINSEL_Msk)
 8020032:	4b2d      	ldr	r3, [pc, #180]	; (80200e8 <SystemCoreClockUpdate+0xc8>)
 8020034:	68db      	ldr	r3, [r3, #12]
 8020036:	f003 0301 	and.w	r3, r3, #1
 802003a:	2b00      	cmp	r3, #0
 802003c:	d002      	beq.n	8020044 <SystemCoreClockUpdate+0x24>
    {
      /* PLL input clock is the backup clock (fOFI) */
      temp = OFI_FREQUENCY;
 802003e:	4b2b      	ldr	r3, [pc, #172]	; (80200ec <SystemCoreClockUpdate+0xcc>)
 8020040:	60fb      	str	r3, [r7, #12]
 8020042:	e002      	b.n	802004a <SystemCoreClockUpdate+0x2a>
    }
    else
    {
      /* PLL input clock is the high performance osicllator (fOSCHP) */
      temp = OSCHP_GetFrequency();
 8020044:	f004 fe5c 	bl	8024d00 <OSCHP_GetFrequency>
 8020048:	60f8      	str	r0, [r7, #12]
    }

    /* check if PLL is locked */
    if (SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk)
 802004a:	4b27      	ldr	r3, [pc, #156]	; (80200e8 <SystemCoreClockUpdate+0xc8>)
 802004c:	681b      	ldr	r3, [r3, #0]
 802004e:	f003 0304 	and.w	r3, r3, #4
 8020052:	2b00      	cmp	r3, #0
 8020054:	d020      	beq.n	8020098 <SystemCoreClockUpdate+0x78>
    {
      /* PLL normal mode */
      /* read back divider settings */
      pdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_PDIV_Msk) >> SCU_PLL_PLLCON1_PDIV_Pos) + 1;
 8020056:	4b24      	ldr	r3, [pc, #144]	; (80200e8 <SystemCoreClockUpdate+0xc8>)
 8020058:	689b      	ldr	r3, [r3, #8]
 802005a:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
 802005e:	0e1b      	lsrs	r3, r3, #24
 8020060:	3301      	adds	r3, #1
 8020062:	60bb      	str	r3, [r7, #8]
      ndiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_NDIV_Msk) >> SCU_PLL_PLLCON1_NDIV_Pos) + 1;
 8020064:	4b20      	ldr	r3, [pc, #128]	; (80200e8 <SystemCoreClockUpdate+0xc8>)
 8020066:	689b      	ldr	r3, [r3, #8]
 8020068:	f403 43fe 	and.w	r3, r3, #32512	; 0x7f00
 802006c:	0a1b      	lsrs	r3, r3, #8
 802006e:	3301      	adds	r3, #1
 8020070:	607b      	str	r3, [r7, #4]
      kdiv = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_K2DIV_Msk) >> SCU_PLL_PLLCON1_K2DIV_Pos) + 1;
 8020072:	4b1d      	ldr	r3, [pc, #116]	; (80200e8 <SystemCoreClockUpdate+0xc8>)
 8020074:	689b      	ldr	r3, [r3, #8]
 8020076:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
 802007a:	0c1b      	lsrs	r3, r3, #16
 802007c:	3301      	adds	r3, #1
 802007e:	603b      	str	r3, [r7, #0]

      temp = (temp / (pdiv * kdiv)) * ndiv;
 8020080:	68bb      	ldr	r3, [r7, #8]
 8020082:	683a      	ldr	r2, [r7, #0]
 8020084:	fb02 f303 	mul.w	r3, r2, r3
 8020088:	68fa      	ldr	r2, [r7, #12]
 802008a:	fbb2 f3f3 	udiv	r3, r2, r3
 802008e:	687a      	ldr	r2, [r7, #4]
 8020090:	fb02 f303 	mul.w	r3, r2, r3
 8020094:	60fb      	str	r3, [r7, #12]
 8020096:	e00d      	b.n	80200b4 <SystemCoreClockUpdate+0x94>
    }
    else
    {
      /* PLL prescalar mode */
      /* read back divider settings */
      kdiv  = ((SCU_PLL->PLLCON1 & SCU_PLL_PLLCON1_K1DIV_Msk) >> SCU_PLL_PLLCON1_K1DIV_Pos) + 1;
 8020098:	4b13      	ldr	r3, [pc, #76]	; (80200e8 <SystemCoreClockUpdate+0xc8>)
 802009a:	689b      	ldr	r3, [r3, #8]
 802009c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80200a0:	3301      	adds	r3, #1
 80200a2:	603b      	str	r3, [r7, #0]

      temp = (temp / kdiv);
 80200a4:	68fa      	ldr	r2, [r7, #12]
 80200a6:	683b      	ldr	r3, [r7, #0]
 80200a8:	fbb2 f3f3 	udiv	r3, r2, r3
 80200ac:	60fb      	str	r3, [r7, #12]
 80200ae:	e001      	b.n	80200b4 <SystemCoreClockUpdate+0x94>
    }
  }
  else
  {
    /* fOFI is clock source for fSYS */
    temp = OFI_FREQUENCY;
 80200b0:	4b0e      	ldr	r3, [pc, #56]	; (80200ec <SystemCoreClockUpdate+0xcc>)
 80200b2:	60fb      	str	r3, [r7, #12]
  }

  temp = temp / ((SCU_CLK->SYSCLKCR & SCU_CLK_SYSCLKCR_SYSDIV_Msk) + 1);
 80200b4:	4b0b      	ldr	r3, [pc, #44]	; (80200e4 <SystemCoreClockUpdate+0xc4>)
 80200b6:	68db      	ldr	r3, [r3, #12]
 80200b8:	b2db      	uxtb	r3, r3
 80200ba:	3301      	adds	r3, #1
 80200bc:	68fa      	ldr	r2, [r7, #12]
 80200be:	fbb2 f3f3 	udiv	r3, r2, r3
 80200c2:	60fb      	str	r3, [r7, #12]
  temp = temp / ((SCU_CLK->CPUCLKCR & SCU_CLK_CPUCLKCR_CPUDIV_Msk) + 1);
 80200c4:	4b07      	ldr	r3, [pc, #28]	; (80200e4 <SystemCoreClockUpdate+0xc4>)
 80200c6:	691b      	ldr	r3, [r3, #16]
 80200c8:	f003 0301 	and.w	r3, r3, #1
 80200cc:	3301      	adds	r3, #1
 80200ce:	68fa      	ldr	r2, [r7, #12]
 80200d0:	fbb2 f3f3 	udiv	r3, r2, r3
 80200d4:	60fb      	str	r3, [r7, #12]

  SystemCoreClock = temp;
 80200d6:	4a06      	ldr	r2, [pc, #24]	; (80200f0 <SystemCoreClockUpdate+0xd0>)
 80200d8:	68fb      	ldr	r3, [r7, #12]
 80200da:	6013      	str	r3, [r2, #0]
}
 80200dc:	3710      	adds	r7, #16
 80200de:	46bd      	mov	sp, r7
 80200e0:	bd80      	pop	{r7, pc}
 80200e2:	bf00      	nop
 80200e4:	50004600 	.word	0x50004600
 80200e8:	50004710 	.word	0x50004710
 80200ec:	016e3600 	.word	0x016e3600
 80200f0:	2000ffc0 	.word	0x2000ffc0

080200f4 <HW_EscRead>:
 * \par<b>Description:</b><br>
 * Reads from the EtherCAT Slave Controller. This function is used to access ESC registers and the DPRAM area.
 *
 */
__STATIC_INLINE void HW_EscRead(MEM_ADDR *pData, UINT16 Address, UINT16 Len)
{
 80200f4:	b580      	push	{r7, lr}
 80200f6:	b082      	sub	sp, #8
 80200f8:	af00      	add	r7, sp, #0
 80200fa:	6078      	str	r0, [r7, #4]
 80200fc:	460b      	mov	r3, r1
 80200fe:	807b      	strh	r3, [r7, #2]
 8020100:	4613      	mov	r3, r2
 8020102:	803b      	strh	r3, [r7, #0]
  memcpy(pData, &pEsc[Address], Len);
 8020104:	887b      	ldrh	r3, [r7, #2]
 8020106:	f103 43a8 	add.w	r3, r3, #1409286144	; 0x54000000
 802010a:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 802010e:	883a      	ldrh	r2, [r7, #0]
 8020110:	6878      	ldr	r0, [r7, #4]
 8020112:	4619      	mov	r1, r3
 8020114:	f005 f812 	bl	802513c <memcpy>
}
 8020118:	3708      	adds	r7, #8
 802011a:	46bd      	mov	sp, r7
 802011c:	bd80      	pop	{r7, pc}
 802011e:	bf00      	nop

08020120 <Read0x10F8>:
sdosrv.h))

\brief    This function reads the object 0x10F8
*/
UINT8 Read0x10F8(UINT16 index, UINT8 subindex, UINT32 dataSize, UINT16 MBXMEM * pData, UINT8 bCompleteAccess)
{
 8020120:	b580      	push	{r7, lr}
 8020122:	b084      	sub	sp, #16
 8020124:	af00      	add	r7, sp, #0
 8020126:	60ba      	str	r2, [r7, #8]
 8020128:	607b      	str	r3, [r7, #4]
 802012a:	4603      	mov	r3, r0
 802012c:	81fb      	strh	r3, [r7, #14]
 802012e:	460b      	mov	r3, r1
 8020130:	737b      	strb	r3, [r7, #13]

    if (index != 0x10F8)
 8020132:	89fb      	ldrh	r3, [r7, #14]
 8020134:	f241 02f8 	movw	r2, #4344	; 0x10f8
 8020138:	4293      	cmp	r3, r2
 802013a:	d001      	beq.n	8020140 <Read0x10F8+0x20>
    {
        return ABORTIDX_PARAM_IS_INCOMPATIBLE;
 802013c:	230b      	movs	r3, #11
 802013e:	e016      	b.n	802016e <Read0x10F8+0x4e>
    }

    
    if (bCompleteAccess)
 8020140:	7e3b      	ldrb	r3, [r7, #24]
 8020142:	2b00      	cmp	r3, #0
 8020144:	d001      	beq.n	802014a <Read0x10F8+0x2a>
    {
         /* Complete Access is not supported for object 0x10F8 */
        return ABORTIDX_UNSUPPORTED_ACCESS;
 8020146:	2305      	movs	r3, #5
 8020148:	e011      	b.n	802016e <Read0x10F8+0x4e>
    }

    if (subindex > 0)
 802014a:	7b7b      	ldrb	r3, [r7, #13]
 802014c:	2b00      	cmp	r3, #0
 802014e:	d001      	beq.n	8020154 <Read0x10F8+0x34>
    {
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
 8020150:	2311      	movs	r3, #17
 8020152:	e00c      	b.n	802016e <Read0x10F8+0x4e>
    }

    if (dataSize > 8)
 8020154:	68bb      	ldr	r3, [r7, #8]
 8020156:	2b08      	cmp	r3, #8
 8020158:	d901      	bls.n	802015e <Read0x10F8+0x3e>
    {
        return ABORTIDX_PARAM_LENGTH_TOO_LONG;
 802015a:	230f      	movs	r3, #15
 802015c:	e007      	b.n	802016e <Read0x10F8+0x4e>
    }


    COE_SyncTimeStamp();
 802015e:	f000 f80d 	bl	802017c <COE_SyncTimeStamp>

    MEMCPY(pData, &u64Timestamp, dataSize);
 8020162:	6878      	ldr	r0, [r7, #4]
 8020164:	4904      	ldr	r1, [pc, #16]	; (8020178 <Read0x10F8+0x58>)
 8020166:	68ba      	ldr	r2, [r7, #8]
 8020168:	f004 ffe8 	bl	802513c <memcpy>
    return 0;
 802016c:	2300      	movs	r3, #0
}
 802016e:	4618      	mov	r0, r3
 8020170:	3710      	adds	r7, #16
 8020172:	46bd      	mov	sp, r7
 8020174:	bd80      	pop	{r7, pc}
 8020176:	bf00      	nop
 8020178:	1fff17e0 	.word	0x1fff17e0

0802017c <COE_SyncTimeStamp>:
/**
\brief    This function updates the local time stamp object (0x10F8) and has to be called at least every 4.2sec to detect an 32Bit DC unit overrun.
          Called from the Timer handler 
*////////////////////////////////////////////////////////////////////////////////////////
void COE_SyncTimeStamp(void)
{
 802017c:	b580      	push	{r7, lr}
 802017e:	b082      	sub	sp, #8
 8020180:	af00      	add	r7, sp, #0

    if (b32BitDc)
 8020182:	4b20      	ldr	r3, [pc, #128]	; (8020204 <COE_SyncTimeStamp+0x88>)
 8020184:	781b      	ldrb	r3, [r3, #0]
 8020186:	2b00      	cmp	r3, #0
 8020188:	d02f      	beq.n	80201ea <COE_SyncTimeStamp+0x6e>
    {
        UINT32 DcTime = (UINT32)(u64Timestamp & (UINT64)0x00000000FFFFFFFF);
 802018a:	4b1f      	ldr	r3, [pc, #124]	; (8020208 <COE_SyncTimeStamp+0x8c>)
 802018c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8020190:	4613      	mov	r3, r2
 8020192:	607b      	str	r3, [r7, #4]


        HW_EscReadDWord(DcTime, ESC_SYSTEMTIME_OFFSET);
 8020194:	4b1d      	ldr	r3, [pc, #116]	; (802020c <COE_SyncTimeStamp+0x90>)
 8020196:	681b      	ldr	r3, [r3, #0]
 8020198:	607b      	str	r3, [r7, #4]

        /*update the lower 32Bit*/
        u64Timestamp = ((u64Timestamp & ((UINT64)0xFFFFFFFF00000000)) | (UINT64)DcTime);
 802019a:	4b1b      	ldr	r3, [pc, #108]	; (8020208 <COE_SyncTimeStamp+0x8c>)
 802019c:	e9d3 2300 	ldrd	r2, r3, [r3]
 80201a0:	f04f 0000 	mov.w	r0, #0
 80201a4:	f04f 31ff 	mov.w	r1, #4294967295
 80201a8:	ea00 0002 	and.w	r0, r0, r2
 80201ac:	ea01 0103 	and.w	r1, r1, r3
 80201b0:	687b      	ldr	r3, [r7, #4]
 80201b2:	461a      	mov	r2, r3
 80201b4:	f04f 0300 	mov.w	r3, #0
 80201b8:	ea42 0200 	orr.w	r2, r2, r0
 80201bc:	ea43 0301 	orr.w	r3, r3, r1
 80201c0:	4911      	ldr	r1, [pc, #68]	; (8020208 <COE_SyncTimeStamp+0x8c>)
 80201c2:	e9c1 2300 	strd	r2, r3, [r1]

        if (DcTime < u32LastDc32Value)
 80201c6:	4b12      	ldr	r3, [pc, #72]	; (8020210 <COE_SyncTimeStamp+0x94>)
 80201c8:	681b      	ldr	r3, [r3, #0]
 80201ca:	687a      	ldr	r2, [r7, #4]
 80201cc:	429a      	cmp	r2, r3
 80201ce:	d208      	bcs.n	80201e2 <COE_SyncTimeStamp+0x66>
        {
            /*32Bit overrun*/
            u64Timestamp = u64Timestamp + ((UINT64)0x0000000100000000);
 80201d0:	4b0d      	ldr	r3, [pc, #52]	; (8020208 <COE_SyncTimeStamp+0x8c>)
 80201d2:	e9d3 2300 	ldrd	r2, r3, [r3]
 80201d6:	3200      	adds	r2, #0
 80201d8:	f143 0301 	adc.w	r3, r3, #1
 80201dc:	490a      	ldr	r1, [pc, #40]	; (8020208 <COE_SyncTimeStamp+0x8c>)
 80201de:	e9c1 2300 	strd	r2, r3, [r1]
        }
        
        u32LastDc32Value = DcTime;
 80201e2:	4a0b      	ldr	r2, [pc, #44]	; (8020210 <COE_SyncTimeStamp+0x94>)
 80201e4:	687b      	ldr	r3, [r7, #4]
 80201e6:	6013      	str	r3, [r2, #0]
 80201e8:	e005      	b.n	80201f6 <COE_SyncTimeStamp+0x7a>
    }
    else
    {
        /*The DC unit supports 64Bit => update the complete object*/
        
        HW_EscRead((MEM_ADDR *)&u64Timestamp, ESC_SYSTEMTIME_OFFSET, 8);
 80201ea:	4807      	ldr	r0, [pc, #28]	; (8020208 <COE_SyncTimeStamp+0x8c>)
 80201ec:	f44f 6111 	mov.w	r1, #2320	; 0x910
 80201f0:	2208      	movs	r2, #8
 80201f2:	f7ff ff7f 	bl	80200f4 <HW_EscRead>
    }

    u32CheckForDcOverrunCnt = 0;
 80201f6:	4b07      	ldr	r3, [pc, #28]	; (8020214 <COE_SyncTimeStamp+0x98>)
 80201f8:	2200      	movs	r2, #0
 80201fa:	601a      	str	r2, [r3, #0]

}
 80201fc:	3708      	adds	r7, #8
 80201fe:	46bd      	mov	sp, r7
 8020200:	bd80      	pop	{r7, pc}
 8020202:	bf00      	nop
 8020204:	1fff29dc 	.word	0x1fff29dc
 8020208:	1fff17e0 	.word	0x1fff17e0
 802020c:	54010910 	.word	0x54010910
 8020210:	1fff2820 	.word	0x1fff2820
 8020214:	1fff2824 	.word	0x1fff2824

08020218 <COE_UpdateSyncErrorStatus>:
/////////////////////////////////////////////////////////////////////////////////////////
/**
\brief     Update the Sync Error Indication
*////////////////////////////////////////////////////////////////////////////////////////
void COE_UpdateSyncErrorStatus(void)
{
 8020218:	b480      	push	{r7}
 802021a:	af00      	add	r7, sp, #0
    if (sSyncManOutPar.u16CycleExceededCounter > 0 || sSyncManOutPar.u16SmEventMissedCounter > sErrorSettings.u16SyncErrorCounterLimit)
 802021c:	4b14      	ldr	r3, [pc, #80]	; (8020270 <COE_UpdateSyncErrorStatus+0x58>)
 802021e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8020220:	2b00      	cmp	r3, #0
 8020222:	d105      	bne.n	8020230 <COE_UpdateSyncErrorStatus+0x18>
 8020224:	4b12      	ldr	r3, [pc, #72]	; (8020270 <COE_UpdateSyncErrorStatus+0x58>)
 8020226:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 8020228:	4b12      	ldr	r3, [pc, #72]	; (8020274 <COE_UpdateSyncErrorStatus+0x5c>)
 802022a:	891b      	ldrh	r3, [r3, #8]
 802022c:	429a      	cmp	r2, r3
 802022e:	d904      	bls.n	802023a <COE_UpdateSyncErrorStatus+0x22>
    {
        sSyncManOutPar.u8SyncError = 1;
 8020230:	4b0f      	ldr	r3, [pc, #60]	; (8020270 <COE_UpdateSyncErrorStatus+0x58>)
 8020232:	2201      	movs	r2, #1
 8020234:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
 8020238:	e003      	b.n	8020242 <COE_UpdateSyncErrorStatus+0x2a>
    }
    else
    {
        sSyncManOutPar.u8SyncError = 0;
 802023a:	4b0d      	ldr	r3, [pc, #52]	; (8020270 <COE_UpdateSyncErrorStatus+0x58>)
 802023c:	2200      	movs	r2, #0
 802023e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    }


    if (sSyncManInPar.u16CycleExceededCounter > 0 || sSyncManInPar.u16SmEventMissedCounter > sErrorSettings.u16SyncErrorCounterLimit)
 8020242:	4b0d      	ldr	r3, [pc, #52]	; (8020278 <COE_UpdateSyncErrorStatus+0x60>)
 8020244:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8020246:	2b00      	cmp	r3, #0
 8020248:	d105      	bne.n	8020256 <COE_UpdateSyncErrorStatus+0x3e>
 802024a:	4b0b      	ldr	r3, [pc, #44]	; (8020278 <COE_UpdateSyncErrorStatus+0x60>)
 802024c:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 802024e:	4b09      	ldr	r3, [pc, #36]	; (8020274 <COE_UpdateSyncErrorStatus+0x5c>)
 8020250:	891b      	ldrh	r3, [r3, #8]
 8020252:	429a      	cmp	r2, r3
 8020254:	d904      	bls.n	8020260 <COE_UpdateSyncErrorStatus+0x48>
    {
        sSyncManInPar.u8SyncError = 1;
 8020256:	4b08      	ldr	r3, [pc, #32]	; (8020278 <COE_UpdateSyncErrorStatus+0x60>)
 8020258:	2201      	movs	r2, #1
 802025a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
 802025e:	e003      	b.n	8020268 <COE_UpdateSyncErrorStatus+0x50>
    }
    else
    {
        sSyncManInPar.u8SyncError = 0;
 8020260:	4b05      	ldr	r3, [pc, #20]	; (8020278 <COE_UpdateSyncErrorStatus+0x60>)
 8020262:	2200      	movs	r2, #0
 8020264:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    }

}
 8020268:	46bd      	mov	sp, r7
 802026a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802026e:	4770      	bx	lr
 8020270:	1fff2ad4 	.word	0x1fff2ad4
 8020274:	1fff13cc 	.word	0x1fff13cc
 8020278:	1fff2a90 	.word	0x1fff2a90

0802027c <COE_ObjInit>:
/**
 \brief     This function initialize the several objects
*////////////////////////////////////////////////////////////////////////////////////////

void COE_ObjInit(void)
{
 802027c:	b580      	push	{r7, lr}
 802027e:	b082      	sub	sp, #8
 8020280:	af00      	add	r7, sp, #0

    /* initialize the Sync Manager Output parameter object 0x1C32 */

    sSyncManOutPar.subindex0         = 32;
 8020282:	4b43      	ldr	r3, [pc, #268]	; (8020390 <COE_ObjInit+0x114>)
 8020284:	2220      	movs	r2, #32
 8020286:	801a      	strh	r2, [r3, #0]
      from the master to switch between ECAT FreeRun and ECAT Synchron Mode
        if the slave supports both modes,
        in DC mode (selected by the DC registers) this value will be overwritten
        with SYNCTYPE_DCSYNC0 or SYNCTYPE_DCSYNC1 */
     /*default mode is ECAT Synchron Mode */
    sSyncManOutPar.u16SyncType     = SYNCTYPE_FREERUN;
 8020288:	4b41      	ldr	r3, [pc, #260]	; (8020390 <COE_ObjInit+0x114>)
 802028a:	2200      	movs	r2, #0
 802028c:	805a      	strh	r2, [r3, #2]
    /* subindex 2 contains the cycle time of the application,
       in ECAT FreeRun mode it could be used for a timer interrupt to run the application,
        in ECAT Synchron mode it could be written from the master with its local cycle time
        that the slave can check if this cycle time is supported,
        in DC Mode this value will be overwritten with the DC cycle time register */
    sSyncManOutPar.u32CycleTime     = 0;
 802028e:	4b40      	ldr	r3, [pc, #256]	; (8020390 <COE_ObjInit+0x114>)
 8020290:	2200      	movs	r2, #0
 8020292:	605a      	str	r2, [r3, #4]

    /* the subindex 4 contains the supported synchronization types */

    sSyncManOutPar.u16SyncTypesSupported    = SYNCTYPE_FREERUNSUPP            /* ECAT FreeRun Mode is supported */
 8020294:	4b3e      	ldr	r3, [pc, #248]	; (8020390 <COE_ObjInit+0x114>)
 8020296:	f244 021f 	movw	r2, #16415	; 0x401f
 802029a:	819a      	strh	r2, [r3, #12]

    /* subindex 5 contains the minimum cycle time the slave is able to support,
       will be calculated dynamically because it depends on the connected modules
        (in this example we will make an online measurement in the ESC Interrupt Routine).
        For the sample application this value is set to MIN_PD_CYCLE_TIME */
    sSyncManOutPar.u32MinCycleTime = MIN_PD_CYCLE_TIME;
 802029c:	4b3c      	ldr	r3, [pc, #240]	; (8020390 <COE_ObjInit+0x114>)
 802029e:	4a3d      	ldr	r2, [pc, #244]	; (8020394 <COE_ObjInit+0x118>)
 80202a0:	611a      	str	r2, [r3, #16]
    /* only for DC Mode important: subindex 6 contains the minimum delay time the slave
       needs after receiving the SM2-event before the SYNC0(SYNC1) can be received without delays
       will be calculated dynamically because it depends on the connected modules
        (in this example we will make an online measurement in the ESC Interrupt Routine) */
    sSyncManOutPar.u32CalcAndCopyTime = (PD_OUTPUT_CALC_AND_COPY_TIME);
 80202a2:	4b3b      	ldr	r3, [pc, #236]	; (8020390 <COE_ObjInit+0x114>)
 80202a4:	2200      	movs	r2, #0
 80202a6:	615a      	str	r2, [r3, #20]

    /*subindex 8: trigger cycle time measurement*/
    sSyncManOutPar.u16GetCycleTime = 0;
 80202a8:	4b39      	ldr	r3, [pc, #228]	; (8020390 <COE_ObjInit+0x114>)
 80202aa:	2200      	movs	r2, #0
 80202ac:	839a      	strh	r2, [r3, #28]

    /*subindex 9: time from start driving outputs until outputs are valid*/
    sSyncManOutPar.u32DelayTime = (PD_OUTPUT_DELAY_TIME);
 80202ae:	4b38      	ldr	r3, [pc, #224]	; (8020390 <COE_ObjInit+0x114>)
 80202b0:	2200      	movs	r2, #0
 80202b2:	621a      	str	r2, [r3, #32]

    /*subindex 11: reset the sm missed error counter*/
    sSyncManOutPar.u16SmEventMissedCounter = 0;
 80202b4:	4b36      	ldr	r3, [pc, #216]	; (8020390 <COE_ObjInit+0x114>)
 80202b6:	2200      	movs	r2, #0
 80202b8:	851a      	strh	r2, [r3, #40]	; 0x28

    /*subindex 12: reset the cycle exceed error counter*/
    sSyncManOutPar.u16CycleExceededCounter = 0;
 80202ba:	4b35      	ldr	r3, [pc, #212]	; (8020390 <COE_ObjInit+0x114>)
 80202bc:	2200      	movs	r2, #0
 80202be:	855a      	strh	r2, [r3, #42]	; 0x2a

    /*subindex 32: indicates if a synchronisation error has occurred*/
    sSyncManOutPar.u8SyncError = 0;
 80202c0:	4b33      	ldr	r3, [pc, #204]	; (8020390 <COE_ObjInit+0x114>)
 80202c2:	2200      	movs	r2, #0
 80202c4:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* initialize the Sync Manager Input parameter object 0x1C33 */
    sSyncManInPar.subindex0         = 32;
 80202c8:	4b33      	ldr	r3, [pc, #204]	; (8020398 <COE_ObjInit+0x11c>)
 80202ca:	2220      	movs	r2, #32
 80202cc:	801a      	strh	r2, [r3, #0]
    /* default mode is ECAT Synchron Mode, if output size > 0 the inputs are updated with the SM2-event */
    sSyncManInPar.u16SyncType         = SYNCTYPE_FREERUN;
 80202ce:	4b32      	ldr	r3, [pc, #200]	; (8020398 <COE_ObjInit+0x11c>)
 80202d0:	2200      	movs	r2, #0
 80202d2:	805a      	strh	r2, [r3, #2]

    
    /* subindex 2: same as 0x1C32:02 */
    sSyncManInPar.u32CycleTime     = sSyncManOutPar.u32CycleTime;
 80202d4:	4b2e      	ldr	r3, [pc, #184]	; (8020390 <COE_ObjInit+0x114>)
 80202d6:	685b      	ldr	r3, [r3, #4]
 80202d8:	4a2f      	ldr	r2, [pc, #188]	; (8020398 <COE_ObjInit+0x11c>)
 80202da:	6053      	str	r3, [r2, #4]

    /* subindex 4: same as 0x1C32:04 */
    sSyncManInPar.u16SyncTypesSupported    = sSyncManOutPar.u16SyncTypesSupported;
 80202dc:	4b2c      	ldr	r3, [pc, #176]	; (8020390 <COE_ObjInit+0x114>)
 80202de:	899a      	ldrh	r2, [r3, #12]
 80202e0:	4b2d      	ldr	r3, [pc, #180]	; (8020398 <COE_ObjInit+0x11c>)
 80202e2:	819a      	strh	r2, [r3, #12]

    /* subindex 5: same as 0x1C32:05 */
    sSyncManInPar.u32MinCycleTime = MIN_PD_CYCLE_TIME;
 80202e4:	4b2c      	ldr	r3, [pc, #176]	; (8020398 <COE_ObjInit+0x11c>)
 80202e6:	4a2b      	ldr	r2, [pc, #172]	; (8020394 <COE_ObjInit+0x118>)
 80202e8:	611a      	str	r2, [r3, #16]
    /* subindex 6: delay read inputs, calculation and copy to SM buffer*/
    sSyncManInPar.u32CalcAndCopyTime = (PD_INPUT_CALC_AND_COPY_TIME);
 80202ea:	4b2b      	ldr	r3, [pc, #172]	; (8020398 <COE_ObjInit+0x11c>)
 80202ec:	2200      	movs	r2, #0
 80202ee:	615a      	str	r2, [r3, #20]
    /*subindex 8: trigger cycle time measurement*/
    sSyncManInPar.u16GetCycleTime = 0;
 80202f0:	4b29      	ldr	r3, [pc, #164]	; (8020398 <COE_ObjInit+0x11c>)
 80202f2:	2200      	movs	r2, #0
 80202f4:	839a      	strh	r2, [r3, #28]
    /*subindex 9: delay to prepare input latch*/
    sSyncManInPar.u32DelayTime = (PD_INPUT_DELAY_TIME);
 80202f6:	4b28      	ldr	r3, [pc, #160]	; (8020398 <COE_ObjInit+0x11c>)
 80202f8:	2200      	movs	r2, #0
 80202fa:	621a      	str	r2, [r3, #32]

    /*subindex 11: reset the sm missed error counter*/
    sSyncManInPar.u16SmEventMissedCounter = 0;
 80202fc:	4b26      	ldr	r3, [pc, #152]	; (8020398 <COE_ObjInit+0x11c>)
 80202fe:	2200      	movs	r2, #0
 8020300:	851a      	strh	r2, [r3, #40]	; 0x28

    /*subindex 12: reset the cycle exceed error counter*/
    sSyncManInPar.u16CycleExceededCounter = 0;
 8020302:	4b25      	ldr	r3, [pc, #148]	; (8020398 <COE_ObjInit+0x11c>)
 8020304:	2200      	movs	r2, #0
 8020306:	855a      	strh	r2, [r3, #42]	; 0x2a

    /*subindex 32: incremented if a synchronisation error has occurred*/
    sSyncManInPar.u8SyncError = 0;
 8020308:	4b23      	ldr	r3, [pc, #140]	; (8020398 <COE_ObjInit+0x11c>)
 802030a:	2200      	movs	r2, #0
 802030c:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /*Indicate no user specified Sync mode*/
    bSyncSetByUser = FALSE;
 8020310:	4b22      	ldr	r3, [pc, #136]	; (802039c <COE_ObjInit+0x120>)
 8020312:	2200      	movs	r2, #0
 8020314:	701a      	strb	r2, [r3, #0]

    {
    UINT16 result = COE_ObjDictionaryInit();
 8020316:	f000 f951 	bl	80205bc <COE_ObjDictionaryInit>
 802031a:	4603      	mov	r3, r0
 802031c:	80fb      	strh	r3, [r7, #6]
    if(result != 0)
 802031e:	88fb      	ldrh	r3, [r7, #6]
 8020320:	2b00      	cmp	r3, #0
 8020322:	d001      	beq.n	8020328 <COE_ObjInit+0xac>
    {
        /*clear already linked objects*/
        COE_ClearObjDictionary();
 8020324:	f000 f90a 	bl	802053c <COE_ClearObjDictionary>
    }
    }

    u8PendingSdo = 0;
 8020328:	4b1d      	ldr	r3, [pc, #116]	; (80203a0 <COE_ObjInit+0x124>)
 802032a:	2200      	movs	r2, #0
 802032c:	701a      	strb	r2, [r3, #0]
    bStoreCompleteAccess = FALSE;
 802032e:	4b1d      	ldr	r3, [pc, #116]	; (80203a4 <COE_ObjInit+0x128>)
 8020330:	2200      	movs	r2, #0
 8020332:	701a      	strb	r2, [r3, #0]
    u16StoreIndex   =   0;
 8020334:	4b1c      	ldr	r3, [pc, #112]	; (80203a8 <COE_ObjInit+0x12c>)
 8020336:	2200      	movs	r2, #0
 8020338:	801a      	strh	r2, [r3, #0]
    u8StoreSubindex = 0;
 802033a:	4b1c      	ldr	r3, [pc, #112]	; (80203ac <COE_ObjInit+0x130>)
 802033c:	2200      	movs	r2, #0
 802033e:	701a      	strb	r2, [r3, #0]
    u32StoreDataSize = 0;
 8020340:	4b1b      	ldr	r3, [pc, #108]	; (80203b0 <COE_ObjInit+0x134>)
 8020342:	2200      	movs	r2, #0
 8020344:	601a      	str	r2, [r3, #0]
    pStoreData = NULL;
 8020346:	4b1b      	ldr	r3, [pc, #108]	; (80203b4 <COE_ObjInit+0x138>)
 8020348:	2200      	movs	r2, #0
 802034a:	601a      	str	r2, [r3, #0]
    pSdoPendFunc    = NULL;
 802034c:	4b1a      	ldr	r3, [pc, #104]	; (80203b8 <COE_ObjInit+0x13c>)
 802034e:	2200      	movs	r2, #0
 8020350:	601a      	str	r2, [r3, #0]

    pSdoSegData = NULL;
 8020352:	4b1a      	ldr	r3, [pc, #104]	; (80203bc <COE_ObjInit+0x140>)
 8020354:	2200      	movs	r2, #0
 8020356:	601a      	str	r2, [r3, #0]


    {
        UINT32 EscFeature = 0;
 8020358:	2300      	movs	r3, #0
 802035a:	603b      	str	r3, [r7, #0]
        HW_EscReadDWord(EscFeature, ESC_FEATURES_OFFSET);
 802035c:	4b18      	ldr	r3, [pc, #96]	; (80203c0 <COE_ObjInit+0x144>)
 802035e:	681b      	ldr	r3, [r3, #0]
 8020360:	603b      	str	r3, [r7, #0]
        EscFeature = SWAPDWORD(EscFeature);

        if ((EscFeature & ESC_DC_32BIT_MASK) > 0)
 8020362:	683b      	ldr	r3, [r7, #0]
 8020364:	f003 0308 	and.w	r3, r3, #8
 8020368:	2b00      	cmp	r3, #0
 802036a:	d003      	beq.n	8020374 <COE_ObjInit+0xf8>
        {
            b32BitDc = FALSE;
 802036c:	4b15      	ldr	r3, [pc, #84]	; (80203c4 <COE_ObjInit+0x148>)
 802036e:	2200      	movs	r2, #0
 8020370:	701a      	strb	r2, [r3, #0]
 8020372:	e006      	b.n	8020382 <COE_ObjInit+0x106>
        }
        else
        {
            b32BitDc = TRUE;
 8020374:	4b13      	ldr	r3, [pc, #76]	; (80203c4 <COE_ObjInit+0x148>)
 8020376:	2201      	movs	r2, #1
 8020378:	701a      	strb	r2, [r3, #0]

            HW_EscReadDWord(u32LastDc32Value, ESC_SYSTEMTIME_OFFSET);
 802037a:	4b13      	ldr	r3, [pc, #76]	; (80203c8 <COE_ObjInit+0x14c>)
 802037c:	681b      	ldr	r3, [r3, #0]
 802037e:	4a13      	ldr	r2, [pc, #76]	; (80203cc <COE_ObjInit+0x150>)
 8020380:	6013      	str	r3, [r2, #0]
        }

        u32CheckForDcOverrunCnt = CHECK_DC_OVERRUN_IN_MS;
 8020382:	4b13      	ldr	r3, [pc, #76]	; (80203d0 <COE_ObjInit+0x154>)
 8020384:	f44f 627a 	mov.w	r2, #4000	; 0xfa0
 8020388:	601a      	str	r2, [r3, #0]
    }
}
 802038a:	3708      	adds	r7, #8
 802038c:	46bd      	mov	sp, r7
 802038e:	bd80      	pop	{r7, pc}
 8020390:	1fff2ad4 	.word	0x1fff2ad4
 8020394:	0001e848 	.word	0x0001e848
 8020398:	1fff2a90 	.word	0x1fff2a90
 802039c:	1fff2b18 	.word	0x1fff2b18
 80203a0:	1fff2b38 	.word	0x1fff2b38
 80203a4:	1fff2b39 	.word	0x1fff2b39
 80203a8:	1fff2b6a 	.word	0x1fff2b6a
 80203ac:	1fff2b6c 	.word	0x1fff2b6c
 80203b0:	1fff2b48 	.word	0x1fff2b48
 80203b4:	1fff2b24 	.word	0x1fff2b24
 80203b8:	1fff2b34 	.word	0x1fff2b34
 80203bc:	1fff2b4c 	.word	0x1fff2b4c
 80203c0:	54010008 	.word	0x54010008
 80203c4:	1fff29dc 	.word	0x1fff29dc
 80203c8:	54010910 	.word	0x54010910
 80203cc:	1fff2820 	.word	0x1fff2820
 80203d0:	1fff2824 	.word	0x1fff2824

080203d4 <COE_AddObjectToDic>:
            ALSTATUSCODE_XX add object failed

 \brief    This function adds an object to the object dictionary
 *////////////////////////////////////////////////////////////////////////////////////////
UINT16 COE_AddObjectToDic(TOBJECT OBJMEM * pNewObjEntry)
{
 80203d4:	b480      	push	{r7}
 80203d6:	b085      	sub	sp, #20
 80203d8:	af00      	add	r7, sp, #0
 80203da:	6078      	str	r0, [r7, #4]
    if(pNewObjEntry != NULL)
 80203dc:	687b      	ldr	r3, [r7, #4]
 80203de:	2b00      	cmp	r3, #0
 80203e0:	d062      	beq.n	80204a8 <COE_AddObjectToDic+0xd4>
    {
        if(ObjDicList == NULL)
 80203e2:	4b35      	ldr	r3, [pc, #212]	; (80204b8 <COE_AddObjectToDic+0xe4>)
 80203e4:	681b      	ldr	r3, [r3, #0]
 80203e6:	2b00      	cmp	r3, #0
 80203e8:	d10c      	bne.n	8020404 <COE_AddObjectToDic+0x30>
        {
            /* Object dictionary is empty */
            ObjDicList = pNewObjEntry;
 80203ea:	4a33      	ldr	r2, [pc, #204]	; (80204b8 <COE_AddObjectToDic+0xe4>)
 80203ec:	687b      	ldr	r3, [r7, #4]
 80203ee:	6013      	str	r3, [r2, #0]
            ObjDicList->pNext = NULL;
 80203f0:	4b31      	ldr	r3, [pc, #196]	; (80204b8 <COE_AddObjectToDic+0xe4>)
 80203f2:	681b      	ldr	r3, [r3, #0]
 80203f4:	2200      	movs	r2, #0
 80203f6:	605a      	str	r2, [r3, #4]
            ObjDicList->pPrev = NULL;
 80203f8:	4b2f      	ldr	r3, [pc, #188]	; (80204b8 <COE_AddObjectToDic+0xe4>)
 80203fa:	681b      	ldr	r3, [r3, #0]
 80203fc:	2200      	movs	r2, #0
 80203fe:	601a      	str	r2, [r3, #0]
            return 0;
 8020400:	2300      	movs	r3, #0
 8020402:	e052      	b.n	80204aa <COE_AddObjectToDic+0xd6>
        }
        else if(ObjDicList->Index > pNewObjEntry->Index)
 8020404:	4b2c      	ldr	r3, [pc, #176]	; (80204b8 <COE_AddObjectToDic+0xe4>)
 8020406:	681b      	ldr	r3, [r3, #0]
 8020408:	891a      	ldrh	r2, [r3, #8]
 802040a:	687b      	ldr	r3, [r7, #4]
 802040c:	891b      	ldrh	r3, [r3, #8]
 802040e:	429a      	cmp	r2, r3
 8020410:	d90f      	bls.n	8020432 <COE_AddObjectToDic+0x5e>
        {
            /*insert new object dictionary head*/
            pNewObjEntry->pPrev = NULL;
 8020412:	687b      	ldr	r3, [r7, #4]
 8020414:	2200      	movs	r2, #0
 8020416:	601a      	str	r2, [r3, #0]
            pNewObjEntry->pNext = ObjDicList;
 8020418:	4b27      	ldr	r3, [pc, #156]	; (80204b8 <COE_AddObjectToDic+0xe4>)
 802041a:	681a      	ldr	r2, [r3, #0]
 802041c:	687b      	ldr	r3, [r7, #4]
 802041e:	605a      	str	r2, [r3, #4]
            ObjDicList->pPrev = pNewObjEntry;
 8020420:	4b25      	ldr	r3, [pc, #148]	; (80204b8 <COE_AddObjectToDic+0xe4>)
 8020422:	681b      	ldr	r3, [r3, #0]
 8020424:	687a      	ldr	r2, [r7, #4]
 8020426:	601a      	str	r2, [r3, #0]
            ObjDicList = pNewObjEntry;
 8020428:	4a23      	ldr	r2, [pc, #140]	; (80204b8 <COE_AddObjectToDic+0xe4>)
 802042a:	687b      	ldr	r3, [r7, #4]
 802042c:	6013      	str	r3, [r2, #0]
            return 0;
 802042e:	2300      	movs	r3, #0
 8020430:	e03b      	b.n	80204aa <COE_AddObjectToDic+0xd6>
        }
        else
        {
            TOBJECT    OBJMEM * pDicEntry = ObjDicList;
 8020432:	4b21      	ldr	r3, [pc, #132]	; (80204b8 <COE_AddObjectToDic+0xe4>)
 8020434:	681b      	ldr	r3, [r3, #0]
 8020436:	60fb      	str	r3, [r7, #12]
            while(pDicEntry != NULL)
 8020438:	e033      	b.n	80204a2 <COE_AddObjectToDic+0xce>
            {
                if(pDicEntry->Index == pNewObjEntry->Index)
 802043a:	68fb      	ldr	r3, [r7, #12]
 802043c:	891a      	ldrh	r2, [r3, #8]
 802043e:	687b      	ldr	r3, [r7, #4]
 8020440:	891b      	ldrh	r3, [r3, #8]
 8020442:	429a      	cmp	r2, r3
 8020444:	d101      	bne.n	802044a <COE_AddObjectToDic+0x76>
                {
                    /*object already exists in object dictionary*/
                    return ALSTATUSCODE_UNSPECIFIEDERROR;
 8020446:	2301      	movs	r3, #1
 8020448:	e02f      	b.n	80204aa <COE_AddObjectToDic+0xd6>
                }
                else if(pDicEntry->Index > pNewObjEntry->Index)
 802044a:	68fb      	ldr	r3, [r7, #12]
 802044c:	891a      	ldrh	r2, [r3, #8]
 802044e:	687b      	ldr	r3, [r7, #4]
 8020450:	891b      	ldrh	r3, [r3, #8]
 8020452:	429a      	cmp	r2, r3
 8020454:	d913      	bls.n	802047e <COE_AddObjectToDic+0xaa>
                {
                    pNewObjEntry->pPrev = pDicEntry->pPrev;
 8020456:	68fb      	ldr	r3, [r7, #12]
 8020458:	681a      	ldr	r2, [r3, #0]
 802045a:	687b      	ldr	r3, [r7, #4]
 802045c:	601a      	str	r2, [r3, #0]
                    pNewObjEntry->pNext = pDicEntry;
 802045e:	687b      	ldr	r3, [r7, #4]
 8020460:	68fa      	ldr	r2, [r7, #12]
 8020462:	605a      	str	r2, [r3, #4]

                    if(pDicEntry->pPrev != NULL)
 8020464:	68fb      	ldr	r3, [r7, #12]
 8020466:	681b      	ldr	r3, [r3, #0]
 8020468:	2b00      	cmp	r3, #0
 802046a:	d003      	beq.n	8020474 <COE_AddObjectToDic+0xa0>
                        pDicEntry->pPrev->pNext = pNewObjEntry;
 802046c:	68fb      	ldr	r3, [r7, #12]
 802046e:	681b      	ldr	r3, [r3, #0]
 8020470:	687a      	ldr	r2, [r7, #4]
 8020472:	605a      	str	r2, [r3, #4]

                    pDicEntry->pPrev = pNewObjEntry;
 8020474:	68fb      	ldr	r3, [r7, #12]
 8020476:	687a      	ldr	r2, [r7, #4]
 8020478:	601a      	str	r2, [r3, #0]

                    return 0;
 802047a:	2300      	movs	r3, #0
 802047c:	e015      	b.n	80204aa <COE_AddObjectToDic+0xd6>
                }
                else if(pDicEntry->pNext == NULL)
 802047e:	68fb      	ldr	r3, [r7, #12]
 8020480:	685b      	ldr	r3, [r3, #4]
 8020482:	2b00      	cmp	r3, #0
 8020484:	d10a      	bne.n	802049c <COE_AddObjectToDic+0xc8>
                {
                    /*Last entry reached => add object to list tail*/
                    pDicEntry->pNext = pNewObjEntry;
 8020486:	68fb      	ldr	r3, [r7, #12]
 8020488:	687a      	ldr	r2, [r7, #4]
 802048a:	605a      	str	r2, [r3, #4]
                    pNewObjEntry->pPrev = pDicEntry;
 802048c:	687b      	ldr	r3, [r7, #4]
 802048e:	68fa      	ldr	r2, [r7, #12]
 8020490:	601a      	str	r2, [r3, #0]
                    pNewObjEntry->pNext = NULL;
 8020492:	687b      	ldr	r3, [r7, #4]
 8020494:	2200      	movs	r2, #0
 8020496:	605a      	str	r2, [r3, #4]
                    return 0;
 8020498:	2300      	movs	r3, #0
 802049a:	e006      	b.n	80204aa <COE_AddObjectToDic+0xd6>
                }
                else
                {
                    /*The new object index is smaller than the current index. Get next object handle.*/
                    pDicEntry = pDicEntry->pNext;
 802049c:	68fb      	ldr	r3, [r7, #12]
 802049e:	685b      	ldr	r3, [r3, #4]
 80204a0:	60fb      	str	r3, [r7, #12]
            return 0;
        }
        else
        {
            TOBJECT    OBJMEM * pDicEntry = ObjDicList;
            while(pDicEntry != NULL)
 80204a2:	68fb      	ldr	r3, [r7, #12]
 80204a4:	2b00      	cmp	r3, #0
 80204a6:	d1c8      	bne.n	802043a <COE_AddObjectToDic+0x66>
                    pDicEntry = pDicEntry->pNext;
                }
            }
        }
    }
    return ALSTATUSCODE_UNSPECIFIEDERROR;
 80204a8:	2301      	movs	r3, #1
}
 80204aa:	4618      	mov	r0, r3
 80204ac:	3714      	adds	r7, #20
 80204ae:	46bd      	mov	sp, r7
 80204b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80204b4:	4770      	bx	lr
 80204b6:	bf00      	nop
 80204b8:	1fff17ec 	.word	0x1fff17ec

080204bc <COE_RemoveDicEntry>:
/**

 \brief    This function removes an object to the object dictionary
*////////////////////////////////////////////////////////////////////////////////////////
void COE_RemoveDicEntry(UINT16 index)
{
 80204bc:	b480      	push	{r7}
 80204be:	b087      	sub	sp, #28
 80204c0:	af00      	add	r7, sp, #0
 80204c2:	4603      	mov	r3, r0
 80204c4:	80fb      	strh	r3, [r7, #6]
    TOBJECT    OBJMEM * pDicEntry = ObjDicList;
 80204c6:	4b1c      	ldr	r3, [pc, #112]	; (8020538 <COE_RemoveDicEntry+0x7c>)
 80204c8:	681b      	ldr	r3, [r3, #0]
 80204ca:	617b      	str	r3, [r7, #20]

    while(pDicEntry != NULL)
 80204cc:	e02b      	b.n	8020526 <COE_RemoveDicEntry+0x6a>
    {
        if(pDicEntry->Index == index)
 80204ce:	697b      	ldr	r3, [r7, #20]
 80204d0:	891b      	ldrh	r3, [r3, #8]
 80204d2:	88fa      	ldrh	r2, [r7, #6]
 80204d4:	429a      	cmp	r2, r3
 80204d6:	d123      	bne.n	8020520 <COE_RemoveDicEntry+0x64>
        {
            TOBJECT OBJMEM *pPrevEntry = pDicEntry->pPrev;
 80204d8:	697b      	ldr	r3, [r7, #20]
 80204da:	681b      	ldr	r3, [r3, #0]
 80204dc:	613b      	str	r3, [r7, #16]
            TOBJECT OBJMEM *pNextEntry = pDicEntry->pNext;
 80204de:	697b      	ldr	r3, [r7, #20]
 80204e0:	685b      	ldr	r3, [r3, #4]
 80204e2:	60fb      	str	r3, [r7, #12]

            if(pPrevEntry != NULL)
 80204e4:	693b      	ldr	r3, [r7, #16]
 80204e6:	2b00      	cmp	r3, #0
 80204e8:	d002      	beq.n	80204f0 <COE_RemoveDicEntry+0x34>
            {
                pPrevEntry->pNext = pNextEntry;
 80204ea:	693b      	ldr	r3, [r7, #16]
 80204ec:	68fa      	ldr	r2, [r7, #12]
 80204ee:	605a      	str	r2, [r3, #4]
            }

            if(pNextEntry != NULL)
 80204f0:	68fb      	ldr	r3, [r7, #12]
 80204f2:	2b00      	cmp	r3, #0
 80204f4:	d002      	beq.n	80204fc <COE_RemoveDicEntry+0x40>
            {
                pNextEntry->pPrev = pPrevEntry;
 80204f6:	68fb      	ldr	r3, [r7, #12]
 80204f8:	693a      	ldr	r2, [r7, #16]
 80204fa:	601a      	str	r2, [r3, #0]
            }

            pDicEntry->pPrev = NULL;
 80204fc:	697b      	ldr	r3, [r7, #20]
 80204fe:	2200      	movs	r2, #0
 8020500:	601a      	str	r2, [r3, #0]
            pDicEntry->pNext = NULL;
 8020502:	697b      	ldr	r3, [r7, #20]
 8020504:	2200      	movs	r2, #0
 8020506:	605a      	str	r2, [r3, #4]
            /*Update Object dictionary pointer if list head was removed*/
            if(pDicEntry->Index == ObjDicList->Index)
 8020508:	697b      	ldr	r3, [r7, #20]
 802050a:	891a      	ldrh	r2, [r3, #8]
 802050c:	4b0a      	ldr	r3, [pc, #40]	; (8020538 <COE_RemoveDicEntry+0x7c>)
 802050e:	681b      	ldr	r3, [r3, #0]
 8020510:	891b      	ldrh	r3, [r3, #8]
 8020512:	429a      	cmp	r2, r3
 8020514:	d103      	bne.n	802051e <COE_RemoveDicEntry+0x62>
            {
                ObjDicList = pNextEntry;
 8020516:	4a08      	ldr	r2, [pc, #32]	; (8020538 <COE_RemoveDicEntry+0x7c>)
 8020518:	68fb      	ldr	r3, [r7, #12]
 802051a:	6013      	str	r3, [r2, #0]
            }
            return;
 802051c:	e006      	b.n	802052c <COE_RemoveDicEntry+0x70>
 802051e:	e005      	b.n	802052c <COE_RemoveDicEntry+0x70>
        }

        pDicEntry = pDicEntry->pNext;
 8020520:	697b      	ldr	r3, [r7, #20]
 8020522:	685b      	ldr	r3, [r3, #4]
 8020524:	617b      	str	r3, [r7, #20]
*////////////////////////////////////////////////////////////////////////////////////////
void COE_RemoveDicEntry(UINT16 index)
{
    TOBJECT    OBJMEM * pDicEntry = ObjDicList;

    while(pDicEntry != NULL)
 8020526:	697b      	ldr	r3, [r7, #20]
 8020528:	2b00      	cmp	r3, #0
 802052a:	d1d0      	bne.n	80204ce <COE_RemoveDicEntry+0x12>
            return;
        }

        pDicEntry = pDicEntry->pNext;
    }
}
 802052c:	371c      	adds	r7, #28
 802052e:	46bd      	mov	sp, r7
 8020530:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020534:	4770      	bx	lr
 8020536:	bf00      	nop
 8020538:	1fff17ec 	.word	0x1fff17ec

0802053c <COE_ClearObjDictionary>:
/**

 \brief    This function clear the object dictionary
*////////////////////////////////////////////////////////////////////////////////////////
void COE_ClearObjDictionary(void)
{
 802053c:	b580      	push	{r7, lr}
 802053e:	b082      	sub	sp, #8
 8020540:	af00      	add	r7, sp, #0
    TOBJECT OBJMEM * pObjEntry = (TOBJECT OBJMEM *) ObjDicList;
 8020542:	4b0c      	ldr	r3, [pc, #48]	; (8020574 <COE_ClearObjDictionary+0x38>)
 8020544:	681b      	ldr	r3, [r3, #0]
 8020546:	607b      	str	r3, [r7, #4]
    UINT16 Index = 0;
 8020548:	2300      	movs	r3, #0
 802054a:	807b      	strh	r3, [r7, #2]

    while(pObjEntry != NULL)
 802054c:	e009      	b.n	8020562 <COE_ClearObjDictionary+0x26>
    {
        Index = pObjEntry->Index;
 802054e:	687b      	ldr	r3, [r7, #4]
 8020550:	891b      	ldrh	r3, [r3, #8]
 8020552:	807b      	strh	r3, [r7, #2]
        pObjEntry = pObjEntry->pNext;
 8020554:	687b      	ldr	r3, [r7, #4]
 8020556:	685b      	ldr	r3, [r3, #4]
 8020558:	607b      	str	r3, [r7, #4]

        COE_RemoveDicEntry(Index);
 802055a:	887b      	ldrh	r3, [r7, #2]
 802055c:	4618      	mov	r0, r3
 802055e:	f7ff ffad 	bl	80204bc <COE_RemoveDicEntry>
void COE_ClearObjDictionary(void)
{
    TOBJECT OBJMEM * pObjEntry = (TOBJECT OBJMEM *) ObjDicList;
    UINT16 Index = 0;

    while(pObjEntry != NULL)
 8020562:	687b      	ldr	r3, [r7, #4]
 8020564:	2b00      	cmp	r3, #0
 8020566:	d1f2      	bne.n	802054e <COE_ClearObjDictionary+0x12>
        Index = pObjEntry->Index;
        pObjEntry = pObjEntry->pNext;

        COE_RemoveDicEntry(Index);
    }
    ObjDicList = NULL;
 8020568:	4b02      	ldr	r3, [pc, #8]	; (8020574 <COE_ClearObjDictionary+0x38>)
 802056a:	2200      	movs	r2, #0
 802056c:	601a      	str	r2, [r3, #0]
}
 802056e:	3708      	adds	r7, #8
 8020570:	46bd      	mov	sp, r7
 8020572:	bd80      	pop	{r7, pc}
 8020574:	1fff17ec 	.word	0x1fff17ec

08020578 <AddObjectsToObjDictionary>:


UINT16 AddObjectsToObjDictionary(TOBJECT OBJMEM * pObjEntry)
{
 8020578:	b580      	push	{r7, lr}
 802057a:	b084      	sub	sp, #16
 802057c:	af00      	add	r7, sp, #0
 802057e:	6078      	str	r0, [r7, #4]
    UINT16 result = 0;
 8020580:	2300      	movs	r3, #0
 8020582:	81fb      	strh	r3, [r7, #14]
    TOBJECT OBJMEM * pEntry = (TOBJECT OBJMEM *)pObjEntry;
 8020584:	687b      	ldr	r3, [r7, #4]
 8020586:	60bb      	str	r3, [r7, #8]

    while(pEntry->Index != 0xFFFF)
 8020588:	e00c      	b.n	80205a4 <AddObjectsToObjDictionary+0x2c>
    {
        result = COE_AddObjectToDic(pEntry);
 802058a:	68b8      	ldr	r0, [r7, #8]
 802058c:	f7ff ff22 	bl	80203d4 <COE_AddObjectToDic>
 8020590:	4603      	mov	r3, r0
 8020592:	81fb      	strh	r3, [r7, #14]

        if(result != 0)
 8020594:	89fb      	ldrh	r3, [r7, #14]
 8020596:	2b00      	cmp	r3, #0
 8020598:	d001      	beq.n	802059e <AddObjectsToObjDictionary+0x26>
        {
            return result;
 802059a:	89fb      	ldrh	r3, [r7, #14]
 802059c:	e009      	b.n	80205b2 <AddObjectsToObjDictionary+0x3a>
        }

        pEntry++;
 802059e:	68bb      	ldr	r3, [r7, #8]
 80205a0:	3328      	adds	r3, #40	; 0x28
 80205a2:	60bb      	str	r3, [r7, #8]
UINT16 AddObjectsToObjDictionary(TOBJECT OBJMEM * pObjEntry)
{
    UINT16 result = 0;
    TOBJECT OBJMEM * pEntry = (TOBJECT OBJMEM *)pObjEntry;

    while(pEntry->Index != 0xFFFF)
 80205a4:	68bb      	ldr	r3, [r7, #8]
 80205a6:	891b      	ldrh	r3, [r3, #8]
 80205a8:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80205ac:	4293      	cmp	r3, r2
 80205ae:	d1ec      	bne.n	802058a <AddObjectsToObjDictionary+0x12>
        }

        pEntry++;
    }

    return result;
 80205b0:	89fb      	ldrh	r3, [r7, #14]

}
 80205b2:	4618      	mov	r0, r3
 80205b4:	3710      	adds	r7, #16
 80205b6:	46bd      	mov	sp, r7
 80205b8:	bd80      	pop	{r7, pc}
 80205ba:	bf00      	nop

080205bc <COE_ObjDictionaryInit>:
            ALSTATUSCODE_XX create object dictionary failed

 \brief    This function initialize the object dictionary
*////////////////////////////////////////////////////////////////////////////////////////
UINT16 COE_ObjDictionaryInit(void)
{
 80205bc:	b580      	push	{r7, lr}
 80205be:	b082      	sub	sp, #8
 80205c0:	af00      	add	r7, sp, #0
    UINT16 result = 0;
 80205c2:	2300      	movs	r3, #0
 80205c4:	80fb      	strh	r3, [r7, #6]

    /*Reset object dictionary pointer*/
    ObjDicList = NULL;
 80205c6:	4b0b      	ldr	r3, [pc, #44]	; (80205f4 <COE_ObjDictionaryInit+0x38>)
 80205c8:	2200      	movs	r2, #0
 80205ca:	601a      	str	r2, [r3, #0]

    result = AddObjectsToObjDictionary((TOBJECT OBJMEM *) GenObjDic);
 80205cc:	480a      	ldr	r0, [pc, #40]	; (80205f8 <COE_ObjDictionaryInit+0x3c>)
 80205ce:	f7ff ffd3 	bl	8020578 <AddObjectsToObjDictionary>
 80205d2:	4603      	mov	r3, r0
 80205d4:	80fb      	strh	r3, [r7, #6]

    if(result != 0)
 80205d6:	88fb      	ldrh	r3, [r7, #6]
 80205d8:	2b00      	cmp	r3, #0
 80205da:	d001      	beq.n	80205e0 <COE_ObjDictionaryInit+0x24>
    {
        return result;
 80205dc:	88fb      	ldrh	r3, [r7, #6]
 80205de:	e005      	b.n	80205ec <COE_ObjDictionaryInit+0x30>
    }
    
    if(ApplicationObjDic != NULL)
    {
        result = AddObjectsToObjDictionary((TOBJECT OBJMEM *) ApplicationObjDic);
 80205e0:	4806      	ldr	r0, [pc, #24]	; (80205fc <COE_ObjDictionaryInit+0x40>)
 80205e2:	f7ff ffc9 	bl	8020578 <AddObjectsToObjDictionary>
 80205e6:	4603      	mov	r3, r0
 80205e8:	80fb      	strh	r3, [r7, #6]
    }



    return result;
 80205ea:	88fb      	ldrh	r3, [r7, #6]
}
 80205ec:	4618      	mov	r0, r3
 80205ee:	3708      	adds	r7, #8
 80205f0:	46bd      	mov	sp, r7
 80205f2:	bd80      	pop	{r7, pc}
 80205f4:	1fff17ec 	.word	0x1fff17ec
 80205f8:	1fff09ec 	.word	0x1fff09ec
 80205fc:	1fff0800 	.word	0x1fff0800

08020600 <XMC_ECAT_GetALEventRegister>:
 *
 * \par
 * Get the first two bytes of the AL Event register (0x220-0x221).
 */
__STATIC_INLINE uint16_t XMC_ECAT_GetALEventRegister(void)
{
 8020600:	b480      	push	{r7}
 8020602:	af00      	add	r7, sp, #0
  return ((uint16_t)ECAT0->AL_EVENT_REQ);
 8020604:	4b04      	ldr	r3, [pc, #16]	; (8020618 <XMC_ECAT_GetALEventRegister+0x18>)
 8020606:	f8d3 3220 	ldr.w	r3, [r3, #544]	; 0x220
 802060a:	b29b      	uxth	r3, r3
}
 802060c:	4618      	mov	r0, r3
 802060e:	46bd      	mov	sp, r7
 8020610:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020614:	4770      	bx	lr
 8020616:	bf00      	nop
 8020618:	54010000 	.word	0x54010000

0802061c <HW_EscRead>:
 * \par<b>Description:</b><br>
 * Reads from the EtherCAT Slave Controller. This function is used to access ESC registers and the DPRAM area.
 *
 */
__STATIC_INLINE void HW_EscRead(MEM_ADDR *pData, UINT16 Address, UINT16 Len)
{
 802061c:	b580      	push	{r7, lr}
 802061e:	b082      	sub	sp, #8
 8020620:	af00      	add	r7, sp, #0
 8020622:	6078      	str	r0, [r7, #4]
 8020624:	460b      	mov	r3, r1
 8020626:	807b      	strh	r3, [r7, #2]
 8020628:	4613      	mov	r3, r2
 802062a:	803b      	strh	r3, [r7, #0]
  memcpy(pData, &pEsc[Address], Len);
 802062c:	887b      	ldrh	r3, [r7, #2]
 802062e:	f103 43a8 	add.w	r3, r3, #1409286144	; 0x54000000
 8020632:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 8020636:	883a      	ldrh	r2, [r7, #0]
 8020638:	6878      	ldr	r0, [r7, #4]
 802063a:	4619      	mov	r1, r3
 802063c:	f004 fd7e 	bl	802513c <memcpy>
}
 8020640:	3708      	adds	r7, #8
 8020642:	46bd      	mov	sp, r7
 8020644:	bd80      	pop	{r7, pc}
 8020646:	bf00      	nop

08020648 <HW_EscReadIsr>:
 * \par<b>Description:</b><br>
 * Reads from the EtherCAT Slave Controller. This function is used to access ESC registers and the DPRAM area.
 *
 */
__STATIC_INLINE void HW_EscReadIsr(MEM_ADDR *pData, UINT16 Address, UINT16 Len)
{
 8020648:	b580      	push	{r7, lr}
 802064a:	b082      	sub	sp, #8
 802064c:	af00      	add	r7, sp, #0
 802064e:	6078      	str	r0, [r7, #4]
 8020650:	460b      	mov	r3, r1
 8020652:	807b      	strh	r3, [r7, #2]
 8020654:	4613      	mov	r3, r2
 8020656:	803b      	strh	r3, [r7, #0]
  HW_EscRead(pData, Address, Len);
 8020658:	887a      	ldrh	r2, [r7, #2]
 802065a:	883b      	ldrh	r3, [r7, #0]
 802065c:	6878      	ldr	r0, [r7, #4]
 802065e:	4611      	mov	r1, r2
 8020660:	461a      	mov	r2, r3
 8020662:	f7ff ffdb 	bl	802061c <HW_EscRead>
}
 8020666:	3708      	adds	r7, #8
 8020668:	46bd      	mov	sp, r7
 802066a:	bd80      	pop	{r7, pc}

0802066c <HW_EscWrite>:
 * \par<b>Description:</b><br>
 * Writes from the EtherCAT Slave Controller. This function is used to access ESC registers and the DPRAM area.
 *
 */
__STATIC_INLINE void HW_EscWrite(MEM_ADDR *pData, UINT16 Address, UINT16 Len)
{
 802066c:	b580      	push	{r7, lr}
 802066e:	b082      	sub	sp, #8
 8020670:	af00      	add	r7, sp, #0
 8020672:	6078      	str	r0, [r7, #4]
 8020674:	460b      	mov	r3, r1
 8020676:	807b      	strh	r3, [r7, #2]
 8020678:	4613      	mov	r3, r2
 802067a:	803b      	strh	r3, [r7, #0]
  memcpy(&pEsc[Address], pData, Len);
 802067c:	887b      	ldrh	r3, [r7, #2]
 802067e:	f103 43a8 	add.w	r3, r3, #1409286144	; 0x54000000
 8020682:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 8020686:	883a      	ldrh	r2, [r7, #0]
 8020688:	4618      	mov	r0, r3
 802068a:	6879      	ldr	r1, [r7, #4]
 802068c:	f004 fd56 	bl	802513c <memcpy>
}
 8020690:	3708      	adds	r7, #8
 8020692:	46bd      	mov	sp, r7
 8020694:	bd80      	pop	{r7, pc}
 8020696:	bf00      	nop

08020698 <HW_EscWriteIsr>:
 * \par<b>Description:</b><br>
 * Writes from the EtherCAT Slave Controller. This function is used to access ESC registers and the DPRAM area.
 *
 */
__STATIC_INLINE void HW_EscWriteIsr(MEM_ADDR *pData, UINT16 Address, UINT16 Len)
{
 8020698:	b580      	push	{r7, lr}
 802069a:	b082      	sub	sp, #8
 802069c:	af00      	add	r7, sp, #0
 802069e:	6078      	str	r0, [r7, #4]
 80206a0:	460b      	mov	r3, r1
 80206a2:	807b      	strh	r3, [r7, #2]
 80206a4:	4613      	mov	r3, r2
 80206a6:	803b      	strh	r3, [r7, #0]
  HW_EscWrite(pData, Address, Len);
 80206a8:	887a      	ldrh	r2, [r7, #2]
 80206aa:	883b      	ldrh	r3, [r7, #0]
 80206ac:	6878      	ldr	r0, [r7, #4]
 80206ae:	4611      	mov	r1, r2
 80206b0:	461a      	mov	r2, r3
 80206b2:	f7ff ffdb 	bl	802066c <HW_EscWrite>
}
 80206b6:	3708      	adds	r7, #8
 80206b8:	46bd      	mov	sp, r7
 80206ba:	bd80      	pop	{r7, pc}

080206bc <HW_GetALEventRegister>:
 * \par<b>Description:</b><br>
 *
 *
 */
__STATIC_INLINE UINT16 HW_GetALEventRegister(void)
{
 80206bc:	b580      	push	{r7, lr}
 80206be:	af00      	add	r7, sp, #0
  return XMC_ECAT_GetALEventRegister();
 80206c0:	f7ff ff9e 	bl	8020600 <XMC_ECAT_GetALEventRegister>
 80206c4:	4603      	mov	r3, r0
}
 80206c6:	4618      	mov	r0, r3
 80206c8:	bd80      	pop	{r7, pc}
 80206ca:	bf00      	nop

080206cc <HW_GetALEventRegister_Isr>:
 * Special function for ESC access from interrupt service routines if required, otherwise this function is defined as
 * HW_GetALEventRegister.
 *
 */
__STATIC_INLINE UINT16 HW_GetALEventRegister_Isr(void)
{
 80206cc:	b580      	push	{r7, lr}
 80206ce:	af00      	add	r7, sp, #0
  return HW_GetALEventRegister();
 80206d0:	f7ff fff4 	bl	80206bc <HW_GetALEventRegister>
 80206d4:	4603      	mov	r3, r0
}
 80206d6:	4618      	mov	r0, r3
 80206d8:	bd80      	pop	{r7, pc}
 80206da:	bf00      	nop

080206dc <PDO_InputMapping>:
/////////////////////////////////////////////////////////////////////////////////////////
/**
\brief      This function will copies the inputs from the local memory to the ESC memory
*////////////////////////////////////////////////////////////////////////////////////////
void PDO_InputMapping(void)
{
 80206dc:	b580      	push	{r7, lr}
 80206de:	b082      	sub	sp, #8
 80206e0:	af00      	add	r7, sp, #0

#if ((MIN_PD_CYCLE_TIME == 0) || (PD_INPUT_CALC_AND_COPY_TIME == 0))
    UINT32 u32TimeValue = 0;
 80206e2:	2300      	movs	r3, #0
 80206e4:	607b      	str	r3, [r7, #4]
    UINT16 ALEvent = HW_GetALEventRegister_Isr();
 80206e6:	f7ff fff1 	bl	80206cc <HW_GetALEventRegister_Isr>
 80206ea:	4603      	mov	r3, r0
 80206ec:	807b      	strh	r3, [r7, #2]
    ALEvent = SWAPWORD(ALEvent);

    if (MEASUREMENT_ACTIVE)
 80206ee:	4b1b      	ldr	r3, [pc, #108]	; (802075c <PDO_InputMapping+0x80>)
 80206f0:	8b9b      	ldrh	r3, [r3, #28]
 80206f2:	f003 0301 	and.w	r3, r3, #1
 80206f6:	2b00      	cmp	r3, #0
 80206f8:	d105      	bne.n	8020706 <PDO_InputMapping+0x2a>
 80206fa:	4b19      	ldr	r3, [pc, #100]	; (8020760 <PDO_InputMapping+0x84>)
 80206fc:	8b9b      	ldrh	r3, [r3, #28]
 80206fe:	f003 0301 	and.w	r3, r3, #1
 8020702:	2b00      	cmp	r3, #0
 8020704:	d003      	beq.n	802070e <PDO_InputMapping+0x32>
    {
        u32TimeValue = GetSystemTimeDelay(0);
 8020706:	2000      	movs	r0, #0
 8020708:	f000 f946 	bl	8020998 <GetSystemTimeDelay>
 802070c:	6078      	str	r0, [r7, #4]




  
    APPL_InputMapping((UINT16*)aPdInputData);
 802070e:	4815      	ldr	r0, [pc, #84]	; (8020764 <PDO_InputMapping+0x88>)
 8020710:	f000 fe6c 	bl	80213ec <APPL_InputMapping>
    HW_EscWriteIsr(((MEM_ADDR *) aPdInputData), nEscAddrInputData, nPdInputSize );
 8020714:	4b14      	ldr	r3, [pc, #80]	; (8020768 <PDO_InputMapping+0x8c>)
 8020716:	881a      	ldrh	r2, [r3, #0]
 8020718:	4b14      	ldr	r3, [pc, #80]	; (802076c <PDO_InputMapping+0x90>)
 802071a:	881b      	ldrh	r3, [r3, #0]
 802071c:	4811      	ldr	r0, [pc, #68]	; (8020764 <PDO_InputMapping+0x88>)
 802071e:	4611      	mov	r1, r2
 8020720:	461a      	mov	r2, r3
 8020722:	f7ff ffb9 	bl	8020698 <HW_EscWriteIsr>

    

#if ((MIN_PD_CYCLE_TIME == 0) || (PD_INPUT_CALC_AND_COPY_TIME == 0))

    if (MEASUREMENT_ACTIVE)
 8020726:	4b0d      	ldr	r3, [pc, #52]	; (802075c <PDO_InputMapping+0x80>)
 8020728:	8b9b      	ldrh	r3, [r3, #28]
 802072a:	f003 0301 	and.w	r3, r3, #1
 802072e:	2b00      	cmp	r3, #0
 8020730:	d105      	bne.n	802073e <PDO_InputMapping+0x62>
 8020732:	4b0b      	ldr	r3, [pc, #44]	; (8020760 <PDO_InputMapping+0x84>)
 8020734:	8b9b      	ldrh	r3, [r3, #28]
 8020736:	f003 0301 	and.w	r3, r3, #1
 802073a:	2b00      	cmp	r3, #0
 802073c:	d00b      	beq.n	8020756 <PDO_InputMapping+0x7a>
    {
        u32TimeValue = GetSystemTimeDelay(u32TimeValue);
 802073e:	6878      	ldr	r0, [r7, #4]
 8020740:	f000 f92a 	bl	8020998 <GetSystemTimeDelay>
 8020744:	6078      	str	r0, [r7, #4]

#if (PD_INPUT_CALC_AND_COPY_TIME == 0)
        if (sSyncManInPar.u32CalcAndCopyTime < u32TimeValue)
 8020746:	4b06      	ldr	r3, [pc, #24]	; (8020760 <PDO_InputMapping+0x84>)
 8020748:	695a      	ldr	r2, [r3, #20]
 802074a:	687b      	ldr	r3, [r7, #4]
 802074c:	429a      	cmp	r2, r3
 802074e:	d202      	bcs.n	8020756 <PDO_InputMapping+0x7a>
        {
            sSyncManInPar.u32CalcAndCopyTime = u32TimeValue;
 8020750:	4a03      	ldr	r2, [pc, #12]	; (8020760 <PDO_InputMapping+0x84>)
 8020752:	687b      	ldr	r3, [r7, #4]
 8020754:	6153      	str	r3, [r2, #20]
#endif /* (MIN_PD_CYCLE_TIME == 0) */
    }

#endif /* ((MIN_PD_CYCLE_TIME == 0) || (PD_INPUT_CALC_AND_COPY_TIME == 0)) */

}
 8020756:	3708      	adds	r7, #8
 8020758:	46bd      	mov	sp, r7
 802075a:	bd80      	pop	{r7, pc}
 802075c:	1fff2ad4 	.word	0x1fff2ad4
 8020760:	1fff2a90 	.word	0x1fff2a90
 8020764:	1fff2900 	.word	0x1fff2900
 8020768:	1fff29fa 	.word	0x1fff29fa
 802076c:	1fff29e2 	.word	0x1fff29e2

08020770 <PDO_OutputMapping>:
/**
\brief    This function will copies the outputs from the ESC memory to the local memory.
        This function is only called in case of an SM2 (output process data) event.
*////////////////////////////////////////////////////////////////////////////////////////
void PDO_OutputMapping(void)
{
 8020770:	b580      	push	{r7, lr}
 8020772:	b082      	sub	sp, #8
 8020774:	af00      	add	r7, sp, #0
   UINT32 u32TimeValue = 0;
 8020776:	2300      	movs	r3, #0
 8020778:	607b      	str	r3, [r7, #4]
   if (MEASUREMENT_ACTIVE)
 802077a:	4b21      	ldr	r3, [pc, #132]	; (8020800 <PDO_OutputMapping+0x90>)
 802077c:	8b9b      	ldrh	r3, [r3, #28]
 802077e:	f003 0301 	and.w	r3, r3, #1
 8020782:	2b00      	cmp	r3, #0
 8020784:	d105      	bne.n	8020792 <PDO_OutputMapping+0x22>
 8020786:	4b1f      	ldr	r3, [pc, #124]	; (8020804 <PDO_OutputMapping+0x94>)
 8020788:	8b9b      	ldrh	r3, [r3, #28]
 802078a:	f003 0301 	and.w	r3, r3, #1
 802078e:	2b00      	cmp	r3, #0
 8020790:	d00e      	beq.n	80207b0 <PDO_OutputMapping+0x40>
   {
#if ((MIN_PD_CYCLE_TIME == 0) || (PD_OUTPUT_CALC_AND_COPY_TIME == 0))
      u32TimeValue = GetSystemTimeDelay(0);
 8020792:	2000      	movs	r0, #0
 8020794:	f000 f900 	bl	8020998 <GetSystemTimeDelay>
 8020798:	6078      	str	r0, [r7, #4]
      u32MinCycleTimeStartValue = u32TimeValue;
 802079a:	4a1b      	ldr	r2, [pc, #108]	; (8020808 <PDO_OutputMapping+0x98>)
 802079c:	687b      	ldr	r3, [r7, #4]
 802079e:	6013      	str	r3, [r2, #0]

      bMinCycleTimeMeasurementStarted = TRUE;
 80207a0:	4b1a      	ldr	r3, [pc, #104]	; (802080c <PDO_OutputMapping+0x9c>)
 80207a2:	2201      	movs	r2, #1
 80207a4:	701a      	strb	r2, [r3, #0]
      u32MinCycleTimeValue = 0;
 80207a6:	4b1a      	ldr	r3, [pc, #104]	; (8020810 <PDO_OutputMapping+0xa0>)
 80207a8:	2200      	movs	r2, #0
 80207aa:	601a      	str	r2, [r3, #0]

#endif /* ((MIN_PD_CYCLE_TIME == 0) || (PD_OUTPUT_CALC_AND_COPY_TIME == 0)) */

      HandleCycleTimeMeasurement();
 80207ac:	f000 f8b4 	bl	8020918 <HandleCycleTimeMeasurement>

   }

    HW_EscReadIsr(((MEM_ADDR *)aPdOutputData), nEscAddrOutputData, nPdOutputSize );
 80207b0:	4b18      	ldr	r3, [pc, #96]	; (8020814 <PDO_OutputMapping+0xa4>)
 80207b2:	881a      	ldrh	r2, [r3, #0]
 80207b4:	4b18      	ldr	r3, [pc, #96]	; (8020818 <PDO_OutputMapping+0xa8>)
 80207b6:	881b      	ldrh	r3, [r3, #0]
 80207b8:	4818      	ldr	r0, [pc, #96]	; (802081c <PDO_OutputMapping+0xac>)
 80207ba:	4611      	mov	r1, r2
 80207bc:	461a      	mov	r2, r3
 80207be:	f7ff ff43 	bl	8020648 <HW_EscReadIsr>
    APPL_OutputMapping((UINT16*) aPdOutputData);
 80207c2:	4816      	ldr	r0, [pc, #88]	; (802081c <PDO_OutputMapping+0xac>)
 80207c4:	f000 fe1c 	bl	8021400 <APPL_OutputMapping>


#if ((MIN_PD_CYCLE_TIME == 0) || (PD_OUTPUT_CALC_AND_COPY_TIME == 0))
    if (MEASUREMENT_ACTIVE)
 80207c8:	4b0d      	ldr	r3, [pc, #52]	; (8020800 <PDO_OutputMapping+0x90>)
 80207ca:	8b9b      	ldrh	r3, [r3, #28]
 80207cc:	f003 0301 	and.w	r3, r3, #1
 80207d0:	2b00      	cmp	r3, #0
 80207d2:	d105      	bne.n	80207e0 <PDO_OutputMapping+0x70>
 80207d4:	4b0b      	ldr	r3, [pc, #44]	; (8020804 <PDO_OutputMapping+0x94>)
 80207d6:	8b9b      	ldrh	r3, [r3, #28]
 80207d8:	f003 0301 	and.w	r3, r3, #1
 80207dc:	2b00      	cmp	r3, #0
 80207de:	d00b      	beq.n	80207f8 <PDO_OutputMapping+0x88>
    {
       u32TimeValue = GetSystemTimeDelay(u32TimeValue);
 80207e0:	6878      	ldr	r0, [r7, #4]
 80207e2:	f000 f8d9 	bl	8020998 <GetSystemTimeDelay>
 80207e6:	6078      	str	r0, [r7, #4]

#if (PD_OUTPUT_CALC_AND_COPY_TIME == 0)
       if (sSyncManOutPar.u32CalcAndCopyTime < u32TimeValue)
 80207e8:	4b05      	ldr	r3, [pc, #20]	; (8020800 <PDO_OutputMapping+0x90>)
 80207ea:	695a      	ldr	r2, [r3, #20]
 80207ec:	687b      	ldr	r3, [r7, #4]
 80207ee:	429a      	cmp	r2, r3
 80207f0:	d202      	bcs.n	80207f8 <PDO_OutputMapping+0x88>
       {
          sSyncManOutPar.u32CalcAndCopyTime = u32TimeValue;
 80207f2:	4a03      	ldr	r2, [pc, #12]	; (8020800 <PDO_OutputMapping+0x90>)
 80207f4:	687b      	ldr	r3, [r7, #4]
 80207f6:	6153      	str	r3, [r2, #20]
       /* add the first part of the min cycle time */
       u32MinCycleTimeValue = u32TimeValue;
#endif
    }
#endif /* #if ((MIN_PD_CYCLE_TIME == 0) || (PD_OUTPUT_CALC_AND_COPY_TIME == 0)) */
}
 80207f8:	3708      	adds	r7, #8
 80207fa:	46bd      	mov	sp, r7
 80207fc:	bd80      	pop	{r7, pc}
 80207fe:	bf00      	nop
 8020800:	1fff2ad4 	.word	0x1fff2ad4
 8020804:	1fff2a90 	.word	0x1fff2a90
 8020808:	1fff28fc 	.word	0x1fff28fc
 802080c:	1fff2830 	.word	0x1fff2830
 8020810:	1fff284c 	.word	0x1fff284c
 8020814:	1fff29c2 	.word	0x1fff29c2
 8020818:	1fff29b6 	.word	0x1fff29b6
 802081c:	1fff2850 	.word	0x1fff2850

08020820 <ECAT_CheckTimer>:
 \brief interrupts. In this case a local timer register is checked every ECAT_Main cycle
 \brief and the function is triggered if 1 ms is elapsed
 *////////////////////////////////////////////////////////////////////////////////////////

void ECAT_CheckTimer(void)
{
 8020820:	b580      	push	{r7, lr}
 8020822:	af00      	add	r7, sp, #0

    /*decrement the state transition timeout counter*/
    if(bEcatWaitForAlControlRes &&  (EsmTimeoutCounter > 0))
 8020824:	4b32      	ldr	r3, [pc, #200]	; (80208f0 <ECAT_CheckTimer+0xd0>)
 8020826:	781b      	ldrb	r3, [r3, #0]
 8020828:	2b00      	cmp	r3, #0
 802082a:	d00d      	beq.n	8020848 <ECAT_CheckTimer+0x28>
 802082c:	4b31      	ldr	r3, [pc, #196]	; (80208f4 <ECAT_CheckTimer+0xd4>)
 802082e:	881b      	ldrh	r3, [r3, #0]
 8020830:	b21b      	sxth	r3, r3
 8020832:	2b00      	cmp	r3, #0
 8020834:	dd08      	ble.n	8020848 <ECAT_CheckTimer+0x28>
    {
        EsmTimeoutCounter--;
 8020836:	4b2f      	ldr	r3, [pc, #188]	; (80208f4 <ECAT_CheckTimer+0xd4>)
 8020838:	881b      	ldrh	r3, [r3, #0]
 802083a:	b29b      	uxth	r3, r3
 802083c:	b29b      	uxth	r3, r3
 802083e:	3b01      	subs	r3, #1
 8020840:	b29b      	uxth	r3, r3
 8020842:	b29a      	uxth	r2, r3
 8020844:	4b2b      	ldr	r3, [pc, #172]	; (80208f4 <ECAT_CheckTimer+0xd4>)
 8020846:	801a      	strh	r2, [r3, #0]
    }



    DC_CheckWatchdog();
 8020848:	f000 fc1a 	bl	8021080 <DC_CheckWatchdog>


    if (u16EepromStoreTimeoutValue > 0)
 802084c:	4b2a      	ldr	r3, [pc, #168]	; (80208f8 <ECAT_CheckTimer+0xd8>)
 802084e:	881b      	ldrh	r3, [r3, #0]
 8020850:	2b00      	cmp	r3, #0
 8020852:	d018      	beq.n	8020886 <ECAT_CheckTimer+0x66>
    {
        u16EepromStoreTimeoutCounter++;
 8020854:	4b29      	ldr	r3, [pc, #164]	; (80208fc <ECAT_CheckTimer+0xdc>)
 8020856:	881b      	ldrh	r3, [r3, #0]
 8020858:	3301      	adds	r3, #1
 802085a:	b29a      	uxth	r2, r3
 802085c:	4b27      	ldr	r3, [pc, #156]	; (80208fc <ECAT_CheckTimer+0xdc>)
 802085e:	801a      	strh	r2, [r3, #0]

        if (u16EepromStoreTimeoutValue <= u16EepromStoreTimeoutCounter)
 8020860:	4b25      	ldr	r3, [pc, #148]	; (80208f8 <ECAT_CheckTimer+0xd8>)
 8020862:	881a      	ldrh	r2, [r3, #0]
 8020864:	4b25      	ldr	r3, [pc, #148]	; (80208fc <ECAT_CheckTimer+0xdc>)
 8020866:	881b      	ldrh	r3, [r3, #0]
 8020868:	429a      	cmp	r2, r3
 802086a:	d80c      	bhi.n	8020886 <ECAT_CheckTimer+0x66>
        {
            u16EepromStoreTimeoutValue = 0;
 802086c:	4b22      	ldr	r3, [pc, #136]	; (80208f8 <ECAT_CheckTimer+0xd8>)
 802086e:	2200      	movs	r2, #0
 8020870:	801a      	strh	r2, [r3, #0]
            u16EepromStoreTimeoutCounter = 0;
 8020872:	4b22      	ldr	r3, [pc, #136]	; (80208fc <ECAT_CheckTimer+0xdc>)
 8020874:	2200      	movs	r2, #0
 8020876:	801a      	strh	r2, [r3, #0]

            if (pAPPL_EEPROM_Store != NULL)
 8020878:	4b21      	ldr	r3, [pc, #132]	; (8020900 <ECAT_CheckTimer+0xe0>)
 802087a:	681b      	ldr	r3, [r3, #0]
 802087c:	2b00      	cmp	r3, #0
 802087e:	d002      	beq.n	8020886 <ECAT_CheckTimer+0x66>
            {
                pAPPL_EEPROM_Store();
 8020880:	4b1f      	ldr	r3, [pc, #124]	; (8020900 <ECAT_CheckTimer+0xe0>)
 8020882:	681b      	ldr	r3, [r3, #0]
 8020884:	4798      	blx	r3



/*ECATCHANGE_START(V5.13) */
    /* Increment the counter every ms between two updates based on the system time (32Bit overrun is handled in COE_SyncTimeStamp) */
    if (!b32BitDc || ((u64Timestamp & 0xFFFFFFFF) <= 4293000000UL))
 8020886:	4b1f      	ldr	r3, [pc, #124]	; (8020904 <ECAT_CheckTimer+0xe4>)
 8020888:	781b      	ldrb	r3, [r3, #0]
 802088a:	f083 0301 	eor.w	r3, r3, #1
 802088e:	b2db      	uxtb	r3, r3
 8020890:	2b00      	cmp	r3, #0
 8020892:	d111      	bne.n	80208b8 <ECAT_CheckTimer+0x98>
 8020894:	4b1c      	ldr	r3, [pc, #112]	; (8020908 <ECAT_CheckTimer+0xe8>)
 8020896:	e9d3 2300 	ldrd	r2, r3, [r3]
 802089a:	f04f 30ff 	mov.w	r0, #4294967295
 802089e:	f04f 0100 	mov.w	r1, #0
 80208a2:	ea02 0200 	and.w	r2, r2, r0
 80208a6:	ea03 0301 	and.w	r3, r3, r1
 80208aa:	4818      	ldr	r0, [pc, #96]	; (802090c <ECAT_CheckTimer+0xec>)
 80208ac:	f04f 0100 	mov.w	r1, #0
 80208b0:	4299      	cmp	r1, r3
 80208b2:	bf08      	it	eq
 80208b4:	4290      	cmpeq	r0, r2
 80208b6:	d30c      	bcc.n	80208d2 <ECAT_CheckTimer+0xb2>
/*ECATCHANGE_END(V5.13) */
    {

        /* the timestamp is stored in ns */
        u64Timestamp = u64Timestamp + 1000000;
 80208b8:	4b13      	ldr	r3, [pc, #76]	; (8020908 <ECAT_CheckTimer+0xe8>)
 80208ba:	e9d3 2300 	ldrd	r2, r3, [r3]
 80208be:	4814      	ldr	r0, [pc, #80]	; (8020910 <ECAT_CheckTimer+0xf0>)
 80208c0:	f04f 0100 	mov.w	r1, #0
 80208c4:	1812      	adds	r2, r2, r0
 80208c6:	eb43 0301 	adc.w	r3, r3, r1
 80208ca:	490f      	ldr	r1, [pc, #60]	; (8020908 <ECAT_CheckTimer+0xe8>)
 80208cc:	e9c1 2300 	strd	r2, r3, [r1]
 80208d0:	e007      	b.n	80208e2 <ECAT_CheckTimer+0xc2>

    }
    else if(b32BitDc)
 80208d2:	4b0c      	ldr	r3, [pc, #48]	; (8020904 <ECAT_CheckTimer+0xe4>)
 80208d4:	781b      	ldrb	r3, [r3, #0]
 80208d6:	2b00      	cmp	r3, #0
 80208d8:	d003      	beq.n	80208e2 <ECAT_CheckTimer+0xc2>
    {
        /* in case of a 32Bit DC and almost expired time stamp check for a DC overrun*/
        u32CheckForDcOverrunCnt = CHECK_DC_OVERRUN_IN_MS;
 80208da:	4b0e      	ldr	r3, [pc, #56]	; (8020914 <ECAT_CheckTimer+0xf4>)
 80208dc:	f44f 627a 	mov.w	r2, #4000	; 0xfa0
 80208e0:	601a      	str	r2, [r3, #0]
    }

    u32CheckForDcOverrunCnt++;
 80208e2:	4b0c      	ldr	r3, [pc, #48]	; (8020914 <ECAT_CheckTimer+0xf4>)
 80208e4:	681b      	ldr	r3, [r3, #0]
 80208e6:	3301      	adds	r3, #1
 80208e8:	4a0a      	ldr	r2, [pc, #40]	; (8020914 <ECAT_CheckTimer+0xf4>)
 80208ea:	6013      	str	r3, [r2, #0]


}
 80208ec:	bd80      	pop	{r7, pc}
 80208ee:	bf00      	nop
 80208f0:	1fff29e0 	.word	0x1fff29e0
 80208f4:	1fff29ea 	.word	0x1fff29ea
 80208f8:	1fff29a8 	.word	0x1fff29a8
 80208fc:	1fff28ec 	.word	0x1fff28ec
 8020900:	1fff2828 	.word	0x1fff2828
 8020904:	1fff29dc 	.word	0x1fff29dc
 8020908:	1fff17e0 	.word	0x1fff17e0
 802090c:	ffe1fb40 	.word	0xffe1fb40
 8020910:	000f4240 	.word	0x000f4240
 8020914:	1fff2824 	.word	0x1fff2824

08020918 <HandleCycleTimeMeasurement>:
/////////////////////////////////////////////////////////////////////////////////////////
/**
\brief    In case of non DC synchronization the cycle time measurement is started and 0x1C3.2 (Cycle time) is updated
*////////////////////////////////////////////////////////////////////////////////////////
void HandleCycleTimeMeasurement(void)
{
 8020918:	b580      	push	{r7, lr}
 802091a:	af00      	add	r7, sp, #0
    if (!bDcSyncActive) //no DC sync configured (cycle time measurement 0x1C3x.2 is only available in no DC sync modes)
 802091c:	4b1a      	ldr	r3, [pc, #104]	; (8020988 <HandleCycleTimeMeasurement+0x70>)
 802091e:	781b      	ldrb	r3, [r3, #0]
 8020920:	f083 0301 	eor.w	r3, r3, #1
 8020924:	b2db      	uxtb	r3, r3
 8020926:	2b00      	cmp	r3, #0
 8020928:	d02d      	beq.n	8020986 <HandleCycleTimeMeasurement+0x6e>
    {
        if (u32CycleTimeStartValue > 0)
 802092a:	4b18      	ldr	r3, [pc, #96]	; (802098c <HandleCycleTimeMeasurement+0x74>)
 802092c:	681b      	ldr	r3, [r3, #0]
 802092e:	2b00      	cmp	r3, #0
 8020930:	d023      	beq.n	802097a <HandleCycleTimeMeasurement+0x62>
        {
            /* bus cycle completed*/
            u32CycleTimeStartValue = GetSystemTimeDelay(u32CycleTimeStartValue);
 8020932:	4b16      	ldr	r3, [pc, #88]	; (802098c <HandleCycleTimeMeasurement+0x74>)
 8020934:	681b      	ldr	r3, [r3, #0]
 8020936:	4618      	mov	r0, r3
 8020938:	f000 f82e 	bl	8020998 <GetSystemTimeDelay>
 802093c:	4602      	mov	r2, r0
 802093e:	4b13      	ldr	r3, [pc, #76]	; (802098c <HandleCycleTimeMeasurement+0x74>)
 8020940:	601a      	str	r2, [r3, #0]

            if ((sSyncManOutPar.u32CycleTime == 0) || (sSyncManOutPar.u32CycleTime > u32CycleTimeStartValue))
 8020942:	4b13      	ldr	r3, [pc, #76]	; (8020990 <HandleCycleTimeMeasurement+0x78>)
 8020944:	685b      	ldr	r3, [r3, #4]
 8020946:	2b00      	cmp	r3, #0
 8020948:	d005      	beq.n	8020956 <HandleCycleTimeMeasurement+0x3e>
 802094a:	4b11      	ldr	r3, [pc, #68]	; (8020990 <HandleCycleTimeMeasurement+0x78>)
 802094c:	685a      	ldr	r2, [r3, #4]
 802094e:	4b0f      	ldr	r3, [pc, #60]	; (802098c <HandleCycleTimeMeasurement+0x74>)
 8020950:	681b      	ldr	r3, [r3, #0]
 8020952:	429a      	cmp	r2, r3
 8020954:	d903      	bls.n	802095e <HandleCycleTimeMeasurement+0x46>
            {
                    sSyncManOutPar.u32CycleTime = u32CycleTimeStartValue;
 8020956:	4b0d      	ldr	r3, [pc, #52]	; (802098c <HandleCycleTimeMeasurement+0x74>)
 8020958:	681b      	ldr	r3, [r3, #0]
 802095a:	4a0d      	ldr	r2, [pc, #52]	; (8020990 <HandleCycleTimeMeasurement+0x78>)
 802095c:	6053      	str	r3, [r2, #4]
            }

            if ((sSyncManInPar.u32CycleTime == 0) || (sSyncManInPar.u32CycleTime > u32CycleTimeStartValue))
 802095e:	4b0d      	ldr	r3, [pc, #52]	; (8020994 <HandleCycleTimeMeasurement+0x7c>)
 8020960:	685b      	ldr	r3, [r3, #4]
 8020962:	2b00      	cmp	r3, #0
 8020964:	d005      	beq.n	8020972 <HandleCycleTimeMeasurement+0x5a>
 8020966:	4b0b      	ldr	r3, [pc, #44]	; (8020994 <HandleCycleTimeMeasurement+0x7c>)
 8020968:	685a      	ldr	r2, [r3, #4]
 802096a:	4b08      	ldr	r3, [pc, #32]	; (802098c <HandleCycleTimeMeasurement+0x74>)
 802096c:	681b      	ldr	r3, [r3, #0]
 802096e:	429a      	cmp	r2, r3
 8020970:	d903      	bls.n	802097a <HandleCycleTimeMeasurement+0x62>
            {
                    sSyncManInPar.u32CycleTime = u32CycleTimeStartValue;
 8020972:	4b06      	ldr	r3, [pc, #24]	; (802098c <HandleCycleTimeMeasurement+0x74>)
 8020974:	681b      	ldr	r3, [r3, #0]
 8020976:	4a07      	ldr	r2, [pc, #28]	; (8020994 <HandleCycleTimeMeasurement+0x7c>)
 8020978:	6053      	str	r3, [r2, #4]
            }
        }
        /* get next start value */
        u32CycleTimeStartValue = GetSystemTimeDelay(0);
 802097a:	2000      	movs	r0, #0
 802097c:	f000 f80c 	bl	8020998 <GetSystemTimeDelay>
 8020980:	4602      	mov	r2, r0
 8020982:	4b02      	ldr	r3, [pc, #8]	; (802098c <HandleCycleTimeMeasurement+0x74>)
 8020984:	601a      	str	r2, [r3, #0]
        
    }/* No DC sync configured */
}
 8020986:	bd80      	pop	{r7, pc}
 8020988:	1fff29ec 	.word	0x1fff29ec
 802098c:	1fff2834 	.word	0x1fff2834
 8020990:	1fff2ad4 	.word	0x1fff2ad4
 8020994:	1fff2a90 	.word	0x1fff2a90

08020998 <GetSystemTimeDelay>:
\brief    Calculates the difference between the old and current system time value in ns.
          NOTE: This function only handles a 32Bit system time values (therefore the maximum delay about 4sec).
*////////////////////////////////////////////////////////////////////////////////////////

UINT32 GetSystemTimeDelay(UINT32 u32StartTime)
{
 8020998:	b480      	push	{r7}
 802099a:	b085      	sub	sp, #20
 802099c:	af00      	add	r7, sp, #0
 802099e:	6078      	str	r0, [r7, #4]
   UINT32 u32CurValue = 0;
 80209a0:	2300      	movs	r3, #0
 80209a2:	60bb      	str	r3, [r7, #8]
   UINT32 u32Delta = 0;
 80209a4:	2300      	movs	r3, #0
 80209a6:	60fb      	str	r3, [r7, #12]

   
   HW_EscReadDWordIsr(u32CurValue, ESC_SYSTEMTIME_OFFSET);
 80209a8:	4b15      	ldr	r3, [pc, #84]	; (8020a00 <GetSystemTimeDelay+0x68>)
 80209aa:	681b      	ldr	r3, [r3, #0]
 80209ac:	60bb      	str	r3, [r7, #8]

   if (u32CurValue > 0)
 80209ae:	68bb      	ldr	r3, [r7, #8]
 80209b0:	2b00      	cmp	r3, #0
 80209b2:	d00d      	beq.n	80209d0 <GetSystemTimeDelay+0x38>
   {
      if (u32StartTime <= u32CurValue)
 80209b4:	687a      	ldr	r2, [r7, #4]
 80209b6:	68bb      	ldr	r3, [r7, #8]
 80209b8:	429a      	cmp	r2, r3
 80209ba:	d804      	bhi.n	80209c6 <GetSystemTimeDelay+0x2e>
      {
         u32Delta = u32CurValue - u32StartTime;
 80209bc:	68ba      	ldr	r2, [r7, #8]
 80209be:	687b      	ldr	r3, [r7, #4]
 80209c0:	1ad3      	subs	r3, r2, r3
 80209c2:	60fb      	str	r3, [r7, #12]
 80209c4:	e004      	b.n	80209d0 <GetSystemTimeDelay+0x38>
      }
      else
      {
         //The 32Bit timer is wrapped around
         u32Delta = u32CurValue + (0xFFFFFFFF - u32StartTime);
 80209c6:	68ba      	ldr	r2, [r7, #8]
 80209c8:	687b      	ldr	r3, [r7, #4]
 80209ca:	1ad3      	subs	r3, r2, r3
 80209cc:	3b01      	subs	r3, #1
 80209ce:	60fb      	str	r3, [r7, #12]
      }
   }// current value successfully read out

   if (u32StartTime > 0)
 80209d0:	687b      	ldr	r3, [r7, #4]
 80209d2:	2b00      	cmp	r3, #0
 80209d4:	d00c      	beq.n	80209f0 <GetSystemTimeDelay+0x58>
   {

       /*the difference between two timestamps are calculated => subtract measurement failure*/
       if (u32SystemTimeReadFailure < u32Delta)
 80209d6:	4b0b      	ldr	r3, [pc, #44]	; (8020a04 <GetSystemTimeDelay+0x6c>)
 80209d8:	681a      	ldr	r2, [r3, #0]
 80209da:	68fb      	ldr	r3, [r7, #12]
 80209dc:	429a      	cmp	r2, r3
 80209de:	d205      	bcs.n	80209ec <GetSystemTimeDelay+0x54>
       {
           u32Delta = u32Delta - u32SystemTimeReadFailure;
 80209e0:	4b08      	ldr	r3, [pc, #32]	; (8020a04 <GetSystemTimeDelay+0x6c>)
 80209e2:	681b      	ldr	r3, [r3, #0]
 80209e4:	68fa      	ldr	r2, [r7, #12]
 80209e6:	1ad3      	subs	r3, r2, r3
 80209e8:	60fb      	str	r3, [r7, #12]
 80209ea:	e001      	b.n	80209f0 <GetSystemTimeDelay+0x58>
       }
       else
       {
           /*set the delta to 0 if the measurement failure is greater than the calculated difference*/
           u32Delta = 0;
 80209ec:	2300      	movs	r3, #0
 80209ee:	60fb      	str	r3, [r7, #12]
       }
   }
   return u32Delta;
 80209f0:	68fb      	ldr	r3, [r7, #12]
}
 80209f2:	4618      	mov	r0, r3
 80209f4:	3714      	adds	r7, #20
 80209f6:	46bd      	mov	sp, r7
 80209f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80209fc:	4770      	bx	lr
 80209fe:	bf00      	nop
 8020a00:	54010910 	.word	0x54010910
 8020a04:	1fff2844 	.word	0x1fff2844

08020a08 <PDI_Isr>:

/*ECATCHANGE_START(V5.13) ECAT1*/
/*ECATCHANGE_END(V5.13) ECAT1*/
void PDI_Isr(void)
{
 8020a08:	b580      	push	{r7, lr}
 8020a0a:	b082      	sub	sp, #8
 8020a0c:	af00      	add	r7, sp, #0
    /*ECATCHANGE_START(V5.13) ECAT1*/
    BOOL SyncAcknowledgePending = FALSE;
 8020a0e:	2300      	movs	r3, #0
 8020a10:	71fb      	strb	r3, [r7, #7]

    /* get the AL event register */
    UINT16  ALEvent = HW_GetALEventRegister_Isr();
 8020a12:	f7ff fe5b 	bl	80206cc <HW_GetALEventRegister_Isr>
 8020a16:	4603      	mov	r3, r0
 8020a18:	80bb      	strh	r3, [r7, #4]
    ALEvent = SWAPWORD(ALEvent);


    /* Check if Sync1 Isr has to be called */

    if (ALEvent & SYNC1_EVENT)
 8020a1a:	88bb      	ldrh	r3, [r7, #4]
 8020a1c:	f003 0308 	and.w	r3, r3, #8
 8020a20:	2b00      	cmp	r3, #0
 8020a22:	d003      	beq.n	8020a2c <PDI_Isr+0x24>
    {
        Sync1_Isr();
 8020a24:	f000 f974 	bl	8020d10 <Sync1_Isr>

        SyncAcknowledgePending = TRUE;
 8020a28:	2301      	movs	r3, #1
 8020a2a:	71fb      	strb	r3, [r7, #7]
    }
    /*ECATCHANGE_END(V5.13) ECAT1*/
    

    if(bEscIntEnabled)
 8020a2c:	4b4d      	ldr	r3, [pc, #308]	; (8020b64 <PDI_Isr+0x15c>)
 8020a2e:	781b      	ldrb	r3, [r3, #0]
 8020a30:	2b00      	cmp	r3, #0
 8020a32:	f000 8081 	beq.w	8020b38 <PDI_Isr+0x130>
    {
        if ( ALEvent & PROCESS_OUTPUT_EVENT )
 8020a36:	88bb      	ldrh	r3, [r7, #4]
 8020a38:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8020a3c:	2b00      	cmp	r3, #0
 8020a3e:	d039      	beq.n	8020ab4 <PDI_Isr+0xac>
        {
            if(bDcRunning && bDcSyncActive)
 8020a40:	4b49      	ldr	r3, [pc, #292]	; (8020b68 <PDI_Isr+0x160>)
 8020a42:	781b      	ldrb	r3, [r3, #0]
 8020a44:	2b00      	cmp	r3, #0
 8020a46:	d006      	beq.n	8020a56 <PDI_Isr+0x4e>
 8020a48:	4b48      	ldr	r3, [pc, #288]	; (8020b6c <PDI_Isr+0x164>)
 8020a4a:	781b      	ldrb	r3, [r3, #0]
 8020a4c:	2b00      	cmp	r3, #0
 8020a4e:	d002      	beq.n	8020a56 <PDI_Isr+0x4e>
            {
                /* Reset SM/Sync0 counter. Will be incremented on every Sync0 event*/
                u16SmSync0Counter = 0;
 8020a50:	4b47      	ldr	r3, [pc, #284]	; (8020b70 <PDI_Isr+0x168>)
 8020a52:	2200      	movs	r2, #0
 8020a54:	801a      	strh	r2, [r3, #0]
            }
            if(sSyncManOutPar.u16SmEventMissedCounter > 0)
 8020a56:	4b47      	ldr	r3, [pc, #284]	; (8020b74 <PDI_Isr+0x16c>)
 8020a58:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8020a5a:	2b00      	cmp	r3, #0
 8020a5c:	d005      	beq.n	8020a6a <PDI_Isr+0x62>
            {
                sSyncManOutPar.u16SmEventMissedCounter--;
 8020a5e:	4b45      	ldr	r3, [pc, #276]	; (8020b74 <PDI_Isr+0x16c>)
 8020a60:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8020a62:	3b01      	subs	r3, #1
 8020a64:	b29a      	uxth	r2, r3
 8020a66:	4b43      	ldr	r3, [pc, #268]	; (8020b74 <PDI_Isr+0x16c>)
 8020a68:	851a      	strh	r2, [r3, #40]	; 0x28
            }

            sSyncManInPar.u16SmEventMissedCounter = sSyncManOutPar.u16SmEventMissedCounter;
 8020a6a:	4b42      	ldr	r3, [pc, #264]	; (8020b74 <PDI_Isr+0x16c>)
 8020a6c:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 8020a6e:	4b42      	ldr	r3, [pc, #264]	; (8020b78 <PDI_Isr+0x170>)
 8020a70:	851a      	strh	r2, [r3, #40]	; 0x28



        /* Outputs were updated, set flag for watchdog monitoring */
        bEcatFirstOutputsReceived = TRUE;
 8020a72:	4b42      	ldr	r3, [pc, #264]	; (8020b7c <PDI_Isr+0x174>)
 8020a74:	2201      	movs	r2, #1
 8020a76:	701a      	strb	r2, [r3, #0]


        /*
            handle output process data event
        */
        if ( bEcatOutputUpdateRunning )
 8020a78:	4b41      	ldr	r3, [pc, #260]	; (8020b80 <PDI_Isr+0x178>)
 8020a7a:	781b      	ldrb	r3, [r3, #0]
 8020a7c:	2b00      	cmp	r3, #0
 8020a7e:	d002      	beq.n	8020a86 <PDI_Isr+0x7e>
        {
            /* slave is in OP, update the outputs */
            PDO_OutputMapping();
 8020a80:	f7ff fe76 	bl	8020770 <PDO_OutputMapping>
 8020a84:	e016      	b.n	8020ab4 <PDI_Isr+0xac>
        }
        else
        {
            /* Just acknowledge the process data event in the INIT,PreOP and SafeOP state */
            HW_EscReadByteIsr(u8dummy,nEscAddrOutputData);
 8020a86:	4b3f      	ldr	r3, [pc, #252]	; (8020b84 <PDI_Isr+0x17c>)
 8020a88:	881b      	ldrh	r3, [r3, #0]
 8020a8a:	f103 43a8 	add.w	r3, r3, #1409286144	; 0x54000000
 8020a8e:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 8020a92:	781b      	ldrb	r3, [r3, #0]
 8020a94:	b2da      	uxtb	r2, r3
 8020a96:	4b3c      	ldr	r3, [pc, #240]	; (8020b88 <PDI_Isr+0x180>)
 8020a98:	701a      	strb	r2, [r3, #0]
            HW_EscReadByteIsr(u8dummy,(nEscAddrOutputData+nPdOutputSize-1));
 8020a9a:	4b3a      	ldr	r3, [pc, #232]	; (8020b84 <PDI_Isr+0x17c>)
 8020a9c:	881b      	ldrh	r3, [r3, #0]
 8020a9e:	461a      	mov	r2, r3
 8020aa0:	4b3a      	ldr	r3, [pc, #232]	; (8020b8c <PDI_Isr+0x184>)
 8020aa2:	881b      	ldrh	r3, [r3, #0]
 8020aa4:	4413      	add	r3, r2
 8020aa6:	461a      	mov	r2, r3
 8020aa8:	4b39      	ldr	r3, [pc, #228]	; (8020b90 <PDI_Isr+0x188>)
 8020aaa:	4413      	add	r3, r2
 8020aac:	781b      	ldrb	r3, [r3, #0]
 8020aae:	b2da      	uxtb	r2, r3
 8020ab0:	4b35      	ldr	r3, [pc, #212]	; (8020b88 <PDI_Isr+0x180>)
 8020ab2:	701a      	strb	r2, [r3, #0]
        }

        /*
            Call ECAT_Application() in SM Sync mode
        */
        if (sSyncManOutPar.u16SyncType == SYNCTYPE_SM_SYNCHRON)
 8020ab4:	4b2f      	ldr	r3, [pc, #188]	; (8020b74 <PDI_Isr+0x16c>)
 8020ab6:	885b      	ldrh	r3, [r3, #2]
 8020ab8:	2b01      	cmp	r3, #1
 8020aba:	d101      	bne.n	8020ac0 <PDI_Isr+0xb8>
        {
            /* The Application is synchronized to process data Sync Manager event*/
            ECAT_Application();
 8020abc:	f000 f9ea 	bl	8020e94 <ECAT_Application>
        }

/*ECATCHANGE_START(V5.13) ECAT 5*/
    if ( (bEcatInputUpdateRunning == TRUE) && (nPdInputSize > 0)
 8020ac0:	4b34      	ldr	r3, [pc, #208]	; (8020b94 <PDI_Isr+0x18c>)
 8020ac2:	781b      	ldrb	r3, [r3, #0]
 8020ac4:	2b00      	cmp	r3, #0
 8020ac6:	d00d      	beq.n	8020ae4 <PDI_Isr+0xdc>
 8020ac8:	4b33      	ldr	r3, [pc, #204]	; (8020b98 <PDI_Isr+0x190>)
 8020aca:	881b      	ldrh	r3, [r3, #0]
 8020acc:	2b00      	cmp	r3, #0
 8020ace:	d009      	beq.n	8020ae4 <PDI_Isr+0xdc>
/*ECATCHANGE_END(V5.13) ECAT 5*/
       && ((sSyncManInPar.u16SyncType == SYNCTYPE_SM_SYNCHRON) || (sSyncManInPar.u16SyncType == SYNCTYPE_SM2_SYNCHRON))
 8020ad0:	4b29      	ldr	r3, [pc, #164]	; (8020b78 <PDI_Isr+0x170>)
 8020ad2:	885b      	ldrh	r3, [r3, #2]
 8020ad4:	2b01      	cmp	r3, #1
 8020ad6:	d003      	beq.n	8020ae0 <PDI_Isr+0xd8>
 8020ad8:	4b27      	ldr	r3, [pc, #156]	; (8020b78 <PDI_Isr+0x170>)
 8020ada:	885b      	ldrh	r3, [r3, #2]
 8020adc:	2b22      	cmp	r3, #34	; 0x22
 8020ade:	d101      	bne.n	8020ae4 <PDI_Isr+0xdc>
        )
    {
        /* EtherCAT slave is at least in SAFE-OPERATIONAL, update inputs */
        PDO_InputMapping();
 8020ae0:	f7ff fdfc 	bl	80206dc <PDO_InputMapping>

    /*
      Check if cycle exceed
    */
    /*if next SM event was triggered during runtime increment cycle exceed counter*/
    ALEvent = HW_GetALEventRegister_Isr();
 8020ae4:	f7ff fdf2 	bl	80206cc <HW_GetALEventRegister_Isr>
 8020ae8:	4603      	mov	r3, r0
 8020aea:	80bb      	strh	r3, [r7, #4]
    ALEvent = SWAPWORD(ALEvent);

    if ( ALEvent & PROCESS_OUTPUT_EVENT )
 8020aec:	88bb      	ldrh	r3, [r7, #4]
 8020aee:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8020af2:	2b00      	cmp	r3, #0
 8020af4:	d020      	beq.n	8020b38 <PDI_Isr+0x130>
    {
        sSyncManOutPar.u16CycleExceededCounter++;
 8020af6:	4b1f      	ldr	r3, [pc, #124]	; (8020b74 <PDI_Isr+0x16c>)
 8020af8:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8020afa:	3301      	adds	r3, #1
 8020afc:	b29a      	uxth	r2, r3
 8020afe:	4b1d      	ldr	r3, [pc, #116]	; (8020b74 <PDI_Isr+0x16c>)
 8020b00:	855a      	strh	r2, [r3, #42]	; 0x2a
        sSyncManInPar.u16CycleExceededCounter = sSyncManOutPar.u16CycleExceededCounter;
 8020b02:	4b1c      	ldr	r3, [pc, #112]	; (8020b74 <PDI_Isr+0x16c>)
 8020b04:	8d5a      	ldrh	r2, [r3, #42]	; 0x2a
 8020b06:	4b1c      	ldr	r3, [pc, #112]	; (8020b78 <PDI_Isr+0x170>)
 8020b08:	855a      	strh	r2, [r3, #42]	; 0x2a

      /* Acknowledge the process data event*/
            HW_EscReadByteIsr(u8dummy,nEscAddrOutputData);
 8020b0a:	4b1e      	ldr	r3, [pc, #120]	; (8020b84 <PDI_Isr+0x17c>)
 8020b0c:	881b      	ldrh	r3, [r3, #0]
 8020b0e:	f103 43a8 	add.w	r3, r3, #1409286144	; 0x54000000
 8020b12:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 8020b16:	781b      	ldrb	r3, [r3, #0]
 8020b18:	b2da      	uxtb	r2, r3
 8020b1a:	4b1b      	ldr	r3, [pc, #108]	; (8020b88 <PDI_Isr+0x180>)
 8020b1c:	701a      	strb	r2, [r3, #0]
            HW_EscReadByteIsr(u8dummy,(nEscAddrOutputData+nPdOutputSize-1));
 8020b1e:	4b19      	ldr	r3, [pc, #100]	; (8020b84 <PDI_Isr+0x17c>)
 8020b20:	881b      	ldrh	r3, [r3, #0]
 8020b22:	461a      	mov	r2, r3
 8020b24:	4b19      	ldr	r3, [pc, #100]	; (8020b8c <PDI_Isr+0x184>)
 8020b26:	881b      	ldrh	r3, [r3, #0]
 8020b28:	4413      	add	r3, r2
 8020b2a:	461a      	mov	r2, r3
 8020b2c:	4b18      	ldr	r3, [pc, #96]	; (8020b90 <PDI_Isr+0x188>)
 8020b2e:	4413      	add	r3, r2
 8020b30:	781b      	ldrb	r3, [r3, #0]
 8020b32:	b2da      	uxtb	r2, r3
 8020b34:	4b14      	ldr	r3, [pc, #80]	; (8020b88 <PDI_Isr+0x180>)
 8020b36:	701a      	strb	r2, [r3, #0]
    }
    } //if(bEscIntEnabled)

      /*ECATCHANGE_START(V5.13) ECAT1*/
    if (ALEvent & SYNC0_EVENT)
 8020b38:	88bb      	ldrh	r3, [r7, #4]
 8020b3a:	f003 0304 	and.w	r3, r3, #4
 8020b3e:	2b00      	cmp	r3, #0
 8020b40:	d003      	beq.n	8020b4a <PDI_Isr+0x142>
    {
        Sync0_Isr();
 8020b42:	f000 f82d 	bl	8020ba0 <Sync0_Isr>

        SyncAcknowledgePending = TRUE;
 8020b46:	2301      	movs	r3, #1
 8020b48:	71fb      	strb	r3, [r7, #7]
    }

    /* Read Sync0/1 Status Register to acknowledge the event bit in the AL Event register */
    if (SyncAcknowledgePending)
 8020b4a:	79fb      	ldrb	r3, [r7, #7]
 8020b4c:	2b00      	cmp	r3, #0
 8020b4e:	d004      	beq.n	8020b5a <PDI_Isr+0x152>
    {
        volatile UINT32 SyncState = 0;
 8020b50:	2300      	movs	r3, #0
 8020b52:	603b      	str	r3, [r7, #0]
        HW_EscReadDWord(SyncState, ESC_DC_SYNC_STATUS);
 8020b54:	4b11      	ldr	r3, [pc, #68]	; (8020b9c <PDI_Isr+0x194>)
 8020b56:	681b      	ldr	r3, [r3, #0]
 8020b58:	603b      	str	r3, [r7, #0]

    }
    /*ECATCHANGE_END(V5.13) ECAT1*/

    COE_UpdateSyncErrorStatus();
 8020b5a:	f7ff fb5d 	bl	8020218 <COE_UpdateSyncErrorStatus>

}
 8020b5e:	3708      	adds	r7, #8
 8020b60:	46bd      	mov	sp, r7
 8020b62:	bd80      	pop	{r7, pc}
 8020b64:	1fff29f3 	.word	0x1fff29f3
 8020b68:	1fff29d0 	.word	0x1fff29d0
 8020b6c:	1fff29ec 	.word	0x1fff29ec
 8020b70:	1fff29f6 	.word	0x1fff29f6
 8020b74:	1fff2ad4 	.word	0x1fff2ad4
 8020b78:	1fff2a90 	.word	0x1fff2a90
 8020b7c:	1fff29e8 	.word	0x1fff29e8
 8020b80:	1fff29ed 	.word	0x1fff29ed
 8020b84:	1fff29c2 	.word	0x1fff29c2
 8020b88:	1fff29cc 	.word	0x1fff29cc
 8020b8c:	1fff29b6 	.word	0x1fff29b6
 8020b90:	5400ffff 	.word	0x5400ffff
 8020b94:	1fff29f2 	.word	0x1fff29f2
 8020b98:	1fff29e2 	.word	0x1fff29e2
 8020b9c:	5401098c 	.word	0x5401098c

08020ba0 <Sync0_Isr>:

void Sync0_Isr(void)
{
 8020ba0:	b580      	push	{r7, lr}
 8020ba2:	b082      	sub	sp, #8
 8020ba4:	af00      	add	r7, sp, #0
     Sync0WdCounter = 0;
 8020ba6:	4b4e      	ldr	r3, [pc, #312]	; (8020ce0 <Sync0_Isr+0x140>)
 8020ba8:	2200      	movs	r2, #0
 8020baa:	801a      	strh	r2, [r3, #0]

    if(bDcSyncActive)
 8020bac:	4b4d      	ldr	r3, [pc, #308]	; (8020ce4 <Sync0_Isr+0x144>)
 8020bae:	781b      	ldrb	r3, [r3, #0]
 8020bb0:	2b00      	cmp	r3, #0
 8020bb2:	f000 8090 	beq.w	8020cd6 <Sync0_Isr+0x136>
    {
/*ECATCHANGE_START(V5.13) ECAT 6*/
        BOOL bCallInputMapping = FALSE;
 8020bb6:	2300      	movs	r3, #0
 8020bb8:	71fb      	strb	r3, [r7, #7]
/*ECATCHANGE_END(V5.13) ECAT 6*/

/*ECATCHANGE_START(V5.13) ECAT 6*/
        if ((bEcatInputUpdateRunning == TRUE) && (LatchInputSync0Value > 0) && (nPdInputSize > 0))
 8020bba:	4b4b      	ldr	r3, [pc, #300]	; (8020ce8 <Sync0_Isr+0x148>)
 8020bbc:	781b      	ldrb	r3, [r3, #0]
 8020bbe:	2b00      	cmp	r3, #0
 8020bc0:	d01b      	beq.n	8020bfa <Sync0_Isr+0x5a>
 8020bc2:	4b4a      	ldr	r3, [pc, #296]	; (8020cec <Sync0_Isr+0x14c>)
 8020bc4:	881b      	ldrh	r3, [r3, #0]
 8020bc6:	2b00      	cmp	r3, #0
 8020bc8:	d017      	beq.n	8020bfa <Sync0_Isr+0x5a>
 8020bca:	4b49      	ldr	r3, [pc, #292]	; (8020cf0 <Sync0_Isr+0x150>)
 8020bcc:	881b      	ldrh	r3, [r3, #0]
 8020bce:	2b00      	cmp	r3, #0
 8020bd0:	d013      	beq.n	8020bfa <Sync0_Isr+0x5a>
        {
            if(LatchInputSync0Value > LatchInputSync0Counter) /* Inputs shall be latched on a specific Sync0 event */
 8020bd2:	4b46      	ldr	r3, [pc, #280]	; (8020cec <Sync0_Isr+0x14c>)
 8020bd4:	881a      	ldrh	r2, [r3, #0]
 8020bd6:	4b47      	ldr	r3, [pc, #284]	; (8020cf4 <Sync0_Isr+0x154>)
 8020bd8:	881b      	ldrh	r3, [r3, #0]
 8020bda:	429a      	cmp	r2, r3
 8020bdc:	d905      	bls.n	8020bea <Sync0_Isr+0x4a>
            {
                LatchInputSync0Counter++;
 8020bde:	4b45      	ldr	r3, [pc, #276]	; (8020cf4 <Sync0_Isr+0x154>)
 8020be0:	881b      	ldrh	r3, [r3, #0]
 8020be2:	3301      	adds	r3, #1
 8020be4:	b29a      	uxth	r2, r3
 8020be6:	4b43      	ldr	r3, [pc, #268]	; (8020cf4 <Sync0_Isr+0x154>)
 8020be8:	801a      	strh	r2, [r3, #0]
            }

            if (LatchInputSync0Value == LatchInputSync0Counter)
 8020bea:	4b40      	ldr	r3, [pc, #256]	; (8020cec <Sync0_Isr+0x14c>)
 8020bec:	881a      	ldrh	r2, [r3, #0]
 8020bee:	4b41      	ldr	r3, [pc, #260]	; (8020cf4 <Sync0_Isr+0x154>)
 8020bf0:	881b      	ldrh	r3, [r3, #0]
 8020bf2:	429a      	cmp	r2, r3
 8020bf4:	d101      	bne.n	8020bfa <Sync0_Isr+0x5a>
            {
                bCallInputMapping = TRUE;
 8020bf6:	2301      	movs	r3, #1
 8020bf8:	71fb      	strb	r3, [r7, #7]
            }
        }
/*ECATCHANGE_END(V5.13) ECAT 6*/

        if(u16SmSync0Value > 0)
 8020bfa:	4b3f      	ldr	r3, [pc, #252]	; (8020cf8 <Sync0_Isr+0x158>)
 8020bfc:	881b      	ldrh	r3, [r3, #0]
 8020bfe:	2b00      	cmp	r3, #0
 8020c00:	d05b      	beq.n	8020cba <Sync0_Isr+0x11a>
        {
           /* Check if Sm-Sync sequence is invalid */
           if (u16SmSync0Counter > u16SmSync0Value)
 8020c02:	4b3e      	ldr	r3, [pc, #248]	; (8020cfc <Sync0_Isr+0x15c>)
 8020c04:	881a      	ldrh	r2, [r3, #0]
 8020c06:	4b3c      	ldr	r3, [pc, #240]	; (8020cf8 <Sync0_Isr+0x158>)
 8020c08:	881b      	ldrh	r3, [r3, #0]
 8020c0a:	429a      	cmp	r2, r3
 8020c0c:	d923      	bls.n	8020c56 <Sync0_Isr+0xb6>
           {
              if ((nPdOutputSize > 0) && (sSyncManOutPar.u16SmEventMissedCounter <= sErrorSettings.u16SyncErrorCounterLimit))
 8020c0e:	4b3c      	ldr	r3, [pc, #240]	; (8020d00 <Sync0_Isr+0x160>)
 8020c10:	881b      	ldrh	r3, [r3, #0]
 8020c12:	2b00      	cmp	r3, #0
 8020c14:	d00b      	beq.n	8020c2e <Sync0_Isr+0x8e>
 8020c16:	4b3b      	ldr	r3, [pc, #236]	; (8020d04 <Sync0_Isr+0x164>)
 8020c18:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 8020c1a:	4b3b      	ldr	r3, [pc, #236]	; (8020d08 <Sync0_Isr+0x168>)
 8020c1c:	891b      	ldrh	r3, [r3, #8]
 8020c1e:	429a      	cmp	r2, r3
 8020c20:	d805      	bhi.n	8020c2e <Sync0_Isr+0x8e>
              {
                 sSyncManOutPar.u16SmEventMissedCounter = sSyncManOutPar.u16SmEventMissedCounter + 3;
 8020c22:	4b38      	ldr	r3, [pc, #224]	; (8020d04 <Sync0_Isr+0x164>)
 8020c24:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8020c26:	3303      	adds	r3, #3
 8020c28:	b29a      	uxth	r2, r3
 8020c2a:	4b36      	ldr	r3, [pc, #216]	; (8020d04 <Sync0_Isr+0x164>)
 8020c2c:	851a      	strh	r2, [r3, #40]	; 0x28
              }

               if ((nPdInputSize > 0) && (nPdOutputSize == 0) && (sSyncManInPar.u16SmEventMissedCounter <= sErrorSettings.u16SyncErrorCounterLimit))
 8020c2e:	4b30      	ldr	r3, [pc, #192]	; (8020cf0 <Sync0_Isr+0x150>)
 8020c30:	881b      	ldrh	r3, [r3, #0]
 8020c32:	2b00      	cmp	r3, #0
 8020c34:	d00f      	beq.n	8020c56 <Sync0_Isr+0xb6>
 8020c36:	4b32      	ldr	r3, [pc, #200]	; (8020d00 <Sync0_Isr+0x160>)
 8020c38:	881b      	ldrh	r3, [r3, #0]
 8020c3a:	2b00      	cmp	r3, #0
 8020c3c:	d10b      	bne.n	8020c56 <Sync0_Isr+0xb6>
 8020c3e:	4b33      	ldr	r3, [pc, #204]	; (8020d0c <Sync0_Isr+0x16c>)
 8020c40:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 8020c42:	4b31      	ldr	r3, [pc, #196]	; (8020d08 <Sync0_Isr+0x168>)
 8020c44:	891b      	ldrh	r3, [r3, #8]
 8020c46:	429a      	cmp	r2, r3
 8020c48:	d805      	bhi.n	8020c56 <Sync0_Isr+0xb6>
               {
                   sSyncManInPar.u16SmEventMissedCounter = sSyncManInPar.u16SmEventMissedCounter + 3;
 8020c4a:	4b30      	ldr	r3, [pc, #192]	; (8020d0c <Sync0_Isr+0x16c>)
 8020c4c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8020c4e:	3303      	adds	r3, #3
 8020c50:	b29a      	uxth	r2, r3
 8020c52:	4b2e      	ldr	r3, [pc, #184]	; (8020d0c <Sync0_Isr+0x16c>)
 8020c54:	851a      	strh	r2, [r3, #40]	; 0x28
               }

           } // if (u16SmSync0Counter > u16SmSync0Value)

           
           if ((nPdOutputSize == 0) && (nPdInputSize > 0))
 8020c56:	4b2a      	ldr	r3, [pc, #168]	; (8020d00 <Sync0_Isr+0x160>)
 8020c58:	881b      	ldrh	r3, [r3, #0]
 8020c5a:	2b00      	cmp	r3, #0
 8020c5c:	d121      	bne.n	8020ca2 <Sync0_Isr+0x102>
 8020c5e:	4b24      	ldr	r3, [pc, #144]	; (8020cf0 <Sync0_Isr+0x150>)
 8020c60:	881b      	ldrh	r3, [r3, #0]
 8020c62:	2b00      	cmp	r3, #0
 8020c64:	d01d      	beq.n	8020ca2 <Sync0_Isr+0x102>
           {
              /* Input only with DC, check if the last input data was read*/
              UINT16  ALEvent = HW_GetALEventRegister_Isr();
 8020c66:	f7ff fd31 	bl	80206cc <HW_GetALEventRegister_Isr>
 8020c6a:	4603      	mov	r3, r0
 8020c6c:	80bb      	strh	r3, [r7, #4]
              ALEvent = SWAPWORD(ALEvent);

              if ((ALEvent & PROCESS_INPUT_EVENT) == 0)
 8020c6e:	88bb      	ldrh	r3, [r7, #4]
 8020c70:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8020c74:	2b00      	cmp	r3, #0
 8020c76:	d10c      	bne.n	8020c92 <Sync0_Isr+0xf2>
              {

                 /* no input data was read by the master, increment the sm missed counter*/
                if (u16SmSync0Counter <= u16SmSync0Value)
 8020c78:	4b20      	ldr	r3, [pc, #128]	; (8020cfc <Sync0_Isr+0x15c>)
 8020c7a:	881a      	ldrh	r2, [r3, #0]
 8020c7c:	4b1e      	ldr	r3, [pc, #120]	; (8020cf8 <Sync0_Isr+0x158>)
 8020c7e:	881b      	ldrh	r3, [r3, #0]
 8020c80:	429a      	cmp	r2, r3
 8020c82:	d80d      	bhi.n	8020ca0 <Sync0_Isr+0x100>
                {
                    u16SmSync0Counter++;
 8020c84:	4b1d      	ldr	r3, [pc, #116]	; (8020cfc <Sync0_Isr+0x15c>)
 8020c86:	881b      	ldrh	r3, [r3, #0]
 8020c88:	3301      	adds	r3, #1
 8020c8a:	b29a      	uxth	r2, r3
 8020c8c:	4b1b      	ldr	r3, [pc, #108]	; (8020cfc <Sync0_Isr+0x15c>)
 8020c8e:	801a      	strh	r2, [r3, #0]

           } // if (u16SmSync0Counter > u16SmSync0Value)

           
           if ((nPdOutputSize == 0) && (nPdInputSize > 0))
           {
 8020c90:	e013      	b.n	8020cba <Sync0_Isr+0x11a>
                }
              }
              else
              {
                 /* Reset SM/Sync0 counter*/
                 u16SmSync0Counter = 0;
 8020c92:	4b1a      	ldr	r3, [pc, #104]	; (8020cfc <Sync0_Isr+0x15c>)
 8020c94:	2200      	movs	r2, #0
 8020c96:	801a      	strh	r2, [r3, #0]

                 sSyncManInPar.u16SmEventMissedCounter = 0;
 8020c98:	4b1c      	ldr	r3, [pc, #112]	; (8020d0c <Sync0_Isr+0x16c>)
 8020c9a:	2200      	movs	r2, #0
 8020c9c:	851a      	strh	r2, [r3, #40]	; 0x28

           } // if (u16SmSync0Counter > u16SmSync0Value)

           
           if ((nPdOutputSize == 0) && (nPdInputSize > 0))
           {
 8020c9e:	e00c      	b.n	8020cba <Sync0_Isr+0x11a>
 8020ca0:	e00b      	b.n	8020cba <Sync0_Isr+0x11a>

                 sSyncManInPar.u16SmEventMissedCounter = 0;

              }
           }
           else if (u16SmSync0Counter <= u16SmSync0Value)
 8020ca2:	4b16      	ldr	r3, [pc, #88]	; (8020cfc <Sync0_Isr+0x15c>)
 8020ca4:	881a      	ldrh	r2, [r3, #0]
 8020ca6:	4b14      	ldr	r3, [pc, #80]	; (8020cf8 <Sync0_Isr+0x158>)
 8020ca8:	881b      	ldrh	r3, [r3, #0]
 8020caa:	429a      	cmp	r2, r3
 8020cac:	d805      	bhi.n	8020cba <Sync0_Isr+0x11a>
           {

               u16SmSync0Counter++;
 8020cae:	4b13      	ldr	r3, [pc, #76]	; (8020cfc <Sync0_Isr+0x15c>)
 8020cb0:	881b      	ldrh	r3, [r3, #0]
 8020cb2:	3301      	adds	r3, #1
 8020cb4:	b29a      	uxth	r2, r3
 8020cb6:	4b11      	ldr	r3, [pc, #68]	; (8020cfc <Sync0_Isr+0x15c>)
 8020cb8:	801a      	strh	r2, [r3, #0]
           }
        }//SM -Sync monitoring enabled


        /* Application is synchronized to SYNC0 event*/
        ECAT_Application();
 8020cba:	f000 f8eb 	bl	8020e94 <ECAT_Application>

/*ECATCHANGE_START(V5.13) ECAT 6*/
        if (bCallInputMapping == TRUE)
 8020cbe:	79fb      	ldrb	r3, [r7, #7]
 8020cc0:	2b00      	cmp	r3, #0
 8020cc2:	d008      	beq.n	8020cd6 <Sync0_Isr+0x136>
        {
            /* EtherCAT slave is at least in SAFE-OPERATIONAL, update inputs */
            PDO_InputMapping();
 8020cc4:	f7ff fd0a 	bl	80206dc <PDO_InputMapping>

            if(LatchInputSync0Value == 1)
 8020cc8:	4b08      	ldr	r3, [pc, #32]	; (8020cec <Sync0_Isr+0x14c>)
 8020cca:	881b      	ldrh	r3, [r3, #0]
 8020ccc:	2b01      	cmp	r3, #1
 8020cce:	d102      	bne.n	8020cd6 <Sync0_Isr+0x136>
            {
                /* if inputs are latched on every Sync0 event (otherwise the counter is reset on the next Sync1 event) */
                LatchInputSync0Counter = 0;
 8020cd0:	4b08      	ldr	r3, [pc, #32]	; (8020cf4 <Sync0_Isr+0x154>)
 8020cd2:	2200      	movs	r2, #0
 8020cd4:	801a      	strh	r2, [r3, #0]
        }
/*ECATCHANGE_END(V5.13) ECAT 6*/

    }

    COE_UpdateSyncErrorStatus();
 8020cd6:	f7ff fa9f 	bl	8020218 <COE_UpdateSyncErrorStatus>

}
 8020cda:	3708      	adds	r7, #8
 8020cdc:	46bd      	mov	sp, r7
 8020cde:	bd80      	pop	{r7, pc}
 8020ce0:	1fff29bc 	.word	0x1fff29bc
 8020ce4:	1fff29ec 	.word	0x1fff29ec
 8020ce8:	1fff29f2 	.word	0x1fff29f2
 8020cec:	1fff29de 	.word	0x1fff29de
 8020cf0:	1fff29e2 	.word	0x1fff29e2
 8020cf4:	1fff29be 	.word	0x1fff29be
 8020cf8:	1fff29e4 	.word	0x1fff29e4
 8020cfc:	1fff29f6 	.word	0x1fff29f6
 8020d00:	1fff29b6 	.word	0x1fff29b6
 8020d04:	1fff2ad4 	.word	0x1fff2ad4
 8020d08:	1fff13cc 	.word	0x1fff13cc
 8020d0c:	1fff2a90 	.word	0x1fff2a90

08020d10 <Sync1_Isr>:

void Sync1_Isr(void)
{
 8020d10:	b580      	push	{r7, lr}
 8020d12:	af00      	add	r7, sp, #0
    Sync1WdCounter = 0;
 8020d14:	4b0c      	ldr	r3, [pc, #48]	; (8020d48 <Sync1_Isr+0x38>)
 8020d16:	2200      	movs	r2, #0
 8020d18:	801a      	strh	r2, [r3, #0]

    /*ECATCHANGE_START(V5.13) ECAT 5*/
    if ( (bEcatInputUpdateRunning == TRUE) && (nPdInputSize > 0)
 8020d1a:	4b0c      	ldr	r3, [pc, #48]	; (8020d4c <Sync1_Isr+0x3c>)
 8020d1c:	781b      	ldrb	r3, [r3, #0]
 8020d1e:	2b00      	cmp	r3, #0
 8020d20:	d00d      	beq.n	8020d3e <Sync1_Isr+0x2e>
 8020d22:	4b0b      	ldr	r3, [pc, #44]	; (8020d50 <Sync1_Isr+0x40>)
 8020d24:	881b      	ldrh	r3, [r3, #0]
 8020d26:	2b00      	cmp	r3, #0
 8020d28:	d009      	beq.n	8020d3e <Sync1_Isr+0x2e>
/*ECATCHANGE_END(V5.13) ECAT 5*/
            && (sSyncManInPar.u16SyncType == SYNCTYPE_DCSYNC1)
 8020d2a:	4b0a      	ldr	r3, [pc, #40]	; (8020d54 <Sync1_Isr+0x44>)
 8020d2c:	885b      	ldrh	r3, [r3, #2]
 8020d2e:	2b03      	cmp	r3, #3
 8020d30:	d105      	bne.n	8020d3e <Sync1_Isr+0x2e>
            && (LatchInputSync0Value == 0)) /* Inputs are latched on Sync1 (LatchInputSync0Value == 0), if LatchInputSync0Value > 0 inputs are latched with Sync0 */
 8020d32:	4b09      	ldr	r3, [pc, #36]	; (8020d58 <Sync1_Isr+0x48>)
 8020d34:	881b      	ldrh	r3, [r3, #0]
 8020d36:	2b00      	cmp	r3, #0
 8020d38:	d101      	bne.n	8020d3e <Sync1_Isr+0x2e>
        {
            /* EtherCAT slave is at least in SAFE-OPERATIONAL, update inputs */
            PDO_InputMapping();
 8020d3a:	f7ff fccf 	bl	80206dc <PDO_InputMapping>
        }

        /* Reset Sync0 latch counter (to start next Sync0 latch cycle) */
        LatchInputSync0Counter = 0;
 8020d3e:	4b07      	ldr	r3, [pc, #28]	; (8020d5c <Sync1_Isr+0x4c>)
 8020d40:	2200      	movs	r2, #0
 8020d42:	801a      	strh	r2, [r3, #0]
}
 8020d44:	bd80      	pop	{r7, pc}
 8020d46:	bf00      	nop
 8020d48:	1fff29ee 	.word	0x1fff29ee
 8020d4c:	1fff29f2 	.word	0x1fff29f2
 8020d50:	1fff29e2 	.word	0x1fff29e2
 8020d54:	1fff2a90 	.word	0x1fff2a90
 8020d58:	1fff29de 	.word	0x1fff29de
 8020d5c:	1fff29be 	.word	0x1fff29be

08020d60 <MainInit>:
 \brief    This function initialize the EtherCAT Sample Code

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 MainInit(void)
{
 8020d60:	b580      	push	{r7, lr}
 8020d62:	b086      	sub	sp, #24
 8020d64:	af00      	add	r7, sp, #0
    UINT16 Error = 0;
 8020d66:	2300      	movs	r3, #0
 8020d68:	81fb      	strh	r3, [r7, #14]
/*Hardware init function need to be called from the application layer*/

#ifdef SET_EEPROM_PTR
    SET_EEPROM_PTR
 8020d6a:	4b39      	ldr	r3, [pc, #228]	; (8020e50 <MainInit+0xf0>)
 8020d6c:	4a39      	ldr	r2, [pc, #228]	; (8020e54 <MainInit+0xf4>)
 8020d6e:	601a      	str	r2, [r3, #0]
#endif


/* Reset application function pointer*/
pAPPL_EEPROM_Read = NULL;
 8020d70:	4b39      	ldr	r3, [pc, #228]	; (8020e58 <MainInit+0xf8>)
 8020d72:	2200      	movs	r2, #0
 8020d74:	601a      	str	r2, [r3, #0]
    pAPPL_EEPROM_Write = NULL;
 8020d76:	4b39      	ldr	r3, [pc, #228]	; (8020e5c <MainInit+0xfc>)
 8020d78:	2200      	movs	r2, #0
 8020d7a:	601a      	str	r2, [r3, #0]
    pAPPL_EEPROM_Reload = NULL;
 8020d7c:	4b38      	ldr	r3, [pc, #224]	; (8020e60 <MainInit+0x100>)
 8020d7e:	2200      	movs	r2, #0
 8020d80:	601a      	str	r2, [r3, #0]
    pAPPL_EEPROM_Store = NULL;
 8020d82:	4b38      	ldr	r3, [pc, #224]	; (8020e64 <MainInit+0x104>)
 8020d84:	2200      	movs	r2, #0
 8020d86:	601a      	str	r2, [r3, #0]




    /* ECATCHANGE_START(V5.13) COE4*/
    pAPPL_CoeReadInd = NULL;
 8020d88:	4b37      	ldr	r3, [pc, #220]	; (8020e68 <MainInit+0x108>)
 8020d8a:	2200      	movs	r2, #0
 8020d8c:	601a      	str	r2, [r3, #0]
    pAPPL_CoeWriteInd = NULL;
 8020d8e:	4b37      	ldr	r3, [pc, #220]	; (8020e6c <MainInit+0x10c>)
 8020d90:	2200      	movs	r2, #0
 8020d92:	601a      	str	r2, [r3, #0]
    /* ECATCHANGE_END(V5.13) COE4*/

    pAPPL_MainLoop = NULL;
 8020d94:	4b36      	ldr	r3, [pc, #216]	; (8020e70 <MainInit+0x110>)
 8020d96:	2200      	movs	r2, #0
 8020d98:	601a      	str	r2, [r3, #0]

    /* initialize the EtherCAT Slave Interface */
    ECAT_Init();
 8020d9a:	f000 fa05 	bl	80211a8 <ECAT_Init>
    /* initialize the objects */
    COE_ObjInit();
 8020d9e:	f7ff fa6d 	bl	802027c <COE_ObjInit>


    /*indicate that the slave stack initialization finished*/
    bInitFinished = TRUE;
 8020da2:	4b34      	ldr	r3, [pc, #208]	; (8020e74 <MainInit+0x114>)
 8020da4:	2201      	movs	r2, #1
 8020da6:	701a      	strb	r2, [r3, #0]


    bMinCycleTimeMeasurementStarted = FALSE;
 8020da8:	4b33      	ldr	r3, [pc, #204]	; (8020e78 <MainInit+0x118>)
 8020daa:	2200      	movs	r2, #0
 8020dac:	701a      	strb	r2, [r3, #0]
    u32CycleTimeStartValue = 0;
 8020dae:	4b33      	ldr	r3, [pc, #204]	; (8020e7c <MainInit+0x11c>)
 8020db0:	2200      	movs	r2, #0
 8020db2:	601a      	str	r2, [r3, #0]
    u32MinCycleTimeStartValue = 0;
 8020db4:	4b32      	ldr	r3, [pc, #200]	; (8020e80 <MainInit+0x120>)
 8020db6:	2200      	movs	r2, #0
 8020db8:	601a      	str	r2, [r3, #0]

    u32SystemTimeReadFailure = 0;
 8020dba:	4b32      	ldr	r3, [pc, #200]	; (8020e84 <MainInit+0x124>)
 8020dbc:	2200      	movs	r2, #0
 8020dbe:	601a      	str	r2, [r3, #0]

    /* Get the System Time read failure */
    {
       UINT32 u32TimeValue = 0;
 8020dc0:	2300      	movs	r3, #0
 8020dc2:	60bb      	str	r3, [r7, #8]
       UINT32 u32Cnt = 0;
 8020dc4:	2300      	movs	r3, #0
 8020dc6:	617b      	str	r3, [r7, #20]
       UINT32 u32Delta = 0;
 8020dc8:	2300      	movs	r3, #0
 8020dca:	613b      	str	r3, [r7, #16]

       while (u32Cnt < 1000)
 8020dcc:	e026      	b.n	8020e1c <MainInit+0xbc>
       {
           HW_EscReadDWordIsr(u32TimeValue, ESC_SYSTEMTIME_OFFSET);
 8020dce:	4b2e      	ldr	r3, [pc, #184]	; (8020e88 <MainInit+0x128>)
 8020dd0:	681b      	ldr	r3, [r3, #0]
 8020dd2:	60bb      	str	r3, [r7, #8]
           HW_EscReadDWordIsr(u32Delta, ESC_SYSTEMTIME_OFFSET);
 8020dd4:	4b2c      	ldr	r3, [pc, #176]	; (8020e88 <MainInit+0x128>)
 8020dd6:	681b      	ldr	r3, [r3, #0]
 8020dd8:	613b      	str	r3, [r7, #16]

            if (u32TimeValue <= u32Delta)
 8020dda:	68ba      	ldr	r2, [r7, #8]
 8020ddc:	693b      	ldr	r3, [r7, #16]
 8020dde:	429a      	cmp	r2, r3
 8020de0:	d804      	bhi.n	8020dec <MainInit+0x8c>
            {
                    u32Delta = u32Delta - u32TimeValue;
 8020de2:	693a      	ldr	r2, [r7, #16]
 8020de4:	68bb      	ldr	r3, [r7, #8]
 8020de6:	1ad3      	subs	r3, r2, r3
 8020de8:	613b      	str	r3, [r7, #16]
 8020dea:	e004      	b.n	8020df6 <MainInit+0x96>
            }
            else
            {
                //The 32Bit timer is wrapped around
                u32Delta = u32Delta + (0xFFFFFFFF - u32TimeValue);
 8020dec:	693a      	ldr	r2, [r7, #16]
 8020dee:	68bb      	ldr	r3, [r7, #8]
 8020df0:	1ad3      	subs	r3, r2, r3
 8020df2:	3b01      	subs	r3, #1
 8020df4:	613b      	str	r3, [r7, #16]
            }


            if (u32SystemTimeReadFailure == 0)
 8020df6:	4b23      	ldr	r3, [pc, #140]	; (8020e84 <MainInit+0x124>)
 8020df8:	681b      	ldr	r3, [r3, #0]
 8020dfa:	2b00      	cmp	r3, #0
 8020dfc:	d103      	bne.n	8020e06 <MainInit+0xa6>
            {
                u32SystemTimeReadFailure = u32Delta;
 8020dfe:	4a21      	ldr	r2, [pc, #132]	; (8020e84 <MainInit+0x124>)
 8020e00:	693b      	ldr	r3, [r7, #16]
 8020e02:	6013      	str	r3, [r2, #0]
 8020e04:	e007      	b.n	8020e16 <MainInit+0xb6>
            }
            else if (u32SystemTimeReadFailure > u32Delta)
 8020e06:	4b1f      	ldr	r3, [pc, #124]	; (8020e84 <MainInit+0x124>)
 8020e08:	681a      	ldr	r2, [r3, #0]
 8020e0a:	693b      	ldr	r3, [r7, #16]
 8020e0c:	429a      	cmp	r2, r3
 8020e0e:	d902      	bls.n	8020e16 <MainInit+0xb6>
            {
                u32SystemTimeReadFailure = u32Delta;
 8020e10:	4a1c      	ldr	r2, [pc, #112]	; (8020e84 <MainInit+0x124>)
 8020e12:	693b      	ldr	r3, [r7, #16]
 8020e14:	6013      	str	r3, [r2, #0]
            }

          u32Cnt++;
 8020e16:	697b      	ldr	r3, [r7, #20]
 8020e18:	3301      	adds	r3, #1
 8020e1a:	617b      	str	r3, [r7, #20]
    {
       UINT32 u32TimeValue = 0;
       UINT32 u32Cnt = 0;
       UINT32 u32Delta = 0;

       while (u32Cnt < 1000)
 8020e1c:	697b      	ldr	r3, [r7, #20]
 8020e1e:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8020e22:	d3d4      	bcc.n	8020dce <MainInit+0x6e>
    }



    {
        UINT16 TmpData = 0;
 8020e24:	2300      	movs	r3, #0
 8020e26:	80fb      	strh	r3, [r7, #6]
        HW_EscReadWord(TmpData, ESC_EEPROM_CONTROL_OFFSET);
 8020e28:	4b18      	ldr	r3, [pc, #96]	; (8020e8c <MainInit+0x12c>)
 8020e2a:	881b      	ldrh	r3, [r3, #0]
 8020e2c:	80fb      	strh	r3, [r7, #6]
        TmpData = SWAPDWORD(TmpData);
        //get bit6 of register 0x502
        if ((TmpData & ESC_EEPROM_SUPPORTED_READBYTES_MASK) > 0)
 8020e2e:	88fb      	ldrh	r3, [r7, #6]
 8020e30:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8020e34:	2b00      	cmp	r3, #0
 8020e36:	dd03      	ble.n	8020e40 <MainInit+0xe0>
        {
            //8Bytes EEPROM read access
            EepromReadSize = 8;
 8020e38:	4b15      	ldr	r3, [pc, #84]	; (8020e90 <MainInit+0x130>)
 8020e3a:	2208      	movs	r2, #8
 8020e3c:	801a      	strh	r2, [r3, #0]
 8020e3e:	e002      	b.n	8020e46 <MainInit+0xe6>
        }
        else
        {
            //4Bytes EEPROM read access
            EepromReadSize = 4;
 8020e40:	4b13      	ldr	r3, [pc, #76]	; (8020e90 <MainInit+0x130>)
 8020e42:	2204      	movs	r2, #4
 8020e44:	801a      	strh	r2, [r3, #0]
        }
    }

/*Application Init need to be called from the application layer*/
     return Error;
 8020e46:	89fb      	ldrh	r3, [r7, #14]
}
 8020e48:	4618      	mov	r0, r3
 8020e4a:	3718      	adds	r7, #24
 8020e4c:	46bd      	mov	sp, r7
 8020e4e:	bd80      	pop	{r7, pc}
 8020e50:	1fff299c 	.word	0x1fff299c
 8020e54:	1fff0bcc 	.word	0x1fff0bcc
 8020e58:	1fff2838 	.word	0x1fff2838
 8020e5c:	1fff283c 	.word	0x1fff283c
 8020e60:	1fff29a4 	.word	0x1fff29a4
 8020e64:	1fff2828 	.word	0x1fff2828
 8020e68:	1fff282c 	.word	0x1fff282c
 8020e6c:	1fff28f0 	.word	0x1fff28f0
 8020e70:	1fff28f4 	.word	0x1fff28f4
 8020e74:	1fff17f0 	.word	0x1fff17f0
 8020e78:	1fff2830 	.word	0x1fff2830
 8020e7c:	1fff2834 	.word	0x1fff2834
 8020e80:	1fff28fc 	.word	0x1fff28fc
 8020e84:	1fff2844 	.word	0x1fff2844
 8020e88:	54010910 	.word	0x54010910
 8020e8c:	54010502 	.word	0x54010502
 8020e90:	1fff28ee 	.word	0x1fff28ee

08020e94 <ECAT_Application>:
/**
 \brief    ECAT_Application (prev. SSC versions "COE_Application")
 this function calculates and the physical process signals and triggers the input mapping
*////////////////////////////////////////////////////////////////////////////////////////
void ECAT_Application(void)
{
 8020e94:	b580      	push	{r7, lr}
 8020e96:	af00      	add	r7, sp, #0
            u32MinCycleTimeValue = 0;
        }
    } /* measurement started*/
#endif /* (MIN_PD_CYCLE_TIME == 0)*/

    if (MEASUREMENT_ACTIVE)
 8020e98:	4b0a      	ldr	r3, [pc, #40]	; (8020ec4 <ECAT_Application+0x30>)
 8020e9a:	8b9b      	ldrh	r3, [r3, #28]
 8020e9c:	f003 0301 	and.w	r3, r3, #1
 8020ea0:	2b00      	cmp	r3, #0
 8020ea2:	d105      	bne.n	8020eb0 <ECAT_Application+0x1c>
 8020ea4:	4b08      	ldr	r3, [pc, #32]	; (8020ec8 <ECAT_Application+0x34>)
 8020ea6:	8b9b      	ldrh	r3, [r3, #28]
 8020ea8:	f003 0301 	and.w	r3, r3, #1
 8020eac:	2b00      	cmp	r3, #0
 8020eae:	d005      	beq.n	8020ebc <ECAT_Application+0x28>
    {
        if (nPdOutputSize == 0)
 8020eb0:	4b06      	ldr	r3, [pc, #24]	; (8020ecc <ECAT_Application+0x38>)
 8020eb2:	881b      	ldrh	r3, [r3, #0]
 8020eb4:	2b00      	cmp	r3, #0
 8020eb6:	d101      	bne.n	8020ebc <ECAT_Application+0x28>
        {
            /* in case of an input only device the cycle starts with an ECAT_Application call*/
            HandleCycleTimeMeasurement();
 8020eb8:	f7ff fd2e 	bl	8020918 <HandleCycleTimeMeasurement>


    /*ECATCHANGE_START(V5.13) CIA402 4*/
    /*decouple CIA402 application from ESM*/
    /*ECATCHANGE_END(V5.13) CIA402 4*/
    APPL_Application();
 8020ebc:	f000 faaa 	bl	8021414 <APPL_Application>
            }
        }

    }/* measurement started*/
#endif /* #if MIN_PD_CYCLE_TIME == 0 */
}
 8020ec0:	bd80      	pop	{r7, pc}
 8020ec2:	bf00      	nop
 8020ec4:	1fff2ad4 	.word	0x1fff2ad4
 8020ec8:	1fff2a90 	.word	0x1fff2a90
 8020ecc:	1fff29b6 	.word	0x1fff29b6

08020ed0 <COE_Init>:

 \brief    This function intialize the CoE Interface.
*////////////////////////////////////////////////////////////////////////////////////////

void COE_Init(void)
{
 8020ed0:	b480      	push	{r7}
 8020ed2:	af00      	add	r7, sp, #0
    pCoeSendStored = 0;
 8020ed4:	4b04      	ldr	r3, [pc, #16]	; (8020ee8 <COE_Init+0x18>)
 8020ed6:	2200      	movs	r2, #0
 8020ed8:	601a      	str	r2, [r3, #0]
    nSdoInfoFragmentsLeft = 0;
 8020eda:	4b04      	ldr	r3, [pc, #16]	; (8020eec <COE_Init+0x1c>)
 8020edc:	2200      	movs	r2, #0
 8020ede:	801a      	strh	r2, [r3, #0]
}
 8020ee0:	46bd      	mov	sp, r7
 8020ee2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020ee6:	4770      	bx	lr
 8020ee8:	1fff29ac 	.word	0x1fff29ac
 8020eec:	1fff2b40 	.word	0x1fff2b40

08020ef0 <ResetALEventMask>:
 \param    intMask        interrupt mask (disabled interrupt shall be zero)

 \brief    This function makes an logical and with the AL Event Mask register (0x204)
*////////////////////////////////////////////////////////////////////////////////////////
void ResetALEventMask(UINT16 intMask)
{
 8020ef0:	b580      	push	{r7, lr}
 8020ef2:	b084      	sub	sp, #16
 8020ef4:	af00      	add	r7, sp, #0
 8020ef6:	4603      	mov	r3, r0
 8020ef8:	80fb      	strh	r3, [r7, #6]
    UINT16 mask;
    HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
 8020efa:	4b08      	ldr	r3, [pc, #32]	; (8020f1c <ResetALEventMask+0x2c>)
 8020efc:	881b      	ldrh	r3, [r3, #0]
 8020efe:	81fb      	strh	r3, [r7, #14]
    
    mask &= intMask;
 8020f00:	89fa      	ldrh	r2, [r7, #14]
 8020f02:	88fb      	ldrh	r3, [r7, #6]
 8020f04:	4013      	ands	r3, r2
 8020f06:	81fb      	strh	r3, [r7, #14]


    DISABLE_ESC_INT();
 8020f08:	f003 fe36 	bl	8024b78 <DISABLE_ESC_INT>


    HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
 8020f0c:	4a03      	ldr	r2, [pc, #12]	; (8020f1c <ResetALEventMask+0x2c>)
 8020f0e:	89fb      	ldrh	r3, [r7, #14]
 8020f10:	8013      	strh	r3, [r2, #0]
    ENABLE_ESC_INT();
 8020f12:	f003 fe23 	bl	8024b5c <ENABLE_ESC_INT>
}
 8020f16:	3710      	adds	r7, #16
 8020f18:	46bd      	mov	sp, r7
 8020f1a:	bd80      	pop	{r7, pc}
 8020f1c:	54010204 	.word	0x54010204

08020f20 <UpdateEEPROMLoadedState>:
/**

\brief    This function reads the EEPROM loaded state
*////////////////////////////////////////////////////////////////////////////////////////
void UpdateEEPROMLoadedState(void)
{
 8020f20:	b480      	push	{r7}
 8020f22:	b083      	sub	sp, #12
 8020f24:	af00      	add	r7, sp, #0
    UINT16 TmpVar = 0;
 8020f26:	2300      	movs	r3, #0
 8020f28:	80fb      	strh	r3, [r7, #6]
    //read EEPROM loaded information
    HW_EscReadWord(TmpVar, ESC_EEPROM_CONTROL_OFFSET);
 8020f2a:	4b0c      	ldr	r3, [pc, #48]	; (8020f5c <UpdateEEPROMLoadedState+0x3c>)
 8020f2c:	881b      	ldrh	r3, [r3, #0]
 8020f2e:	80fb      	strh	r3, [r7, #6]
    TmpVar = SWAPWORD(TmpVar);


    if (((TmpVar & ESC_EEPROM_ERROR_CRC) > 0)
 8020f30:	88fb      	ldrh	r3, [r7, #6]
 8020f32:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8020f36:	2b00      	cmp	r3, #0
 8020f38:	dc04      	bgt.n	8020f44 <UpdateEEPROMLoadedState+0x24>
        || ((TmpVar & ESC_EEPROM_ERROR_LOAD) > 0))
 8020f3a:	88fb      	ldrh	r3, [r7, #6]
 8020f3c:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8020f40:	2b00      	cmp	r3, #0
 8020f42:	dd03      	ble.n	8020f4c <UpdateEEPROMLoadedState+0x2c>
    {
        EepromLoaded = FALSE;
 8020f44:	4b06      	ldr	r3, [pc, #24]	; (8020f60 <UpdateEEPROMLoadedState+0x40>)
 8020f46:	2200      	movs	r2, #0
 8020f48:	701a      	strb	r2, [r3, #0]
 8020f4a:	e002      	b.n	8020f52 <UpdateEEPROMLoadedState+0x32>
    }
    else
    {
        EepromLoaded = TRUE;
 8020f4c:	4b04      	ldr	r3, [pc, #16]	; (8020f60 <UpdateEEPROMLoadedState+0x40>)
 8020f4e:	2201      	movs	r2, #1
 8020f50:	701a      	strb	r2, [r3, #0]
    }
}
 8020f52:	370c      	adds	r7, #12
 8020f54:	46bd      	mov	sp, r7
 8020f56:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020f5a:	4770      	bx	lr
 8020f5c:	54010502 	.word	0x54010502
 8020f60:	1fff17f1 	.word	0x1fff17f1

08020f64 <DisableSyncManChannel>:
 \param     channel        Sync Manager channel

 \brief    This function disables a Sync Manager channel
*////////////////////////////////////////////////////////////////////////////////////////
void DisableSyncManChannel(UINT8 channel)
{
 8020f64:	b480      	push	{r7}
 8020f66:	b085      	sub	sp, #20
 8020f68:	af00      	add	r7, sp, #0
 8020f6a:	4603      	mov	r3, r0
 8020f6c:	71fb      	strb	r3, [r7, #7]
    UINT16 Offset;
    VARVOLATILE UINT8 smStatus = SM_SETTING_PDI_DISABLE;
 8020f6e:	2301      	movs	r3, #1
 8020f70:	737b      	strb	r3, [r7, #13]
    Offset = (ESC_SM_PDICONTROL_OFFSET + (SIZEOF_SM_REGISTER*channel));
 8020f72:	79fb      	ldrb	r3, [r7, #7]
 8020f74:	b29b      	uxth	r3, r3
 8020f76:	00db      	lsls	r3, r3, #3
 8020f78:	b29b      	uxth	r3, r3
 8020f7a:	f603 0307 	addw	r3, r3, #2055	; 0x807
 8020f7e:	81fb      	strh	r3, [r7, #14]

    HW_EscWriteByte(smStatus,Offset);
 8020f80:	89fb      	ldrh	r3, [r7, #14]
 8020f82:	f103 43a8 	add.w	r3, r3, #1409286144	; 0x54000000
 8020f86:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 8020f8a:	7b7a      	ldrb	r2, [r7, #13]
 8020f8c:	b2d2      	uxtb	r2, r2
 8020f8e:	701a      	strb	r2, [r3, #0]
    
    /*wait until SyncManager is disabled*/
    do
    {
        HW_EscReadByte(smStatus, Offset);
 8020f90:	89fb      	ldrh	r3, [r7, #14]
 8020f92:	f103 43a8 	add.w	r3, r3, #1409286144	; 0x54000000
 8020f96:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 8020f9a:	781b      	ldrb	r3, [r3, #0]
 8020f9c:	b2db      	uxtb	r3, r3
 8020f9e:	737b      	strb	r3, [r7, #13]
    }while(!(smStatus & SM_SETTING_PDI_DISABLE));
 8020fa0:	7b7b      	ldrb	r3, [r7, #13]
 8020fa2:	b2db      	uxtb	r3, r3
 8020fa4:	f003 0301 	and.w	r3, r3, #1
 8020fa8:	2b00      	cmp	r3, #0
 8020faa:	d0f1      	beq.n	8020f90 <DisableSyncManChannel+0x2c>
}
 8020fac:	3714      	adds	r7, #20
 8020fae:	46bd      	mov	sp, r7
 8020fb0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8020fb4:	4770      	bx	lr
 8020fb6:	bf00      	nop

08020fb8 <SetALStatus>:
 \param alStatusCode    New AL Status Code (written to register 0x134)

  \brief  The function changes the state of the EtherCAT ASIC to the requested.
*////////////////////////////////////////////////////////////////////////////////////////
void SetALStatus(UINT8 alStatus, UINT16 alStatusCode)
{
 8020fb8:	b480      	push	{r7}
 8020fba:	b085      	sub	sp, #20
 8020fbc:	af00      	add	r7, sp, #0
 8020fbe:	4603      	mov	r3, r0
 8020fc0:	460a      	mov	r2, r1
 8020fc2:	71fb      	strb	r3, [r7, #7]
 8020fc4:	4613      	mov	r3, r2
 8020fc6:	80bb      	strh	r3, [r7, #4]
    UINT16 Value = alStatusCode;
 8020fc8:	88bb      	ldrh	r3, [r7, #4]
 8020fca:	81fb      	strh	r3, [r7, #14]

    /*update global status variable if required*/
    if(nAlStatus != alStatus)
 8020fcc:	4b26      	ldr	r3, [pc, #152]	; (8021068 <SetALStatus+0xb0>)
 8020fce:	781b      	ldrb	r3, [r3, #0]
 8020fd0:	79fa      	ldrb	r2, [r7, #7]
 8020fd2:	429a      	cmp	r2, r3
 8020fd4:	d002      	beq.n	8020fdc <SetALStatus+0x24>
    {
        nAlStatus = alStatus;
 8020fd6:	4a24      	ldr	r2, [pc, #144]	; (8021068 <SetALStatus+0xb0>)
 8020fd8:	79fb      	ldrb	r3, [r7, #7]
 8020fda:	7013      	strb	r3, [r2, #0]
    }


    if (alStatusCode != 0xFFFF)
 8020fdc:	88bb      	ldrh	r3, [r7, #4]
 8020fde:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8020fe2:	4293      	cmp	r3, r2
 8020fe4:	d002      	beq.n	8020fec <SetALStatus+0x34>
    {
        Value = SWAPWORD(Value);

        HW_EscWriteWord(Value,ESC_AL_STATUS_CODE_OFFSET);
 8020fe6:	4a21      	ldr	r2, [pc, #132]	; (802106c <SetALStatus+0xb4>)
 8020fe8:	89fb      	ldrh	r3, [r7, #14]
 8020fea:	8013      	strh	r3, [r2, #0]
    }

    Value = nAlStatus;
 8020fec:	4b1e      	ldr	r3, [pc, #120]	; (8021068 <SetALStatus+0xb0>)
 8020fee:	781b      	ldrb	r3, [r3, #0]
 8020ff0:	81fb      	strh	r3, [r7, #14]
    Value = SWAPWORD(Value);
    HW_EscWriteWord(Value,ESC_AL_STATUS_OFFSET);
 8020ff2:	4a1f      	ldr	r2, [pc, #124]	; (8021070 <SetALStatus+0xb8>)
 8020ff4:	89fb      	ldrh	r3, [r7, #14]
 8020ff6:	8013      	strh	r3, [r2, #0]

    /*The Run LED state is set in Set LED Indication, only the Error LED blink code is set here*/

    /*set Error blink code*/
    if(alStatusCode == 0x00 || !(alStatus & STATE_CHANGE))
 8020ff8:	88bb      	ldrh	r3, [r7, #4]
 8020ffa:	2b00      	cmp	r3, #0
 8020ffc:	d004      	beq.n	8021008 <SetALStatus+0x50>
 8020ffe:	79fb      	ldrb	r3, [r7, #7]
 8021000:	f003 0310 	and.w	r3, r3, #16
 8021004:	2b00      	cmp	r3, #0
 8021006:	d103      	bne.n	8021010 <SetALStatus+0x58>
    {
        u8EcatErrorLed = LED_OFF;
 8021008:	4b1a      	ldr	r3, [pc, #104]	; (8021074 <SetALStatus+0xbc>)
 802100a:	2200      	movs	r2, #0
 802100c:	701a      	strb	r2, [r3, #0]
 802100e:	e01a      	b.n	8021046 <SetALStatus+0x8e>
    }
    else if((alStatusCode == ALSTATUSCODE_NOSYNCERROR) ||
 8021010:	88bb      	ldrh	r3, [r7, #4]
 8021012:	2b2d      	cmp	r3, #45	; 0x2d
 8021014:	d009      	beq.n	802102a <SetALStatus+0x72>
 8021016:	88bb      	ldrh	r3, [r7, #4]
 8021018:	2b1a      	cmp	r3, #26
 802101a:	d006      	beq.n	802102a <SetALStatus+0x72>
        (alStatusCode == ALSTATUSCODE_SYNCERROR) ||
 802101c:	88bb      	ldrh	r3, [r7, #4]
 802101e:	2b32      	cmp	r3, #50	; 0x32
 8021020:	d003      	beq.n	802102a <SetALStatus+0x72>
        (alStatusCode == ALSTATUSCODE_DCPLLSYNCERROR)
/*ECATCHANGE_START(V5.13) ESM1*/
        || (u8LocalErrorState > 0))
 8021022:	4b15      	ldr	r3, [pc, #84]	; (8021078 <SetALStatus+0xc0>)
 8021024:	781b      	ldrb	r3, [r3, #0]
 8021026:	2b00      	cmp	r3, #0
 8021028:	d003      	beq.n	8021032 <SetALStatus+0x7a>
/*ECATCHANGE_END(V5.13) ESM1*/
    {
        u8EcatErrorLed = LED_SINGLEFLASH;
 802102a:	4b12      	ldr	r3, [pc, #72]	; (8021074 <SetALStatus+0xbc>)
 802102c:	2201      	movs	r2, #1
 802102e:	701a      	strb	r2, [r3, #0]
 8021030:	e009      	b.n	8021046 <SetALStatus+0x8e>
    }
    else if((alStatusCode == ALSTATUSCODE_SMWATCHDOG))
 8021032:	88bb      	ldrh	r3, [r7, #4]
 8021034:	2b1b      	cmp	r3, #27
 8021036:	d103      	bne.n	8021040 <SetALStatus+0x88>
    {
        u8EcatErrorLed = LED_DOUBLEFLASH;
 8021038:	4b0e      	ldr	r3, [pc, #56]	; (8021074 <SetALStatus+0xbc>)
 802103a:	2202      	movs	r2, #2
 802103c:	701a      	strb	r2, [r3, #0]
 802103e:	e002      	b.n	8021046 <SetALStatus+0x8e>
    }
    else
    {
        u8EcatErrorLed = LED_BLINKING;
 8021040:	4b0c      	ldr	r3, [pc, #48]	; (8021074 <SetALStatus+0xbc>)
 8021042:	220d      	movs	r2, #13
 8021044:	701a      	strb	r2, [r3, #0]
    }
    u8EcatErrorLed |= LED_OVERRIDE;
 8021046:	4b0b      	ldr	r3, [pc, #44]	; (8021074 <SetALStatus+0xbc>)
 8021048:	781b      	ldrb	r3, [r3, #0]
 802104a:	f043 0310 	orr.w	r3, r3, #16
 802104e:	b2da      	uxtb	r2, r3
 8021050:	4b08      	ldr	r3, [pc, #32]	; (8021074 <SetALStatus+0xbc>)
 8021052:	701a      	strb	r2, [r3, #0]

    HW_EscWriteByte(u8EcatErrorLed,ESC_ERROR_LED_OVERRIDE);
 8021054:	4b09      	ldr	r3, [pc, #36]	; (802107c <SetALStatus+0xc4>)
 8021056:	4a07      	ldr	r2, [pc, #28]	; (8021074 <SetALStatus+0xbc>)
 8021058:	7812      	ldrb	r2, [r2, #0]
 802105a:	701a      	strb	r2, [r3, #0]
}
 802105c:	3714      	adds	r7, #20
 802105e:	46bd      	mov	sp, r7
 8021060:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021064:	4770      	bx	lr
 8021066:	bf00      	nop
 8021068:	1fff29b5 	.word	0x1fff29b5
 802106c:	54010134 	.word	0x54010134
 8021070:	54010130 	.word	0x54010130
 8021074:	1fff29f9 	.word	0x1fff29f9
 8021078:	1fff29ba 	.word	0x1fff29ba
 802107c:	54010139 	.word	0x54010139

08021080 <DC_CheckWatchdog>:
 \brief    This function checks the current Sync state and set the local flags
 The analyse of the local flags is handled in "CheckIfEcatError"

*////////////////////////////////////////////////////////////////////////////////////////
void DC_CheckWatchdog(void)
{
 8021080:	b480      	push	{r7}
 8021082:	af00      	add	r7, sp, #0

    if(bDcSyncActive && bEcatInputUpdateRunning)
 8021084:	4b3c      	ldr	r3, [pc, #240]	; (8021178 <DC_CheckWatchdog+0xf8>)
 8021086:	781b      	ldrb	r3, [r3, #0]
 8021088:	2b00      	cmp	r3, #0
 802108a:	d071      	beq.n	8021170 <DC_CheckWatchdog+0xf0>
 802108c:	4b3b      	ldr	r3, [pc, #236]	; (802117c <DC_CheckWatchdog+0xfc>)
 802108e:	781b      	ldrb	r3, [r3, #0]
 8021090:	2b00      	cmp	r3, #0
 8021092:	d06d      	beq.n	8021170 <DC_CheckWatchdog+0xf0>
    {
        /*If Sync0 watchdog is enabled and expired*/
        if((Sync0WdValue > 0) && (Sync0WdCounter >= Sync0WdValue))
 8021094:	4b3a      	ldr	r3, [pc, #232]	; (8021180 <DC_CheckWatchdog+0x100>)
 8021096:	881b      	ldrh	r3, [r3, #0]
 8021098:	2b00      	cmp	r3, #0
 802109a:	d009      	beq.n	80210b0 <DC_CheckWatchdog+0x30>
 802109c:	4b39      	ldr	r3, [pc, #228]	; (8021184 <DC_CheckWatchdog+0x104>)
 802109e:	881a      	ldrh	r2, [r3, #0]
 80210a0:	4b37      	ldr	r3, [pc, #220]	; (8021180 <DC_CheckWatchdog+0x100>)
 80210a2:	881b      	ldrh	r3, [r3, #0]
 80210a4:	429a      	cmp	r2, r3
 80210a6:	d303      	bcc.n	80210b0 <DC_CheckWatchdog+0x30>
        {
                /*Sync0 watchdog expired*/
                bDcRunning = FALSE;        
 80210a8:	4b37      	ldr	r3, [pc, #220]	; (8021188 <DC_CheckWatchdog+0x108>)
 80210aa:	2200      	movs	r2, #0
 80210ac:	701a      	strb	r2, [r3, #0]
 80210ae:	e00e      	b.n	80210ce <DC_CheckWatchdog+0x4e>
        }
        else
        {
            if(Sync0WdCounter < Sync0WdValue)
 80210b0:	4b34      	ldr	r3, [pc, #208]	; (8021184 <DC_CheckWatchdog+0x104>)
 80210b2:	881a      	ldrh	r2, [r3, #0]
 80210b4:	4b32      	ldr	r3, [pc, #200]	; (8021180 <DC_CheckWatchdog+0x100>)
 80210b6:	881b      	ldrh	r3, [r3, #0]
 80210b8:	429a      	cmp	r2, r3
 80210ba:	d205      	bcs.n	80210c8 <DC_CheckWatchdog+0x48>
            {
                Sync0WdCounter ++;
 80210bc:	4b31      	ldr	r3, [pc, #196]	; (8021184 <DC_CheckWatchdog+0x104>)
 80210be:	881b      	ldrh	r3, [r3, #0]
 80210c0:	3301      	adds	r3, #1
 80210c2:	b29a      	uxth	r2, r3
 80210c4:	4b2f      	ldr	r3, [pc, #188]	; (8021184 <DC_CheckWatchdog+0x104>)
 80210c6:	801a      	strh	r2, [r3, #0]
            }

            bDcRunning = TRUE;
 80210c8:	4b2f      	ldr	r3, [pc, #188]	; (8021188 <DC_CheckWatchdog+0x108>)
 80210ca:	2201      	movs	r2, #1
 80210cc:	701a      	strb	r2, [r3, #0]
        }

        if(bDcRunning)
 80210ce:	4b2e      	ldr	r3, [pc, #184]	; (8021188 <DC_CheckWatchdog+0x108>)
 80210d0:	781b      	ldrb	r3, [r3, #0]
 80210d2:	2b00      	cmp	r3, #0
 80210d4:	d013      	beq.n	80210fe <DC_CheckWatchdog+0x7e>
        {
            /*Check the Sync1 cycle if Sync1 Wd is enabled*/
            if(Sync1WdValue > 0)
 80210d6:	4b2d      	ldr	r3, [pc, #180]	; (802118c <DC_CheckWatchdog+0x10c>)
 80210d8:	881b      	ldrh	r3, [r3, #0]
 80210da:	2b00      	cmp	r3, #0
 80210dc:	d00f      	beq.n	80210fe <DC_CheckWatchdog+0x7e>
            {
                if(Sync1WdCounter < Sync1WdValue)
 80210de:	4b2c      	ldr	r3, [pc, #176]	; (8021190 <DC_CheckWatchdog+0x110>)
 80210e0:	881a      	ldrh	r2, [r3, #0]
 80210e2:	4b2a      	ldr	r3, [pc, #168]	; (802118c <DC_CheckWatchdog+0x10c>)
 80210e4:	881b      	ldrh	r3, [r3, #0]
 80210e6:	429a      	cmp	r2, r3
 80210e8:	d206      	bcs.n	80210f8 <DC_CheckWatchdog+0x78>
                {
                    Sync1WdCounter ++;
 80210ea:	4b29      	ldr	r3, [pc, #164]	; (8021190 <DC_CheckWatchdog+0x110>)
 80210ec:	881b      	ldrh	r3, [r3, #0]
 80210ee:	3301      	adds	r3, #1
 80210f0:	b29a      	uxth	r2, r3
 80210f2:	4b27      	ldr	r3, [pc, #156]	; (8021190 <DC_CheckWatchdog+0x110>)
 80210f4:	801a      	strh	r2, [r3, #0]
 80210f6:	e002      	b.n	80210fe <DC_CheckWatchdog+0x7e>
                }
                else
                {
                    /*Sync1 watchdog expired*/
                    bDcRunning = FALSE;
 80210f8:	4b23      	ldr	r3, [pc, #140]	; (8021188 <DC_CheckWatchdog+0x108>)
 80210fa:	2200      	movs	r2, #0
 80210fc:	701a      	strb	r2, [r3, #0]
                }
            }
        }
        if(bDcRunning)
 80210fe:	4b22      	ldr	r3, [pc, #136]	; (8021188 <DC_CheckWatchdog+0x108>)
 8021100:	781b      	ldrb	r3, [r3, #0]
 8021102:	2b00      	cmp	r3, #0
 8021104:	d02d      	beq.n	8021162 <DC_CheckWatchdog+0xe2>
        {
/*ECATCHANGE_START(V5.13) ESM4*/
           if((sErrorSettings.u16SyncErrorCounterLimit == 0) || (sSyncManOutPar.u16SmEventMissedCounter < sErrorSettings.u16SyncErrorCounterLimit))
 8021106:	4b23      	ldr	r3, [pc, #140]	; (8021194 <DC_CheckWatchdog+0x114>)
 8021108:	891b      	ldrh	r3, [r3, #8]
 802110a:	2b00      	cmp	r3, #0
 802110c:	d005      	beq.n	802111a <DC_CheckWatchdog+0x9a>
 802110e:	4b22      	ldr	r3, [pc, #136]	; (8021198 <DC_CheckWatchdog+0x118>)
 8021110:	8d1a      	ldrh	r2, [r3, #40]	; 0x28
 8021112:	4b20      	ldr	r3, [pc, #128]	; (8021194 <DC_CheckWatchdog+0x114>)
 8021114:	891b      	ldrh	r3, [r3, #8]
 8021116:	429a      	cmp	r2, r3
 8021118:	d212      	bcs.n	8021140 <DC_CheckWatchdog+0xc0>
/*ECATCHANGE_END(V5.13) ESM4*/
            {
                bSmSyncSequenceValid = TRUE;
 802111a:	4b20      	ldr	r3, [pc, #128]	; (802119c <DC_CheckWatchdog+0x11c>)
 802111c:	2201      	movs	r2, #1
 802111e:	701a      	strb	r2, [r3, #0]

                /*Wait for PLL is active increment the Pll valid counter*/
                if (i16WaitForPllRunningTimeout > 0)
 8021120:	4b1f      	ldr	r3, [pc, #124]	; (80211a0 <DC_CheckWatchdog+0x120>)
 8021122:	881b      	ldrh	r3, [r3, #0]
 8021124:	b21b      	sxth	r3, r3
 8021126:	2b00      	cmp	r3, #0
 8021128:	dd09      	ble.n	802113e <DC_CheckWatchdog+0xbe>
                {
                    i16WaitForPllRunningCnt++;
 802112a:	4b1e      	ldr	r3, [pc, #120]	; (80211a4 <DC_CheckWatchdog+0x124>)
 802112c:	881b      	ldrh	r3, [r3, #0]
 802112e:	b29b      	uxth	r3, r3
 8021130:	b29b      	uxth	r3, r3
 8021132:	3301      	adds	r3, #1
 8021134:	b29b      	uxth	r3, r3
 8021136:	b29a      	uxth	r2, r3
 8021138:	4b1a      	ldr	r3, [pc, #104]	; (80211a4 <DC_CheckWatchdog+0x124>)
 802113a:	801a      	strh	r2, [r3, #0]
/*ECATCHANGE_END(V5.13) ESM4*/
            {
                bSmSyncSequenceValid = TRUE;

                /*Wait for PLL is active increment the Pll valid counter*/
                if (i16WaitForPllRunningTimeout > 0)
 802113c:	e010      	b.n	8021160 <DC_CheckWatchdog+0xe0>
 802113e:	e00f      	b.n	8021160 <DC_CheckWatchdog+0xe0>
                {
                    i16WaitForPllRunningCnt++;
                }
            }
            else if (bSmSyncSequenceValid)
 8021140:	4b16      	ldr	r3, [pc, #88]	; (802119c <DC_CheckWatchdog+0x11c>)
 8021142:	781b      	ldrb	r3, [r3, #0]
 8021144:	2b00      	cmp	r3, #0
 8021146:	d013      	beq.n	8021170 <DC_CheckWatchdog+0xf0>
            {
                    bSmSyncSequenceValid = FALSE;
 8021148:	4b14      	ldr	r3, [pc, #80]	; (802119c <DC_CheckWatchdog+0x11c>)
 802114a:	2200      	movs	r2, #0
 802114c:	701a      	strb	r2, [r3, #0]

                /*Wait for PLL is active reset the Pll valid counter*/
                if (i16WaitForPllRunningTimeout > 0)
 802114e:	4b14      	ldr	r3, [pc, #80]	; (80211a0 <DC_CheckWatchdog+0x120>)
 8021150:	881b      	ldrh	r3, [r3, #0]
 8021152:	b21b      	sxth	r3, r3
 8021154:	2b00      	cmp	r3, #0
 8021156:	dd0b      	ble.n	8021170 <DC_CheckWatchdog+0xf0>
                {
                    i16WaitForPllRunningCnt = 0;
 8021158:	4b12      	ldr	r3, [pc, #72]	; (80211a4 <DC_CheckWatchdog+0x124>)
 802115a:	2200      	movs	r2, #0
 802115c:	801a      	strh	r2, [r3, #0]
 802115e:	e007      	b.n	8021170 <DC_CheckWatchdog+0xf0>
 8021160:	e006      	b.n	8021170 <DC_CheckWatchdog+0xf0>
                }
            }
        }
        else if(bSmSyncSequenceValid)
 8021162:	4b0e      	ldr	r3, [pc, #56]	; (802119c <DC_CheckWatchdog+0x11c>)
 8021164:	781b      	ldrb	r3, [r3, #0]
 8021166:	2b00      	cmp	r3, #0
 8021168:	d002      	beq.n	8021170 <DC_CheckWatchdog+0xf0>
        {
           bSmSyncSequenceValid = FALSE;
 802116a:	4b0c      	ldr	r3, [pc, #48]	; (802119c <DC_CheckWatchdog+0x11c>)
 802116c:	2200      	movs	r2, #0
 802116e:	701a      	strb	r2, [r3, #0]
        }
    }
}
 8021170:	46bd      	mov	sp, r7
 8021172:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021176:	4770      	bx	lr
 8021178:	1fff29ec 	.word	0x1fff29ec
 802117c:	1fff29f2 	.word	0x1fff29f2
 8021180:	1fff29c4 	.word	0x1fff29c4
 8021184:	1fff29bc 	.word	0x1fff29bc
 8021188:	1fff29d0 	.word	0x1fff29d0
 802118c:	1fff29ca 	.word	0x1fff29ca
 8021190:	1fff29ee 	.word	0x1fff29ee
 8021194:	1fff13cc 	.word	0x1fff13cc
 8021198:	1fff2ad4 	.word	0x1fff2ad4
 802119c:	1fff29e9 	.word	0x1fff29e9
 80211a0:	1fff29c8 	.word	0x1fff29c8
 80211a4:	1fff29c0 	.word	0x1fff29c0

080211a8 <ECAT_Init>:

 \brief    This function initialize the EtherCAT Slave Interface.
*////////////////////////////////////////////////////////////////////////////////////////

void ECAT_Init(void)
{
 80211a8:	b580      	push	{r7, lr}
 80211aa:	b082      	sub	sp, #8
 80211ac:	af00      	add	r7, sp, #0
    UINT8 i;
    /*Get Maximum Number of SyncManagers and supported DPRAM size*/
    HW_EscReadByte(nMaxSyncMan, ESC_SM_CHANNELS_OFFSET);
 80211ae:	4b39      	ldr	r3, [pc, #228]	; (8021294 <ECAT_Init+0xec>)
 80211b0:	781b      	ldrb	r3, [r3, #0]
 80211b2:	b2da      	uxtb	r2, r3
 80211b4:	4b38      	ldr	r3, [pc, #224]	; (8021298 <ECAT_Init+0xf0>)
 80211b6:	701a      	strb	r2, [r3, #0]

    HW_EscReadWord(nMaxEscAddress, ESC_DPRAM_SIZE_OFFSET);
 80211b8:	4b38      	ldr	r3, [pc, #224]	; (802129c <ECAT_Init+0xf4>)
 80211ba:	881b      	ldrh	r3, [r3, #0]
 80211bc:	b29a      	uxth	r2, r3
 80211be:	4b38      	ldr	r3, [pc, #224]	; (80212a0 <ECAT_Init+0xf8>)
 80211c0:	801a      	strh	r2, [r3, #0]
    //get max address (register + DPRAM size in Byte (in the register it is stored in KB))
    nMaxEscAddress = (nMaxEscAddress << 10) + 0xFFF;
 80211c2:	4b37      	ldr	r3, [pc, #220]	; (80212a0 <ECAT_Init+0xf8>)
 80211c4:	881b      	ldrh	r3, [r3, #0]
 80211c6:	029b      	lsls	r3, r3, #10
 80211c8:	b29b      	uxth	r3, r3
 80211ca:	f603 73ff 	addw	r3, r3, #4095	; 0xfff
 80211ce:	b29a      	uxth	r2, r3
 80211d0:	4b33      	ldr	r3, [pc, #204]	; (80212a0 <ECAT_Init+0xf8>)
 80211d2:	801a      	strh	r2, [r3, #0]


    /* Get EEPROM loaded information */
    UpdateEEPROMLoadedState();
 80211d4:	f7ff fea4 	bl	8020f20 <UpdateEEPROMLoadedState>

    /* disable all Sync Manager channels */
    for (i = 0; i < nMaxSyncMan; i++)
 80211d8:	2300      	movs	r3, #0
 80211da:	71fb      	strb	r3, [r7, #7]
 80211dc:	e006      	b.n	80211ec <ECAT_Init+0x44>
    {
        DisableSyncManChannel(i);
 80211de:	79fb      	ldrb	r3, [r7, #7]
 80211e0:	4618      	mov	r0, r3
 80211e2:	f7ff febf 	bl	8020f64 <DisableSyncManChannel>

    /* Get EEPROM loaded information */
    UpdateEEPROMLoadedState();

    /* disable all Sync Manager channels */
    for (i = 0; i < nMaxSyncMan; i++)
 80211e6:	79fb      	ldrb	r3, [r7, #7]
 80211e8:	3301      	adds	r3, #1
 80211ea:	71fb      	strb	r3, [r7, #7]
 80211ec:	4b2a      	ldr	r3, [pc, #168]	; (8021298 <ECAT_Init+0xf0>)
 80211ee:	781b      	ldrb	r3, [r3, #0]
 80211f0:	79fa      	ldrb	r2, [r7, #7]
 80211f2:	429a      	cmp	r2, r3
 80211f4:	d3f3      	bcc.n	80211de <ECAT_Init+0x36>
    {
        DisableSyncManChannel(i);
    }

    /* initialize the mailbox handler */
    MBX_Init();
 80211f6:	f000 f87f 	bl	80212f8 <MBX_Init>

    /* initialize variables */
    bApplEsmPending = FALSE;
 80211fa:	4b2a      	ldr	r3, [pc, #168]	; (80212a4 <ECAT_Init+0xfc>)
 80211fc:	2200      	movs	r2, #0
 80211fe:	701a      	strb	r2, [r3, #0]
    bEcatWaitForAlControlRes = FALSE;
 8021200:	4b29      	ldr	r3, [pc, #164]	; (80212a8 <ECAT_Init+0x100>)
 8021202:	2200      	movs	r2, #0
 8021204:	701a      	strb	r2, [r3, #0]
    bEcatFirstOutputsReceived = FALSE;
 8021206:	4b29      	ldr	r3, [pc, #164]	; (80212ac <ECAT_Init+0x104>)
 8021208:	2200      	movs	r2, #0
 802120a:	701a      	strb	r2, [r3, #0]
     bEcatOutputUpdateRunning = FALSE;
 802120c:	4b28      	ldr	r3, [pc, #160]	; (80212b0 <ECAT_Init+0x108>)
 802120e:	2200      	movs	r2, #0
 8021210:	701a      	strb	r2, [r3, #0]
     bEcatInputUpdateRunning = FALSE;
 8021212:	4b28      	ldr	r3, [pc, #160]	; (80212b4 <ECAT_Init+0x10c>)
 8021214:	2200      	movs	r2, #0
 8021216:	701a      	strb	r2, [r3, #0]
    bWdTrigger = FALSE;
 8021218:	4b27      	ldr	r3, [pc, #156]	; (80212b8 <ECAT_Init+0x110>)
 802121a:	2200      	movs	r2, #0
 802121c:	701a      	strb	r2, [r3, #0]
    EcatWdValue = 0;
 802121e:	4b27      	ldr	r3, [pc, #156]	; (80212bc <ECAT_Init+0x114>)
 8021220:	2200      	movs	r2, #0
 8021222:	801a      	strh	r2, [r3, #0]
    Sync0WdCounter = 0;
 8021224:	4b26      	ldr	r3, [pc, #152]	; (80212c0 <ECAT_Init+0x118>)
 8021226:	2200      	movs	r2, #0
 8021228:	801a      	strh	r2, [r3, #0]
    Sync0WdValue = 0;
 802122a:	4b26      	ldr	r3, [pc, #152]	; (80212c4 <ECAT_Init+0x11c>)
 802122c:	2200      	movs	r2, #0
 802122e:	801a      	strh	r2, [r3, #0]
    Sync1WdCounter = 0;
 8021230:	4b25      	ldr	r3, [pc, #148]	; (80212c8 <ECAT_Init+0x120>)
 8021232:	2200      	movs	r2, #0
 8021234:	801a      	strh	r2, [r3, #0]
    Sync1WdValue = 0;
 8021236:	4b25      	ldr	r3, [pc, #148]	; (80212cc <ECAT_Init+0x124>)
 8021238:	2200      	movs	r2, #0
 802123a:	801a      	strh	r2, [r3, #0]
    bDcSyncActive = FALSE;
 802123c:	4b24      	ldr	r3, [pc, #144]	; (80212d0 <ECAT_Init+0x128>)
 802123e:	2200      	movs	r2, #0
 8021240:	701a      	strb	r2, [r3, #0]

    /*ECATCHANGE_START(V5.13) ESM1*/
    u8LocalErrorState = 0;
 8021242:	4b24      	ldr	r3, [pc, #144]	; (80212d4 <ECAT_Init+0x12c>)
 8021244:	2200      	movs	r2, #0
 8021246:	701a      	strb	r2, [r3, #0]
    /*ECATCHANGE_END(V5.13) ESM1*/
    u16LocalErrorCode = 0x00;
 8021248:	4b23      	ldr	r3, [pc, #140]	; (80212d8 <ECAT_Init+0x130>)
 802124a:	2200      	movs	r2, #0
 802124c:	801a      	strh	r2, [r3, #0]

    u16ALEventMask = 0;
 802124e:	4b23      	ldr	r3, [pc, #140]	; (80212dc <ECAT_Init+0x134>)
 8021250:	2200      	movs	r2, #0
 8021252:	801a      	strh	r2, [r3, #0]
    nPdOutputSize = 0;
 8021254:	4b22      	ldr	r3, [pc, #136]	; (80212e0 <ECAT_Init+0x138>)
 8021256:	2200      	movs	r2, #0
 8021258:	801a      	strh	r2, [r3, #0]
    nPdInputSize = 0;
 802125a:	4b22      	ldr	r3, [pc, #136]	; (80212e4 <ECAT_Init+0x13c>)
 802125c:	2200      	movs	r2, #0
 802125e:	801a      	strh	r2, [r3, #0]

    /* initialize the AL Status register */
    nAlStatus    = STATE_INIT;
 8021260:	4b21      	ldr	r3, [pc, #132]	; (80212e8 <ECAT_Init+0x140>)
 8021262:	2201      	movs	r2, #1
 8021264:	701a      	strb	r2, [r3, #0]
    SetALStatus(nAlStatus, 0);
 8021266:	4b20      	ldr	r3, [pc, #128]	; (80212e8 <ECAT_Init+0x140>)
 8021268:	781b      	ldrb	r3, [r3, #0]
 802126a:	4618      	mov	r0, r3
 802126c:	2100      	movs	r1, #0
 802126e:	f7ff fea3 	bl	8020fb8 <SetALStatus>
    nEcatStateTrans = 0;
 8021272:	4b1e      	ldr	r3, [pc, #120]	; (80212ec <ECAT_Init+0x144>)
 8021274:	2200      	movs	r2, #0
 8021276:	801a      	strh	r2, [r3, #0]
    u8EcatErrorLed = LED_OFF;
 8021278:	4b1d      	ldr	r3, [pc, #116]	; (80212f0 <ECAT_Init+0x148>)
 802127a:	2200      	movs	r2, #0
 802127c:	701a      	strb	r2, [r3, #0]

    bEscIntEnabled = FALSE;
 802127e:	4b1d      	ldr	r3, [pc, #116]	; (80212f4 <ECAT_Init+0x14c>)
 8021280:	2200      	movs	r2, #0
 8021282:	701a      	strb	r2, [r3, #0]

    /* initialize the COE part */
    COE_Init();
 8021284:	f7ff fe24 	bl	8020ed0 <COE_Init>

/*ECATCHANGE_START(V5.13) ECAT1*/
/*ECATCHANGE_END(V5.13) ECAT1*/
    /*reset AL event mask*/
    ResetALEventMask(0);
 8021288:	2000      	movs	r0, #0
 802128a:	f7ff fe31 	bl	8020ef0 <ResetALEventMask>
}
 802128e:	3708      	adds	r7, #8
 8021290:	46bd      	mov	sp, r7
 8021292:	bd80      	pop	{r7, pc}
 8021294:	54010005 	.word	0x54010005
 8021298:	1fff29f8 	.word	0x1fff29f8
 802129c:	54010006 	.word	0x54010006
 80212a0:	1fff29e6 	.word	0x1fff29e6
 80212a4:	1fff29b4 	.word	0x1fff29b4
 80212a8:	1fff29e0 	.word	0x1fff29e0
 80212ac:	1fff29e8 	.word	0x1fff29e8
 80212b0:	1fff29ed 	.word	0x1fff29ed
 80212b4:	1fff29f2 	.word	0x1fff29f2
 80212b8:	1fff29f4 	.word	0x1fff29f4
 80212bc:	1fff29f0 	.word	0x1fff29f0
 80212c0:	1fff29bc 	.word	0x1fff29bc
 80212c4:	1fff29c4 	.word	0x1fff29c4
 80212c8:	1fff29ee 	.word	0x1fff29ee
 80212cc:	1fff29ca 	.word	0x1fff29ca
 80212d0:	1fff29ec 	.word	0x1fff29ec
 80212d4:	1fff29ba 	.word	0x1fff29ba
 80212d8:	1fff29b8 	.word	0x1fff29b8
 80212dc:	1fff29ce 	.word	0x1fff29ce
 80212e0:	1fff29b6 	.word	0x1fff29b6
 80212e4:	1fff29e2 	.word	0x1fff29e2
 80212e8:	1fff29b5 	.word	0x1fff29b5
 80212ec:	1fff29b2 	.word	0x1fff29b2
 80212f0:	1fff29f9 	.word	0x1fff29f9
 80212f4:	1fff29f3 	.word	0x1fff29f3

080212f8 <MBX_Init>:
/**
 \brief    This function intialize the Mailbox Interface.
*////////////////////////////////////////////////////////////////////////////////////////

void MBX_Init(void)
{
 80212f8:	b480      	push	{r7}
 80212fa:	b083      	sub	sp, #12
 80212fc:	af00      	add	r7, sp, #0
    
    u16ReceiveMbxSize = MIN_MBX_SIZE;
 80212fe:	4b29      	ldr	r3, [pc, #164]	; (80213a4 <MBX_Init+0xac>)
 8021300:	2224      	movs	r2, #36	; 0x24
 8021302:	801a      	strh	r2, [r3, #0]
    u16SendMbxSize = MAX_MBX_SIZE;
 8021304:	4b28      	ldr	r3, [pc, #160]	; (80213a8 <MBX_Init+0xb0>)
 8021306:	2280      	movs	r2, #128	; 0x80
 8021308:	801a      	strh	r2, [r3, #0]
    u16EscAddrReceiveMbx = MIN_MBX_WRITE_ADDRESS;
 802130a:	4b28      	ldr	r3, [pc, #160]	; (80213ac <MBX_Init+0xb4>)
 802130c:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8021310:	801a      	strh	r2, [r3, #0]
    u16EscAddrSendMbx = MIN_MBX_READ_ADDRESS;
 8021312:	4b27      	ldr	r3, [pc, #156]	; (80213b0 <MBX_Init+0xb8>)
 8021314:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8021318:	801a      	strh	r2, [r3, #0]

    sMbxReceiveQueue.firstInQueue    = 0;
 802131a:	4b26      	ldr	r3, [pc, #152]	; (80213b4 <MBX_Init+0xbc>)
 802131c:	2200      	movs	r2, #0
 802131e:	801a      	strh	r2, [r3, #0]
    sMbxReceiveQueue.lastInQueue     = 0;
 8021320:	4b24      	ldr	r3, [pc, #144]	; (80213b4 <MBX_Init+0xbc>)
 8021322:	2200      	movs	r2, #0
 8021324:	805a      	strh	r2, [r3, #2]
    sMbxReceiveQueue.maxQueueSize = MAX_MBX_QUEUE_SIZE;
 8021326:	4b23      	ldr	r3, [pc, #140]	; (80213b4 <MBX_Init+0xbc>)
 8021328:	220a      	movs	r2, #10
 802132a:	809a      	strh	r2, [r3, #4]
    sMbxSendQueue.firstInQueue        = 0;
 802132c:	4b22      	ldr	r3, [pc, #136]	; (80213b8 <MBX_Init+0xc0>)
 802132e:	2200      	movs	r2, #0
 8021330:	801a      	strh	r2, [r3, #0]
    sMbxSendQueue.lastInQueue         = 0;
 8021332:	4b21      	ldr	r3, [pc, #132]	; (80213b8 <MBX_Init+0xc0>)
 8021334:	2200      	movs	r2, #0
 8021336:	805a      	strh	r2, [r3, #2]
    sMbxSendQueue.maxQueueSize     = MAX_MBX_QUEUE_SIZE;
 8021338:	4b1f      	ldr	r3, [pc, #124]	; (80213b8 <MBX_Init+0xc0>)
 802133a:	220a      	movs	r2, #10
 802133c:	809a      	strh	r2, [r3, #4]
    psWriteMbx  = NULL;
 802133e:	4b1f      	ldr	r3, [pc, #124]	; (80213bc <MBX_Init+0xc4>)
 8021340:	2200      	movs	r2, #0
 8021342:	601a      	str	r2, [r3, #0]


    psRepeatMbx = NULL;
 8021344:	4b1e      	ldr	r3, [pc, #120]	; (80213c0 <MBX_Init+0xc8>)
 8021346:	2200      	movs	r2, #0
 8021348:	601a      	str	r2, [r3, #0]
    psReadMbx    = NULL;
 802134a:	4b1e      	ldr	r3, [pc, #120]	; (80213c4 <MBX_Init+0xcc>)
 802134c:	2200      	movs	r2, #0
 802134e:	601a      	str	r2, [r3, #0]
    psStoreMbx    = NULL;
 8021350:	4b1d      	ldr	r3, [pc, #116]	; (80213c8 <MBX_Init+0xd0>)
 8021352:	2200      	movs	r2, #0
 8021354:	601a      	str	r2, [r3, #0]

    bMbxRepeatToggle    = FALSE;
 8021356:	4b1d      	ldr	r3, [pc, #116]	; (80213cc <MBX_Init+0xd4>)
 8021358:	2200      	movs	r2, #0
 802135a:	701a      	strb	r2, [r3, #0]
    /*Reset Repeat acknowledge bit of SyncManager1 (0x80F bit 2)*/
    {
        UINT8 sm1Activate = 0;
 802135c:	2300      	movs	r3, #0
 802135e:	71fb      	strb	r3, [r7, #7]
        HW_EscReadByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
 8021360:	4b1b      	ldr	r3, [pc, #108]	; (80213d0 <MBX_Init+0xd8>)
 8021362:	781b      	ldrb	r3, [r3, #0]
 8021364:	71fb      	strb	r3, [r7, #7]
        sm1Activate &= ~0x02;
 8021366:	79fb      	ldrb	r3, [r7, #7]
 8021368:	f023 0302 	bic.w	r3, r3, #2
 802136c:	71fb      	strb	r3, [r7, #7]
        HW_EscWriteByte(sm1Activate,(ESC_SM_PDICONTROL_OFFSET + SIZEOF_SM_REGISTER));
 802136e:	4a18      	ldr	r2, [pc, #96]	; (80213d0 <MBX_Init+0xd8>)
 8021370:	79fb      	ldrb	r3, [r7, #7]
 8021372:	7013      	strb	r3, [r2, #0]
    }
    bMbxRunning = FALSE;
 8021374:	4b17      	ldr	r3, [pc, #92]	; (80213d4 <MBX_Init+0xdc>)
 8021376:	2200      	movs	r2, #0
 8021378:	701a      	strb	r2, [r3, #0]
    bSendMbxIsFull = FALSE;
 802137a:	4b17      	ldr	r3, [pc, #92]	; (80213d8 <MBX_Init+0xe0>)
 802137c:	2200      	movs	r2, #0
 802137e:	701a      	strb	r2, [r3, #0]
    bReceiveMbxIsLocked = FALSE;
 8021380:	4b16      	ldr	r3, [pc, #88]	; (80213dc <MBX_Init+0xe4>)
 8021382:	2200      	movs	r2, #0
 8021384:	701a      	strb	r2, [r3, #0]
    u8MailboxSendReqStored    = 0;
 8021386:	4b16      	ldr	r3, [pc, #88]	; (80213e0 <MBX_Init+0xe8>)
 8021388:	2200      	movs	r2, #0
 802138a:	701a      	strb	r2, [r3, #0]
    u8MbxWriteCounter = 0;
 802138c:	4b15      	ldr	r3, [pc, #84]	; (80213e4 <MBX_Init+0xec>)
 802138e:	2200      	movs	r2, #0
 8021390:	701a      	strb	r2, [r3, #0]
    u8MbxReadCounter    = 0;
 8021392:	4b15      	ldr	r3, [pc, #84]	; (80213e8 <MBX_Init+0xf0>)
 8021394:	2200      	movs	r2, #0
 8021396:	701a      	strb	r2, [r3, #0]
}
 8021398:	370c      	adds	r7, #12
 802139a:	46bd      	mov	sp, r7
 802139c:	f85d 7b04 	ldr.w	r7, [sp], #4
 80213a0:	4770      	bx	lr
 80213a2:	bf00      	nop
 80213a4:	1fff2a86 	.word	0x1fff2a86
 80213a8:	1fff2a74 	.word	0x1fff2a74
 80213ac:	1fff2a6c 	.word	0x1fff2a6c
 80213b0:	1fff2a7e 	.word	0x1fff2a7e
 80213b4:	1fff2a34 	.word	0x1fff2a34
 80213b8:	1fff2a00 	.word	0x1fff2a00
 80213bc:	1fff2a80 	.word	0x1fff2a80
 80213c0:	1fff2a8c 	.word	0x1fff2a8c
 80213c4:	1fff2a78 	.word	0x1fff2a78
 80213c8:	1fff2a70 	.word	0x1fff2a70
 80213cc:	1fff2a88 	.word	0x1fff2a88
 80213d0:	5401080f 	.word	0x5401080f
 80213d4:	1fff2a6a 	.word	0x1fff2a6a
 80213d8:	1fff2a69 	.word	0x1fff2a69
 80213dc:	1fff2a7c 	.word	0x1fff2a7c
 80213e0:	1fff2a85 	.word	0x1fff2a85
 80213e4:	1fff2a84 	.word	0x1fff2a84
 80213e8:	1fff29fc 	.word	0x1fff29fc

080213ec <APPL_InputMapping>:

\brief      This function will copies the inputs from the local memory to the ESC memory
            to the hardware
*////////////////////////////////////////////////////////////////////////////////////////
void APPL_InputMapping(UINT16* pData)
{
 80213ec:	b480      	push	{r7}
 80213ee:	b083      	sub	sp, #12
 80213f0:	af00      	add	r7, sp, #0
 80213f2:	6078      	str	r0, [r7, #4]
#if _WIN32
   #pragma message ("Warning: Implement input (Slave->Master) mapping")
#else
    #warning "Implement input (Slave->Master) mapping"
#endif
}
 80213f4:	370c      	adds	r7, #12
 80213f6:	46bd      	mov	sp, r7
 80213f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80213fc:	4770      	bx	lr
 80213fe:	bf00      	nop

08021400 <APPL_OutputMapping>:

\brief    This function will copies the outputs from the ESC memory to the local memory
            to the hardware
*////////////////////////////////////////////////////////////////////////////////////////
void APPL_OutputMapping(UINT16* pData)
{
 8021400:	b480      	push	{r7}
 8021402:	b083      	sub	sp, #12
 8021404:	af00      	add	r7, sp, #0
 8021406:	6078      	str	r0, [r7, #4]
#if _WIN32
   #pragma message ("Warning: Implement output (Master->Slave) mapping")
#else
    #warning "Implement output (Master->Slave) mapping"
#endif
}
 8021408:	370c      	adds	r7, #12
 802140a:	46bd      	mov	sp, r7
 802140c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021410:	4770      	bx	lr
 8021412:	bf00      	nop

08021414 <APPL_Application>:
/**
\brief    This function will called from the synchronisation ISR 
            or from the mainloop if no synchronisation is supported
*////////////////////////////////////////////////////////////////////////////////////////
void APPL_Application(void)
{
 8021414:	b480      	push	{r7}
 8021416:	af00      	add	r7, sp, #0
#if _WIN32
   #pragma message ("Warning: Implement the slave application")
#else
    #warning "Implement the slave application"
#endif
}
 8021418:	46bd      	mov	sp, r7
 802141a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802141e:	4770      	bx	lr

08021420 <WriteSimulateCANFD>:
                               object shall be done or not

 \return    result of the read operation (0 (success) or an abort code (ABORTIDX_.... defined in
            sdosrv.h))
 *////////////////////////////////////////////////////////////////////////////////////////
UINT8 WriteSimulateCANFD(UINT16 index, UINT8 subindex, UINT32 dataSize, UINT16 MBXMEM * pData, UINT8 bCompleteAccess) {
 8021420:	b480      	push	{r7}
 8021422:	b085      	sub	sp, #20
 8021424:	af00      	add	r7, sp, #0
 8021426:	60ba      	str	r2, [r7, #8]
 8021428:	607b      	str	r3, [r7, #4]
 802142a:	4603      	mov	r3, r0
 802142c:	81fb      	strh	r3, [r7, #14]
 802142e:	460b      	mov	r3, r1
 8021430:	737b      	strb	r3, [r7, #13]
#if _WIN32
#pragma message ("Warning: Implement CoE write callback")
#else
 #warning "Implement CoE write callback"
#endif
 return 0;
 8021432:	2300      	movs	r3, #0
}
 8021434:	4618      	mov	r0, r3
 8021436:	3714      	adds	r7, #20
 8021438:	46bd      	mov	sp, r7
 802143a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802143e:	4770      	bx	lr

08021440 <XMC_FLASH_lEnterPageModeCommand>:

/*
 * Command to program the PFLASH in to page mode, so that assembly buffer is used
 */
void XMC_FLASH_lEnterPageModeCommand(void)
{
 8021440:	b480      	push	{r7}
 8021442:	b083      	sub	sp, #12
 8021444:	af00      	add	r7, sp, #0
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
 8021446:	4b05      	ldr	r3, [pc, #20]	; (802145c <XMC_FLASH_lEnterPageModeCommand+0x1c>)
 8021448:	607b      	str	r3, [r7, #4]
  *address = (uint32_t)0x50U;
 802144a:	687b      	ldr	r3, [r7, #4]
 802144c:	2250      	movs	r2, #80	; 0x50
 802144e:	601a      	str	r2, [r3, #0]
}
 8021450:	370c      	adds	r7, #12
 8021452:	46bd      	mov	sp, r7
 8021454:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021458:	4770      	bx	lr
 802145a:	bf00      	nop
 802145c:	0c005554 	.word	0x0c005554

08021460 <XMC_FLASH_lLoadPageCommand>:

/*
 * Command to load the data into the page assembly buffer
 */
void XMC_FLASH_lLoadPageCommand(uint32_t low_word, uint32_t high_word)
{
 8021460:	b480      	push	{r7}
 8021462:	b085      	sub	sp, #20
 8021464:	af00      	add	r7, sp, #0
 8021466:	6078      	str	r0, [r7, #4]
 8021468:	6039      	str	r1, [r7, #0]
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x55f0U);
 802146a:	4b07      	ldr	r3, [pc, #28]	; (8021488 <XMC_FLASH_lLoadPageCommand+0x28>)
 802146c:	60fb      	str	r3, [r7, #12]
  *address = low_word;
 802146e:	68fb      	ldr	r3, [r7, #12]
 8021470:	687a      	ldr	r2, [r7, #4]
 8021472:	601a      	str	r2, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x55f4U);
 8021474:	4b05      	ldr	r3, [pc, #20]	; (802148c <XMC_FLASH_lLoadPageCommand+0x2c>)
 8021476:	60fb      	str	r3, [r7, #12]
  *address = high_word;
 8021478:	68fb      	ldr	r3, [r7, #12]
 802147a:	683a      	ldr	r2, [r7, #0]
 802147c:	601a      	str	r2, [r3, #0]
}
 802147e:	3714      	adds	r7, #20
 8021480:	46bd      	mov	sp, r7
 8021482:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021486:	4770      	bx	lr
 8021488:	0c0055f0 	.word	0x0c0055f0
 802148c:	0c0055f4 	.word	0x0c0055f4

08021490 <XMC_FLASH_lWritePageCommand>:

/*
 * Command to start the programming of one page with data from the assembly buffer
 */
void XMC_FLASH_lWritePageCommand(uint32_t *page_start_address)
{
 8021490:	b480      	push	{r7}
 8021492:	b085      	sub	sp, #20
 8021494:	af00      	add	r7, sp, #0
 8021496:	6078      	str	r0, [r7, #4]
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
 8021498:	4b0c      	ldr	r3, [pc, #48]	; (80214cc <XMC_FLASH_lWritePageCommand+0x3c>)
 802149a:	60fb      	str	r3, [r7, #12]
  *address = 0xaaU;
 802149c:	68fb      	ldr	r3, [r7, #12]
 802149e:	22aa      	movs	r2, #170	; 0xaa
 80214a0:	601a      	str	r2, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0xaaa8U);
 80214a2:	4b0b      	ldr	r3, [pc, #44]	; (80214d0 <XMC_FLASH_lWritePageCommand+0x40>)
 80214a4:	60fb      	str	r3, [r7, #12]
  *address = 0x55U;
 80214a6:	68fb      	ldr	r3, [r7, #12]
 80214a8:	2255      	movs	r2, #85	; 0x55
 80214aa:	601a      	str	r2, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
 80214ac:	4b07      	ldr	r3, [pc, #28]	; (80214cc <XMC_FLASH_lWritePageCommand+0x3c>)
 80214ae:	60fb      	str	r3, [r7, #12]
  *address = 0xa0U;
 80214b0:	68fb      	ldr	r3, [r7, #12]
 80214b2:	22a0      	movs	r2, #160	; 0xa0
 80214b4:	601a      	str	r2, [r3, #0]
  address = page_start_address;
 80214b6:	687b      	ldr	r3, [r7, #4]
 80214b8:	60fb      	str	r3, [r7, #12]
  *address = 0xaaU;
 80214ba:	68fb      	ldr	r3, [r7, #12]
 80214bc:	22aa      	movs	r2, #170	; 0xaa
 80214be:	601a      	str	r2, [r3, #0]
}
 80214c0:	3714      	adds	r7, #20
 80214c2:	46bd      	mov	sp, r7
 80214c4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80214c8:	4770      	bx	lr
 80214ca:	bf00      	nop
 80214cc:	0c005554 	.word	0x0c005554
 80214d0:	0c00aaa8 	.word	0x0c00aaa8

080214d4 <XMC_FLASH_lEraseSectorCommand>:

/*
 * Command to erase sector which is starting with the specified address
 */
void XMC_FLASH_lEraseSectorCommand(uint32_t *sector_start_address)
{
 80214d4:	b480      	push	{r7}
 80214d6:	b085      	sub	sp, #20
 80214d8:	af00      	add	r7, sp, #0
 80214da:	6078      	str	r0, [r7, #4]
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
 80214dc:	4b11      	ldr	r3, [pc, #68]	; (8021524 <XMC_FLASH_lEraseSectorCommand+0x50>)
 80214de:	60fb      	str	r3, [r7, #12]
  *address = 0xaaU;
 80214e0:	68fb      	ldr	r3, [r7, #12]
 80214e2:	22aa      	movs	r2, #170	; 0xaa
 80214e4:	601a      	str	r2, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0xaaa8U);
 80214e6:	4b10      	ldr	r3, [pc, #64]	; (8021528 <XMC_FLASH_lEraseSectorCommand+0x54>)
 80214e8:	60fb      	str	r3, [r7, #12]
  *address = 0x55U;
 80214ea:	68fb      	ldr	r3, [r7, #12]
 80214ec:	2255      	movs	r2, #85	; 0x55
 80214ee:	601a      	str	r2, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
 80214f0:	4b0c      	ldr	r3, [pc, #48]	; (8021524 <XMC_FLASH_lEraseSectorCommand+0x50>)
 80214f2:	60fb      	str	r3, [r7, #12]
  *address = 0x80U;
 80214f4:	68fb      	ldr	r3, [r7, #12]
 80214f6:	2280      	movs	r2, #128	; 0x80
 80214f8:	601a      	str	r2, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
 80214fa:	4b0a      	ldr	r3, [pc, #40]	; (8021524 <XMC_FLASH_lEraseSectorCommand+0x50>)
 80214fc:	60fb      	str	r3, [r7, #12]
  *address = 0xaaU;
 80214fe:	68fb      	ldr	r3, [r7, #12]
 8021500:	22aa      	movs	r2, #170	; 0xaa
 8021502:	601a      	str	r2, [r3, #0]
  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0xaaa8U);
 8021504:	4b08      	ldr	r3, [pc, #32]	; (8021528 <XMC_FLASH_lEraseSectorCommand+0x54>)
 8021506:	60fb      	str	r3, [r7, #12]
  *address = 0x55U;
 8021508:	68fb      	ldr	r3, [r7, #12]
 802150a:	2255      	movs	r2, #85	; 0x55
 802150c:	601a      	str	r2, [r3, #0]
  address = sector_start_address;
 802150e:	687b      	ldr	r3, [r7, #4]
 8021510:	60fb      	str	r3, [r7, #12]
  *address = 0x30U;
 8021512:	68fb      	ldr	r3, [r7, #12]
 8021514:	2230      	movs	r2, #48	; 0x30
 8021516:	601a      	str	r2, [r3, #0]
}
 8021518:	3714      	adds	r7, #20
 802151a:	46bd      	mov	sp, r7
 802151c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021520:	4770      	bx	lr
 8021522:	bf00      	nop
 8021524:	0c005554 	.word	0x0c005554
 8021528:	0c00aaa8 	.word	0x0c00aaa8

0802152c <XMC_FLASH_lClearStatusCommand>:

/*
 * Command to clear FSR.PROG and FSR.ERASE and the error flags in FSR such as PFOPER, SQER, PROER, PFDBER, ORIER, VER
 */
void XMC_FLASH_lClearStatusCommand(void)
{
 802152c:	b480      	push	{r7}
 802152e:	b083      	sub	sp, #12
 8021530:	af00      	add	r7, sp, #0
  volatile uint32_t *address;

  address = (uint32_t *)(XMC_FLASH_UNCACHED_BASE + 0x5554U);
 8021532:	4b05      	ldr	r3, [pc, #20]	; (8021548 <XMC_FLASH_lClearStatusCommand+0x1c>)
 8021534:	607b      	str	r3, [r7, #4]
  *address = 0xf5U;
 8021536:	687b      	ldr	r3, [r7, #4]
 8021538:	22f5      	movs	r2, #245	; 0xf5
 802153a:	601a      	str	r2, [r3, #0]
}
 802153c:	370c      	adds	r7, #12
 802153e:	46bd      	mov	sp, r7
 8021540:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021544:	4770      	bx	lr
 8021546:	bf00      	nop
 8021548:	0c005554 	.word	0x0c005554

0802154c <XMC_FLASH_ClearStatus>:

/*
* This API shall clear Program, erase and error flags(PFOPER, SQER, PROER, PFDBER, ORIER, VER) of FSR register.
*/
void XMC_FLASH_ClearStatus(void)
{
 802154c:	b580      	push	{r7, lr}
 802154e:	af00      	add	r7, sp, #0
  XMC_FLASH_lClearStatusCommand();
 8021550:	f7ff ffec 	bl	802152c <XMC_FLASH_lClearStatusCommand>
}
 8021554:	bd80      	pop	{r7, pc}
 8021556:	bf00      	nop

08021558 <XMC_FLASH_GetStatus>:

/*
 * This API returns the FSR register value
 */
uint32_t XMC_FLASH_GetStatus(void)
{
 8021558:	b480      	push	{r7}
 802155a:	af00      	add	r7, sp, #0
  return FLASH0->FSR;
 802155c:	4b04      	ldr	r3, [pc, #16]	; (8021570 <XMC_FLASH_GetStatus+0x18>)
 802155e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8021562:	3310      	adds	r3, #16
 8021564:	681b      	ldr	r3, [r3, #0]
}
 8021566:	4618      	mov	r0, r3
 8021568:	46bd      	mov	sp, r7
 802156a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802156e:	4770      	bx	lr
 8021570:	58001000 	.word	0x58001000

08021574 <XMC_FLASH_ProgramPage>:

/*
 * This API write the PFLASH page
 */
void XMC_FLASH_ProgramPage(uint32_t *address, const uint32_t *data)
{
 8021574:	b580      	push	{r7, lr}
 8021576:	b084      	sub	sp, #16
 8021578:	af00      	add	r7, sp, #0
 802157a:	6078      	str	r0, [r7, #4]
 802157c:	6039      	str	r1, [r7, #0]
  uint32_t idx;

  XMC_FLASH_lClearStatusCommand();
 802157e:	f7ff ffd5 	bl	802152c <XMC_FLASH_lClearStatusCommand>
  XMC_FLASH_lEnterPageModeCommand();
 8021582:	f7ff ff5d 	bl	8021440 <XMC_FLASH_lEnterPageModeCommand>

  for (idx = 0U; idx < XMC_FLASH_WORDS_PER_PAGE; idx += 2U)
 8021586:	2300      	movs	r3, #0
 8021588:	60fb      	str	r3, [r7, #12]
 802158a:	e011      	b.n	80215b0 <XMC_FLASH_ProgramPage+0x3c>
  {
    XMC_FLASH_lLoadPageCommand(data[idx], data[idx + 1U]);
 802158c:	68fb      	ldr	r3, [r7, #12]
 802158e:	009b      	lsls	r3, r3, #2
 8021590:	683a      	ldr	r2, [r7, #0]
 8021592:	4413      	add	r3, r2
 8021594:	6819      	ldr	r1, [r3, #0]
 8021596:	68fb      	ldr	r3, [r7, #12]
 8021598:	3301      	adds	r3, #1
 802159a:	009b      	lsls	r3, r3, #2
 802159c:	683a      	ldr	r2, [r7, #0]
 802159e:	4413      	add	r3, r2
 80215a0:	681b      	ldr	r3, [r3, #0]
 80215a2:	4608      	mov	r0, r1
 80215a4:	4619      	mov	r1, r3
 80215a6:	f7ff ff5b 	bl	8021460 <XMC_FLASH_lLoadPageCommand>
  uint32_t idx;

  XMC_FLASH_lClearStatusCommand();
  XMC_FLASH_lEnterPageModeCommand();

  for (idx = 0U; idx < XMC_FLASH_WORDS_PER_PAGE; idx += 2U)
 80215aa:	68fb      	ldr	r3, [r7, #12]
 80215ac:	3302      	adds	r3, #2
 80215ae:	60fb      	str	r3, [r7, #12]
 80215b0:	68fb      	ldr	r3, [r7, #12]
 80215b2:	2b3f      	cmp	r3, #63	; 0x3f
 80215b4:	d9ea      	bls.n	802158c <XMC_FLASH_ProgramPage+0x18>
  {
    XMC_FLASH_lLoadPageCommand(data[idx], data[idx + 1U]);
  }

  XMC_FLASH_lWritePageCommand(address);
 80215b6:	6878      	ldr	r0, [r7, #4]
 80215b8:	f7ff ff6a 	bl	8021490 <XMC_FLASH_lWritePageCommand>

  /* wait until the operation is completed */
  while ((FLASH0->FSR & (uint32_t)FLASH_FSR_PBUSY_Msk) != 0U) {}
 80215bc:	bf00      	nop
 80215be:	4b06      	ldr	r3, [pc, #24]	; (80215d8 <XMC_FLASH_ProgramPage+0x64>)
 80215c0:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80215c4:	3310      	adds	r3, #16
 80215c6:	681b      	ldr	r3, [r3, #0]
 80215c8:	f003 0301 	and.w	r3, r3, #1
 80215cc:	2b00      	cmp	r3, #0
 80215ce:	d1f6      	bne.n	80215be <XMC_FLASH_ProgramPage+0x4a>
}
 80215d0:	3710      	adds	r7, #16
 80215d2:	46bd      	mov	sp, r7
 80215d4:	bd80      	pop	{r7, pc}
 80215d6:	bf00      	nop
 80215d8:	58001000 	.word	0x58001000

080215dc <XMC_FLASH_EraseSector>:

/*
 * This API erase the logical sector
 */
void XMC_FLASH_EraseSector(uint32_t *address)
{
 80215dc:	b580      	push	{r7, lr}
 80215de:	b082      	sub	sp, #8
 80215e0:	af00      	add	r7, sp, #0
 80215e2:	6078      	str	r0, [r7, #4]
  XMC_FLASH_lClearStatusCommand();
 80215e4:	f7ff ffa2 	bl	802152c <XMC_FLASH_lClearStatusCommand>
  XMC_FLASH_lEraseSectorCommand(address);
 80215e8:	6878      	ldr	r0, [r7, #4]
 80215ea:	f7ff ff73 	bl	80214d4 <XMC_FLASH_lEraseSectorCommand>

  /* wait until the operation is completed */
  while ((FLASH0->FSR & (uint32_t)FLASH_FSR_PBUSY_Msk) != 0U) {}
 80215ee:	bf00      	nop
 80215f0:	4b05      	ldr	r3, [pc, #20]	; (8021608 <XMC_FLASH_EraseSector+0x2c>)
 80215f2:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80215f6:	3310      	adds	r3, #16
 80215f8:	681b      	ldr	r3, [r3, #0]
 80215fa:	f003 0301 	and.w	r3, r3, #1
 80215fe:	2b00      	cmp	r3, #0
 8021600:	d1f6      	bne.n	80215f0 <XMC_FLASH_EraseSector+0x14>
}
 8021602:	3708      	adds	r7, #8
 8021604:	46bd      	mov	sp, r7
 8021606:	bd80      	pop	{r7, pc}
 8021608:	58001000 	.word	0x58001000

0802160c <XMC_GPIO_Init>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

void XMC_GPIO_Init(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_CONFIG_t *const config)
{
 802160c:	b480      	push	{r7}
 802160e:	b085      	sub	sp, #20
 8021610:	af00      	add	r7, sp, #0
 8021612:	60f8      	str	r0, [r7, #12]
 8021614:	460b      	mov	r3, r1
 8021616:	607a      	str	r2, [r7, #4]
 8021618:	72fb      	strb	r3, [r7, #11]
  XMC_ASSERT("XMC_GPIO_Init: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_Init: Invalid mode", XMC_GPIO_IsModeValid(config->mode));

  /* Switch to input */
  port->IOCR[pin >> 2U] &= (uint32_t)~(PORT_IOCR_PC_Msk << (PORT_IOCR_PC_Size * (pin & 0x3U)));
 802161a:	7afb      	ldrb	r3, [r7, #11]
 802161c:	089b      	lsrs	r3, r3, #2
 802161e:	b2db      	uxtb	r3, r3
 8021620:	4618      	mov	r0, r3
 8021622:	7afb      	ldrb	r3, [r7, #11]
 8021624:	089b      	lsrs	r3, r3, #2
 8021626:	b2db      	uxtb	r3, r3
 8021628:	461a      	mov	r2, r3
 802162a:	68fb      	ldr	r3, [r7, #12]
 802162c:	3204      	adds	r2, #4
 802162e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8021632:	7afb      	ldrb	r3, [r7, #11]
 8021634:	f003 0303 	and.w	r3, r3, #3
 8021638:	00db      	lsls	r3, r3, #3
 802163a:	4619      	mov	r1, r3
 802163c:	23f8      	movs	r3, #248	; 0xf8
 802163e:	408b      	lsls	r3, r1
 8021640:	43db      	mvns	r3, r3
 8021642:	ea02 0103 	and.w	r1, r2, r3
 8021646:	68fb      	ldr	r3, [r7, #12]
 8021648:	1d02      	adds	r2, r0, #4
 802164a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]

  /* HW port control is disabled */
  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
 802164e:	68fb      	ldr	r3, [r7, #12]
 8021650:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8021652:	7afb      	ldrb	r3, [r7, #11]
 8021654:	005b      	lsls	r3, r3, #1
 8021656:	4619      	mov	r1, r3
 8021658:	2303      	movs	r3, #3
 802165a:	408b      	lsls	r3, r1
 802165c:	43db      	mvns	r3, r3
 802165e:	401a      	ands	r2, r3
 8021660:	68fb      	ldr	r3, [r7, #12]
 8021662:	675a      	str	r2, [r3, #116]	; 0x74


  /* Enable digital input */
  if (XMC_GPIO_CHECK_ANALOG_PORT(port))
 8021664:	68fb      	ldr	r3, [r7, #12]
 8021666:	4a3a      	ldr	r2, [pc, #232]	; (8021750 <XMC_GPIO_Init+0x144>)
 8021668:	4293      	cmp	r3, r2
 802166a:	d003      	beq.n	8021674 <XMC_GPIO_Init+0x68>
 802166c:	68fb      	ldr	r3, [r7, #12]
 802166e:	4a39      	ldr	r2, [pc, #228]	; (8021754 <XMC_GPIO_Init+0x148>)
 8021670:	4293      	cmp	r3, r2
 8021672:	d10a      	bne.n	802168a <XMC_GPIO_Init+0x7e>
  {
    port->PDISC &= ~(uint32_t)((uint32_t)0x1U << pin);
 8021674:	68fb      	ldr	r3, [r7, #12]
 8021676:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8021678:	7afb      	ldrb	r3, [r7, #11]
 802167a:	2101      	movs	r1, #1
 802167c:	fa01 f303 	lsl.w	r3, r1, r3
 8021680:	43db      	mvns	r3, r3
 8021682:	401a      	ands	r2, r3
 8021684:	68fb      	ldr	r3, [r7, #12]
 8021686:	661a      	str	r2, [r3, #96]	; 0x60
 8021688:	e042      	b.n	8021710 <XMC_GPIO_Init+0x104>
  }
  else
  {
    if ((config->mode & XMC_GPIO_MODE_OE) != 0)
 802168a:	687b      	ldr	r3, [r7, #4]
 802168c:	781b      	ldrb	r3, [r3, #0]
 802168e:	b2db      	uxtb	r3, r3
 8021690:	b25b      	sxtb	r3, r3
 8021692:	2b00      	cmp	r3, #0
 8021694:	da3c      	bge.n	8021710 <XMC_GPIO_Init+0x104>
    {
      /* If output is enabled */

      /* Set output level */
      port->OMR = (uint32_t)config->output_level << pin;
 8021696:	687b      	ldr	r3, [r7, #4]
 8021698:	685a      	ldr	r2, [r3, #4]
 802169a:	7afb      	ldrb	r3, [r7, #11]
 802169c:	409a      	lsls	r2, r3
 802169e:	68fb      	ldr	r3, [r7, #12]
 80216a0:	605a      	str	r2, [r3, #4]

      /* Set output driver strength */
      port->PDR[pin >> 3U] &= (uint32_t)~(PORT_PDR_Msk << ((uint32_t)PORT_PDR_Size * ((uint32_t)pin & 0x7U)));
 80216a2:	7afb      	ldrb	r3, [r7, #11]
 80216a4:	08db      	lsrs	r3, r3, #3
 80216a6:	b2db      	uxtb	r3, r3
 80216a8:	4618      	mov	r0, r3
 80216aa:	7afb      	ldrb	r3, [r7, #11]
 80216ac:	08db      	lsrs	r3, r3, #3
 80216ae:	b2db      	uxtb	r3, r3
 80216b0:	461a      	mov	r2, r3
 80216b2:	68fb      	ldr	r3, [r7, #12]
 80216b4:	3210      	adds	r2, #16
 80216b6:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80216ba:	7afb      	ldrb	r3, [r7, #11]
 80216bc:	f003 0307 	and.w	r3, r3, #7
 80216c0:	009b      	lsls	r3, r3, #2
 80216c2:	4619      	mov	r1, r3
 80216c4:	2307      	movs	r3, #7
 80216c6:	408b      	lsls	r3, r1
 80216c8:	43db      	mvns	r3, r3
 80216ca:	ea02 0103 	and.w	r1, r2, r3
 80216ce:	68fb      	ldr	r3, [r7, #12]
 80216d0:	f100 0210 	add.w	r2, r0, #16
 80216d4:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      port->PDR[pin >> 3U] |= (uint32_t)config->output_strength << ((uint32_t)PORT_PDR_Size * ((uint32_t)pin & 0x7U));
 80216d8:	7afb      	ldrb	r3, [r7, #11]
 80216da:	08db      	lsrs	r3, r3, #3
 80216dc:	b2db      	uxtb	r3, r3
 80216de:	4618      	mov	r0, r3
 80216e0:	7afb      	ldrb	r3, [r7, #11]
 80216e2:	08db      	lsrs	r3, r3, #3
 80216e4:	b2db      	uxtb	r3, r3
 80216e6:	461a      	mov	r2, r3
 80216e8:	68fb      	ldr	r3, [r7, #12]
 80216ea:	3210      	adds	r2, #16
 80216ec:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 80216f0:	687b      	ldr	r3, [r7, #4]
 80216f2:	7a1b      	ldrb	r3, [r3, #8]
 80216f4:	4619      	mov	r1, r3
 80216f6:	7afb      	ldrb	r3, [r7, #11]
 80216f8:	f003 0307 	and.w	r3, r3, #7
 80216fc:	009b      	lsls	r3, r3, #2
 80216fe:	fa01 f303 	lsl.w	r3, r1, r3
 8021702:	ea42 0103 	orr.w	r1, r2, r3
 8021706:	68fb      	ldr	r3, [r7, #12]
 8021708:	f100 0210 	add.w	r2, r0, #16
 802170c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    }
  }

  /* Set mode */
  port->IOCR[pin >> 2U] |= (uint32_t)config->mode << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U));
 8021710:	7afb      	ldrb	r3, [r7, #11]
 8021712:	089b      	lsrs	r3, r3, #2
 8021714:	b2db      	uxtb	r3, r3
 8021716:	4618      	mov	r0, r3
 8021718:	7afb      	ldrb	r3, [r7, #11]
 802171a:	089b      	lsrs	r3, r3, #2
 802171c:	b2db      	uxtb	r3, r3
 802171e:	461a      	mov	r2, r3
 8021720:	68fb      	ldr	r3, [r7, #12]
 8021722:	3204      	adds	r2, #4
 8021724:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 8021728:	687b      	ldr	r3, [r7, #4]
 802172a:	781b      	ldrb	r3, [r3, #0]
 802172c:	4619      	mov	r1, r3
 802172e:	7afb      	ldrb	r3, [r7, #11]
 8021730:	f003 0303 	and.w	r3, r3, #3
 8021734:	00db      	lsls	r3, r3, #3
 8021736:	fa01 f303 	lsl.w	r3, r1, r3
 802173a:	ea42 0103 	orr.w	r1, r2, r3
 802173e:	68fb      	ldr	r3, [r7, #12]
 8021740:	1d02      	adds	r2, r0, #4
 8021742:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 8021746:	3714      	adds	r7, #20
 8021748:	46bd      	mov	sp, r7
 802174a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802174e:	4770      	bx	lr
 8021750:	48028e00 	.word	0x48028e00
 8021754:	48028f00 	.word	0x48028f00

08021758 <XMC_SCU_CLOCK_GetCpuClockFrequency>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_SCU_CLOCK_GetPeripheralClockFrequency(), XMC_SCU_CLOCK_GatePeripheralClock() \n\n\n
 */
__STATIC_INLINE uint32_t XMC_SCU_CLOCK_GetCpuClockFrequency(void)
{
 8021758:	b480      	push	{r7}
 802175a:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 802175c:	4b03      	ldr	r3, [pc, #12]	; (802176c <XMC_SCU_CLOCK_GetCpuClockFrequency+0x14>)
 802175e:	681b      	ldr	r3, [r3, #0]
}
 8021760:	4618      	mov	r0, r3
 8021762:	46bd      	mov	sp, r7
 8021764:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021768:	4770      	bx	lr
 802176a:	bf00      	nop
 802176c:	2000ffc0 	.word	0x2000ffc0

08021770 <XMC_SCU_GetMirrorStatus>:
 * that a corresponding register of the hibernate domain is ready to accept a write or that the communication interface
 * is busy with executing the previous operation.\n
 * Note: There is no hibernate domain in XMC1x devices. This register is retained for legacy purpose.
 */
__STATIC_INLINE uint32_t XMC_SCU_GetMirrorStatus(void)
{
 8021770:	b480      	push	{r7}
 8021772:	af00      	add	r7, sp, #0
  return (SCU_GENERAL->MIRRSTS);
 8021774:	4b03      	ldr	r3, [pc, #12]	; (8021784 <XMC_SCU_GetMirrorStatus+0x14>)
 8021776:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
}
 802177a:	4618      	mov	r0, r3
 802177c:	46bd      	mov	sp, r7
 802177e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021782:	4770      	bx	lr
 8021784:	50004000 	.word	0x50004000

08021788 <XMC_SCU_lDelay>:
/*********************************************************************************************************************
 * API IMPLEMENTATION
 ********************************************************************************************************************/
/* This is a local function used to generate the delay until register get updated with new configured value.  */
void XMC_SCU_lDelay(uint32_t delay)
{
 8021788:	b580      	push	{r7, lr}
 802178a:	b084      	sub	sp, #16
 802178c:	af00      	add	r7, sp, #0
 802178e:	6078      	str	r0, [r7, #4]
  uint32_t i;

  SystemCoreClockUpdate();
 8021790:	f7fe fc46 	bl	8020020 <SystemCoreClockUpdate>
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);
 8021794:	4b0b      	ldr	r3, [pc, #44]	; (80217c4 <XMC_SCU_lDelay+0x3c>)
 8021796:	681b      	ldr	r3, [r3, #0]
 8021798:	4a0b      	ldr	r2, [pc, #44]	; (80217c8 <XMC_SCU_lDelay+0x40>)
 802179a:	fba2 2303 	umull	r2, r3, r2, r3
 802179e:	0c9a      	lsrs	r2, r3, #18
 80217a0:	687b      	ldr	r3, [r7, #4]
 80217a2:	fb02 f303 	mul.w	r3, r2, r3
 80217a6:	607b      	str	r3, [r7, #4]

  for (i = 0U; i < delay; ++i)
 80217a8:	2300      	movs	r3, #0
 80217aa:	60fb      	str	r3, [r7, #12]
 80217ac:	e003      	b.n	80217b6 <XMC_SCU_lDelay+0x2e>
  {
    __NOP();
 80217ae:	bf00      	nop
  uint32_t i;

  SystemCoreClockUpdate();
  delay =  delay * (uint32_t)(SystemCoreClock / FREQ_1MHZ);

  for (i = 0U; i < delay; ++i)
 80217b0:	68fb      	ldr	r3, [r7, #12]
 80217b2:	3301      	adds	r3, #1
 80217b4:	60fb      	str	r3, [r7, #12]
 80217b6:	68fa      	ldr	r2, [r7, #12]
 80217b8:	687b      	ldr	r3, [r7, #4]
 80217ba:	429a      	cmp	r2, r3
 80217bc:	d3f7      	bcc.n	80217ae <XMC_SCU_lDelay+0x26>
  {
    __NOP();
  }
}
 80217be:	3710      	adds	r7, #16
 80217c0:	46bd      	mov	sp, r7
 80217c2:	bd80      	pop	{r7, pc}
 80217c4:	2000ffc0 	.word	0x2000ffc0
 80217c8:	431bde83 	.word	0x431bde83

080217cc <XMC_SCU_INTERUPT_GetEventStatus>:
  SCU_INTERRUPT->SRSET |= (uint32_t)event;
}

/* API to retrieve the SCU event status */
XMC_SCU_INTERRUPT_EVENT_t XMC_SCU_INTERUPT_GetEventStatus(void)
{
 80217cc:	b480      	push	{r7}
 80217ce:	af00      	add	r7, sp, #0
  return (SCU_INTERRUPT->SRRAW);
 80217d0:	4b03      	ldr	r3, [pc, #12]	; (80217e0 <XMC_SCU_INTERUPT_GetEventStatus+0x14>)
 80217d2:	685b      	ldr	r3, [r3, #4]
}
 80217d4:	4618      	mov	r0, r3
 80217d6:	46bd      	mov	sp, r7
 80217d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80217dc:	4770      	bx	lr
 80217de:	bf00      	nop
 80217e0:	50004074 	.word	0x50004074

080217e4 <XMC_SCU_INTERRUPT_ClearEventStatus>:

/* API to clear the SCU event status */
void XMC_SCU_INTERRUPT_ClearEventStatus(const XMC_SCU_INTERRUPT_EVENT_t event)
{
 80217e4:	b480      	push	{r7}
 80217e6:	b083      	sub	sp, #12
 80217e8:	af00      	add	r7, sp, #0
 80217ea:	6078      	str	r0, [r7, #4]
  SCU_INTERRUPT->SRCLR = (uint32_t)event;
 80217ec:	4a03      	ldr	r2, [pc, #12]	; (80217fc <XMC_SCU_INTERRUPT_ClearEventStatus+0x18>)
 80217ee:	687b      	ldr	r3, [r7, #4]
 80217f0:	60d3      	str	r3, [r2, #12]
}
 80217f2:	370c      	adds	r7, #12
 80217f4:	46bd      	mov	sp, r7
 80217f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80217fa:	4770      	bx	lr
 80217fc:	50004074 	.word	0x50004074

08021800 <XMC_SCU_CLOCK_Init>:
  return (SCU_GENERAL->RMDATA);
}

/* API to initialize the clock tree */
void XMC_SCU_CLOCK_Init(const XMC_SCU_CLOCK_CONFIG_t *const config)
{
 8021800:	b5b0      	push	{r4, r5, r7, lr}
 8021802:	b084      	sub	sp, #16
 8021804:	af02      	add	r7, sp, #8
 8021806:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("", ((config->fstdby_clksrc == XMC_SCU_HIB_STDBYCLKSRC_OSCULP) && (config->enable_osculp == true)) ||
             (config->fstdby_clksrc != XMC_SCU_HIB_STDBYCLKSRC_OSCULP));
  XMC_ASSERT("", ((config->syspll_config.clksrc == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP) &&
                  (config->enable_oschp == true)) || (config->syspll_config.clksrc != XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP));

  XMC_SCU_CLOCK_SetSystemClockSource(XMC_SCU_CLOCK_SYSCLKSRC_OFI);
 8021808:	2000      	movs	r0, #0
 802180a:	f000 f8c5 	bl	8021998 <XMC_SCU_CLOCK_SetSystemClockSource>

  XMC_SCU_HIB_EnableHibernateDomain();
 802180e:	f000 fac7 	bl	8021da0 <XMC_SCU_HIB_EnableHibernateDomain>

  if (config->enable_osculp == true)
 8021812:	687b      	ldr	r3, [r7, #4]
 8021814:	79db      	ldrb	r3, [r3, #7]
 8021816:	2b00      	cmp	r3, #0
 8021818:	d00a      	beq.n	8021830 <XMC_SCU_CLOCK_Init+0x30>
  {
    XMC_SCU_CLOCK_EnableLowPowerOscillator();
 802181a:	f000 faff 	bl	8021e1c <XMC_SCU_CLOCK_EnableLowPowerOscillator>
    while (XMC_SCU_CLOCK_IsLowPowerOscillatorStable() == false);
 802181e:	bf00      	nop
 8021820:	f000 faea 	bl	8021df8 <XMC_SCU_CLOCK_IsLowPowerOscillatorStable>
 8021824:	4603      	mov	r3, r0
 8021826:	f083 0301 	eor.w	r3, r3, #1
 802182a:	b2db      	uxtb	r3, r3
 802182c:	2b00      	cmp	r3, #0
 802182e:	d1f7      	bne.n	8021820 <XMC_SCU_CLOCK_Init+0x20>
  }

  XMC_SCU_HIB_SetStandbyClockSource(config->fstdby_clksrc);
 8021830:	687b      	ldr	r3, [r7, #4]
 8021832:	7a5b      	ldrb	r3, [r3, #9]
 8021834:	4618      	mov	r0, r3
 8021836:	f000 f929 	bl	8021a8c <XMC_SCU_HIB_SetStandbyClockSource>
  while (XMC_SCU_GetMirrorStatus() != 0)
 802183a:	bf00      	nop
 802183c:	f7ff ff98 	bl	8021770 <XMC_SCU_GetMirrorStatus>
 8021840:	4603      	mov	r3, r0
 8021842:	2b00      	cmp	r3, #0
 8021844:	d1fa      	bne.n	802183c <XMC_SCU_CLOCK_Init+0x3c>
  {
    /* Wait until update of the stanby clock source is done in the HIB domain */
  }

  XMC_SCU_CLOCK_SetBackupClockCalibrationMode(config->calibration_mode);
 8021846:	687b      	ldr	r3, [r7, #4]
 8021848:	7a1b      	ldrb	r3, [r3, #8]
 802184a:	4618      	mov	r0, r3
 802184c:	f000 fa82 	bl	8021d54 <XMC_SCU_CLOCK_SetBackupClockCalibrationMode>

  XMC_SCU_CLOCK_SetSystemClockDivider((uint32_t)config->fsys_clkdiv);
 8021850:	687b      	ldr	r3, [r7, #4]
 8021852:	7c1b      	ldrb	r3, [r3, #16]
 8021854:	4618      	mov	r0, r3
 8021856:	f000 f937 	bl	8021ac8 <XMC_SCU_CLOCK_SetSystemClockDivider>
  XMC_SCU_CLOCK_SetCpuClockDivider((uint32_t)config->fcpu_clkdiv);
 802185a:	687b      	ldr	r3, [r7, #4]
 802185c:	7c5b      	ldrb	r3, [r3, #17]
 802185e:	4618      	mov	r0, r3
 8021860:	f000 f95a 	bl	8021b18 <XMC_SCU_CLOCK_SetCpuClockDivider>
  XMC_SCU_CLOCK_SetCcuClockDivider((uint32_t)config->fccu_clkdiv);
 8021864:	687b      	ldr	r3, [r7, #4]
 8021866:	7c9b      	ldrb	r3, [r3, #18]
 8021868:	4618      	mov	r0, r3
 802186a:	f000 f941 	bl	8021af0 <XMC_SCU_CLOCK_SetCcuClockDivider>
  XMC_SCU_CLOCK_SetPeripheralClockDivider((uint32_t)config->fperipheral_clkdiv);
 802186e:	687b      	ldr	r3, [r7, #4]
 8021870:	7cdb      	ldrb	r3, [r3, #19]
 8021872:	4618      	mov	r0, r3
 8021874:	f000 f964 	bl	8021b40 <XMC_SCU_CLOCK_SetPeripheralClockDivider>

  if (config->enable_oschp == true)
 8021878:	687b      	ldr	r3, [r7, #4]
 802187a:	799b      	ldrb	r3, [r3, #6]
 802187c:	2b00      	cmp	r3, #0
 802187e:	d00a      	beq.n	8021896 <XMC_SCU_CLOCK_Init+0x96>
  {
    XMC_SCU_CLOCK_EnableHighPerformanceOscillator();
 8021880:	f000 fb04 	bl	8021e8c <XMC_SCU_CLOCK_EnableHighPerformanceOscillator>
    while (XMC_SCU_CLOCK_IsHighPerformanceOscillatorStable() == false);
 8021884:	bf00      	nop
 8021886:	f000 fb29 	bl	8021edc <XMC_SCU_CLOCK_IsHighPerformanceOscillatorStable>
 802188a:	4603      	mov	r3, r0
 802188c:	f083 0301 	eor.w	r3, r3, #1
 8021890:	b2db      	uxtb	r3, r3
 8021892:	2b00      	cmp	r3, #0
 8021894:	d1f7      	bne.n	8021886 <XMC_SCU_CLOCK_Init+0x86>
  }

  if (config->syspll_config.mode == XMC_SCU_CLOCK_SYSPLL_MODE_DISABLED)
 8021896:	687b      	ldr	r3, [r7, #4]
 8021898:	78db      	ldrb	r3, [r3, #3]
 802189a:	2b00      	cmp	r3, #0
 802189c:	d109      	bne.n	80218b2 <XMC_SCU_CLOCK_Init+0xb2>
  {
    /* Do not enable PLL Power Down Mode when the OSC Watchdog is enabled */
    if (config->enable_oschp == false)
 802189e:	687b      	ldr	r3, [r7, #4]
 80218a0:	799b      	ldrb	r3, [r3, #6]
 80218a2:	f083 0301 	eor.w	r3, r3, #1
 80218a6:	b2db      	uxtb	r3, r3
 80218a8:	2b00      	cmp	r3, #0
 80218aa:	d017      	beq.n	80218dc <XMC_SCU_CLOCK_Init+0xdc>
    {
      XMC_SCU_CLOCK_DisableSystemPll();
 80218ac:	f000 fb3a 	bl	8021f24 <XMC_SCU_CLOCK_DisableSystemPll>
 80218b0:	e014      	b.n	80218dc <XMC_SCU_CLOCK_Init+0xdc>
    }
  }
  else
  {

    XMC_SCU_CLOCK_EnableSystemPll();
 80218b2:	f000 fb27 	bl	8021f04 <XMC_SCU_CLOCK_EnableSystemPll>
    XMC_SCU_CLOCK_StartSystemPll(config->syspll_config.clksrc,
 80218b6:	687b      	ldr	r3, [r7, #4]
 80218b8:	8899      	ldrh	r1, [r3, #4]
 80218ba:	687b      	ldr	r3, [r7, #4]
 80218bc:	78da      	ldrb	r2, [r3, #3]
                                 config->syspll_config.mode,
                                 (uint32_t)config->syspll_config.p_div,
 80218be:	687b      	ldr	r3, [r7, #4]
 80218c0:	785b      	ldrb	r3, [r3, #1]
  }
  else
  {

    XMC_SCU_CLOCK_EnableSystemPll();
    XMC_SCU_CLOCK_StartSystemPll(config->syspll_config.clksrc,
 80218c2:	461d      	mov	r5, r3
                                 config->syspll_config.mode,
                                 (uint32_t)config->syspll_config.p_div,
                                 (uint32_t)config->syspll_config.n_div,
 80218c4:	687b      	ldr	r3, [r7, #4]
 80218c6:	781b      	ldrb	r3, [r3, #0]
  }
  else
  {

    XMC_SCU_CLOCK_EnableSystemPll();
    XMC_SCU_CLOCK_StartSystemPll(config->syspll_config.clksrc,
 80218c8:	461c      	mov	r4, r3
                                 config->syspll_config.mode,
                                 (uint32_t)config->syspll_config.p_div,
                                 (uint32_t)config->syspll_config.n_div,
                                 (uint32_t)config->syspll_config.k_div);
 80218ca:	687b      	ldr	r3, [r7, #4]
 80218cc:	789b      	ldrb	r3, [r3, #2]
  }
  else
  {

    XMC_SCU_CLOCK_EnableSystemPll();
    XMC_SCU_CLOCK_StartSystemPll(config->syspll_config.clksrc,
 80218ce:	9300      	str	r3, [sp, #0]
 80218d0:	4608      	mov	r0, r1
 80218d2:	4611      	mov	r1, r2
 80218d4:	462a      	mov	r2, r5
 80218d6:	4623      	mov	r3, r4
 80218d8:	f000 fb34 	bl	8021f44 <XMC_SCU_CLOCK_StartSystemPll>
                                 (uint32_t)config->syspll_config.n_div,
                                 (uint32_t)config->syspll_config.k_div);
  }

  /* use SYSPLL? */
  if (config->fsys_clksrc == XMC_SCU_CLOCK_SYSCLKSRC_PLL)
 80218dc:	687b      	ldr	r3, [r7, #4]
 80218de:	68db      	ldr	r3, [r3, #12]
 80218e0:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80218e4:	d103      	bne.n	80218ee <XMC_SCU_CLOCK_Init+0xee>
  {
    XMC_SCU_CLOCK_SetSystemClockSource(XMC_SCU_CLOCK_SYSCLKSRC_PLL);
 80218e6:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 80218ea:	f000 f855 	bl	8021998 <XMC_SCU_CLOCK_SetSystemClockSource>
  }
  SystemCoreClockUpdate();
 80218ee:	f7fe fb97 	bl	8020020 <SystemCoreClockUpdate>
}
 80218f2:	3708      	adds	r7, #8
 80218f4:	46bd      	mov	sp, r7
 80218f6:	bdb0      	pop	{r4, r5, r7, pc}

080218f8 <XMC_SCU_RESET_DeassertPeripheralReset>:
  *(volatile uint32_t *)(&(SCU_RESET->PRSET0) + (index * 3U)) = (uint32_t)mask;
}

/* API to manually de-assert a reset request */
void XMC_SCU_RESET_DeassertPeripheralReset(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
 80218f8:	b480      	push	{r7}
 80218fa:	b085      	sub	sp, #20
 80218fc:	af00      	add	r7, sp, #0
 80218fe:	6078      	str	r0, [r7, #4]
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
 8021900:	687b      	ldr	r3, [r7, #4]
 8021902:	0f1b      	lsrs	r3, r3, #28
 8021904:	60fb      	str	r3, [r7, #12]
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));
 8021906:	687b      	ldr	r3, [r7, #4]
 8021908:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 802190c:	60bb      	str	r3, [r7, #8]

  *(volatile uint32_t *)(&(SCU_RESET->PRCLR0) + (index * 3U)) = (uint32_t)mask;
 802190e:	68fa      	ldr	r2, [r7, #12]
 8021910:	4613      	mov	r3, r2
 8021912:	005b      	lsls	r3, r3, #1
 8021914:	4413      	add	r3, r2
 8021916:	009b      	lsls	r3, r3, #2
 8021918:	461a      	mov	r2, r3
 802191a:	4b04      	ldr	r3, [pc, #16]	; (802192c <XMC_SCU_RESET_DeassertPeripheralReset+0x34>)
 802191c:	4413      	add	r3, r2
 802191e:	68ba      	ldr	r2, [r7, #8]
 8021920:	601a      	str	r2, [r3, #0]
}
 8021922:	3714      	adds	r7, #20
 8021924:	46bd      	mov	sp, r7
 8021926:	f85d 7b04 	ldr.w	r7, [sp], #4
 802192a:	4770      	bx	lr
 802192c:	50004414 	.word	0x50004414

08021930 <XMC_SCU_RESET_IsPeripheralResetAsserted>:

/* Find out if the peripheral reset is asserted */
bool XMC_SCU_RESET_IsPeripheralResetAsserted(const XMC_SCU_PERIPHERAL_RESET_t peripheral)
{
 8021930:	b480      	push	{r7}
 8021932:	b085      	sub	sp, #20
 8021934:	af00      	add	r7, sp, #0
 8021936:	6078      	str	r0, [r7, #4]
  uint32_t index = (uint32_t)((((uint32_t)peripheral) & 0xf0000000UL) >> 28UL);
 8021938:	687b      	ldr	r3, [r7, #4]
 802193a:	0f1b      	lsrs	r3, r3, #28
 802193c:	60fb      	str	r3, [r7, #12]
  uint32_t mask = (((uint32_t)peripheral) & ((uint32_t)~0xf0000000UL));
 802193e:	687b      	ldr	r3, [r7, #4]
 8021940:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 8021944:	60bb      	str	r3, [r7, #8]

  return ((*(const volatile uint32_t *)(&(SCU_RESET->PRSTAT0) + (index * 3U)) & mask) != 0U);
 8021946:	68fa      	ldr	r2, [r7, #12]
 8021948:	4613      	mov	r3, r2
 802194a:	005b      	lsls	r3, r3, #1
 802194c:	4413      	add	r3, r2
 802194e:	009b      	lsls	r3, r3, #2
 8021950:	461a      	mov	r2, r3
 8021952:	4b08      	ldr	r3, [pc, #32]	; (8021974 <XMC_SCU_RESET_IsPeripheralResetAsserted+0x44>)
 8021954:	4413      	add	r3, r2
 8021956:	681a      	ldr	r2, [r3, #0]
 8021958:	68bb      	ldr	r3, [r7, #8]
 802195a:	4013      	ands	r3, r2
 802195c:	2b00      	cmp	r3, #0
 802195e:	bf14      	ite	ne
 8021960:	2301      	movne	r3, #1
 8021962:	2300      	moveq	r3, #0
 8021964:	b2db      	uxtb	r3, r3
}
 8021966:	4618      	mov	r0, r3
 8021968:	3714      	adds	r7, #20
 802196a:	46bd      	mov	sp, r7
 802196c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021970:	4770      	bx	lr
 8021972:	bf00      	nop
 8021974:	5000440c 	.word	0x5000440c

08021978 <XMC_SCU_CLOCK_GetPeripheralClockFrequency>:

/*
 * API to retrieve clock frequency of peripherals on the peripheral bus using a shared functional clock
 */
uint32_t XMC_SCU_CLOCK_GetPeripheralClockFrequency(void)
{
 8021978:	b580      	push	{r7, lr}
 802197a:	af00      	add	r7, sp, #0
  return (uint32_t)(XMC_SCU_CLOCK_GetCpuClockFrequency() >>
 802197c:	f7ff feec 	bl	8021758 <XMC_SCU_CLOCK_GetCpuClockFrequency>
 8021980:	4602      	mov	r2, r0
                    ((SCU_CLK->PBCLKCR & SCU_CLK_PBCLKCR_PBDIV_Msk) >> SCU_CLK_PBCLKCR_PBDIV_Pos));
 8021982:	4b04      	ldr	r3, [pc, #16]	; (8021994 <XMC_SCU_CLOCK_GetPeripheralClockFrequency+0x1c>)
 8021984:	695b      	ldr	r3, [r3, #20]
/*
 * API to retrieve clock frequency of peripherals on the peripheral bus using a shared functional clock
 */
uint32_t XMC_SCU_CLOCK_GetPeripheralClockFrequency(void)
{
  return (uint32_t)(XMC_SCU_CLOCK_GetCpuClockFrequency() >>
 8021986:	f003 0301 	and.w	r3, r3, #1
 802198a:	fa22 f303 	lsr.w	r3, r2, r3
                    ((SCU_CLK->PBCLKCR & SCU_CLK_PBCLKCR_PBDIV_Msk) >> SCU_CLK_PBCLKCR_PBDIV_Pos));
}
 802198e:	4618      	mov	r0, r3
 8021990:	bd80      	pop	{r7, pc}
 8021992:	bf00      	nop
 8021994:	50004600 	.word	0x50004600

08021998 <XMC_SCU_CLOCK_SetSystemClockSource>:

/* API to select fSYS */
void XMC_SCU_CLOCK_SetSystemClockSource(const XMC_SCU_CLOCK_SYSCLKSRC_t source)
{
 8021998:	b480      	push	{r7}
 802199a:	b083      	sub	sp, #12
 802199c:	af00      	add	r7, sp, #0
 802199e:	6078      	str	r0, [r7, #4]
  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSSEL_Msk)) |
 80219a0:	4906      	ldr	r1, [pc, #24]	; (80219bc <XMC_SCU_CLOCK_SetSystemClockSource+0x24>)
 80219a2:	4b06      	ldr	r3, [pc, #24]	; (80219bc <XMC_SCU_CLOCK_SetSystemClockSource+0x24>)
 80219a4:	68db      	ldr	r3, [r3, #12]
 80219a6:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 80219aa:	687b      	ldr	r3, [r7, #4]
 80219ac:	4313      	orrs	r3, r2
 80219ae:	60cb      	str	r3, [r1, #12]
                      ((uint32_t)source);
}
 80219b0:	370c      	adds	r7, #12
 80219b2:	46bd      	mov	sp, r7
 80219b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80219b8:	4770      	bx	lr
 80219ba:	bf00      	nop
 80219bc:	50004600 	.word	0x50004600

080219c0 <XMC_SCU_CLOCK_SetUsbClockSource>:

/* API to select fUSB */
void XMC_SCU_CLOCK_SetUsbClockSource(const XMC_SCU_CLOCK_USBCLKSRC_t source)
{
 80219c0:	b480      	push	{r7}
 80219c2:	b083      	sub	sp, #12
 80219c4:	af00      	add	r7, sp, #0
 80219c6:	6078      	str	r0, [r7, #4]
  SCU_CLK->USBCLKCR = (SCU_CLK->USBCLKCR & ((uint32_t)~SCU_CLK_USBCLKCR_USBSEL_Msk)) |
 80219c8:	4906      	ldr	r1, [pc, #24]	; (80219e4 <XMC_SCU_CLOCK_SetUsbClockSource+0x24>)
 80219ca:	4b06      	ldr	r3, [pc, #24]	; (80219e4 <XMC_SCU_CLOCK_SetUsbClockSource+0x24>)
 80219cc:	699b      	ldr	r3, [r3, #24]
 80219ce:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 80219d2:	687b      	ldr	r3, [r7, #4]
 80219d4:	4313      	orrs	r3, r2
 80219d6:	618b      	str	r3, [r1, #24]
                      ((uint32_t)source);
}
 80219d8:	370c      	adds	r7, #12
 80219da:	46bd      	mov	sp, r7
 80219dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80219e0:	4770      	bx	lr
 80219e2:	bf00      	nop
 80219e4:	50004600 	.word	0x50004600

080219e8 <XMC_SCU_CLOCK_SetWdtClockSource>:

/* API to select fWDT */
void XMC_SCU_CLOCK_SetWdtClockSource(const XMC_SCU_CLOCK_WDTCLKSRC_t source)
{
 80219e8:	b480      	push	{r7}
 80219ea:	b083      	sub	sp, #12
 80219ec:	af00      	add	r7, sp, #0
 80219ee:	6078      	str	r0, [r7, #4]
  SCU_CLK->WDTCLKCR = (SCU_CLK->WDTCLKCR & ((uint32_t)~SCU_CLK_WDTCLKCR_WDTSEL_Msk)) |
 80219f0:	4906      	ldr	r1, [pc, #24]	; (8021a0c <XMC_SCU_CLOCK_SetWdtClockSource+0x24>)
 80219f2:	4b06      	ldr	r3, [pc, #24]	; (8021a0c <XMC_SCU_CLOCK_SetWdtClockSource+0x24>)
 80219f4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80219f6:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
 80219fa:	687b      	ldr	r3, [r7, #4]
 80219fc:	4313      	orrs	r3, r2
 80219fe:	624b      	str	r3, [r1, #36]	; 0x24
                      ((uint32_t)source);
}
 8021a00:	370c      	adds	r7, #12
 8021a02:	46bd      	mov	sp, r7
 8021a04:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021a08:	4770      	bx	lr
 8021a0a:	bf00      	nop
 8021a0c:	50004600 	.word	0x50004600

08021a10 <XMC_SCU_CLOCK_SetSystemPllClockSource>:
                      ((uint32_t)source);
}

/* API to select fPLL */
void XMC_SCU_CLOCK_SetSystemPllClockSource(const XMC_SCU_CLOCK_SYSPLLCLKSRC_t source)
{
 8021a10:	b480      	push	{r7}
 8021a12:	b083      	sub	sp, #12
 8021a14:	af00      	add	r7, sp, #0
 8021a16:	4603      	mov	r3, r0
 8021a18:	80fb      	strh	r3, [r7, #6]
  /* Check input clock */
  if (source == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP) /* Select PLLClockSource */
 8021a1a:	88fb      	ldrh	r3, [r7, #6]
 8021a1c:	2b00      	cmp	r3, #0
 8021a1e:	d108      	bne.n	8021a32 <XMC_SCU_CLOCK_SetSystemPllClockSource+0x22>
  {
    SCU_PLL->PLLCON2 &= (uint32_t)~(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
 8021a20:	4a0a      	ldr	r2, [pc, #40]	; (8021a4c <XMC_SCU_CLOCK_SetSystemPllClockSource+0x3c>)
 8021a22:	4b0a      	ldr	r3, [pc, #40]	; (8021a4c <XMC_SCU_CLOCK_SetSystemPllClockSource+0x3c>)
 8021a24:	68db      	ldr	r3, [r3, #12]
 8021a26:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8021a2a:	f023 0301 	bic.w	r3, r3, #1
 8021a2e:	60d3      	str	r3, [r2, #12]
 8021a30:	e007      	b.n	8021a42 <XMC_SCU_CLOCK_SetSystemPllClockSource+0x32>
  }
  else
  {
    SCU_PLL->PLLCON2 |= (uint32_t)(SCU_PLL_PLLCON2_PINSEL_Msk | SCU_PLL_PLLCON2_K1INSEL_Msk);
 8021a32:	4a06      	ldr	r2, [pc, #24]	; (8021a4c <XMC_SCU_CLOCK_SetSystemPllClockSource+0x3c>)
 8021a34:	4b05      	ldr	r3, [pc, #20]	; (8021a4c <XMC_SCU_CLOCK_SetSystemPllClockSource+0x3c>)
 8021a36:	68db      	ldr	r3, [r3, #12]
 8021a38:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8021a3c:	f043 0301 	orr.w	r3, r3, #1
 8021a40:	60d3      	str	r3, [r2, #12]
  }
}
 8021a42:	370c      	adds	r7, #12
 8021a44:	46bd      	mov	sp, r7
 8021a46:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021a4a:	4770      	bx	lr
 8021a4c:	50004710 	.word	0x50004710

08021a50 <XMC_SCU_HIB_SetRtcClockSource>:

/* API to select fRTC */
void XMC_SCU_HIB_SetRtcClockSource(const XMC_SCU_HIB_RTCCLKSRC_t source)
{
 8021a50:	b480      	push	{r7}
 8021a52:	b083      	sub	sp, #12
 8021a54:	af00      	add	r7, sp, #0
 8021a56:	4603      	mov	r3, r0
 8021a58:	71fb      	strb	r3, [r7, #7]
  /* Wait until the update of HDCR register in hibernate domain is completed */
  while ((SCU_GENERAL->MIRRSTS) & SCU_GENERAL_MIRRSTS_HDCR_Msk)
 8021a5a:	bf00      	nop
 8021a5c:	4b09      	ldr	r3, [pc, #36]	; (8021a84 <XMC_SCU_HIB_SetRtcClockSource+0x34>)
 8021a5e:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 8021a62:	f003 0308 	and.w	r3, r3, #8
 8021a66:	2b00      	cmp	r3, #0
 8021a68:	d1f8      	bne.n	8021a5c <XMC_SCU_HIB_SetRtcClockSource+0xc>
  {
  }

  SCU_HIBERNATE->HDCR = (SCU_HIBERNATE->HDCR & ((uint32_t)~SCU_HIBERNATE_HDCR_RCS_Msk)) |
 8021a6a:	4907      	ldr	r1, [pc, #28]	; (8021a88 <XMC_SCU_HIB_SetRtcClockSource+0x38>)
 8021a6c:	4b06      	ldr	r3, [pc, #24]	; (8021a88 <XMC_SCU_HIB_SetRtcClockSource+0x38>)
 8021a6e:	68db      	ldr	r3, [r3, #12]
 8021a70:	f023 0240 	bic.w	r2, r3, #64	; 0x40
                        ((uint32_t)source);
 8021a74:	79fb      	ldrb	r3, [r7, #7]
  /* Wait until the update of HDCR register in hibernate domain is completed */
  while ((SCU_GENERAL->MIRRSTS) & SCU_GENERAL_MIRRSTS_HDCR_Msk)
  {
  }

  SCU_HIBERNATE->HDCR = (SCU_HIBERNATE->HDCR & ((uint32_t)~SCU_HIBERNATE_HDCR_RCS_Msk)) |
 8021a76:	4313      	orrs	r3, r2
 8021a78:	60cb      	str	r3, [r1, #12]
                        ((uint32_t)source);
}
 8021a7a:	370c      	adds	r7, #12
 8021a7c:	46bd      	mov	sp, r7
 8021a7e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021a82:	4770      	bx	lr
 8021a84:	50004000 	.word	0x50004000
 8021a88:	50004300 	.word	0x50004300

08021a8c <XMC_SCU_HIB_SetStandbyClockSource>:

/* API to select fSTDBY */
void XMC_SCU_HIB_SetStandbyClockSource(const XMC_SCU_HIB_STDBYCLKSRC_t source)
{
 8021a8c:	b480      	push	{r7}
 8021a8e:	b083      	sub	sp, #12
 8021a90:	af00      	add	r7, sp, #0
 8021a92:	4603      	mov	r3, r0
 8021a94:	71fb      	strb	r3, [r7, #7]
  while ((SCU_GENERAL->MIRRSTS) & SCU_GENERAL_MIRRSTS_HDCR_Msk)
 8021a96:	bf00      	nop
 8021a98:	4b09      	ldr	r3, [pc, #36]	; (8021ac0 <XMC_SCU_HIB_SetStandbyClockSource+0x34>)
 8021a9a:	f8d3 30c4 	ldr.w	r3, [r3, #196]	; 0xc4
 8021a9e:	f003 0308 	and.w	r3, r3, #8
 8021aa2:	2b00      	cmp	r3, #0
 8021aa4:	d1f8      	bne.n	8021a98 <XMC_SCU_HIB_SetStandbyClockSource+0xc>
  {
    /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
  }
  SCU_HIBERNATE->HDCR = (SCU_HIBERNATE->HDCR & ((uint32_t)~SCU_HIBERNATE_HDCR_STDBYSEL_Msk)) |
 8021aa6:	4907      	ldr	r1, [pc, #28]	; (8021ac4 <XMC_SCU_HIB_SetStandbyClockSource+0x38>)
 8021aa8:	4b06      	ldr	r3, [pc, #24]	; (8021ac4 <XMC_SCU_HIB_SetStandbyClockSource+0x38>)
 8021aaa:	68db      	ldr	r3, [r3, #12]
 8021aac:	f023 0280 	bic.w	r2, r3, #128	; 0x80
                        ((uint32_t)source);
 8021ab0:	79fb      	ldrb	r3, [r7, #7]
{
  while ((SCU_GENERAL->MIRRSTS) & SCU_GENERAL_MIRRSTS_HDCR_Msk)
  {
    /* check SCU_MIRRSTS to ensure that no transfer over serial interface is pending */
  }
  SCU_HIBERNATE->HDCR = (SCU_HIBERNATE->HDCR & ((uint32_t)~SCU_HIBERNATE_HDCR_STDBYSEL_Msk)) |
 8021ab2:	4313      	orrs	r3, r2
 8021ab4:	60cb      	str	r3, [r1, #12]
                        ((uint32_t)source);
}
 8021ab6:	370c      	adds	r7, #12
 8021ab8:	46bd      	mov	sp, r7
 8021aba:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021abe:	4770      	bx	lr
 8021ac0:	50004000 	.word	0x50004000
 8021ac4:	50004300 	.word	0x50004300

08021ac8 <XMC_SCU_CLOCK_SetSystemClockDivider>:

/* API to program the divider placed between fsys and its parent */
void XMC_SCU_CLOCK_SetSystemClockDivider(const uint32_t divider)
{
 8021ac8:	b480      	push	{r7}
 8021aca:	b083      	sub	sp, #12
 8021acc:	af00      	add	r7, sp, #0
 8021ace:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_SCU_CLOCK_SetSystemClockDivider:Wrong clock divider value",
             (divider <= (SCU_CLK_SYSCLKCR_SYSDIV_Msk + 1UL)) );

  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSDIV_Msk)) |
 8021ad0:	4906      	ldr	r1, [pc, #24]	; (8021aec <XMC_SCU_CLOCK_SetSystemClockDivider+0x24>)
 8021ad2:	4b06      	ldr	r3, [pc, #24]	; (8021aec <XMC_SCU_CLOCK_SetSystemClockDivider+0x24>)
 8021ad4:	68db      	ldr	r3, [r3, #12]
 8021ad6:	f023 02ff 	bic.w	r2, r3, #255	; 0xff
                      ((uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_SYSCLKCR_SYSDIV_Pos));
 8021ada:	687b      	ldr	r3, [r7, #4]
 8021adc:	3b01      	subs	r3, #1
void XMC_SCU_CLOCK_SetSystemClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetSystemClockDivider:Wrong clock divider value",
             (divider <= (SCU_CLK_SYSCLKCR_SYSDIV_Msk + 1UL)) );

  SCU_CLK->SYSCLKCR = (SCU_CLK->SYSCLKCR & ((uint32_t)~SCU_CLK_SYSCLKCR_SYSDIV_Msk)) |
 8021ade:	4313      	orrs	r3, r2
 8021ae0:	60cb      	str	r3, [r1, #12]
                      ((uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_SYSCLKCR_SYSDIV_Pos));
}
 8021ae2:	370c      	adds	r7, #12
 8021ae4:	46bd      	mov	sp, r7
 8021ae6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021aea:	4770      	bx	lr
 8021aec:	50004600 	.word	0x50004600

08021af0 <XMC_SCU_CLOCK_SetCcuClockDivider>:

/* API to program the divider placed between fccu and its parent */
void XMC_SCU_CLOCK_SetCcuClockDivider(const uint32_t divider)
{
 8021af0:	b480      	push	{r7}
 8021af2:	b083      	sub	sp, #12
 8021af4:	af00      	add	r7, sp, #0
 8021af6:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_SCU_CLOCK_SetCapcomClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CCUCLKCR = (SCU_CLK->CCUCLKCR & ((uint32_t)~SCU_CLK_CCUCLKCR_CCUDIV_Msk)) |
 8021af8:	4906      	ldr	r1, [pc, #24]	; (8021b14 <XMC_SCU_CLOCK_SetCcuClockDivider+0x24>)
 8021afa:	4b06      	ldr	r3, [pc, #24]	; (8021b14 <XMC_SCU_CLOCK_SetCcuClockDivider+0x24>)
 8021afc:	6a1b      	ldr	r3, [r3, #32]
 8021afe:	f023 0201 	bic.w	r2, r3, #1
                      (uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_CCUCLKCR_CCUDIV_Pos);
 8021b02:	687b      	ldr	r3, [r7, #4]
 8021b04:	3b01      	subs	r3, #1
/* API to program the divider placed between fccu and its parent */
void XMC_SCU_CLOCK_SetCcuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetCapcomClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CCUCLKCR = (SCU_CLK->CCUCLKCR & ((uint32_t)~SCU_CLK_CCUCLKCR_CCUDIV_Msk)) |
 8021b06:	4313      	orrs	r3, r2
 8021b08:	620b      	str	r3, [r1, #32]
                      (uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_CCUCLKCR_CCUDIV_Pos);
}
 8021b0a:	370c      	adds	r7, #12
 8021b0c:	46bd      	mov	sp, r7
 8021b0e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021b12:	4770      	bx	lr
 8021b14:	50004600 	.word	0x50004600

08021b18 <XMC_SCU_CLOCK_SetCpuClockDivider>:

/* API to program the divider placed between fcpu and its parent */
void XMC_SCU_CLOCK_SetCpuClockDivider(const uint32_t divider)
{
 8021b18:	b480      	push	{r7}
 8021b1a:	b083      	sub	sp, #12
 8021b1c:	af00      	add	r7, sp, #0
 8021b1e:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_SCU_CLOCK_SetCpuClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CPUCLKCR = (SCU_CLK->CPUCLKCR & ((uint32_t)~SCU_CLK_CPUCLKCR_CPUDIV_Msk)) |
 8021b20:	4906      	ldr	r1, [pc, #24]	; (8021b3c <XMC_SCU_CLOCK_SetCpuClockDivider+0x24>)
 8021b22:	4b06      	ldr	r3, [pc, #24]	; (8021b3c <XMC_SCU_CLOCK_SetCpuClockDivider+0x24>)
 8021b24:	691b      	ldr	r3, [r3, #16]
 8021b26:	f023 0201 	bic.w	r2, r3, #1
                      (uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_CPUCLKCR_CPUDIV_Pos);
 8021b2a:	687b      	ldr	r3, [r7, #4]
 8021b2c:	3b01      	subs	r3, #1
/* API to program the divider placed between fcpu and its parent */
void XMC_SCU_CLOCK_SetCpuClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetCpuClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->CPUCLKCR = (SCU_CLK->CPUCLKCR & ((uint32_t)~SCU_CLK_CPUCLKCR_CPUDIV_Msk)) |
 8021b2e:	4313      	orrs	r3, r2
 8021b30:	610b      	str	r3, [r1, #16]
                      (uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_CPUCLKCR_CPUDIV_Pos);
}
 8021b32:	370c      	adds	r7, #12
 8021b34:	46bd      	mov	sp, r7
 8021b36:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021b3a:	4770      	bx	lr
 8021b3c:	50004600 	.word	0x50004600

08021b40 <XMC_SCU_CLOCK_SetPeripheralClockDivider>:

/* API to program the divider placed between fperiph and its parent */
void XMC_SCU_CLOCK_SetPeripheralClockDivider(const uint32_t divider)
{
 8021b40:	b480      	push	{r7}
 8021b42:	b083      	sub	sp, #12
 8021b44:	af00      	add	r7, sp, #0
 8021b46:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_SCU_CLOCK_SetPeripheralClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->PBCLKCR = (SCU_CLK->PBCLKCR & ((uint32_t)~SCU_CLK_PBCLKCR_PBDIV_Msk)) |
 8021b48:	4906      	ldr	r1, [pc, #24]	; (8021b64 <XMC_SCU_CLOCK_SetPeripheralClockDivider+0x24>)
 8021b4a:	4b06      	ldr	r3, [pc, #24]	; (8021b64 <XMC_SCU_CLOCK_SetPeripheralClockDivider+0x24>)
 8021b4c:	695b      	ldr	r3, [r3, #20]
 8021b4e:	f023 0201 	bic.w	r2, r3, #1
                     ((uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_PBCLKCR_PBDIV_Pos));
 8021b52:	687b      	ldr	r3, [r7, #4]
 8021b54:	3b01      	subs	r3, #1
/* API to program the divider placed between fperiph and its parent */
void XMC_SCU_CLOCK_SetPeripheralClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetPeripheralClockDivider:Wrong clock divider value", (divider <= 2UL) );

  SCU_CLK->PBCLKCR = (SCU_CLK->PBCLKCR & ((uint32_t)~SCU_CLK_PBCLKCR_PBDIV_Msk)) |
 8021b56:	4313      	orrs	r3, r2
 8021b58:	614b      	str	r3, [r1, #20]
                     ((uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_PBCLKCR_PBDIV_Pos));
}
 8021b5a:	370c      	adds	r7, #12
 8021b5c:	46bd      	mov	sp, r7
 8021b5e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021b62:	4770      	bx	lr
 8021b64:	50004600 	.word	0x50004600

08021b68 <XMC_SCU_CLOCK_SetUsbClockDivider>:

/* API to program the divider placed between fsdmmc and its parent */
void XMC_SCU_CLOCK_SetUsbClockDivider(const uint32_t divider)
{
 8021b68:	b480      	push	{r7}
 8021b6a:	b083      	sub	sp, #12
 8021b6c:	af00      	add	r7, sp, #0
 8021b6e:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_SCU_CLOCK_SetSdmmcClockDivider:Wrong clock divider value",
             (divider <= (SCU_CLK_USBCLKCR_USBDIV_Msk + 1UL)) );

  SCU_CLK->USBCLKCR = (SCU_CLK->USBCLKCR & ((uint32_t)~SCU_CLK_USBCLKCR_USBDIV_Msk)) |
 8021b70:	4906      	ldr	r1, [pc, #24]	; (8021b8c <XMC_SCU_CLOCK_SetUsbClockDivider+0x24>)
 8021b72:	4b06      	ldr	r3, [pc, #24]	; (8021b8c <XMC_SCU_CLOCK_SetUsbClockDivider+0x24>)
 8021b74:	699b      	ldr	r3, [r3, #24]
 8021b76:	f023 0207 	bic.w	r2, r3, #7
                      (uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_USBCLKCR_USBDIV_Pos);
 8021b7a:	687b      	ldr	r3, [r7, #4]
 8021b7c:	3b01      	subs	r3, #1
void XMC_SCU_CLOCK_SetUsbClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetSdmmcClockDivider:Wrong clock divider value",
             (divider <= (SCU_CLK_USBCLKCR_USBDIV_Msk + 1UL)) );

  SCU_CLK->USBCLKCR = (SCU_CLK->USBCLKCR & ((uint32_t)~SCU_CLK_USBCLKCR_USBDIV_Msk)) |
 8021b7e:	4313      	orrs	r3, r2
 8021b80:	618b      	str	r3, [r1, #24]
                      (uint32_t)((uint32_t)(divider - 1UL) << SCU_CLK_USBCLKCR_USBDIV_Pos);
}
 8021b82:	370c      	adds	r7, #12
 8021b84:	46bd      	mov	sp, r7
 8021b86:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021b8a:	4770      	bx	lr
 8021b8c:	50004600 	.word	0x50004600

08021b90 <XMC_SCU_CLOCK_SetWdtClockDivider>:
}
#endif

/* API to program the divider placed between fwdt and its parent */
void XMC_SCU_CLOCK_SetWdtClockDivider(const uint32_t divider)
{
 8021b90:	b480      	push	{r7}
 8021b92:	b083      	sub	sp, #12
 8021b94:	af00      	add	r7, sp, #0
 8021b96:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_SCU_CLOCK_SetWdtClockDivider:Wrong clock divider value",
             (divider <= (SCU_CLK_WDTCLKCR_WDTDIV_Msk + 1UL) ) );

  SCU_CLK->WDTCLKCR = (SCU_CLK->WDTCLKCR & ((uint32_t)~SCU_CLK_WDTCLKCR_WDTDIV_Msk)) |
 8021b98:	4906      	ldr	r1, [pc, #24]	; (8021bb4 <XMC_SCU_CLOCK_SetWdtClockDivider+0x24>)
 8021b9a:	4b06      	ldr	r3, [pc, #24]	; (8021bb4 <XMC_SCU_CLOCK_SetWdtClockDivider+0x24>)
 8021b9c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8021b9e:	f023 02ff 	bic.w	r2, r3, #255	; 0xff
                      (uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_WDTCLKCR_WDTDIV_Pos);
 8021ba2:	687b      	ldr	r3, [r7, #4]
 8021ba4:	3b01      	subs	r3, #1
void XMC_SCU_CLOCK_SetWdtClockDivider(const uint32_t divider)
{
  XMC_ASSERT("XMC_SCU_CLOCK_SetWdtClockDivider:Wrong clock divider value",
             (divider <= (SCU_CLK_WDTCLKCR_WDTDIV_Msk + 1UL) ) );

  SCU_CLK->WDTCLKCR = (SCU_CLK->WDTCLKCR & ((uint32_t)~SCU_CLK_WDTCLKCR_WDTDIV_Msk)) |
 8021ba6:	4313      	orrs	r3, r2
 8021ba8:	624b      	str	r3, [r1, #36]	; 0x24
                      (uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_WDTCLKCR_WDTDIV_Pos);
}
 8021baa:	370c      	adds	r7, #12
 8021bac:	46bd      	mov	sp, r7
 8021bae:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021bb2:	4770      	bx	lr
 8021bb4:	50004600 	.word	0x50004600

08021bb8 <XMC_SCU_CLOCK_SetECATClockDivider>:
}

#if defined(ECAT0)
/* API to configure the ECAT clock by setting the clock divider for the ECAT clock source */
void XMC_SCU_CLOCK_SetECATClockDivider(const uint32_t divider)
{
 8021bb8:	b480      	push	{r7}
 8021bba:	b083      	sub	sp, #12
 8021bbc:	af00      	add	r7, sp, #0
 8021bbe:	6078      	str	r0, [r7, #4]
  SCU_CLK->ECATCLKCR = (SCU_CLK->ECATCLKCR & ~SCU_CLK_ECATCLKCR_ECADIV_Msk) |
 8021bc0:	4906      	ldr	r1, [pc, #24]	; (8021bdc <XMC_SCU_CLOCK_SetECATClockDivider+0x24>)
 8021bc2:	4b06      	ldr	r3, [pc, #24]	; (8021bdc <XMC_SCU_CLOCK_SetECATClockDivider+0x24>)
 8021bc4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8021bc6:	f023 0203 	bic.w	r2, r3, #3
                       (uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_ECATCLKCR_ECADIV_Pos);
 8021bca:	687b      	ldr	r3, [r7, #4]
 8021bcc:	3b01      	subs	r3, #1

#if defined(ECAT0)
/* API to configure the ECAT clock by setting the clock divider for the ECAT clock source */
void XMC_SCU_CLOCK_SetECATClockDivider(const uint32_t divider)
{
  SCU_CLK->ECATCLKCR = (SCU_CLK->ECATCLKCR & ~SCU_CLK_ECATCLKCR_ECADIV_Msk) |
 8021bce:	4313      	orrs	r3, r2
 8021bd0:	638b      	str	r3, [r1, #56]	; 0x38
                       (uint32_t)(((uint32_t)(divider - 1UL)) << SCU_CLK_ECATCLKCR_ECADIV_Pos);
}
 8021bd2:	370c      	adds	r7, #12
 8021bd4:	46bd      	mov	sp, r7
 8021bd6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021bda:	4770      	bx	lr
 8021bdc:	50004600 	.word	0x50004600

08021be0 <XMC_SCU_CLOCK_EnableClock>:
#endif

/* API to enable a given module clock */
void XMC_SCU_CLOCK_EnableClock(const XMC_SCU_CLOCK_t clock)
{
 8021be0:	b480      	push	{r7}
 8021be2:	b083      	sub	sp, #12
 8021be4:	af00      	add	r7, sp, #0
 8021be6:	4603      	mov	r3, r0
 8021be8:	71fb      	strb	r3, [r7, #7]
  SCU_CLK->CLKSET = ((uint32_t)clock);
 8021bea:	4a04      	ldr	r2, [pc, #16]	; (8021bfc <XMC_SCU_CLOCK_EnableClock+0x1c>)
 8021bec:	79fb      	ldrb	r3, [r7, #7]
 8021bee:	6053      	str	r3, [r2, #4]
}
 8021bf0:	370c      	adds	r7, #12
 8021bf2:	46bd      	mov	sp, r7
 8021bf4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021bf8:	4770      	bx	lr
 8021bfa:	bf00      	nop
 8021bfc:	50004600 	.word	0x50004600

08021c00 <XMC_SCU_CLOCK_UngatePeripheralClock>:
  *(volatile uint32_t *)((&(SCU_CLK->CGATSET0)) + (index * 3U)) = (uint32_t)mask;
}

/* API to ungate a given module clock */
void XMC_SCU_CLOCK_UngatePeripheralClock(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
 8021c00:	b480      	push	{r7}
 8021c02:	b085      	sub	sp, #20
 8021c04:	af00      	add	r7, sp, #0
 8021c06:	6078      	str	r0, [r7, #4]
  uint32_t index = (uint32_t)((peripheral & 0xf0000000UL) >> 28UL);
 8021c08:	687b      	ldr	r3, [r7, #4]
 8021c0a:	0f1b      	lsrs	r3, r3, #28
 8021c0c:	60fb      	str	r3, [r7, #12]
  uint32_t mask = (peripheral & (uint32_t)~0xf0000000UL);
 8021c0e:	687b      	ldr	r3, [r7, #4]
 8021c10:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 8021c14:	60bb      	str	r3, [r7, #8]

  *(volatile uint32_t *)(&(SCU_CLK->CGATCLR0) + (index * 3U)) = (uint32_t)mask;
 8021c16:	68fa      	ldr	r2, [r7, #12]
 8021c18:	4613      	mov	r3, r2
 8021c1a:	005b      	lsls	r3, r3, #1
 8021c1c:	4413      	add	r3, r2
 8021c1e:	009b      	lsls	r3, r3, #2
 8021c20:	461a      	mov	r2, r3
 8021c22:	4b04      	ldr	r3, [pc, #16]	; (8021c34 <XMC_SCU_CLOCK_UngatePeripheralClock+0x34>)
 8021c24:	4413      	add	r3, r2
 8021c26:	68ba      	ldr	r2, [r7, #8]
 8021c28:	601a      	str	r2, [r3, #0]
}
 8021c2a:	3714      	adds	r7, #20
 8021c2c:	46bd      	mov	sp, r7
 8021c2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021c32:	4770      	bx	lr
 8021c34:	50004648 	.word	0x50004648

08021c38 <XMC_SCU_CLOCK_IsPeripheralClockGated>:

/* API to ungate a given module clock */
bool XMC_SCU_CLOCK_IsPeripheralClockGated(const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)
{
 8021c38:	b480      	push	{r7}
 8021c3a:	b085      	sub	sp, #20
 8021c3c:	af00      	add	r7, sp, #0
 8021c3e:	6078      	str	r0, [r7, #4]
  uint32_t index = ((peripheral & 0xf0000000UL) >> 28UL);
 8021c40:	687b      	ldr	r3, [r7, #4]
 8021c42:	0f1b      	lsrs	r3, r3, #28
 8021c44:	60fb      	str	r3, [r7, #12]
  uint32_t mask = (peripheral & (uint32_t)~0xf0000000UL);
 8021c46:	687b      	ldr	r3, [r7, #4]
 8021c48:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 8021c4c:	60bb      	str	r3, [r7, #8]

  return ((*(const volatile uint32_t *)(&(SCU_CLK->CGATSTAT0) + (index * 3U)) & mask) != 0U);
 8021c4e:	68fa      	ldr	r2, [r7, #12]
 8021c50:	4613      	mov	r3, r2
 8021c52:	005b      	lsls	r3, r3, #1
 8021c54:	4413      	add	r3, r2
 8021c56:	009b      	lsls	r3, r3, #2
 8021c58:	461a      	mov	r2, r3
 8021c5a:	4b08      	ldr	r3, [pc, #32]	; (8021c7c <XMC_SCU_CLOCK_IsPeripheralClockGated+0x44>)
 8021c5c:	4413      	add	r3, r2
 8021c5e:	681a      	ldr	r2, [r3, #0]
 8021c60:	68bb      	ldr	r3, [r7, #8]
 8021c62:	4013      	ands	r3, r2
 8021c64:	2b00      	cmp	r3, #0
 8021c66:	bf14      	ite	ne
 8021c68:	2301      	movne	r3, #1
 8021c6a:	2300      	moveq	r3, #0
 8021c6c:	b2db      	uxtb	r3, r3
}
 8021c6e:	4618      	mov	r0, r3
 8021c70:	3714      	adds	r7, #20
 8021c72:	46bd      	mov	sp, r7
 8021c74:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021c78:	4770      	bx	lr
 8021c7a:	bf00      	nop
 8021c7c:	50004640 	.word	0x50004640

08021c80 <XMC_SCU_CLOCK_EnableUsbPll>:
  return ((SCU_POWER->EVRVADCSTAT & SCU_POWER_EVRVADCSTAT_VADC33V_Msk) >> SCU_POWER_EVRVADCSTAT_VADC33V_Pos) * XMC_SCU_POWER_LSB33V;
}

/* API to enable USB PLL for USB clock */
void XMC_SCU_CLOCK_EnableUsbPll(void)
{
 8021c80:	b480      	push	{r7}
 8021c82:	af00      	add	r7, sp, #0
  SCU_PLL->USBPLLCON &= (uint32_t)~(SCU_PLL_USBPLLCON_VCOPWD_Msk | SCU_PLL_USBPLLCON_PLLPWD_Msk);
 8021c84:	4a05      	ldr	r2, [pc, #20]	; (8021c9c <XMC_SCU_CLOCK_EnableUsbPll+0x1c>)
 8021c86:	4b05      	ldr	r3, [pc, #20]	; (8021c9c <XMC_SCU_CLOCK_EnableUsbPll+0x1c>)
 8021c88:	695b      	ldr	r3, [r3, #20]
 8021c8a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8021c8e:	f023 0302 	bic.w	r3, r3, #2
 8021c92:	6153      	str	r3, [r2, #20]
}
 8021c94:	46bd      	mov	sp, r7
 8021c96:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021c9a:	4770      	bx	lr
 8021c9c:	50004710 	.word	0x50004710

08021ca0 <XMC_SCU_CLOCK_StartUsbPll>:
  SCU_PLL->USBPLLCON |= (uint32_t)(SCU_PLL_USBPLLCON_VCOPWD_Msk | SCU_PLL_USBPLLCON_PLLPWD_Msk);
}

/* API to configure USB PLL */
void XMC_SCU_CLOCK_StartUsbPll(uint32_t pdiv, uint32_t ndiv)
{
 8021ca0:	b480      	push	{r7}
 8021ca2:	b083      	sub	sp, #12
 8021ca4:	af00      	add	r7, sp, #0
 8021ca6:	6078      	str	r0, [r7, #4]
 8021ca8:	6039      	str	r1, [r7, #0]
  /* Go to bypass the USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_VCOBYP_Msk;
 8021caa:	4a28      	ldr	r2, [pc, #160]	; (8021d4c <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8021cac:	4b27      	ldr	r3, [pc, #156]	; (8021d4c <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8021cae:	695b      	ldr	r3, [r3, #20]
 8021cb0:	f043 0301 	orr.w	r3, r3, #1
 8021cb4:	6153      	str	r3, [r2, #20]
  while ((SCU_PLL->USBPLLSTAT & SCU_PLL_USBPLLSTAT_VCOBYST_Msk) == 0U)
 8021cb6:	bf00      	nop
 8021cb8:	4b24      	ldr	r3, [pc, #144]	; (8021d4c <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8021cba:	691b      	ldr	r3, [r3, #16]
 8021cbc:	f003 0301 	and.w	r3, r3, #1
 8021cc0:	2b00      	cmp	r3, #0
 8021cc2:	d0f9      	beq.n	8021cb8 <XMC_SCU_CLOCK_StartUsbPll+0x18>
  {
    /* wait for prescaler mode */
  }

  /* disconnect Oscillator from USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_FINDIS_Msk;
 8021cc4:	4a21      	ldr	r2, [pc, #132]	; (8021d4c <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8021cc6:	4b21      	ldr	r3, [pc, #132]	; (8021d4c <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8021cc8:	695b      	ldr	r3, [r3, #20]
 8021cca:	f043 0310 	orr.w	r3, r3, #16
 8021cce:	6153      	str	r3, [r2, #20]

  /* Setup Divider settings for USB PLL */
  SCU_PLL->USBPLLCON = (uint32_t)((uint32_t)((ndiv - 1U) << SCU_PLL_USBPLLCON_NDIV_Pos) |
 8021cd0:	491e      	ldr	r1, [pc, #120]	; (8021d4c <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8021cd2:	683b      	ldr	r3, [r7, #0]
 8021cd4:	3b01      	subs	r3, #1
 8021cd6:	021a      	lsls	r2, r3, #8
                                  (uint32_t)((pdiv - 1U) << SCU_PLL_USBPLLCON_PDIV_Pos));
 8021cd8:	687b      	ldr	r3, [r7, #4]
 8021cda:	3b01      	subs	r3, #1
 8021cdc:	061b      	lsls	r3, r3, #24

  /* disconnect Oscillator from USB PLL */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_FINDIS_Msk;

  /* Setup Divider settings for USB PLL */
  SCU_PLL->USBPLLCON = (uint32_t)((uint32_t)((ndiv - 1U) << SCU_PLL_USBPLLCON_NDIV_Pos) |
 8021cde:	4313      	orrs	r3, r2
 8021ce0:	614b      	str	r3, [r1, #20]
                                  (uint32_t)((pdiv - 1U) << SCU_PLL_USBPLLCON_PDIV_Pos));

  /* Set OSCDISCDIS */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_OSCDISCDIS_Msk;
 8021ce2:	4a1a      	ldr	r2, [pc, #104]	; (8021d4c <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8021ce4:	4b19      	ldr	r3, [pc, #100]	; (8021d4c <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8021ce6:	695b      	ldr	r3, [r3, #20]
 8021ce8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8021cec:	6153      	str	r3, [r2, #20]

  /* connect Oscillator to USB PLL */
  SCU_PLL->USBPLLCON &= (uint32_t)~SCU_PLL_USBPLLCON_FINDIS_Msk;
 8021cee:	4a17      	ldr	r2, [pc, #92]	; (8021d4c <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8021cf0:	4b16      	ldr	r3, [pc, #88]	; (8021d4c <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8021cf2:	695b      	ldr	r3, [r3, #20]
 8021cf4:	f023 0310 	bic.w	r3, r3, #16
 8021cf8:	6153      	str	r3, [r2, #20]

  /* restart PLL Lock detection */
  SCU_PLL->USBPLLCON |= (uint32_t)SCU_PLL_USBPLLCON_RESLD_Msk;
 8021cfa:	4a14      	ldr	r2, [pc, #80]	; (8021d4c <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8021cfc:	4b13      	ldr	r3, [pc, #76]	; (8021d4c <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8021cfe:	695b      	ldr	r3, [r3, #20]
 8021d00:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8021d04:	6153      	str	r3, [r2, #20]

  while ((SCU_PLL->USBPLLSTAT & SCU_PLL_USBPLLSTAT_VCOLOCK_Msk) == 0U)
 8021d06:	bf00      	nop
 8021d08:	4b10      	ldr	r3, [pc, #64]	; (8021d4c <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8021d0a:	691b      	ldr	r3, [r3, #16]
 8021d0c:	f003 0304 	and.w	r3, r3, #4
 8021d10:	2b00      	cmp	r3, #0
 8021d12:	d0f9      	beq.n	8021d08 <XMC_SCU_CLOCK_StartUsbPll+0x68>
  {
    /* wait for PLL Lock */
  }

  /* Disable bypass- put PLL clock back */
  SCU_PLL->USBPLLCON &= ~SCU_PLL_USBPLLCON_VCOBYP_Msk;
 8021d14:	4a0d      	ldr	r2, [pc, #52]	; (8021d4c <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8021d16:	4b0d      	ldr	r3, [pc, #52]	; (8021d4c <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8021d18:	695b      	ldr	r3, [r3, #20]
 8021d1a:	f023 0301 	bic.w	r3, r3, #1
 8021d1e:	6153      	str	r3, [r2, #20]
  while ((SCU_PLL->USBPLLSTAT & SCU_PLL_USBPLLSTAT_VCOBYST_Msk) != 0U)
 8021d20:	bf00      	nop
 8021d22:	4b0a      	ldr	r3, [pc, #40]	; (8021d4c <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8021d24:	691b      	ldr	r3, [r3, #16]
 8021d26:	f003 0301 	and.w	r3, r3, #1
 8021d2a:	2b00      	cmp	r3, #0
 8021d2c:	d1f9      	bne.n	8021d22 <XMC_SCU_CLOCK_StartUsbPll+0x82>
  {
    /* wait for normal mode */
  }

  /* Reset OSCDISCDIS */
  SCU_PLL->USBPLLCON &= ~SCU_PLL_USBPLLCON_OSCDISCDIS_Msk;
 8021d2e:	4a07      	ldr	r2, [pc, #28]	; (8021d4c <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8021d30:	4b06      	ldr	r3, [pc, #24]	; (8021d4c <XMC_SCU_CLOCK_StartUsbPll+0xac>)
 8021d32:	695b      	ldr	r3, [r3, #20]
 8021d34:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8021d38:	6153      	str	r3, [r2, #20]

  SCU_TRAP->TRAPCLR = SCU_TRAP_TRAPCLR_UVCOLCKT_Msk;
 8021d3a:	4b05      	ldr	r3, [pc, #20]	; (8021d50 <XMC_SCU_CLOCK_StartUsbPll+0xb0>)
 8021d3c:	2208      	movs	r2, #8
 8021d3e:	60da      	str	r2, [r3, #12]
}
 8021d40:	370c      	adds	r7, #12
 8021d42:	46bd      	mov	sp, r7
 8021d44:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021d48:	4770      	bx	lr
 8021d4a:	bf00      	nop
 8021d4c:	50004710 	.word	0x50004710
 8021d50:	50004160 	.word	0x50004160

08021d54 <XMC_SCU_CLOCK_SetBackupClockCalibrationMode>:
                                  SCU_PLL_USBPLLCON_VCOBYP_Msk);
}

/* API to onfigure the calibration mode for internal oscillator */
void XMC_SCU_CLOCK_SetBackupClockCalibrationMode(XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_t mode)
{
 8021d54:	b580      	push	{r7, lr}
 8021d56:	b082      	sub	sp, #8
 8021d58:	af00      	add	r7, sp, #0
 8021d5a:	4603      	mov	r3, r0
 8021d5c:	71fb      	strb	r3, [r7, #7]
  /* Enable factory calibration based trimming */
  SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FOTR_Msk;
 8021d5e:	4a0f      	ldr	r2, [pc, #60]	; (8021d9c <XMC_SCU_CLOCK_SetBackupClockCalibrationMode+0x48>)
 8021d60:	4b0e      	ldr	r3, [pc, #56]	; (8021d9c <XMC_SCU_CLOCK_SetBackupClockCalibrationMode+0x48>)
 8021d62:	685b      	ldr	r3, [r3, #4]
 8021d64:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8021d68:	6053      	str	r3, [r2, #4]

  if (mode == XMC_SCU_CLOCK_FOFI_CALIBRATION_MODE_AUTOMATIC)
 8021d6a:	79fb      	ldrb	r3, [r7, #7]
 8021d6c:	2b01      	cmp	r3, #1
 8021d6e:	d10e      	bne.n	8021d8e <XMC_SCU_CLOCK_SetBackupClockCalibrationMode+0x3a>
  {
    /* Disable factory calibration based trimming */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_FOTR_Msk;
 8021d70:	4a0a      	ldr	r2, [pc, #40]	; (8021d9c <XMC_SCU_CLOCK_SetBackupClockCalibrationMode+0x48>)
 8021d72:	4b0a      	ldr	r3, [pc, #40]	; (8021d9c <XMC_SCU_CLOCK_SetBackupClockCalibrationMode+0x48>)
 8021d74:	685b      	ldr	r3, [r3, #4]
 8021d76:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 8021d7a:	6053      	str	r3, [r2, #4]
    XMC_SCU_lDelay(100UL);
 8021d7c:	2064      	movs	r0, #100	; 0x64
 8021d7e:	f7ff fd03 	bl	8021788 <XMC_SCU_lDelay>

    /* Enable automatic calibration */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_AOTREN_Msk;
 8021d82:	4a06      	ldr	r2, [pc, #24]	; (8021d9c <XMC_SCU_CLOCK_SetBackupClockCalibrationMode+0x48>)
 8021d84:	4b05      	ldr	r3, [pc, #20]	; (8021d9c <XMC_SCU_CLOCK_SetBackupClockCalibrationMode+0x48>)
 8021d86:	685b      	ldr	r3, [r3, #4]
 8021d88:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 8021d8c:	6053      	str	r3, [r2, #4]
  }

  XMC_SCU_lDelay(100UL);
 8021d8e:	2064      	movs	r0, #100	; 0x64
 8021d90:	f7ff fcfa 	bl	8021788 <XMC_SCU_lDelay>
}
 8021d94:	3708      	adds	r7, #8
 8021d96:	46bd      	mov	sp, r7
 8021d98:	bd80      	pop	{r7, pc}
 8021d9a:	bf00      	nop
 8021d9c:	50004710 	.word	0x50004710

08021da0 <XMC_SCU_HIB_EnableHibernateDomain>:
  return (bool)((SCU_PLL->USBPLLSTAT & SCU_PLL_USBPLLSTAT_VCOLOCK_Msk) != 0UL);
}

/* API to power up the hibernation domain */
void XMC_SCU_HIB_EnableHibernateDomain(void)
{
 8021da0:	b480      	push	{r7}
 8021da2:	af00      	add	r7, sp, #0
  /* Power up HIB domain if and only if it is currently powered down */
  if ((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0UL)
 8021da4:	4b12      	ldr	r3, [pc, #72]	; (8021df0 <XMC_SCU_HIB_EnableHibernateDomain+0x50>)
 8021da6:	681b      	ldr	r3, [r3, #0]
 8021da8:	f003 0301 	and.w	r3, r3, #1
 8021dac:	2b00      	cmp	r3, #0
 8021dae:	d109      	bne.n	8021dc4 <XMC_SCU_HIB_EnableHibernateDomain+0x24>
  {
    SCU_POWER->PWRSET = (uint32_t)SCU_POWER_PWRSET_HIB_Msk;
 8021db0:	4b0f      	ldr	r3, [pc, #60]	; (8021df0 <XMC_SCU_HIB_EnableHibernateDomain+0x50>)
 8021db2:	2201      	movs	r2, #1
 8021db4:	605a      	str	r2, [r3, #4]

    while ((SCU_POWER->PWRSTAT & SCU_POWER_PWRSTAT_HIBEN_Msk) == 0UL)
 8021db6:	bf00      	nop
 8021db8:	4b0d      	ldr	r3, [pc, #52]	; (8021df0 <XMC_SCU_HIB_EnableHibernateDomain+0x50>)
 8021dba:	681b      	ldr	r3, [r3, #0]
 8021dbc:	f003 0301 	and.w	r3, r3, #1
 8021dc0:	2b00      	cmp	r3, #0
 8021dc2:	d0f9      	beq.n	8021db8 <XMC_SCU_HIB_EnableHibernateDomain+0x18>
      /* wait until HIB domain is enabled */
    }
  }

  /* Remove the reset only if HIB domain were in a state of reset */
  if ((SCU_RESET->RSTSTAT) & SCU_RESET_RSTSTAT_HIBRS_Msk)
 8021dc4:	4b0b      	ldr	r3, [pc, #44]	; (8021df4 <XMC_SCU_HIB_EnableHibernateDomain+0x54>)
 8021dc6:	681b      	ldr	r3, [r3, #0]
 8021dc8:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8021dcc:	2b00      	cmp	r3, #0
 8021dce:	d00a      	beq.n	8021de6 <XMC_SCU_HIB_EnableHibernateDomain+0x46>
  {
    SCU_RESET->RSTCLR = (uint32_t)SCU_RESET_RSTCLR_HIBRS_Msk;
 8021dd0:	4b08      	ldr	r3, [pc, #32]	; (8021df4 <XMC_SCU_HIB_EnableHibernateDomain+0x54>)
 8021dd2:	f44f 7200 	mov.w	r2, #512	; 0x200
 8021dd6:	609a      	str	r2, [r3, #8]
    while ((SCU_RESET->RSTSTAT & SCU_RESET_RSTSTAT_HIBRS_Msk) != 0UL)
 8021dd8:	bf00      	nop
 8021dda:	4b06      	ldr	r3, [pc, #24]	; (8021df4 <XMC_SCU_HIB_EnableHibernateDomain+0x54>)
 8021ddc:	681b      	ldr	r3, [r3, #0]
 8021dde:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8021de2:	2b00      	cmp	r3, #0
 8021de4:	d1f9      	bne.n	8021dda <XMC_SCU_HIB_EnableHibernateDomain+0x3a>
    {
      /* wait until HIB domain is enabled */
    }
  }
}
 8021de6:	46bd      	mov	sp, r7
 8021de8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021dec:	4770      	bx	lr
 8021dee:	bf00      	nop
 8021df0:	50004200 	.word	0x50004200
 8021df4:	50004400 	.word	0x50004400

08021df8 <XMC_SCU_CLOCK_IsLowPowerOscillatorStable>:
}

#endif

bool XMC_SCU_CLOCK_IsLowPowerOscillatorStable(void)
{
 8021df8:	b480      	push	{r7}
 8021dfa:	af00      	add	r7, sp, #0
  return ((SCU_HIBERNATE->HDSTAT & SCU_HIBERNATE_HDSTAT_ULPWDG_Msk) == 0UL);
 8021dfc:	4b06      	ldr	r3, [pc, #24]	; (8021e18 <XMC_SCU_CLOCK_IsLowPowerOscillatorStable+0x20>)
 8021dfe:	681b      	ldr	r3, [r3, #0]
 8021e00:	f003 0308 	and.w	r3, r3, #8
 8021e04:	2b00      	cmp	r3, #0
 8021e06:	bf0c      	ite	eq
 8021e08:	2301      	moveq	r3, #1
 8021e0a:	2300      	movne	r3, #0
 8021e0c:	b2db      	uxtb	r3, r3
}
 8021e0e:	4618      	mov	r0, r3
 8021e10:	46bd      	mov	sp, r7
 8021e12:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021e16:	4770      	bx	lr
 8021e18:	50004300 	.word	0x50004300

08021e1c <XMC_SCU_CLOCK_EnableLowPowerOscillator>:

/* API to configure the 32khz Ultra Low Power oscillator */
void XMC_SCU_CLOCK_EnableLowPowerOscillator(void)
{
 8021e1c:	b580      	push	{r7, lr}
 8021e1e:	af00      	add	r7, sp, #0
  /* Enable OSC_ULP */
  XMC_SCU_INTERRUPT_ClearEventStatus(XMC_SCU_INTERRUPT_EVENT_OSCULCTRL_UPDATED);
 8021e20:	f44f 0000 	mov.w	r0, #8388608	; 0x800000
 8021e24:	f7ff fcde 	bl	80217e4 <XMC_SCU_INTERRUPT_ClearEventStatus>
  SCU_HIBERNATE->OSCULCTRL &= ~SCU_HIBERNATE_OSCULCTRL_MODE_Msk;
 8021e28:	4a17      	ldr	r2, [pc, #92]	; (8021e88 <XMC_SCU_CLOCK_EnableLowPowerOscillator+0x6c>)
 8021e2a:	4b17      	ldr	r3, [pc, #92]	; (8021e88 <XMC_SCU_CLOCK_EnableLowPowerOscillator+0x6c>)
 8021e2c:	69db      	ldr	r3, [r3, #28]
 8021e2e:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 8021e32:	61d3      	str	r3, [r2, #28]
  while ((XMC_SCU_INTERUPT_GetEventStatus() & XMC_SCU_INTERRUPT_EVENT_OSCULCTRL_UPDATED) == 0);
 8021e34:	bf00      	nop
 8021e36:	f7ff fcc9 	bl	80217cc <XMC_SCU_INTERUPT_GetEventStatus>
 8021e3a:	4603      	mov	r3, r0
 8021e3c:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8021e40:	2b00      	cmp	r3, #0
 8021e42:	d0f8      	beq.n	8021e36 <XMC_SCU_CLOCK_EnableLowPowerOscillator+0x1a>

  /* Clear ULP WDG status */
  XMC_SCU_INTERRUPT_ClearEventStatus(XMC_SCU_INTERRUPT_EVENT_HDCLR_UPDATED);
 8021e44:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8021e48:	f7ff fccc 	bl	80217e4 <XMC_SCU_INTERRUPT_ClearEventStatus>
  SCU_HIBERNATE->HDCLR = (uint32_t)SCU_HIBERNATE_HDCLR_ULPWDG_Msk;
 8021e4c:	4b0e      	ldr	r3, [pc, #56]	; (8021e88 <XMC_SCU_CLOCK_EnableLowPowerOscillator+0x6c>)
 8021e4e:	2208      	movs	r2, #8
 8021e50:	605a      	str	r2, [r3, #4]
  while ((XMC_SCU_INTERUPT_GetEventStatus() & XMC_SCU_INTERRUPT_EVENT_HDCLR_UPDATED) == 0);
 8021e52:	bf00      	nop
 8021e54:	f7ff fcba 	bl	80217cc <XMC_SCU_INTERUPT_GetEventStatus>
 8021e58:	4603      	mov	r3, r0
 8021e5a:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8021e5e:	2b00      	cmp	r3, #0
 8021e60:	d0f8      	beq.n	8021e54 <XMC_SCU_CLOCK_EnableLowPowerOscillator+0x38>

  /* Enable ULP WDG */
  XMC_SCU_INTERRUPT_ClearEventStatus(XMC_SCU_INTERRUPT_EVENT_HDCR_UPDATED);
 8021e62:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 8021e66:	f7ff fcbd 	bl	80217e4 <XMC_SCU_INTERRUPT_ClearEventStatus>
  SCU_HIBERNATE->HDCR |= (uint32_t)SCU_HIBERNATE_HDCR_ULPWDGEN_Msk;
 8021e6a:	4a07      	ldr	r2, [pc, #28]	; (8021e88 <XMC_SCU_CLOCK_EnableLowPowerOscillator+0x6c>)
 8021e6c:	4b06      	ldr	r3, [pc, #24]	; (8021e88 <XMC_SCU_CLOCK_EnableLowPowerOscillator+0x6c>)
 8021e6e:	68db      	ldr	r3, [r3, #12]
 8021e70:	f043 0308 	orr.w	r3, r3, #8
 8021e74:	60d3      	str	r3, [r2, #12]
  while ((XMC_SCU_INTERUPT_GetEventStatus() & XMC_SCU_INTERRUPT_EVENT_HDCR_UPDATED) == 0);
 8021e76:	bf00      	nop
 8021e78:	f7ff fca8 	bl	80217cc <XMC_SCU_INTERUPT_GetEventStatus>
 8021e7c:	4603      	mov	r3, r0
 8021e7e:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8021e82:	2b00      	cmp	r3, #0
 8021e84:	d0f8      	beq.n	8021e78 <XMC_SCU_CLOCK_EnableLowPowerOscillator+0x5c>
}
 8021e86:	bd80      	pop	{r7, pc}
 8021e88:	50004300 	.word	0x50004300

08021e8c <XMC_SCU_CLOCK_EnableHighPerformanceOscillator>:
  return (SCU_HIBERNATE->OSCULSTAT & SCU_HIBERNATE_OSCULSTAT_X1D_Msk);
}

/* API to enable High Precision High Speed oscillator */
void XMC_SCU_CLOCK_EnableHighPerformanceOscillator(void)
{
 8021e8c:	b5b0      	push	{r4, r5, r7, lr}
 8021e8e:	af00      	add	r7, sp, #0
  SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_PLLPWD_Msk;
 8021e90:	4a0f      	ldr	r2, [pc, #60]	; (8021ed0 <XMC_SCU_CLOCK_EnableHighPerformanceOscillator+0x44>)
 8021e92:	4b0f      	ldr	r3, [pc, #60]	; (8021ed0 <XMC_SCU_CLOCK_EnableHighPerformanceOscillator+0x44>)
 8021e94:	685b      	ldr	r3, [r3, #4]
 8021e96:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8021e9a:	6053      	str	r3, [r2, #4]

  SCU_OSC->OSCHPCTRL = (uint32_t)((SCU_OSC->OSCHPCTRL & ~(SCU_OSC_OSCHPCTRL_MODE_Msk | SCU_OSC_OSCHPCTRL_OSCVAL_Msk)) |
 8021e9c:	4d0d      	ldr	r5, [pc, #52]	; (8021ed4 <XMC_SCU_CLOCK_EnableHighPerformanceOscillator+0x48>)
 8021e9e:	4b0d      	ldr	r3, [pc, #52]	; (8021ed4 <XMC_SCU_CLOCK_EnableHighPerformanceOscillator+0x48>)
 8021ea0:	685b      	ldr	r3, [r3, #4]
 8021ea2:	f423 2470 	bic.w	r4, r3, #983040	; 0xf0000
 8021ea6:	f024 0430 	bic.w	r4, r4, #48	; 0x30
                                  (((OSCHP_GetFrequency() / FOSCREF) - 1UL) << SCU_OSC_OSCHPCTRL_OSCVAL_Pos));
 8021eaa:	f002 ff29 	bl	8024d00 <OSCHP_GetFrequency>
 8021eae:	4602      	mov	r2, r0
 8021eb0:	4b09      	ldr	r3, [pc, #36]	; (8021ed8 <XMC_SCU_CLOCK_EnableHighPerformanceOscillator+0x4c>)
 8021eb2:	fba3 2302 	umull	r2, r3, r3, r2
 8021eb6:	0d1b      	lsrs	r3, r3, #20
 8021eb8:	3b01      	subs	r3, #1
 8021eba:	041b      	lsls	r3, r3, #16
/* API to enable High Precision High Speed oscillator */
void XMC_SCU_CLOCK_EnableHighPerformanceOscillator(void)
{
  SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_PLLPWD_Msk;

  SCU_OSC->OSCHPCTRL = (uint32_t)((SCU_OSC->OSCHPCTRL & ~(SCU_OSC_OSCHPCTRL_MODE_Msk | SCU_OSC_OSCHPCTRL_OSCVAL_Msk)) |
 8021ebc:	4323      	orrs	r3, r4
 8021ebe:	606b      	str	r3, [r5, #4]
                                  (((OSCHP_GetFrequency() / FOSCREF) - 1UL) << SCU_OSC_OSCHPCTRL_OSCVAL_Pos));

  /* restart OSC Watchdog */
  SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_OSCRES_Msk;
 8021ec0:	4a03      	ldr	r2, [pc, #12]	; (8021ed0 <XMC_SCU_CLOCK_EnableHighPerformanceOscillator+0x44>)
 8021ec2:	4b03      	ldr	r3, [pc, #12]	; (8021ed0 <XMC_SCU_CLOCK_EnableHighPerformanceOscillator+0x44>)
 8021ec4:	685b      	ldr	r3, [r3, #4]
 8021ec6:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8021eca:	6053      	str	r3, [r2, #4]
}
 8021ecc:	bdb0      	pop	{r4, r5, r7, pc}
 8021ece:	bf00      	nop
 8021ed0:	50004710 	.word	0x50004710
 8021ed4:	50004700 	.word	0x50004700
 8021ed8:	6b5fca6b 	.word	0x6b5fca6b

08021edc <XMC_SCU_CLOCK_IsHighPerformanceOscillatorStable>:

bool XMC_SCU_CLOCK_IsHighPerformanceOscillatorStable(void)
{
 8021edc:	b480      	push	{r7}
 8021ede:	af00      	add	r7, sp, #0
  return ((SCU_PLL->PLLSTAT & XMC_SCU_PLL_PLLSTAT_OSC_USABLE) == XMC_SCU_PLL_PLLSTAT_OSC_USABLE);
 8021ee0:	4b07      	ldr	r3, [pc, #28]	; (8021f00 <XMC_SCU_CLOCK_IsHighPerformanceOscillatorStable+0x24>)
 8021ee2:	681b      	ldr	r3, [r3, #0]
 8021ee4:	f403 7360 	and.w	r3, r3, #896	; 0x380
 8021ee8:	f5b3 7f60 	cmp.w	r3, #896	; 0x380
 8021eec:	bf0c      	ite	eq
 8021eee:	2301      	moveq	r3, #1
 8021ef0:	2300      	movne	r3, #0
 8021ef2:	b2db      	uxtb	r3, r3
}
 8021ef4:	4618      	mov	r0, r3
 8021ef6:	46bd      	mov	sp, r7
 8021ef8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021efc:	4770      	bx	lr
 8021efe:	bf00      	nop
 8021f00:	50004710 	.word	0x50004710

08021f04 <XMC_SCU_CLOCK_EnableSystemPll>:
  return (SCU_OSC->OSCHPSTAT & SCU_OSC_OSCHPSTAT_X1D_Msk);
}

/* API to enable main PLL */
void XMC_SCU_CLOCK_EnableSystemPll(void)
{
 8021f04:	b480      	push	{r7}
 8021f06:	af00      	add	r7, sp, #0
  SCU_PLL->PLLCON0 &= (uint32_t)~(SCU_PLL_PLLCON0_VCOPWD_Msk | SCU_PLL_PLLCON0_PLLPWD_Msk);
 8021f08:	4a05      	ldr	r2, [pc, #20]	; (8021f20 <XMC_SCU_CLOCK_EnableSystemPll+0x1c>)
 8021f0a:	4b05      	ldr	r3, [pc, #20]	; (8021f20 <XMC_SCU_CLOCK_EnableSystemPll+0x1c>)
 8021f0c:	685b      	ldr	r3, [r3, #4]
 8021f0e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8021f12:	f023 0302 	bic.w	r3, r3, #2
 8021f16:	6053      	str	r3, [r2, #4]
}
 8021f18:	46bd      	mov	sp, r7
 8021f1a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021f1e:	4770      	bx	lr
 8021f20:	50004710 	.word	0x50004710

08021f24 <XMC_SCU_CLOCK_DisableSystemPll>:

/* API to disable main PLL */
void XMC_SCU_CLOCK_DisableSystemPll(void)
{
 8021f24:	b480      	push	{r7}
 8021f26:	af00      	add	r7, sp, #0
  SCU_PLL->PLLCON0 |= (uint32_t)(SCU_PLL_PLLCON0_VCOPWD_Msk | SCU_PLL_PLLCON0_PLLPWD_Msk);
 8021f28:	4a05      	ldr	r2, [pc, #20]	; (8021f40 <XMC_SCU_CLOCK_DisableSystemPll+0x1c>)
 8021f2a:	4b05      	ldr	r3, [pc, #20]	; (8021f40 <XMC_SCU_CLOCK_DisableSystemPll+0x1c>)
 8021f2c:	685b      	ldr	r3, [r3, #4]
 8021f2e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8021f32:	f043 0302 	orr.w	r3, r3, #2
 8021f36:	6053      	str	r3, [r2, #4]
}
 8021f38:	46bd      	mov	sp, r7
 8021f3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021f3e:	4770      	bx	lr
 8021f40:	50004710 	.word	0x50004710

08021f44 <XMC_SCU_CLOCK_StartSystemPll>:
void XMC_SCU_CLOCK_StartSystemPll(XMC_SCU_CLOCK_SYSPLLCLKSRC_t source,
                                  XMC_SCU_CLOCK_SYSPLL_MODE_t mode,
                                  uint32_t pdiv,
                                  uint32_t ndiv,
                                  uint32_t kdiv)
{
 8021f44:	b580      	push	{r7, lr}
 8021f46:	b086      	sub	sp, #24
 8021f48:	af00      	add	r7, sp, #0
 8021f4a:	60ba      	str	r2, [r7, #8]
 8021f4c:	607b      	str	r3, [r7, #4]
 8021f4e:	4603      	mov	r3, r0
 8021f50:	81fb      	strh	r3, [r7, #14]
 8021f52:	460b      	mov	r3, r1
 8021f54:	737b      	strb	r3, [r7, #13]

  uint32_t vco_frequency; /* Q10.22, max VCO frequency = 520MHz */
  uint32_t kdiv_temp;

  XMC_SCU_CLOCK_SetSystemPllClockSource(source);
 8021f56:	89fb      	ldrh	r3, [r7, #14]
 8021f58:	4618      	mov	r0, r3
 8021f5a:	f7ff fd59 	bl	8021a10 <XMC_SCU_CLOCK_SetSystemPllClockSource>

  if (mode == XMC_SCU_CLOCK_SYSPLL_MODE_NORMAL)
 8021f5e:	7b7b      	ldrb	r3, [r7, #13]
 8021f60:	2b01      	cmp	r3, #1
 8021f62:	f040 808b 	bne.w	802207c <XMC_SCU_CLOCK_StartSystemPll+0x138>
  {
    /* Calculate initial step to be close to fOFI */
    if (source == XMC_SCU_CLOCK_SYSPLLCLKSRC_OSCHP)
 8021f66:	89fb      	ldrh	r3, [r7, #14]
 8021f68:	2b00      	cmp	r3, #0
 8021f6a:	d109      	bne.n	8021f80 <XMC_SCU_CLOCK_StartSystemPll+0x3c>
    {
      vco_frequency = (OSCHP_GetFrequency() / 1000000U) << 22;
 8021f6c:	f002 fec8 	bl	8024d00 <OSCHP_GetFrequency>
 8021f70:	4602      	mov	r2, r0
 8021f72:	4b54      	ldr	r3, [pc, #336]	; (80220c4 <XMC_SCU_CLOCK_StartSystemPll+0x180>)
 8021f74:	fba3 2302 	umull	r2, r3, r3, r2
 8021f78:	0c9b      	lsrs	r3, r3, #18
 8021f7a:	059b      	lsls	r3, r3, #22
 8021f7c:	617b      	str	r3, [r7, #20]
 8021f7e:	e002      	b.n	8021f86 <XMC_SCU_CLOCK_StartSystemPll+0x42>
    }
    else
    {
      vco_frequency = (OFI_FREQUENCY / 1000000U) << 22;
 8021f80:	f04f 63c0 	mov.w	r3, #100663296	; 0x6000000
 8021f84:	617b      	str	r3, [r7, #20]
    }
    vco_frequency = ((vco_frequency * ndiv) / pdiv);
 8021f86:	697b      	ldr	r3, [r7, #20]
 8021f88:	687a      	ldr	r2, [r7, #4]
 8021f8a:	fb02 f203 	mul.w	r2, r2, r3
 8021f8e:	68bb      	ldr	r3, [r7, #8]
 8021f90:	fbb2 f3f3 	udiv	r3, r2, r3
 8021f94:	617b      	str	r3, [r7, #20]
    kdiv_temp = (vco_frequency / (OFI_FREQUENCY / 1000000U)) >> 22;
 8021f96:	697b      	ldr	r3, [r7, #20]
 8021f98:	4a4b      	ldr	r2, [pc, #300]	; (80220c8 <XMC_SCU_CLOCK_StartSystemPll+0x184>)
 8021f9a:	fba2 2303 	umull	r2, r3, r2, r3
 8021f9e:	091b      	lsrs	r3, r3, #4
 8021fa0:	0d9b      	lsrs	r3, r3, #22
 8021fa2:	613b      	str	r3, [r7, #16]

    /* Switch to prescaler mode */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_VCOBYP_Msk;
 8021fa4:	4a49      	ldr	r2, [pc, #292]	; (80220cc <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 8021fa6:	4b49      	ldr	r3, [pc, #292]	; (80220cc <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 8021fa8:	685b      	ldr	r3, [r3, #4]
 8021faa:	f043 0301 	orr.w	r3, r3, #1
 8021fae:	6053      	str	r3, [r2, #4]
    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOBYST_Msk) == 0U)
 8021fb0:	bf00      	nop
 8021fb2:	4b46      	ldr	r3, [pc, #280]	; (80220cc <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 8021fb4:	681b      	ldr	r3, [r3, #0]
 8021fb6:	f003 0301 	and.w	r3, r3, #1
 8021fba:	2b00      	cmp	r3, #0
 8021fbc:	d0f9      	beq.n	8021fb2 <XMC_SCU_CLOCK_StartSystemPll+0x6e>
    {
      /* wait for prescaler mode */
    }

    /* disconnect Oscillator from PLL */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FINDIS_Msk;
 8021fbe:	4a43      	ldr	r2, [pc, #268]	; (80220cc <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 8021fc0:	4b42      	ldr	r3, [pc, #264]	; (80220cc <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 8021fc2:	685b      	ldr	r3, [r3, #4]
 8021fc4:	f043 0310 	orr.w	r3, r3, #16
 8021fc8:	6053      	str	r3, [r2, #4]

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
 8021fca:	4940      	ldr	r1, [pc, #256]	; (80220cc <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 8021fcc:	4b3f      	ldr	r3, [pc, #252]	; (80220cc <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 8021fce:	689a      	ldr	r2, [r3, #8]
 8021fd0:	4b3f      	ldr	r3, [pc, #252]	; (80220d0 <XMC_SCU_CLOCK_StartSystemPll+0x18c>)
 8021fd2:	4013      	ands	r3, r2
                                   SCU_PLL_PLLCON1_PDIV_Msk)) | ((ndiv - 1UL) << SCU_PLL_PLLCON1_NDIV_Pos) |
 8021fd4:	687a      	ldr	r2, [r7, #4]
 8021fd6:	3a01      	subs	r2, #1
 8021fd8:	0212      	lsls	r2, r2, #8
 8021fda:	431a      	orrs	r2, r3
                                  ((kdiv_temp - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos) |
 8021fdc:	693b      	ldr	r3, [r7, #16]
 8021fde:	3b01      	subs	r3, #1
 8021fe0:	041b      	lsls	r3, r3, #16
    /* disconnect Oscillator from PLL */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FINDIS_Msk;

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
                                   SCU_PLL_PLLCON1_PDIV_Msk)) | ((ndiv - 1UL) << SCU_PLL_PLLCON1_NDIV_Pos) |
 8021fe2:	431a      	orrs	r2, r3
                                  ((kdiv_temp - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos) |
                                  ((pdiv - 1UL) << SCU_PLL_PLLCON1_PDIV_Pos));
 8021fe4:	68bb      	ldr	r3, [r7, #8]
 8021fe6:	3b01      	subs	r3, #1
 8021fe8:	061b      	lsls	r3, r3, #24

    /* disconnect Oscillator from PLL */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_FINDIS_Msk;

    /* Setup divider settings for main PLL */
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~(SCU_PLL_PLLCON1_NDIV_Msk | SCU_PLL_PLLCON1_K2DIV_Msk |
 8021fea:	4313      	orrs	r3, r2
 8021fec:	608b      	str	r3, [r1, #8]
                                   SCU_PLL_PLLCON1_PDIV_Msk)) | ((ndiv - 1UL) << SCU_PLL_PLLCON1_NDIV_Pos) |
                                  ((kdiv_temp - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos) |
                                  ((pdiv - 1UL) << SCU_PLL_PLLCON1_PDIV_Pos));

    /* Set OSCDISCDIS, OSC clock remains connected to the VCO in case of loss of lock */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_OSCDISCDIS_Msk;
 8021fee:	4a37      	ldr	r2, [pc, #220]	; (80220cc <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 8021ff0:	4b36      	ldr	r3, [pc, #216]	; (80220cc <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 8021ff2:	685b      	ldr	r3, [r3, #4]
 8021ff4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8021ff8:	6053      	str	r3, [r2, #4]

    /* connect Oscillator to PLL */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_FINDIS_Msk;
 8021ffa:	4a34      	ldr	r2, [pc, #208]	; (80220cc <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 8021ffc:	4b33      	ldr	r3, [pc, #204]	; (80220cc <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 8021ffe:	685b      	ldr	r3, [r3, #4]
 8022000:	f023 0310 	bic.w	r3, r3, #16
 8022004:	6053      	str	r3, [r2, #4]

    /* restart PLL Lock detection */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_RESLD_Msk;
 8022006:	4a31      	ldr	r2, [pc, #196]	; (80220cc <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 8022008:	4b30      	ldr	r3, [pc, #192]	; (80220cc <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 802200a:	685b      	ldr	r3, [r3, #4]
 802200c:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8022010:	6053      	str	r3, [r2, #4]
    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOLOCK_Msk) == 0U)
 8022012:	bf00      	nop
 8022014:	4b2d      	ldr	r3, [pc, #180]	; (80220cc <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 8022016:	681b      	ldr	r3, [r3, #0]
 8022018:	f003 0304 	and.w	r3, r3, #4
 802201c:	2b00      	cmp	r3, #0
 802201e:	d0f9      	beq.n	8022014 <XMC_SCU_CLOCK_StartSystemPll+0xd0>
    {
      /* wait for PLL Lock */
    }

    /* Switch to normal mode */
    SCU_PLL->PLLCON0 &= (uint32_t)~SCU_PLL_PLLCON0_VCOBYP_Msk;
 8022020:	4a2a      	ldr	r2, [pc, #168]	; (80220cc <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 8022022:	4b2a      	ldr	r3, [pc, #168]	; (80220cc <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 8022024:	685b      	ldr	r3, [r3, #4]
 8022026:	f023 0301 	bic.w	r3, r3, #1
 802202a:	6053      	str	r3, [r2, #4]
    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOBYST_Msk) != 0U)
 802202c:	bf00      	nop
 802202e:	4b27      	ldr	r3, [pc, #156]	; (80220cc <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 8022030:	681b      	ldr	r3, [r3, #0]
 8022032:	f003 0301 	and.w	r3, r3, #1
 8022036:	2b00      	cmp	r3, #0
 8022038:	d1f9      	bne.n	802202e <XMC_SCU_CLOCK_StartSystemPll+0xea>
    {
      /* wait for normal mode */
    }

    /* Ramp up PLL frequency in steps */
    kdiv_temp = (vco_frequency / 60UL) >> 22;
 802203a:	697b      	ldr	r3, [r7, #20]
 802203c:	4a25      	ldr	r2, [pc, #148]	; (80220d4 <XMC_SCU_CLOCK_StartSystemPll+0x190>)
 802203e:	fba2 2303 	umull	r2, r3, r2, r3
 8022042:	095b      	lsrs	r3, r3, #5
 8022044:	0d9b      	lsrs	r3, r3, #22
 8022046:	613b      	str	r3, [r7, #16]
    if (kdiv < kdiv_temp)
 8022048:	6a3a      	ldr	r2, [r7, #32]
 802204a:	693b      	ldr	r3, [r7, #16]
 802204c:	429a      	cmp	r2, r3
 802204e:	d202      	bcs.n	8022056 <XMC_SCU_CLOCK_StartSystemPll+0x112>
    {
      XMC_SCU_CLOCK_StepSystemPllFrequency(kdiv_temp);
 8022050:	6938      	ldr	r0, [r7, #16]
 8022052:	f000 f845 	bl	80220e0 <XMC_SCU_CLOCK_StepSystemPllFrequency>
    }

    kdiv_temp = (vco_frequency / 90UL) >> 22;
 8022056:	697b      	ldr	r3, [r7, #20]
 8022058:	085b      	lsrs	r3, r3, #1
 802205a:	4a1f      	ldr	r2, [pc, #124]	; (80220d8 <XMC_SCU_CLOCK_StartSystemPll+0x194>)
 802205c:	fba2 2303 	umull	r2, r3, r2, r3
 8022060:	095b      	lsrs	r3, r3, #5
 8022062:	0d9b      	lsrs	r3, r3, #22
 8022064:	613b      	str	r3, [r7, #16]
    if (kdiv < kdiv_temp)
 8022066:	6a3a      	ldr	r2, [r7, #32]
 8022068:	693b      	ldr	r3, [r7, #16]
 802206a:	429a      	cmp	r2, r3
 802206c:	d202      	bcs.n	8022074 <XMC_SCU_CLOCK_StartSystemPll+0x130>
    {
      XMC_SCU_CLOCK_StepSystemPllFrequency(kdiv_temp);
 802206e:	6938      	ldr	r0, [r7, #16]
 8022070:	f000 f836 	bl	80220e0 <XMC_SCU_CLOCK_StepSystemPllFrequency>
    }

    XMC_SCU_CLOCK_StepSystemPllFrequency(kdiv);
 8022074:	6a38      	ldr	r0, [r7, #32]
 8022076:	f000 f833 	bl	80220e0 <XMC_SCU_CLOCK_StepSystemPllFrequency>
 802207a:	e01c      	b.n	80220b6 <XMC_SCU_CLOCK_StartSystemPll+0x172>
  }
  else
  {
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K1DIV_Msk) |
 802207c:	4913      	ldr	r1, [pc, #76]	; (80220cc <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 802207e:	4b13      	ldr	r3, [pc, #76]	; (80220cc <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 8022080:	689b      	ldr	r3, [r3, #8]
 8022082:	f023 027f 	bic.w	r2, r3, #127	; 0x7f
                                  ((kdiv - 1UL) << SCU_PLL_PLLCON1_K1DIV_Pos));
 8022086:	6a3b      	ldr	r3, [r7, #32]
 8022088:	3b01      	subs	r3, #1

    XMC_SCU_CLOCK_StepSystemPllFrequency(kdiv);
  }
  else
  {
    SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K1DIV_Msk) |
 802208a:	4313      	orrs	r3, r2
 802208c:	608b      	str	r3, [r1, #8]
                                  ((kdiv - 1UL) << SCU_PLL_PLLCON1_K1DIV_Pos));

    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_K1RDY_Msk) == 0U)
 802208e:	bf00      	nop
 8022090:	4b0e      	ldr	r3, [pc, #56]	; (80220cc <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 8022092:	681b      	ldr	r3, [r3, #0]
 8022094:	f003 0310 	and.w	r3, r3, #16
 8022098:	2b00      	cmp	r3, #0
 802209a:	d0f9      	beq.n	8022090 <XMC_SCU_CLOCK_StartSystemPll+0x14c>
    {
      /* wait until K1-divider operates on the configured value  */
    }

    /* Switch to prescaler mode */
    SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_VCOBYP_Msk;
 802209c:	4a0b      	ldr	r2, [pc, #44]	; (80220cc <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 802209e:	4b0b      	ldr	r3, [pc, #44]	; (80220cc <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 80220a0:	685b      	ldr	r3, [r3, #4]
 80220a2:	f043 0301 	orr.w	r3, r3, #1
 80220a6:	6053      	str	r3, [r2, #4]

    while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_VCOBYST_Msk) == 0U)
 80220a8:	bf00      	nop
 80220aa:	4b08      	ldr	r3, [pc, #32]	; (80220cc <XMC_SCU_CLOCK_StartSystemPll+0x188>)
 80220ac:	681b      	ldr	r3, [r3, #0]
 80220ae:	f003 0301 	and.w	r3, r3, #1
 80220b2:	2b00      	cmp	r3, #0
 80220b4:	d0f9      	beq.n	80220aa <XMC_SCU_CLOCK_StartSystemPll+0x166>
    {
      /* wait for prescaler mode */
    }
  }

  SCU_TRAP->TRAPCLR = SCU_TRAP_TRAPCLR_SOSCWDGT_Msk | SCU_TRAP_TRAPCLR_SVCOLCKT_Msk;
 80220b6:	4b09      	ldr	r3, [pc, #36]	; (80220dc <XMC_SCU_CLOCK_StartSystemPll+0x198>)
 80220b8:	2205      	movs	r2, #5
 80220ba:	60da      	str	r2, [r3, #12]
}
 80220bc:	3718      	adds	r7, #24
 80220be:	46bd      	mov	sp, r7
 80220c0:	bd80      	pop	{r7, pc}
 80220c2:	bf00      	nop
 80220c4:	431bde83 	.word	0x431bde83
 80220c8:	aaaaaaab 	.word	0xaaaaaaab
 80220cc:	50004710 	.word	0x50004710
 80220d0:	f08080ff 	.word	0xf08080ff
 80220d4:	88888889 	.word	0x88888889
 80220d8:	b60b60b7 	.word	0xb60b60b7
 80220dc:	50004160 	.word	0x50004160

080220e0 <XMC_SCU_CLOCK_StepSystemPllFrequency>:
  SCU_PLL->PLLCON0 |= (uint32_t)SCU_PLL_PLLCON0_PLLPWD_Msk;
}

/* API to step up/down the main PLL frequency */
void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
{
 80220e0:	b580      	push	{r7, lr}
 80220e2:	b082      	sub	sp, #8
 80220e4:	af00      	add	r7, sp, #0
 80220e6:	6078      	str	r0, [r7, #4]
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 80220e8:	490b      	ldr	r1, [pc, #44]	; (8022118 <XMC_SCU_CLOCK_StepSystemPllFrequency+0x38>)
 80220ea:	4b0b      	ldr	r3, [pc, #44]	; (8022118 <XMC_SCU_CLOCK_StepSystemPllFrequency+0x38>)
 80220ec:	689b      	ldr	r3, [r3, #8]
 80220ee:	f423 02fe 	bic.w	r2, r3, #8323072	; 0x7f0000
                                ((kdiv - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos));
 80220f2:	687b      	ldr	r3, [r7, #4]
 80220f4:	3b01      	subs	r3, #1
 80220f6:	041b      	lsls	r3, r3, #16
}

/* API to step up/down the main PLL frequency */
void XMC_SCU_CLOCK_StepSystemPllFrequency(uint32_t kdiv)
{
  SCU_PLL->PLLCON1 = (uint32_t)((SCU_PLL->PLLCON1 & ~SCU_PLL_PLLCON1_K2DIV_Msk) |
 80220f8:	4313      	orrs	r3, r2
 80220fa:	608b      	str	r3, [r1, #8]
                                ((kdiv - 1UL) << SCU_PLL_PLLCON1_K2DIV_Pos));

  while ((SCU_PLL->PLLSTAT & SCU_PLL_PLLSTAT_K2RDY_Msk) == 0U)
 80220fc:	bf00      	nop
 80220fe:	4b06      	ldr	r3, [pc, #24]	; (8022118 <XMC_SCU_CLOCK_StepSystemPllFrequency+0x38>)
 8022100:	681b      	ldr	r3, [r3, #0]
 8022102:	f003 0320 	and.w	r3, r3, #32
 8022106:	2b00      	cmp	r3, #0
 8022108:	d0f9      	beq.n	80220fe <XMC_SCU_CLOCK_StepSystemPllFrequency+0x1e>
  {
    /* wait until K2-divider operates on the configured value  */
  }

  XMC_SCU_lDelay(50U);
 802210a:	2032      	movs	r0, #50	; 0x32
 802210c:	f7ff fb3c 	bl	8021788 <XMC_SCU_lDelay>
}
 8022110:	3708      	adds	r7, #8
 8022112:	46bd      	mov	sp, r7
 8022114:	bd80      	pop	{r7, pc}
 8022116:	bf00      	nop
 8022118:	50004710 	.word	0x50004710

0802211c <XMC_CCU4_StartPrescaler>:
 * \par<b>Related APIs:</b><br>
 * XMC_CCU4_Init()<BR> XMC_CCU4_EnableClock()<BR> XMC_CCU4_DisableClock()<BR> XMC_CCU4_StartPrescaler()<BR>
 * XMC_CCU4_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU4_StartPrescaler(XMC_CCU4_MODULE_t *const module)
{
 802211c:	b480      	push	{r7}
 802211e:	b083      	sub	sp, #12
 8022120:	af00      	add	r7, sp, #0
 8022122:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_StartPrescaler:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  module->GIDLC = (uint32_t) CCU4_GIDLC_SPRB_Msk;
 8022124:	687b      	ldr	r3, [r7, #4]
 8022126:	f44f 7280 	mov.w	r2, #256	; 0x100
 802212a:	60da      	str	r2, [r3, #12]
}
 802212c:	370c      	adds	r7, #12
 802212e:	46bd      	mov	sp, r7
 8022130:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022134:	4770      	bx	lr
 8022136:	bf00      	nop

08022138 <XMC_CCU4_lDeassertReset>:
    XMC_ASSERT("XMC_CCU4_lAssertReset:Invalid Module Pointer", 0);
  }
}

__STATIC_INLINE void XMC_CCU4_lDeassertReset(const XMC_CCU4_MODULE_t *const module)
{
 8022138:	b580      	push	{r7, lr}
 802213a:	b082      	sub	sp, #8
 802213c:	af00      	add	r7, sp, #0
 802213e:	6078      	str	r0, [r7, #4]
  if (module == CCU40)
 8022140:	687b      	ldr	r3, [r7, #4]
 8022142:	4a08      	ldr	r2, [pc, #32]	; (8022164 <XMC_CCU4_lDeassertReset+0x2c>)
 8022144:	4293      	cmp	r3, r2
 8022146:	d103      	bne.n	8022150 <XMC_CCU4_lDeassertReset+0x18>
  {
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU40);
 8022148:	2004      	movs	r0, #4
 802214a:	f7ff fbd5 	bl	80218f8 <XMC_SCU_RESET_DeassertPeripheralReset>
 802214e:	e006      	b.n	802215e <XMC_CCU4_lDeassertReset+0x26>
  }
#if defined(CCU41)
  else if (module == CCU41)
 8022150:	687b      	ldr	r3, [r7, #4]
 8022152:	4a05      	ldr	r2, [pc, #20]	; (8022168 <XMC_CCU4_lDeassertReset+0x30>)
 8022154:	4293      	cmp	r3, r2
 8022156:	d102      	bne.n	802215e <XMC_CCU4_lDeassertReset+0x26>
  {
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_CCU41);
 8022158:	2008      	movs	r0, #8
 802215a:	f7ff fbcd 	bl	80218f8 <XMC_SCU_RESET_DeassertPeripheralReset>
#endif
  else
  {
    XMC_ASSERT("XMC_CCU4_lDeassertReset:Invalid Module Pointer", 0);
  }
}
 802215e:	3708      	adds	r7, #8
 8022160:	46bd      	mov	sp, r7
 8022162:	bd80      	pop	{r7, pc}
 8022164:	4000c000 	.word	0x4000c000
 8022168:	40010000 	.word	0x40010000

0802216c <XMC_CCU4_lUngateClock>:
    XMC_ASSERT("XMC_CCU4_lGateClock:Invalid Module Pointer", 0);
  }
}

__STATIC_INLINE void XMC_CCU4_lUngateClock(const XMC_CCU4_MODULE_t *const module)
{
 802216c:	b580      	push	{r7, lr}
 802216e:	b082      	sub	sp, #8
 8022170:	af00      	add	r7, sp, #0
 8022172:	6078      	str	r0, [r7, #4]
  if (module == CCU40)
 8022174:	687b      	ldr	r3, [r7, #4]
 8022176:	4a08      	ldr	r2, [pc, #32]	; (8022198 <XMC_CCU4_lUngateClock+0x2c>)
 8022178:	4293      	cmp	r3, r2
 802217a:	d103      	bne.n	8022184 <XMC_CCU4_lUngateClock+0x18>
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU40);
 802217c:	2004      	movs	r0, #4
 802217e:	f7ff fd3f 	bl	8021c00 <XMC_SCU_CLOCK_UngatePeripheralClock>
 8022182:	e006      	b.n	8022192 <XMC_CCU4_lUngateClock+0x26>
  }
#if defined(CCU41)
  else if (module == CCU41)
 8022184:	687b      	ldr	r3, [r7, #4]
 8022186:	4a05      	ldr	r2, [pc, #20]	; (802219c <XMC_CCU4_lUngateClock+0x30>)
 8022188:	4293      	cmp	r3, r2
 802218a:	d102      	bne.n	8022192 <XMC_CCU4_lUngateClock+0x26>
  {
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_CCU41);
 802218c:	2008      	movs	r0, #8
 802218e:	f7ff fd37 	bl	8021c00 <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif
  else
  {
    XMC_ASSERT("XMC_CCU4_lUngateClock:Invalid Module Pointer", 0);
  }
}
 8022192:	3708      	adds	r7, #8
 8022194:	46bd      	mov	sp, r7
 8022196:	bd80      	pop	{r7, pc}
 8022198:	4000c000 	.word	0x4000c000
 802219c:	40010000 	.word	0x40010000

080221a0 <XMC_CCU4_EnableModule>:
/*********************************************************************************************************************
 * API IMPLEMENTATION
 ********************************************************************************************************************/

void XMC_CCU4_EnableModule(XMC_CCU4_MODULE_t *const module)
{
 80221a0:	b580      	push	{r7, lr}
 80221a2:	b082      	sub	sp, #8
 80221a4:	af00      	add	r7, sp, #0
 80221a6:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_EnableModule:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));

#if UC_FAMILY == XMC4
  /* Enable CCU4 module clock */
  XMC_SCU_CLOCK_EnableClock(XMC_SCU_CLOCK_CCU);
 80221a8:	2010      	movs	r0, #16
 80221aa:	f7ff fd19 	bl	8021be0 <XMC_SCU_CLOCK_EnableClock>
#endif

#if defined(CLOCK_GATING_SUPPORTED)
  XMC_CCU4_lUngateClock(module);
 80221ae:	6878      	ldr	r0, [r7, #4]
 80221b0:	f7ff ffdc 	bl	802216c <XMC_CCU4_lUngateClock>
#endif

#if defined(PERIPHERAL_RESET_SUPPORTED)
  XMC_CCU4_lDeassertReset(module);
 80221b4:	6878      	ldr	r0, [r7, #4]
 80221b6:	f7ff ffbf 	bl	8022138 <XMC_CCU4_lDeassertReset>
#endif
}
 80221ba:	3708      	adds	r7, #8
 80221bc:	46bd      	mov	sp, r7
 80221be:	bd80      	pop	{r7, pc}

080221c0 <XMC_CCU4_Init>:
#endif
}

/* API to initialize CCU4 global resources  */
void XMC_CCU4_Init(XMC_CCU4_MODULE_t *const module, const XMC_CCU4_SLICE_MCMS_ACTION_t mcs_action)
{
 80221c0:	b580      	push	{r7, lr}
 80221c2:	b084      	sub	sp, #16
 80221c4:	af00      	add	r7, sp, #0
 80221c6:	6078      	str	r0, [r7, #4]
 80221c8:	460b      	mov	r3, r1
 80221ca:	70fb      	strb	r3, [r7, #3]

  XMC_ASSERT("XMC_CCU4_Init:Invalid module pointer", XMC_CCU4_IsValidModule(module));
  XMC_ASSERT("XMC_CCU4_Init:Invalid mcs action", XMC_CCU4_SLICE_CHECK_MCS_ACTION(mcs_action));

  /* Enable CCU4 module */
  XMC_CCU4_EnableModule(module);
 80221cc:	6878      	ldr	r0, [r7, #4]
 80221ce:	f7ff ffe7 	bl	80221a0 <XMC_CCU4_EnableModule>
  /* Start the prescaler */
  XMC_CCU4_StartPrescaler(module);
 80221d2:	6878      	ldr	r0, [r7, #4]
 80221d4:	f7ff ffa2 	bl	802211c <XMC_CCU4_StartPrescaler>

  gctrl = module->GCTRL;
 80221d8:	687b      	ldr	r3, [r7, #4]
 80221da:	681b      	ldr	r3, [r3, #0]
 80221dc:	60fb      	str	r3, [r7, #12]
  gctrl &= ~((uint32_t) CCU4_GCTRL_MSDE_Msk);
 80221de:	68fb      	ldr	r3, [r7, #12]
 80221e0:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
 80221e4:	60fb      	str	r3, [r7, #12]
  gctrl |= ((uint32_t) mcs_action) << CCU4_GCTRL_MSDE_Pos;
 80221e6:	78fb      	ldrb	r3, [r7, #3]
 80221e8:	039b      	lsls	r3, r3, #14
 80221ea:	68fa      	ldr	r2, [r7, #12]
 80221ec:	4313      	orrs	r3, r2
 80221ee:	60fb      	str	r3, [r7, #12]

  module->GCTRL = gctrl;
 80221f0:	687b      	ldr	r3, [r7, #4]
 80221f2:	68fa      	ldr	r2, [r7, #12]
 80221f4:	601a      	str	r2, [r3, #0]
}
 80221f6:	3710      	adds	r7, #16
 80221f8:	46bd      	mov	sp, r7
 80221fa:	bd80      	pop	{r7, pc}

080221fc <XMC_CCU4_SLICE_CompareInit>:
}

/* API to configure CC4 Slice as Timer */
void XMC_CCU4_SLICE_CompareInit(XMC_CCU4_SLICE_t *const slice,
                                const XMC_CCU4_SLICE_COMPARE_CONFIG_t *const compare_init)
{
 80221fc:	b480      	push	{r7}
 80221fe:	b083      	sub	sp, #12
 8022200:	af00      	add	r7, sp, #0
 8022202:	6078      	str	r0, [r7, #4]
 8022204:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_CCU4_SLICE_CompareInit:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_CompareInit:Compare Init Pointer is NULL",
             (XMC_CCU4_SLICE_COMPARE_CONFIG_t *) NULL != compare_init);

  /* Program the timer mode */
  slice->TC = compare_init->tc;
 8022206:	683b      	ldr	r3, [r7, #0]
 8022208:	681a      	ldr	r2, [r3, #0]
 802220a:	687b      	ldr	r3, [r7, #4]
 802220c:	615a      	str	r2, [r3, #20]
  /* Enable the timer concatenation */
  slice->CMC = ((uint32_t) compare_init->timer_concatenation << CCU4_CC4_CMC_TCE_Pos);
 802220e:	683b      	ldr	r3, [r7, #0]
 8022210:	795b      	ldrb	r3, [r3, #5]
 8022212:	f3c3 1340 	ubfx	r3, r3, #5, #1
 8022216:	b2db      	uxtb	r3, r3
 8022218:	051a      	lsls	r2, r3, #20
 802221a:	687b      	ldr	r3, [r7, #4]
 802221c:	605a      	str	r2, [r3, #4]
  /* Program initial prescaler divider value */
  slice->PSC = (uint32_t) compare_init->prescaler_initval;
 802221e:	683b      	ldr	r3, [r7, #0]
 8022220:	791b      	ldrb	r3, [r3, #4]
 8022222:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8022226:	b2db      	uxtb	r3, r3
 8022228:	461a      	mov	r2, r3
 802222a:	687b      	ldr	r3, [r7, #4]
 802222c:	625a      	str	r2, [r3, #36]	; 0x24
  /* Program the dither compare value */
  slice->DITS = (uint32_t) compare_init->dither_limit;
 802222e:	683b      	ldr	r3, [r7, #0]
 8022230:	795b      	ldrb	r3, [r3, #5]
 8022232:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8022236:	b2db      	uxtb	r3, r3
 8022238:	461a      	mov	r2, r3
 802223a:	687b      	ldr	r3, [r7, #4]
 802223c:	621a      	str	r2, [r3, #32]
  /* Program timer output passive level */
  slice->PSL = (uint32_t) compare_init->passive_level;
 802223e:	683b      	ldr	r3, [r7, #0]
 8022240:	795b      	ldrb	r3, [r3, #5]
 8022242:	f3c3 1300 	ubfx	r3, r3, #4, #1
 8022246:	b2db      	uxtb	r3, r3
 8022248:	461a      	mov	r2, r3
 802224a:	687b      	ldr	r3, [r7, #4]
 802224c:	619a      	str	r2, [r3, #24]
  /* Program floating prescaler compare value */
  slice->FPCS = (uint32_t) compare_init->float_limit;
 802224e:	683b      	ldr	r3, [r7, #0]
 8022250:	791b      	ldrb	r3, [r3, #4]
 8022252:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8022256:	b2db      	uxtb	r3, r3
 8022258:	461a      	mov	r2, r3
 802225a:	687b      	ldr	r3, [r7, #4]
 802225c:	62da      	str	r2, [r3, #44]	; 0x2c
}
 802225e:	370c      	adds	r7, #12
 8022260:	46bd      	mov	sp, r7
 8022262:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022266:	4770      	bx	lr

08022268 <XMC_CCU4_SLICE_SetInterruptNode>:

/* Binds a capcom event to an NVIC node  */
void XMC_CCU4_SLICE_SetInterruptNode(XMC_CCU4_SLICE_t *const slice,
                                     const XMC_CCU4_SLICE_IRQ_ID_t event,
                                     const XMC_CCU4_SLICE_SR_ID_t sr)
{
 8022268:	b480      	push	{r7}
 802226a:	b087      	sub	sp, #28
 802226c:	af00      	add	r7, sp, #0
 802226e:	6078      	str	r0, [r7, #4]
 8022270:	460b      	mov	r3, r1
 8022272:	70fb      	strb	r3, [r7, #3]
 8022274:	4613      	mov	r3, r2
 8022276:	70bb      	strb	r3, [r7, #2]

  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid SR ID ", XMC_CCU4_SLICE_CHECK_SR_ID(sr));
  XMC_ASSERT("XMC_CCU4_SLICE_SetInterruptNode:Invalid event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));

  switch (event)
 8022278:	78fb      	ldrb	r3, [r7, #3]
 802227a:	2b0b      	cmp	r3, #11
 802227c:	d836      	bhi.n	80222ec <XMC_CCU4_SLICE_SetInterruptNode+0x84>
 802227e:	a201      	add	r2, pc, #4	; (adr r2, 8022284 <XMC_CCU4_SLICE_SetInterruptNode+0x1c>)
 8022280:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8022284:	080222b5 	.word	0x080222b5
 8022288:	080222b5 	.word	0x080222b5
 802228c:	080222bf 	.word	0x080222bf
 8022290:	080222bf 	.word	0x080222bf
 8022294:	080222ed 	.word	0x080222ed
 8022298:	080222ed 	.word	0x080222ed
 802229c:	080222ed 	.word	0x080222ed
 80222a0:	080222ed 	.word	0x080222ed
 80222a4:	080222c9 	.word	0x080222c9
 80222a8:	080222d5 	.word	0x080222d5
 80222ac:	080222e1 	.word	0x080222e1
 80222b0:	080222e1 	.word	0x080222e1
  {
    case XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH:
    case XMC_CCU4_SLICE_IRQ_ID_ONE_MATCH:
      mask = ((uint32_t) CCU4_CC4_SRS_POSR_Msk);
 80222b4:	2303      	movs	r3, #3
 80222b6:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_POSR_Pos;
 80222b8:	2300      	movs	r3, #0
 80222ba:	617b      	str	r3, [r7, #20]
      break;
 80222bc:	e01b      	b.n	80222f6 <XMC_CCU4_SLICE_SetInterruptNode+0x8e>

    case XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_UP:
    case XMC_CCU4_SLICE_IRQ_ID_COMPARE_MATCH_DOWN:
      mask = ((uint32_t) CCU4_CC4_SRS_CMSR_Msk);
 80222be:	230c      	movs	r3, #12
 80222c0:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_CMSR_Pos;
 80222c2:	2302      	movs	r3, #2
 80222c4:	617b      	str	r3, [r7, #20]
      break;
 80222c6:	e016      	b.n	80222f6 <XMC_CCU4_SLICE_SetInterruptNode+0x8e>

    case XMC_CCU4_SLICE_IRQ_ID_EVENT0:
      mask = ((uint32_t) CCU4_CC4_SRS_E0SR_Msk);
 80222c8:	f44f 7340 	mov.w	r3, #768	; 0x300
 80222cc:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_E0SR_Pos;
 80222ce:	2308      	movs	r3, #8
 80222d0:	617b      	str	r3, [r7, #20]
      break;
 80222d2:	e010      	b.n	80222f6 <XMC_CCU4_SLICE_SetInterruptNode+0x8e>

    case XMC_CCU4_SLICE_IRQ_ID_EVENT1:
      mask = ((uint32_t) CCU4_CC4_SRS_E1SR_Msk);
 80222d4:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 80222d8:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_E1SR_Pos;
 80222da:	230a      	movs	r3, #10
 80222dc:	617b      	str	r3, [r7, #20]
      break;
 80222de:	e00a      	b.n	80222f6 <XMC_CCU4_SLICE_SetInterruptNode+0x8e>

    case XMC_CCU4_SLICE_IRQ_ID_EVENT2:
    case XMC_CCU4_SLICE_IRQ_ID_TRAP:
      mask = ((uint32_t) CCU4_CC4_SRS_E2SR_Msk);
 80222e0:	f44f 5340 	mov.w	r3, #12288	; 0x3000
 80222e4:	613b      	str	r3, [r7, #16]
      pos  = CCU4_CC4_SRS_E2SR_Pos;
 80222e6:	230c      	movs	r3, #12
 80222e8:	617b      	str	r3, [r7, #20]
      break;
 80222ea:	e004      	b.n	80222f6 <XMC_CCU4_SLICE_SetInterruptNode+0x8e>
	  
	default:
	  mask = 0;
 80222ec:	2300      	movs	r3, #0
 80222ee:	613b      	str	r3, [r7, #16]
	  pos = 0;
 80222f0:	2300      	movs	r3, #0
 80222f2:	617b      	str	r3, [r7, #20]
	  break;
 80222f4:	bf00      	nop
  }

  if (mask != 0)
 80222f6:	693b      	ldr	r3, [r7, #16]
 80222f8:	2b00      	cmp	r3, #0
 80222fa:	d013      	beq.n	8022324 <XMC_CCU4_SLICE_SetInterruptNode+0xbc>
  {
    srs = slice->SRS;
 80222fc:	687b      	ldr	r3, [r7, #4]
 80222fe:	f8d3 30a8 	ldr.w	r3, [r3, #168]	; 0xa8
 8022302:	60fb      	str	r3, [r7, #12]
    srs &= ~mask;
 8022304:	693b      	ldr	r3, [r7, #16]
 8022306:	43db      	mvns	r3, r3
 8022308:	68fa      	ldr	r2, [r7, #12]
 802230a:	4013      	ands	r3, r2
 802230c:	60fb      	str	r3, [r7, #12]
    srs |= (uint32_t)sr << pos;
 802230e:	78ba      	ldrb	r2, [r7, #2]
 8022310:	697b      	ldr	r3, [r7, #20]
 8022312:	fa02 f303 	lsl.w	r3, r2, r3
 8022316:	68fa      	ldr	r2, [r7, #12]
 8022318:	4313      	orrs	r3, r2
 802231a:	60fb      	str	r3, [r7, #12]
    slice->SRS = srs;
 802231c:	687b      	ldr	r3, [r7, #4]
 802231e:	68fa      	ldr	r2, [r7, #12]
 8022320:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
  }
}
 8022324:	371c      	adds	r7, #28
 8022326:	46bd      	mov	sp, r7
 8022328:	f85d 7b04 	ldr.w	r7, [sp], #4
 802232c:	4770      	bx	lr
 802232e:	bf00      	nop

08022330 <XMC_DMA_GetEventStatus>:
 * Source transaction complete -> ::XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE      <br>
 * Destination transaction complete -> ::XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE <br>
 * DMA error event -> ::XMC_DMA_CH_EVENT_ERROR                                     <br>
 */
__STATIC_INLINE uint32_t XMC_DMA_GetEventStatus(XMC_DMA_t *const dma)
{
 8022330:	b480      	push	{r7}
 8022332:	b083      	sub	sp, #12
 8022334:	af00      	add	r7, sp, #0
 8022336:	6078      	str	r0, [r7, #4]
  return (dma->STATUSGLEV);
 8022338:	687b      	ldr	r3, [r7, #4]
 802233a:	f8d3 3360 	ldr.w	r3, [r3, #864]	; 0x360
}
 802233e:	4618      	mov	r0, r3
 8022340:	370c      	adds	r7, #12
 8022342:	46bd      	mov	sp, r7
 8022344:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022348:	4770      	bx	lr
 802234a:	bf00      	nop

0802234c <XMC_DMA_GetChannelsTransferCompleteStatus>:
 *
 * \par
 * The function returns GPDMA transfer complete interrupt status. <br>
 */
__STATIC_INLINE uint32_t XMC_DMA_GetChannelsTransferCompleteStatus(XMC_DMA_t *const dma)
{
 802234c:	b480      	push	{r7}
 802234e:	b083      	sub	sp, #12
 8022350:	af00      	add	r7, sp, #0
 8022352:	6078      	str	r0, [r7, #4]
  return (dma->STATUSCHEV[0]);
 8022354:	687b      	ldr	r3, [r7, #4]
 8022356:	f8d3 32e8 	ldr.w	r3, [r3, #744]	; 0x2e8
}
 802235a:	4618      	mov	r0, r3
 802235c:	370c      	adds	r7, #12
 802235e:	46bd      	mov	sp, r7
 8022360:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022364:	4770      	bx	lr
 8022366:	bf00      	nop

08022368 <XMC_DMA_GetChannelsBlockCompleteStatus>:
 *
 * \par
 * The function returns GPDMA block transfer complete interrupt status. <br>
 */
__STATIC_INLINE uint32_t XMC_DMA_GetChannelsBlockCompleteStatus(XMC_DMA_t *const dma)
{
 8022368:	b480      	push	{r7}
 802236a:	b083      	sub	sp, #12
 802236c:	af00      	add	r7, sp, #0
 802236e:	6078      	str	r0, [r7, #4]
  return (dma->STATUSCHEV[2]);
 8022370:	687b      	ldr	r3, [r7, #4]
 8022372:	f8d3 32f0 	ldr.w	r3, [r3, #752]	; 0x2f0
}
 8022376:	4618      	mov	r0, r3
 8022378:	370c      	adds	r7, #12
 802237a:	46bd      	mov	sp, r7
 802237c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022380:	4770      	bx	lr
 8022382:	bf00      	nop

08022384 <XMC_DMA_GetChannelsSourceTransactionCompleteStatus>:
 * \par<b>Note: </b><br>
 * If the source peripheral is memory, the source transaction complete interrupt is
 * ignored.
 */
__STATIC_INLINE uint32_t XMC_DMA_GetChannelsSourceTransactionCompleteStatus(XMC_DMA_t *const dma)
{
 8022384:	b480      	push	{r7}
 8022386:	b083      	sub	sp, #12
 8022388:	af00      	add	r7, sp, #0
 802238a:	6078      	str	r0, [r7, #4]
  return (dma->STATUSCHEV[4]);
 802238c:	687b      	ldr	r3, [r7, #4]
 802238e:	f8d3 32f8 	ldr.w	r3, [r3, #760]	; 0x2f8
}
 8022392:	4618      	mov	r0, r3
 8022394:	370c      	adds	r7, #12
 8022396:	46bd      	mov	sp, r7
 8022398:	f85d 7b04 	ldr.w	r7, [sp], #4
 802239c:	4770      	bx	lr
 802239e:	bf00      	nop

080223a0 <XMC_DMA_GetChannelsDestinationTransactionCompleteStatus>:
 * \par<b>Note: </b><br>
 * If the destination peripheral is memory, the destination transaction complete
 * interrupt is ignored.
 */
__STATIC_INLINE uint32_t XMC_DMA_GetChannelsDestinationTransactionCompleteStatus(XMC_DMA_t *const dma)
{
 80223a0:	b480      	push	{r7}
 80223a2:	b083      	sub	sp, #12
 80223a4:	af00      	add	r7, sp, #0
 80223a6:	6078      	str	r0, [r7, #4]
  return (dma->STATUSCHEV[6]);
 80223a8:	687b      	ldr	r3, [r7, #4]
 80223aa:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
}
 80223ae:	4618      	mov	r0, r3
 80223b0:	370c      	adds	r7, #12
 80223b2:	46bd      	mov	sp, r7
 80223b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80223b8:	4770      	bx	lr
 80223ba:	bf00      	nop

080223bc <XMC_DMA_GetChannelsErrorStatus>:
 *
 * \par
 * The function returns error interrupt status. <br>
 */
__STATIC_INLINE uint32_t XMC_DMA_GetChannelsErrorStatus(XMC_DMA_t *const dma)
{
 80223bc:	b480      	push	{r7}
 80223be:	b083      	sub	sp, #12
 80223c0:	af00      	add	r7, sp, #0
 80223c2:	6078      	str	r0, [r7, #4]
  return (dma->STATUSCHEV[8]);
 80223c4:	687b      	ldr	r3, [r7, #4]
 80223c6:	f8d3 3308 	ldr.w	r3, [r3, #776]	; 0x308
}
 80223ca:	4618      	mov	r0, r3
 80223cc:	370c      	adds	r7, #12
 80223ce:	46bd      	mov	sp, r7
 80223d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80223d4:	4770      	bx	lr
 80223d6:	bf00      	nop

080223d8 <XMC_DMA_Init>:
 * API IMPLEMENTATION
 *******************************************************************************/

/* Initialize GPDMA */
void XMC_DMA_Init(XMC_DMA_t *const dma)
{
 80223d8:	b580      	push	{r7, lr}
 80223da:	b082      	sub	sp, #8
 80223dc:	af00      	add	r7, sp, #0
 80223de:	6078      	str	r0, [r7, #4]
  XMC_DMA_Enable(dma);
 80223e0:	6878      	ldr	r0, [r7, #4]
 80223e2:	f000 f803 	bl	80223ec <XMC_DMA_Enable>
}
 80223e6:	3708      	adds	r7, #8
 80223e8:	46bd      	mov	sp, r7
 80223ea:	bd80      	pop	{r7, pc}

080223ec <XMC_DMA_Enable>:

/* Enable GPDMA module */
void XMC_DMA_Enable(XMC_DMA_t *const dma)
{
 80223ec:	b580      	push	{r7, lr}
 80223ee:	b082      	sub	sp, #8
 80223f0:	af00      	add	r7, sp, #0
 80223f2:	6078      	str	r0, [r7, #4]
#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_GPDMA0);
 80223f4:	4806      	ldr	r0, [pc, #24]	; (8022410 <XMC_DMA_Enable+0x24>)
 80223f6:	f7ff fc03 	bl	8021c00 <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_GPDMA0);
 80223fa:	4805      	ldr	r0, [pc, #20]	; (8022410 <XMC_DMA_Enable+0x24>)
 80223fc:	f7ff fa7c 	bl	80218f8 <XMC_SCU_RESET_DeassertPeripheralReset>
#endif
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_GPDMA1);
  }
#endif

  dma->DMACFGREG = 0x1U;
 8022400:	687b      	ldr	r3, [r7, #4]
 8022402:	2201      	movs	r2, #1
 8022404:	f8c3 2398 	str.w	r2, [r3, #920]	; 0x398
}
 8022408:	3708      	adds	r7, #8
 802240a:	46bd      	mov	sp, r7
 802240c:	bd80      	pop	{r7, pc}
 802240e:	bf00      	nop
 8022410:	20000010 	.word	0x20000010

08022414 <XMC_DMA_IsEnabled>:
#endif
}

/* Check is the GPDMA peripheral is enabled */
bool XMC_DMA_IsEnabled(const XMC_DMA_t *const dma)
{
 8022414:	b580      	push	{r7, lr}
 8022416:	b084      	sub	sp, #16
 8022418:	af00      	add	r7, sp, #0
 802241a:	6078      	str	r0, [r7, #4]

#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    status = !XMC_SCU_RESET_IsPeripheralResetAsserted(XMC_SCU_PERIPHERAL_RESET_GPDMA0);
 802241c:	481e      	ldr	r0, [pc, #120]	; (8022498 <XMC_DMA_IsEnabled+0x84>)
 802241e:	f7ff fa87 	bl	8021930 <XMC_SCU_RESET_IsPeripheralResetAsserted>
 8022422:	4603      	mov	r3, r0
 8022424:	2b00      	cmp	r3, #0
 8022426:	bf14      	ite	ne
 8022428:	2301      	movne	r3, #1
 802242a:	2300      	moveq	r3, #0
 802242c:	b2db      	uxtb	r3, r3
 802242e:	f083 0301 	eor.w	r3, r3, #1
 8022432:	b2db      	uxtb	r3, r3
 8022434:	73fb      	strb	r3, [r7, #15]
 8022436:	7bfb      	ldrb	r3, [r7, #15]
 8022438:	f003 0301 	and.w	r3, r3, #1
 802243c:	73fb      	strb	r3, [r7, #15]
#if defined(CLOCK_GATING_SUPPORTED)
    status = status && !XMC_SCU_CLOCK_IsPeripheralClockGated(XMC_SCU_PERIPHERAL_CLOCK_GPDMA0);
 802243e:	7bfb      	ldrb	r3, [r7, #15]
 8022440:	2b00      	cmp	r3, #0
 8022442:	d00a      	beq.n	802245a <XMC_DMA_IsEnabled+0x46>
 8022444:	4814      	ldr	r0, [pc, #80]	; (8022498 <XMC_DMA_IsEnabled+0x84>)
 8022446:	f7ff fbf7 	bl	8021c38 <XMC_SCU_CLOCK_IsPeripheralClockGated>
 802244a:	4603      	mov	r3, r0
 802244c:	f083 0301 	eor.w	r3, r3, #1
 8022450:	b2db      	uxtb	r3, r3
 8022452:	2b00      	cmp	r3, #0
 8022454:	d001      	beq.n	802245a <XMC_DMA_IsEnabled+0x46>
 8022456:	2301      	movs	r3, #1
 8022458:	e000      	b.n	802245c <XMC_DMA_IsEnabled+0x48>
 802245a:	2300      	movs	r3, #0
 802245c:	73fb      	strb	r3, [r7, #15]
 802245e:	7bfb      	ldrb	r3, [r7, #15]
 8022460:	f003 0301 	and.w	r3, r3, #1
 8022464:	73fb      	strb	r3, [r7, #15]
#endif
  }
#endif

  /* DMA reset is not asserted and peripheral clock is not gated */
  if (status == true)
 8022466:	7bfb      	ldrb	r3, [r7, #15]
 8022468:	2b00      	cmp	r3, #0
 802246a:	d00f      	beq.n	802248c <XMC_DMA_IsEnabled+0x78>
  {
    status = status && (dma->DMACFGREG != 0U);
 802246c:	7bfb      	ldrb	r3, [r7, #15]
 802246e:	2b00      	cmp	r3, #0
 8022470:	d006      	beq.n	8022480 <XMC_DMA_IsEnabled+0x6c>
 8022472:	687b      	ldr	r3, [r7, #4]
 8022474:	f8d3 3398 	ldr.w	r3, [r3, #920]	; 0x398
 8022478:	2b00      	cmp	r3, #0
 802247a:	d001      	beq.n	8022480 <XMC_DMA_IsEnabled+0x6c>
 802247c:	2301      	movs	r3, #1
 802247e:	e000      	b.n	8022482 <XMC_DMA_IsEnabled+0x6e>
 8022480:	2300      	movs	r3, #0
 8022482:	73fb      	strb	r3, [r7, #15]
 8022484:	7bfb      	ldrb	r3, [r7, #15]
 8022486:	f003 0301 	and.w	r3, r3, #1
 802248a:	73fb      	strb	r3, [r7, #15]
  }

  return status;
 802248c:	7bfb      	ldrb	r3, [r7, #15]
}
 802248e:	4618      	mov	r0, r3
 8022490:	3710      	adds	r7, #16
 8022492:	46bd      	mov	sp, r7
 8022494:	bd80      	pop	{r7, pc}
 8022496:	bf00      	nop
 8022498:	20000010 	.word	0x20000010

0802249c <XMC_DMA_EnableRequestLine>:

/* Enable request line */
void XMC_DMA_EnableRequestLine(XMC_DMA_t *const dma, uint8_t line, uint8_t peripheral)
{
 802249c:	b480      	push	{r7}
 802249e:	b083      	sub	sp, #12
 80224a0:	af00      	add	r7, sp, #0
 80224a2:	6078      	str	r0, [r7, #4]
 80224a4:	460b      	mov	r3, r1
 80224a6:	70fb      	strb	r3, [r7, #3]
 80224a8:	4613      	mov	r3, r2
 80224aa:	70bb      	strb	r3, [r7, #2]
  if (dma == XMC_DMA0)
  {
#else
  XMC_UNUSED_ARG(dma);
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 80224ac:	480f      	ldr	r0, [pc, #60]	; (80224ec <XMC_DMA_EnableRequestLine+0x50>)
 80224ae:	4b0f      	ldr	r3, [pc, #60]	; (80224ec <XMC_DMA_EnableRequestLine+0x50>)
 80224b0:	689a      	ldr	r2, [r3, #8]
 80224b2:	78fb      	ldrb	r3, [r7, #3]
 80224b4:	009b      	lsls	r3, r3, #2
 80224b6:	4619      	mov	r1, r3
 80224b8:	230f      	movs	r3, #15
 80224ba:	408b      	lsls	r3, r1
 80224bc:	43db      	mvns	r3, r3
 80224be:	401a      	ands	r2, r3
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
 80224c0:	78bb      	ldrb	r3, [r7, #2]
 80224c2:	78f9      	ldrb	r1, [r7, #3]
 80224c4:	0089      	lsls	r1, r1, #2
 80224c6:	408b      	lsls	r3, r1
  if (dma == XMC_DMA0)
  {
#else
  XMC_UNUSED_ARG(dma);
#endif
    DLR->SRSEL0 = ((DLR->SRSEL0 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
 80224c8:	4313      	orrs	r3, r2
 80224ca:	6083      	str	r3, [r0, #8]
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
    DLR->LNEN |= (0x1UL << (line & GPDMA0_CH_CFGH_PER_Msk));
 80224cc:	4907      	ldr	r1, [pc, #28]	; (80224ec <XMC_DMA_EnableRequestLine+0x50>)
 80224ce:	4b07      	ldr	r3, [pc, #28]	; (80224ec <XMC_DMA_EnableRequestLine+0x50>)
 80224d0:	691a      	ldr	r2, [r3, #16]
 80224d2:	78fb      	ldrb	r3, [r7, #3]
 80224d4:	f003 0307 	and.w	r3, r3, #7
 80224d8:	2001      	movs	r0, #1
 80224da:	fa00 f303 	lsl.w	r3, r0, r3
 80224de:	4313      	orrs	r3, r2
 80224e0:	610b      	str	r3, [r1, #16]
    DLR->SRSEL1 = ((DLR->SRSEL1 & (uint32_t)~(DLR_SRSEL_RS_MSK << (line * DLR_SRSEL_RS_BITSIZE))) |
                   ((uint32_t)peripheral << (line * DLR_SRSEL_RS_BITSIZE)));
    DLR->LNEN |= (0x100UL << line);
  }
#endif
}
 80224e2:	370c      	adds	r7, #12
 80224e4:	46bd      	mov	sp, r7
 80224e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80224ea:	4770      	bx	lr
 80224ec:	50004900 	.word	0x50004900

080224f0 <XMC_DMA_CH_IsEnabled>:
  }
}

/* Check if a DMA channel is enabled */
bool XMC_DMA_CH_IsEnabled(XMC_DMA_t *const dma, const uint8_t channel)
{
 80224f0:	b480      	push	{r7}
 80224f2:	b083      	sub	sp, #12
 80224f4:	af00      	add	r7, sp, #0
 80224f6:	6078      	str	r0, [r7, #4]
 80224f8:	460b      	mov	r3, r1
 80224fa:	70fb      	strb	r3, [r7, #3]
  return (bool)(dma->CHENREG & ((uint32_t)1U << channel));
 80224fc:	687b      	ldr	r3, [r7, #4]
 80224fe:	f8d3 23a0 	ldr.w	r2, [r3, #928]	; 0x3a0
 8022502:	78fb      	ldrb	r3, [r7, #3]
 8022504:	fa22 f303 	lsr.w	r3, r2, r3
 8022508:	f003 0301 	and.w	r3, r3, #1
 802250c:	2b00      	cmp	r3, #0
 802250e:	bf14      	ite	ne
 8022510:	2301      	movne	r3, #1
 8022512:	2300      	moveq	r3, #0
 8022514:	b2db      	uxtb	r3, r3
}
 8022516:	4618      	mov	r0, r3
 8022518:	370c      	adds	r7, #12
 802251a:	46bd      	mov	sp, r7
 802251c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022520:	4770      	bx	lr
 8022522:	bf00      	nop

08022524 <XMC_DMA_CH_Init>:

/* Initialize DMA channel */
XMC_DMA_CH_STATUS_t XMC_DMA_CH_Init(XMC_DMA_t *const dma, const uint8_t channel, const XMC_DMA_CH_CONFIG_t *const config)
{
 8022524:	b580      	push	{r7, lr}
 8022526:	b086      	sub	sp, #24
 8022528:	af00      	add	r7, sp, #0
 802252a:	60f8      	str	r0, [r7, #12]
 802252c:	460b      	mov	r3, r1
 802252e:	607a      	str	r2, [r7, #4]
 8022530:	72fb      	strb	r3, [r7, #11]
  XMC_DMA_CH_STATUS_t status;
  uint8_t line;
  uint8_t peripheral;

  if (XMC_DMA_IsEnabled(dma) == true)
 8022532:	68f8      	ldr	r0, [r7, #12]
 8022534:	f7ff ff6e 	bl	8022414 <XMC_DMA_IsEnabled>
 8022538:	4603      	mov	r3, r0
 802253a:	2b00      	cmp	r3, #0
 802253c:	f000 81db 	beq.w	80228f6 <XMC_DMA_CH_Init+0x3d2>
  {
    if (XMC_DMA_CH_IsEnabled(dma, channel) == false)
 8022540:	7afb      	ldrb	r3, [r7, #11]
 8022542:	68f8      	ldr	r0, [r7, #12]
 8022544:	4619      	mov	r1, r3
 8022546:	f7ff ffd3 	bl	80224f0 <XMC_DMA_CH_IsEnabled>
 802254a:	4603      	mov	r3, r0
 802254c:	f083 0301 	eor.w	r3, r3, #1
 8022550:	b2db      	uxtb	r3, r3
 8022552:	2b00      	cmp	r3, #0
 8022554:	f000 81cc 	beq.w	80228f0 <XMC_DMA_CH_Init+0x3cc>
    {
      dma->CH[channel].SAR = config->src_addr;
 8022558:	7afb      	ldrb	r3, [r7, #11]
 802255a:	687a      	ldr	r2, [r7, #4]
 802255c:	6852      	ldr	r2, [r2, #4]
 802255e:	68f9      	ldr	r1, [r7, #12]
 8022560:	2058      	movs	r0, #88	; 0x58
 8022562:	fb00 f303 	mul.w	r3, r0, r3
 8022566:	440b      	add	r3, r1
 8022568:	601a      	str	r2, [r3, #0]
      dma->CH[channel].DAR = config->dst_addr;
 802256a:	7afb      	ldrb	r3, [r7, #11]
 802256c:	687a      	ldr	r2, [r7, #4]
 802256e:	6892      	ldr	r2, [r2, #8]
 8022570:	68f9      	ldr	r1, [r7, #12]
 8022572:	2058      	movs	r0, #88	; 0x58
 8022574:	fb00 f303 	mul.w	r3, r0, r3
 8022578:	440b      	add	r3, r1
 802257a:	3308      	adds	r3, #8
 802257c:	601a      	str	r2, [r3, #0]
      dma->CH[channel].LLP = (uint32_t)config->linked_list_pointer;
 802257e:	7afb      	ldrb	r3, [r7, #11]
 8022580:	687a      	ldr	r2, [r7, #4]
 8022582:	68d2      	ldr	r2, [r2, #12]
 8022584:	4610      	mov	r0, r2
 8022586:	68fa      	ldr	r2, [r7, #12]
 8022588:	2158      	movs	r1, #88	; 0x58
 802258a:	fb01 f303 	mul.w	r3, r1, r3
 802258e:	4413      	add	r3, r2
 8022590:	3310      	adds	r3, #16
 8022592:	6018      	str	r0, [r3, #0]
      dma->CH[channel].CTLH = (uint32_t)config->block_size;
 8022594:	7afb      	ldrb	r3, [r7, #11]
 8022596:	687a      	ldr	r2, [r7, #4]
 8022598:	8b12      	ldrh	r2, [r2, #24]
 802259a:	4610      	mov	r0, r2
 802259c:	68fa      	ldr	r2, [r7, #12]
 802259e:	2158      	movs	r1, #88	; 0x58
 80225a0:	fb01 f303 	mul.w	r3, r1, r3
 80225a4:	4413      	add	r3, r2
 80225a6:	3318      	adds	r3, #24
 80225a8:	6058      	str	r0, [r3, #4]
      dma->CH[channel].CTLL = config->control;
 80225aa:	7afb      	ldrb	r3, [r7, #11]
 80225ac:	687a      	ldr	r2, [r7, #4]
 80225ae:	6812      	ldr	r2, [r2, #0]
 80225b0:	68f9      	ldr	r1, [r7, #12]
 80225b2:	2058      	movs	r0, #88	; 0x58
 80225b4:	fb00 f303 	mul.w	r3, r0, r3
 80225b8:	440b      	add	r3, r1
 80225ba:	3318      	adds	r3, #24
 80225bc:	601a      	str	r2, [r3, #0]

      dma->CH[channel].CFGL = (uint32_t)((uint32_t)config->priority |
 80225be:	7afb      	ldrb	r3, [r7, #11]
 80225c0:	687a      	ldr	r2, [r7, #4]
 80225c2:	7ed2      	ldrb	r2, [r2, #27]
 80225c4:	f442 6240 	orr.w	r2, r2, #3072	; 0xc00
 80225c8:	68f9      	ldr	r1, [r7, #12]
 80225ca:	2058      	movs	r0, #88	; 0x58
 80225cc:	fb00 f303 	mul.w	r3, r0, r3
 80225d0:	440b      	add	r3, r1
 80225d2:	3340      	adds	r3, #64	; 0x40
 80225d4:	601a      	str	r2, [r3, #0]
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_SRC_Msk |
                                         (uint32_t)GPDMA0_CH_CFGL_HS_SEL_DST_Msk);

      if ((dma == XMC_DMA0) && (channel < (uint8_t)2))
 80225d6:	68fb      	ldr	r3, [r7, #12]
 80225d8:	4aa6      	ldr	r2, [pc, #664]	; (8022874 <XMC_DMA_CH_Init+0x350>)
 80225da:	4293      	cmp	r3, r2
 80225dc:	d116      	bne.n	802260c <XMC_DMA_CH_Init+0xe8>
 80225de:	7afb      	ldrb	r3, [r7, #11]
 80225e0:	2b01      	cmp	r3, #1
 80225e2:	d813      	bhi.n	802260c <XMC_DMA_CH_Init+0xe8>
      {
        /* Configure scatter and gather */
        dma->CH[channel].SGR = config->src_gather_control;
 80225e4:	7afb      	ldrb	r3, [r7, #11]
 80225e6:	687a      	ldr	r2, [r7, #4]
 80225e8:	6912      	ldr	r2, [r2, #16]
 80225ea:	68f9      	ldr	r1, [r7, #12]
 80225ec:	2058      	movs	r0, #88	; 0x58
 80225ee:	fb00 f303 	mul.w	r3, r0, r3
 80225f2:	440b      	add	r3, r1
 80225f4:	3348      	adds	r3, #72	; 0x48
 80225f6:	601a      	str	r2, [r3, #0]
        dma->CH[channel].DSR = config->dst_scatter_control;
 80225f8:	7afb      	ldrb	r3, [r7, #11]
 80225fa:	687a      	ldr	r2, [r7, #4]
 80225fc:	6952      	ldr	r2, [r2, #20]
 80225fe:	68f9      	ldr	r1, [r7, #12]
 8022600:	2058      	movs	r0, #88	; 0x58
 8022602:	fb00 f303 	mul.w	r3, r0, r3
 8022606:	440b      	add	r3, r1
 8022608:	3350      	adds	r3, #80	; 0x50
 802260a:	601a      	str	r2, [r3, #0]
      }

      if (config->dst_handshaking == XMC_DMA_CH_DST_HANDSHAKING_HARDWARE)
 802260c:	687b      	ldr	r3, [r7, #4]
 802260e:	8c1b      	ldrh	r3, [r3, #32]
 8022610:	2b00      	cmp	r3, #0
 8022612:	d144      	bne.n	802269e <XMC_DMA_CH_Init+0x17a>
      {
        /* Hardware handshaking interface configuration */
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_M2P_DMA) ||
 8022614:	687b      	ldr	r3, [r7, #4]
 8022616:	789b      	ldrb	r3, [r3, #2]
 8022618:	f003 0370 	and.w	r3, r3, #112	; 0x70
 802261c:	b2db      	uxtb	r3, r3
 802261e:	2b10      	cmp	r3, #16
 8022620:	d006      	beq.n	8022630 <XMC_DMA_CH_Init+0x10c>
            (config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2P_DMA))
 8022622:	687b      	ldr	r3, [r7, #4]
 8022624:	789b      	ldrb	r3, [r3, #2]
 8022626:	f003 0370 	and.w	r3, r3, #112	; 0x70
 802262a:	b2db      	uxtb	r3, r3
      }

      if (config->dst_handshaking == XMC_DMA_CH_DST_HANDSHAKING_HARDWARE)
      {
        /* Hardware handshaking interface configuration */
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_M2P_DMA) ||
 802262c:	2b30      	cmp	r3, #48	; 0x30
 802262e:	d136      	bne.n	802269e <XMC_DMA_CH_Init+0x17a>
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
          {
#endif
            line = config->dst_peripheral_request & GPDMA0_CH_CFGH_PER_Msk;
 8022630:	687b      	ldr	r3, [r7, #4]
 8022632:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8022636:	f003 0307 	and.w	r3, r3, #7
 802263a:	75bb      	strb	r3, [r7, #22]
          else
          {
            line = config->dst_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
          }
#endif
          peripheral = config->dst_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;
 802263c:	687b      	ldr	r3, [r7, #4]
 802263e:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8022642:	091b      	lsrs	r3, r3, #4
 8022644:	757b      	strb	r3, [r7, #21]

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_DEST_PER_Pos);
 8022646:	7afb      	ldrb	r3, [r7, #11]
 8022648:	7afa      	ldrb	r2, [r7, #11]
 802264a:	68f9      	ldr	r1, [r7, #12]
 802264c:	2058      	movs	r0, #88	; 0x58
 802264e:	fb00 f202 	mul.w	r2, r0, r2
 8022652:	440a      	add	r2, r1
 8022654:	3240      	adds	r2, #64	; 0x40
 8022656:	6851      	ldr	r1, [r2, #4]
 8022658:	7dba      	ldrb	r2, [r7, #22]
 802265a:	02d2      	lsls	r2, r2, #11
 802265c:	430a      	orrs	r2, r1
 802265e:	68f9      	ldr	r1, [r7, #12]
 8022660:	2058      	movs	r0, #88	; 0x58
 8022662:	fb00 f303 	mul.w	r3, r0, r3
 8022666:	440b      	add	r3, r1
 8022668:	3340      	adds	r3, #64	; 0x40
 802266a:	605a      	str	r2, [r3, #4]
          XMC_DMA_EnableRequestLine(dma, line, peripheral);
 802266c:	7dba      	ldrb	r2, [r7, #22]
 802266e:	7d7b      	ldrb	r3, [r7, #21]
 8022670:	68f8      	ldr	r0, [r7, #12]
 8022672:	4611      	mov	r1, r2
 8022674:	461a      	mov	r2, r3
 8022676:	f7ff ff11 	bl	802249c <XMC_DMA_EnableRequestLine>
          dma->CH[channel].CFGL &= (uint32_t)~GPDMA0_CH_CFGL_HS_SEL_DST_Msk;
 802267a:	7afb      	ldrb	r3, [r7, #11]
 802267c:	7afa      	ldrb	r2, [r7, #11]
 802267e:	68f9      	ldr	r1, [r7, #12]
 8022680:	2058      	movs	r0, #88	; 0x58
 8022682:	fb00 f202 	mul.w	r2, r0, r2
 8022686:	440a      	add	r2, r1
 8022688:	3240      	adds	r2, #64	; 0x40
 802268a:	6812      	ldr	r2, [r2, #0]
 802268c:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8022690:	68f9      	ldr	r1, [r7, #12]
 8022692:	2058      	movs	r0, #88	; 0x58
 8022694:	fb00 f303 	mul.w	r3, r0, r3
 8022698:	440b      	add	r3, r1
 802269a:	3340      	adds	r3, #64	; 0x40
 802269c:	601a      	str	r2, [r3, #0]
        }
      }


      if (config->src_handshaking == XMC_DMA_CH_SRC_HANDSHAKING_HARDWARE)
 802269e:	687b      	ldr	r3, [r7, #4]
 80226a0:	8b9b      	ldrh	r3, [r3, #28]
 80226a2:	2b00      	cmp	r3, #0
 80226a4:	d142      	bne.n	802272c <XMC_DMA_CH_Init+0x208>
      {
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2M_DMA) ||
 80226a6:	687b      	ldr	r3, [r7, #4]
 80226a8:	789b      	ldrb	r3, [r3, #2]
 80226aa:	f003 0370 	and.w	r3, r3, #112	; 0x70
 80226ae:	b2db      	uxtb	r3, r3
 80226b0:	2b20      	cmp	r3, #32
 80226b2:	d006      	beq.n	80226c2 <XMC_DMA_CH_Init+0x19e>
            (config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2P_DMA))
 80226b4:	687b      	ldr	r3, [r7, #4]
 80226b6:	789b      	ldrb	r3, [r3, #2]
 80226b8:	f003 0370 	and.w	r3, r3, #112	; 0x70
 80226bc:	b2db      	uxtb	r3, r3
      }


      if (config->src_handshaking == XMC_DMA_CH_SRC_HANDSHAKING_HARDWARE)
      {
        if ((config->transfer_flow == (uint32_t)XMC_DMA_CH_TRANSFER_FLOW_P2M_DMA) ||
 80226be:	2b30      	cmp	r3, #48	; 0x30
 80226c0:	d134      	bne.n	802272c <XMC_DMA_CH_Init+0x208>
        {
#if defined(GPDMA1)
          if (dma == XMC_DMA0)
          {
#endif
            line = config->src_peripheral_request & GPDMA0_CH_CFGH_PER_Msk;
 80226c2:	687b      	ldr	r3, [r7, #4]
 80226c4:	7f9b      	ldrb	r3, [r3, #30]
 80226c6:	f003 0307 	and.w	r3, r3, #7
 80226ca:	75bb      	strb	r3, [r7, #22]
          else
          {
            line = config->src_peripheral_request & GPDMA1_CH_CFGH_PER_Msk;
          }
#endif
          peripheral = config->src_peripheral_request >> GPDMA_CH_CFGH_PER_BITSIZE;
 80226cc:	687b      	ldr	r3, [r7, #4]
 80226ce:	7f9b      	ldrb	r3, [r3, #30]
 80226d0:	091b      	lsrs	r3, r3, #4
 80226d2:	757b      	strb	r3, [r7, #21]

          dma->CH[channel].CFGH |= (uint32_t)((uint32_t)line << GPDMA0_CH_CFGH_SRC_PER_Pos);
 80226d4:	7afb      	ldrb	r3, [r7, #11]
 80226d6:	7afa      	ldrb	r2, [r7, #11]
 80226d8:	68f9      	ldr	r1, [r7, #12]
 80226da:	2058      	movs	r0, #88	; 0x58
 80226dc:	fb00 f202 	mul.w	r2, r0, r2
 80226e0:	440a      	add	r2, r1
 80226e2:	3240      	adds	r2, #64	; 0x40
 80226e4:	6851      	ldr	r1, [r2, #4]
 80226e6:	7dba      	ldrb	r2, [r7, #22]
 80226e8:	01d2      	lsls	r2, r2, #7
 80226ea:	430a      	orrs	r2, r1
 80226ec:	68f9      	ldr	r1, [r7, #12]
 80226ee:	2058      	movs	r0, #88	; 0x58
 80226f0:	fb00 f303 	mul.w	r3, r0, r3
 80226f4:	440b      	add	r3, r1
 80226f6:	3340      	adds	r3, #64	; 0x40
 80226f8:	605a      	str	r2, [r3, #4]
          XMC_DMA_EnableRequestLine(dma, line, peripheral);
 80226fa:	7dba      	ldrb	r2, [r7, #22]
 80226fc:	7d7b      	ldrb	r3, [r7, #21]
 80226fe:	68f8      	ldr	r0, [r7, #12]
 8022700:	4611      	mov	r1, r2
 8022702:	461a      	mov	r2, r3
 8022704:	f7ff feca 	bl	802249c <XMC_DMA_EnableRequestLine>
          dma->CH[channel].CFGL &= (uint32_t)~GPDMA0_CH_CFGL_HS_SEL_SRC_Msk;
 8022708:	7afb      	ldrb	r3, [r7, #11]
 802270a:	7afa      	ldrb	r2, [r7, #11]
 802270c:	68f9      	ldr	r1, [r7, #12]
 802270e:	2058      	movs	r0, #88	; 0x58
 8022710:	fb00 f202 	mul.w	r2, r0, r2
 8022714:	440a      	add	r2, r1
 8022716:	3240      	adds	r2, #64	; 0x40
 8022718:	6812      	ldr	r2, [r2, #0]
 802271a:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 802271e:	68f9      	ldr	r1, [r7, #12]
 8022720:	2058      	movs	r0, #88	; 0x58
 8022722:	fb00 f303 	mul.w	r3, r0, r3
 8022726:	440b      	add	r3, r1
 8022728:	3340      	adds	r3, #64	; 0x40
 802272a:	601a      	str	r2, [r3, #0]
        }
      }

      XMC_DMA_CH_ClearEventStatus(dma, channel, (uint32_t)((uint32_t)XMC_DMA_CH_EVENT_TRANSFER_COMPLETE |
 802272c:	7afb      	ldrb	r3, [r7, #11]
 802272e:	68f8      	ldr	r0, [r7, #12]
 8022730:	4619      	mov	r1, r3
 8022732:	221f      	movs	r2, #31
 8022734:	f000 f90e 	bl	8022954 <XMC_DMA_CH_ClearEventStatus>
                                  (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE |
                                  (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE |
                                  (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE |
                                  (uint32_t)XMC_DMA_CH_EVENT_ERROR));

      switch (config->transfer_type)
 8022738:	687b      	ldr	r3, [r7, #4]
 802273a:	7e9b      	ldrb	r3, [r3, #26]
 802273c:	2b08      	cmp	r3, #8
 802273e:	f200 80d3 	bhi.w	80228e8 <XMC_DMA_CH_Init+0x3c4>
 8022742:	a201      	add	r2, pc, #4	; (adr r2, 8022748 <XMC_DMA_CH_Init+0x224>)
 8022744:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8022748:	080228e9 	.word	0x080228e9
 802274c:	0802276d 	.word	0x0802276d
 8022750:	08022793 	.word	0x08022793
 8022754:	080227b9 	.word	0x080227b9
 8022758:	080227df 	.word	0x080227df
 802275c:	08022805 	.word	0x08022805
 8022760:	0802284f 	.word	0x0802284f
 8022764:	08022879 	.word	0x08022879
 8022768:	080228c3 	.word	0x080228c3
      {
        case XMC_DMA_CH_TRANSFER_TYPE_SINGLE_BLOCK:
          break;

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_CONTIGUOUS_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk;
 802276c:	7afb      	ldrb	r3, [r7, #11]
 802276e:	7afa      	ldrb	r2, [r7, #11]
 8022770:	68f9      	ldr	r1, [r7, #12]
 8022772:	2058      	movs	r0, #88	; 0x58
 8022774:	fb00 f202 	mul.w	r2, r0, r2
 8022778:	440a      	add	r2, r1
 802277a:	3240      	adds	r2, #64	; 0x40
 802277c:	6812      	ldr	r2, [r2, #0]
 802277e:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8022782:	68f9      	ldr	r1, [r7, #12]
 8022784:	2058      	movs	r0, #88	; 0x58
 8022786:	fb00 f303 	mul.w	r3, r0, r3
 802278a:	440b      	add	r3, r1
 802278c:	3340      	adds	r3, #64	; 0x40
 802278e:	601a      	str	r2, [r3, #0]
          break;
 8022790:	e0ab      	b.n	80228ea <XMC_DMA_CH_Init+0x3c6>

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_CONTIGUOUS:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk;
 8022792:	7afb      	ldrb	r3, [r7, #11]
 8022794:	7afa      	ldrb	r2, [r7, #11]
 8022796:	68f9      	ldr	r1, [r7, #12]
 8022798:	2058      	movs	r0, #88	; 0x58
 802279a:	fb00 f202 	mul.w	r2, r0, r2
 802279e:	440a      	add	r2, r1
 80227a0:	3240      	adds	r2, #64	; 0x40
 80227a2:	6812      	ldr	r2, [r2, #0]
 80227a4:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 80227a8:	68f9      	ldr	r1, [r7, #12]
 80227aa:	2058      	movs	r0, #88	; 0x58
 80227ac:	fb00 f303 	mul.w	r3, r0, r3
 80227b0:	440b      	add	r3, r1
 80227b2:	3340      	adds	r3, #64	; 0x40
 80227b4:	601a      	str	r2, [r3, #0]
          break;
 80227b6:	e098      	b.n	80228ea <XMC_DMA_CH_Init+0x3c6>

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)((uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk |
 80227b8:	7afb      	ldrb	r3, [r7, #11]
 80227ba:	7afa      	ldrb	r2, [r7, #11]
 80227bc:	68f9      	ldr	r1, [r7, #12]
 80227be:	2058      	movs	r0, #88	; 0x58
 80227c0:	fb00 f202 	mul.w	r2, r0, r2
 80227c4:	440a      	add	r2, r1
 80227c6:	3240      	adds	r2, #64	; 0x40
 80227c8:	6812      	ldr	r2, [r2, #0]
 80227ca:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
 80227ce:	68f9      	ldr	r1, [r7, #12]
 80227d0:	2058      	movs	r0, #88	; 0x58
 80227d2:	fb00 f303 	mul.w	r3, r0, r3
 80227d6:	440b      	add	r3, r1
 80227d8:	3340      	adds	r3, #64	; 0x40
 80227da:	601a      	str	r2, [r3, #0]
                                              (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk);
          break;
 80227dc:	e085      	b.n	80228ea <XMC_DMA_CH_Init+0x3c6>

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_CONTIGUOUS_DSTADR_LINKED:
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_DST_EN_Msk;
 80227de:	7afb      	ldrb	r3, [r7, #11]
 80227e0:	7afa      	ldrb	r2, [r7, #11]
 80227e2:	68f9      	ldr	r1, [r7, #12]
 80227e4:	2058      	movs	r0, #88	; 0x58
 80227e6:	fb00 f202 	mul.w	r2, r0, r2
 80227ea:	440a      	add	r2, r1
 80227ec:	3218      	adds	r2, #24
 80227ee:	6812      	ldr	r2, [r2, #0]
 80227f0:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 80227f4:	68f9      	ldr	r1, [r7, #12]
 80227f6:	2058      	movs	r0, #88	; 0x58
 80227f8:	fb00 f303 	mul.w	r3, r0, r3
 80227fc:	440b      	add	r3, r1
 80227fe:	3318      	adds	r3, #24
 8022800:	601a      	str	r2, [r3, #0]
          break;
 8022802:	e072      	b.n	80228ea <XMC_DMA_CH_Init+0x3c6>

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_RELOAD_DSTADR_LINKED:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_SRC_Msk;
 8022804:	7afb      	ldrb	r3, [r7, #11]
 8022806:	7afa      	ldrb	r2, [r7, #11]
 8022808:	68f9      	ldr	r1, [r7, #12]
 802280a:	2058      	movs	r0, #88	; 0x58
 802280c:	fb00 f202 	mul.w	r2, r0, r2
 8022810:	440a      	add	r2, r1
 8022812:	3240      	adds	r2, #64	; 0x40
 8022814:	6812      	ldr	r2, [r2, #0]
 8022816:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 802281a:	68f9      	ldr	r1, [r7, #12]
 802281c:	2058      	movs	r0, #88	; 0x58
 802281e:	fb00 f303 	mul.w	r3, r0, r3
 8022822:	440b      	add	r3, r1
 8022824:	3340      	adds	r3, #64	; 0x40
 8022826:	601a      	str	r2, [r3, #0]
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_DST_EN_Msk;
 8022828:	7afb      	ldrb	r3, [r7, #11]
 802282a:	7afa      	ldrb	r2, [r7, #11]
 802282c:	68f9      	ldr	r1, [r7, #12]
 802282e:	2058      	movs	r0, #88	; 0x58
 8022830:	fb00 f202 	mul.w	r2, r0, r2
 8022834:	440a      	add	r2, r1
 8022836:	3218      	adds	r2, #24
 8022838:	6812      	ldr	r2, [r2, #0]
 802283a:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 802283e:	68f9      	ldr	r1, [r7, #12]
 8022840:	2058      	movs	r0, #88	; 0x58
 8022842:	fb00 f303 	mul.w	r3, r0, r3
 8022846:	440b      	add	r3, r1
 8022848:	3318      	adds	r3, #24
 802284a:	601a      	str	r2, [r3, #0]
          break;
 802284c:	e04d      	b.n	80228ea <XMC_DMA_CH_Init+0x3c6>

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_CONTIGUOUS:
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk;
 802284e:	7afb      	ldrb	r3, [r7, #11]
 8022850:	7afa      	ldrb	r2, [r7, #11]
 8022852:	68f9      	ldr	r1, [r7, #12]
 8022854:	2058      	movs	r0, #88	; 0x58
 8022856:	fb00 f202 	mul.w	r2, r0, r2
 802285a:	440a      	add	r2, r1
 802285c:	3218      	adds	r2, #24
 802285e:	6812      	ldr	r2, [r2, #0]
 8022860:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8022864:	68f9      	ldr	r1, [r7, #12]
 8022866:	2058      	movs	r0, #88	; 0x58
 8022868:	fb00 f303 	mul.w	r3, r0, r3
 802286c:	440b      	add	r3, r1
 802286e:	3318      	adds	r3, #24
 8022870:	601a      	str	r2, [r3, #0]
          break;
 8022872:	e03a      	b.n	80228ea <XMC_DMA_CH_Init+0x3c6>
 8022874:	50014000 	.word	0x50014000

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_RELOAD:
          dma->CH[channel].CFGL |= (uint32_t)GPDMA0_CH_CFGL_RELOAD_DST_Msk;
 8022878:	7afb      	ldrb	r3, [r7, #11]
 802287a:	7afa      	ldrb	r2, [r7, #11]
 802287c:	68f9      	ldr	r1, [r7, #12]
 802287e:	2058      	movs	r0, #88	; 0x58
 8022880:	fb00 f202 	mul.w	r2, r0, r2
 8022884:	440a      	add	r2, r1
 8022886:	3240      	adds	r2, #64	; 0x40
 8022888:	6812      	ldr	r2, [r2, #0]
 802288a:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 802288e:	68f9      	ldr	r1, [r7, #12]
 8022890:	2058      	movs	r0, #88	; 0x58
 8022892:	fb00 f303 	mul.w	r3, r0, r3
 8022896:	440b      	add	r3, r1
 8022898:	3340      	adds	r3, #64	; 0x40
 802289a:	601a      	str	r2, [r3, #0]
          dma->CH[channel].CTLL |= (uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk;
 802289c:	7afb      	ldrb	r3, [r7, #11]
 802289e:	7afa      	ldrb	r2, [r7, #11]
 80228a0:	68f9      	ldr	r1, [r7, #12]
 80228a2:	2058      	movs	r0, #88	; 0x58
 80228a4:	fb00 f202 	mul.w	r2, r0, r2
 80228a8:	440a      	add	r2, r1
 80228aa:	3218      	adds	r2, #24
 80228ac:	6812      	ldr	r2, [r2, #0]
 80228ae:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80228b2:	68f9      	ldr	r1, [r7, #12]
 80228b4:	2058      	movs	r0, #88	; 0x58
 80228b6:	fb00 f303 	mul.w	r3, r0, r3
 80228ba:	440b      	add	r3, r1
 80228bc:	3318      	adds	r3, #24
 80228be:	601a      	str	r2, [r3, #0]
          break;
 80228c0:	e013      	b.n	80228ea <XMC_DMA_CH_Init+0x3c6>

        case XMC_DMA_CH_TRANSFER_TYPE_MULTI_BLOCK_SRCADR_LINKED_DSTADR_LINKED:
          dma->CH[channel].CTLL |= (uint32_t)((uint32_t)GPDMA0_CH_CTLL_LLP_SRC_EN_Msk |
 80228c2:	7afb      	ldrb	r3, [r7, #11]
 80228c4:	7afa      	ldrb	r2, [r7, #11]
 80228c6:	68f9      	ldr	r1, [r7, #12]
 80228c8:	2058      	movs	r0, #88	; 0x58
 80228ca:	fb00 f202 	mul.w	r2, r0, r2
 80228ce:	440a      	add	r2, r1
 80228d0:	3218      	adds	r2, #24
 80228d2:	6812      	ldr	r2, [r2, #0]
 80228d4:	f042 52c0 	orr.w	r2, r2, #402653184	; 0x18000000
 80228d8:	68f9      	ldr	r1, [r7, #12]
 80228da:	2058      	movs	r0, #88	; 0x58
 80228dc:	fb00 f303 	mul.w	r3, r0, r3
 80228e0:	440b      	add	r3, r1
 80228e2:	3318      	adds	r3, #24
 80228e4:	601a      	str	r2, [r3, #0]
                                              (uint32_t)GPDMA0_CH_CTLL_LLP_DST_EN_Msk);
          break;
 80228e6:	e000      	b.n	80228ea <XMC_DMA_CH_Init+0x3c6>

        default:
          break;
 80228e8:	bf00      	nop
      }

      status = XMC_DMA_CH_STATUS_OK;
 80228ea:	2300      	movs	r3, #0
 80228ec:	75fb      	strb	r3, [r7, #23]
 80228ee:	e004      	b.n	80228fa <XMC_DMA_CH_Init+0x3d6>

    }
    else
    {
      status = XMC_DMA_CH_STATUS_BUSY;
 80228f0:	2302      	movs	r3, #2
 80228f2:	75fb      	strb	r3, [r7, #23]
 80228f4:	e001      	b.n	80228fa <XMC_DMA_CH_Init+0x3d6>
    }
  }
  else
  {
    status = XMC_DMA_CH_STATUS_ERROR;
 80228f6:	2301      	movs	r3, #1
 80228f8:	75fb      	strb	r3, [r7, #23]
  }

  return status;
 80228fa:	7dfb      	ldrb	r3, [r7, #23]
}
 80228fc:	4618      	mov	r0, r3
 80228fe:	3718      	adds	r7, #24
 8022900:	46bd      	mov	sp, r7
 8022902:	bd80      	pop	{r7, pc}

08022904 <XMC_DMA_CH_EnableEvent>:
  return (bool)(dma->CH[channel].CFGL & (uint32_t)GPDMA0_CH_CFGL_CH_SUSP_Msk);
}

/* Enable GPDMA event */
void XMC_DMA_CH_EnableEvent(XMC_DMA_t *const dma, const uint8_t channel, const uint32_t event)
{
 8022904:	b480      	push	{r7}
 8022906:	b087      	sub	sp, #28
 8022908:	af00      	add	r7, sp, #0
 802290a:	60f8      	str	r0, [r7, #12]
 802290c:	460b      	mov	r3, r1
 802290e:	607a      	str	r2, [r7, #4]
 8022910:	72fb      	strb	r3, [r7, #11]
  uint32_t event_idx;

  for (event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
 8022912:	2300      	movs	r3, #0
 8022914:	617b      	str	r3, [r7, #20]
 8022916:	e014      	b.n	8022942 <XMC_DMA_CH_EnableEvent+0x3e>
  {
    if (event & ((uint32_t)0x1UL << event_idx))
 8022918:	697b      	ldr	r3, [r7, #20]
 802291a:	687a      	ldr	r2, [r7, #4]
 802291c:	fa22 f303 	lsr.w	r3, r2, r3
 8022920:	f003 0301 	and.w	r3, r3, #1
 8022924:	2b00      	cmp	r3, #0
 8022926:	d009      	beq.n	802293c <XMC_DMA_CH_EnableEvent+0x38>
    {
      dma->MASKCHEV[event_idx * 2UL] = ((uint32_t)0x101UL << channel);
 8022928:	697b      	ldr	r3, [r7, #20]
 802292a:	005a      	lsls	r2, r3, #1
 802292c:	7afb      	ldrb	r3, [r7, #11]
 802292e:	f240 1101 	movw	r1, #257	; 0x101
 8022932:	4099      	lsls	r1, r3
 8022934:	68fb      	ldr	r3, [r7, #12]
 8022936:	32c4      	adds	r2, #196	; 0xc4
 8022938:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
/* Enable GPDMA event */
void XMC_DMA_CH_EnableEvent(XMC_DMA_t *const dma, const uint8_t channel, const uint32_t event)
{
  uint32_t event_idx;

  for (event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
 802293c:	697b      	ldr	r3, [r7, #20]
 802293e:	3301      	adds	r3, #1
 8022940:	617b      	str	r3, [r7, #20]
 8022942:	697b      	ldr	r3, [r7, #20]
 8022944:	2b04      	cmp	r3, #4
 8022946:	d9e7      	bls.n	8022918 <XMC_DMA_CH_EnableEvent+0x14>
    if (event & ((uint32_t)0x1UL << event_idx))
    {
      dma->MASKCHEV[event_idx * 2UL] = ((uint32_t)0x101UL << channel);
    }
  }
}
 8022948:	371c      	adds	r7, #28
 802294a:	46bd      	mov	sp, r7
 802294c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022950:	4770      	bx	lr
 8022952:	bf00      	nop

08022954 <XMC_DMA_CH_ClearEventStatus>:
  }
}

/* Clear GPDMA event */
void XMC_DMA_CH_ClearEventStatus(XMC_DMA_t *const dma, const uint8_t channel, const uint32_t event)
{
 8022954:	b480      	push	{r7}
 8022956:	b087      	sub	sp, #28
 8022958:	af00      	add	r7, sp, #0
 802295a:	60f8      	str	r0, [r7, #12]
 802295c:	460b      	mov	r3, r1
 802295e:	607a      	str	r2, [r7, #4]
 8022960:	72fb      	strb	r3, [r7, #11]
  uint32_t event_idx;

  for (event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
 8022962:	2300      	movs	r3, #0
 8022964:	617b      	str	r3, [r7, #20]
 8022966:	e013      	b.n	8022990 <XMC_DMA_CH_ClearEventStatus+0x3c>
  {
    if (event & (uint32_t)((uint32_t)0x1UL << event_idx))
 8022968:	697b      	ldr	r3, [r7, #20]
 802296a:	687a      	ldr	r2, [r7, #4]
 802296c:	fa22 f303 	lsr.w	r3, r2, r3
 8022970:	f003 0301 	and.w	r3, r3, #1
 8022974:	2b00      	cmp	r3, #0
 8022976:	d008      	beq.n	802298a <XMC_DMA_CH_ClearEventStatus+0x36>
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
 8022978:	697b      	ldr	r3, [r7, #20]
 802297a:	005a      	lsls	r2, r3, #1
 802297c:	7afb      	ldrb	r3, [r7, #11]
 802297e:	2101      	movs	r1, #1
 8022980:	4099      	lsls	r1, r3
 8022982:	68fb      	ldr	r3, [r7, #12]
 8022984:	32ce      	adds	r2, #206	; 0xce
 8022986:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
/* Clear GPDMA event */
void XMC_DMA_CH_ClearEventStatus(XMC_DMA_t *const dma, const uint8_t channel, const uint32_t event)
{
  uint32_t event_idx;

  for (event_idx = 0UL; event_idx < DMA_EVENT_MAX; ++event_idx)
 802298a:	697b      	ldr	r3, [r7, #20]
 802298c:	3301      	adds	r3, #1
 802298e:	617b      	str	r3, [r7, #20]
 8022990:	697b      	ldr	r3, [r7, #20]
 8022992:	2b04      	cmp	r3, #4
 8022994:	d9e8      	bls.n	8022968 <XMC_DMA_CH_ClearEventStatus+0x14>
    {
      dma->CLEARCHEV[event_idx * 2UL] = ((uint32_t)0x1UL << channel);
    }
  }

}
 8022996:	371c      	adds	r7, #28
 8022998:	46bd      	mov	sp, r7
 802299a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802299e:	4770      	bx	lr

080229a0 <XMC_DMA_CH_SetEventHandler>:
  dma->CH[channel].CTLL &= (uint32_t)~(GPDMA0_CH_CTLL_LLP_SRC_EN_Msk | GPDMA0_CH_CTLL_LLP_DST_EN_Msk);
}

/* Set event handler */
void XMC_DMA_CH_SetEventHandler(XMC_DMA_t *const dma, const uint8_t channel, XMC_DMA_CH_EVENT_HANDLER_t event_handler)
{
 80229a0:	b480      	push	{r7}
 80229a2:	b085      	sub	sp, #20
 80229a4:	af00      	add	r7, sp, #0
 80229a6:	60f8      	str	r0, [r7, #12]
 80229a8:	460b      	mov	r3, r1
 80229aa:	607a      	str	r2, [r7, #4]
 80229ac:	72fb      	strb	r3, [r7, #11]
  if (dma == XMC_DMA0)
  {
#else
  XMC_UNUSED_ARG(dma);
#endif
    dma0_event_handlers[channel] = event_handler;
 80229ae:	7afb      	ldrb	r3, [r7, #11]
 80229b0:	4904      	ldr	r1, [pc, #16]	; (80229c4 <XMC_DMA_CH_SetEventHandler+0x24>)
 80229b2:	687a      	ldr	r2, [r7, #4]
 80229b4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  else
  {
    dma1_event_handlers[channel] = event_handler;
  }
#endif
}
 80229b8:	3714      	adds	r7, #20
 80229ba:	46bd      	mov	sp, r7
 80229bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80229c0:	4770      	bx	lr
 80229c2:	bf00      	nop
 80229c4:	1fff17f4 	.word	0x1fff17f4

080229c8 <XMC_DMA_IRQHandler>:
  XMC_DMA_ClearRequestLine(dma, (uint8_t)line);
}

/* Default DMA IRQ handler */
void XMC_DMA_IRQHandler(XMC_DMA_t *const dma)
{
 80229c8:	b580      	push	{r7, lr}
 80229ca:	b088      	sub	sp, #32
 80229cc:	af00      	add	r7, sp, #0
 80229ce:	6078      	str	r0, [r7, #4]

#if defined(GPDMA1)
  if (dma == XMC_DMA0)
  {
#endif
    dma_event_handlers = dma0_event_handlers;
 80229d0:	4b7f      	ldr	r3, [pc, #508]	; (8022bd0 <XMC_DMA_IRQHandler+0x208>)
 80229d2:	61bb      	str	r3, [r7, #24]
  {
    dma_event_handlers = dma1_event_handlers;
  }
#endif

  event = XMC_DMA_GetEventStatus(dma);
 80229d4:	6878      	ldr	r0, [r7, #4]
 80229d6:	f7ff fcab 	bl	8022330 <XMC_DMA_GetEventStatus>
 80229da:	6178      	str	r0, [r7, #20]
  channel = 0;
 80229dc:	2300      	movs	r3, #0
 80229de:	61fb      	str	r3, [r7, #28]

  if ((event & (uint32_t)XMC_DMA_CH_EVENT_ERROR) != (uint32_t)0UL)
 80229e0:	697b      	ldr	r3, [r7, #20]
 80229e2:	f003 0310 	and.w	r3, r3, #16
 80229e6:	2b00      	cmp	r3, #0
 80229e8:	d02b      	beq.n	8022a42 <XMC_DMA_IRQHandler+0x7a>
  {
    event = XMC_DMA_GetChannelsErrorStatus(dma);
 80229ea:	6878      	ldr	r0, [r7, #4]
 80229ec:	f7ff fce6 	bl	80223bc <XMC_DMA_GetChannelsErrorStatus>
 80229f0:	6178      	str	r0, [r7, #20]
    while (event != 0)
 80229f2:	e021      	b.n	8022a38 <XMC_DMA_IRQHandler+0x70>
    {
      mask = (uint32_t)1U << channel;
 80229f4:	2201      	movs	r2, #1
 80229f6:	69fb      	ldr	r3, [r7, #28]
 80229f8:	fa02 f303 	lsl.w	r3, r2, r3
 80229fc:	613b      	str	r3, [r7, #16]
      if ((event & mask) != 0)
 80229fe:	697a      	ldr	r2, [r7, #20]
 8022a00:	693b      	ldr	r3, [r7, #16]
 8022a02:	4013      	ands	r3, r2
 8022a04:	2b00      	cmp	r3, #0
 8022a06:	d014      	beq.n	8022a32 <XMC_DMA_IRQHandler+0x6a>
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)XMC_DMA_CH_EVENT_ERROR);
 8022a08:	69fb      	ldr	r3, [r7, #28]
 8022a0a:	b2db      	uxtb	r3, r3
 8022a0c:	6878      	ldr	r0, [r7, #4]
 8022a0e:	4619      	mov	r1, r3
 8022a10:	2210      	movs	r2, #16
 8022a12:	f7ff ff9f 	bl	8022954 <XMC_DMA_CH_ClearEventStatus>

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
 8022a16:	69fb      	ldr	r3, [r7, #28]
 8022a18:	009b      	lsls	r3, r3, #2
 8022a1a:	69ba      	ldr	r2, [r7, #24]
 8022a1c:	4413      	add	r3, r2
 8022a1e:	681b      	ldr	r3, [r3, #0]
 8022a20:	60fb      	str	r3, [r7, #12]
        if (event_handler != NULL)
 8022a22:	68fb      	ldr	r3, [r7, #12]
 8022a24:	2b00      	cmp	r3, #0
 8022a26:	d003      	beq.n	8022a30 <XMC_DMA_IRQHandler+0x68>
        {
          event_handler(XMC_DMA_CH_EVENT_ERROR);
 8022a28:	68fb      	ldr	r3, [r7, #12]
 8022a2a:	2010      	movs	r0, #16
 8022a2c:	4798      	blx	r3
        }

        break;
 8022a2e:	e007      	b.n	8022a40 <XMC_DMA_IRQHandler+0x78>
 8022a30:	e006      	b.n	8022a40 <XMC_DMA_IRQHandler+0x78>
      }
      ++channel;
 8022a32:	69fb      	ldr	r3, [r7, #28]
 8022a34:	3301      	adds	r3, #1
 8022a36:	61fb      	str	r3, [r7, #28]
  channel = 0;

  if ((event & (uint32_t)XMC_DMA_CH_EVENT_ERROR) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsErrorStatus(dma);
    while (event != 0)
 8022a38:	697b      	ldr	r3, [r7, #20]
 8022a3a:	2b00      	cmp	r3, #0
 8022a3c:	d1da      	bne.n	80229f4 <XMC_DMA_IRQHandler+0x2c>
 8022a3e:	e0c3      	b.n	8022bc8 <XMC_DMA_IRQHandler+0x200>
 8022a40:	e0c2      	b.n	8022bc8 <XMC_DMA_IRQHandler+0x200>
        break;
      }
      ++channel;
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_TRANSFER_COMPLETE) != (uint32_t)0UL)
 8022a42:	697b      	ldr	r3, [r7, #20]
 8022a44:	f003 0301 	and.w	r3, r3, #1
 8022a48:	2b00      	cmp	r3, #0
 8022a4a:	d02b      	beq.n	8022aa4 <XMC_DMA_IRQHandler+0xdc>
  {
    event = XMC_DMA_GetChannelsTransferCompleteStatus(dma);
 8022a4c:	6878      	ldr	r0, [r7, #4]
 8022a4e:	f7ff fc7d 	bl	802234c <XMC_DMA_GetChannelsTransferCompleteStatus>
 8022a52:	6178      	str	r0, [r7, #20]
    while (event != 0)
 8022a54:	e021      	b.n	8022a9a <XMC_DMA_IRQHandler+0xd2>
    {
      mask = (uint32_t)1U << channel;
 8022a56:	2201      	movs	r2, #1
 8022a58:	69fb      	ldr	r3, [r7, #28]
 8022a5a:	fa02 f303 	lsl.w	r3, r2, r3
 8022a5e:	613b      	str	r3, [r7, #16]
      if (event & mask)
 8022a60:	697a      	ldr	r2, [r7, #20]
 8022a62:	693b      	ldr	r3, [r7, #16]
 8022a64:	4013      	ands	r3, r2
 8022a66:	2b00      	cmp	r3, #0
 8022a68:	d014      	beq.n	8022a94 <XMC_DMA_IRQHandler+0xcc>
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)((uint32_t)XMC_DMA_CH_EVENT_TRANSFER_COMPLETE |
 8022a6a:	69fb      	ldr	r3, [r7, #28]
 8022a6c:	b2db      	uxtb	r3, r3
 8022a6e:	6878      	ldr	r0, [r7, #4]
 8022a70:	4619      	mov	r1, r3
 8022a72:	220f      	movs	r2, #15
 8022a74:	f7ff ff6e 	bl	8022954 <XMC_DMA_CH_ClearEventStatus>
                                    (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE |
                                    (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE |
                                    (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE));

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
 8022a78:	69fb      	ldr	r3, [r7, #28]
 8022a7a:	009b      	lsls	r3, r3, #2
 8022a7c:	69ba      	ldr	r2, [r7, #24]
 8022a7e:	4413      	add	r3, r2
 8022a80:	681b      	ldr	r3, [r3, #0]
 8022a82:	60fb      	str	r3, [r7, #12]
        if (event_handler != NULL)
 8022a84:	68fb      	ldr	r3, [r7, #12]
 8022a86:	2b00      	cmp	r3, #0
 8022a88:	d003      	beq.n	8022a92 <XMC_DMA_IRQHandler+0xca>
        {
          event_handler(XMC_DMA_CH_EVENT_TRANSFER_COMPLETE);
 8022a8a:	68fb      	ldr	r3, [r7, #12]
 8022a8c:	2001      	movs	r0, #1
 8022a8e:	4798      	blx	r3
        }

        break;
 8022a90:	e007      	b.n	8022aa2 <XMC_DMA_IRQHandler+0xda>
 8022a92:	e006      	b.n	8022aa2 <XMC_DMA_IRQHandler+0xda>
      }
      ++channel;
 8022a94:	69fb      	ldr	r3, [r7, #28]
 8022a96:	3301      	adds	r3, #1
 8022a98:	61fb      	str	r3, [r7, #28]
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_TRANSFER_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsTransferCompleteStatus(dma);
    while (event != 0)
 8022a9a:	697b      	ldr	r3, [r7, #20]
 8022a9c:	2b00      	cmp	r3, #0
 8022a9e:	d1da      	bne.n	8022a56 <XMC_DMA_IRQHandler+0x8e>
 8022aa0:	e092      	b.n	8022bc8 <XMC_DMA_IRQHandler+0x200>
 8022aa2:	e091      	b.n	8022bc8 <XMC_DMA_IRQHandler+0x200>
        break;
      }
      ++channel;
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE) != (uint32_t)0UL)
 8022aa4:	697b      	ldr	r3, [r7, #20]
 8022aa6:	f003 0302 	and.w	r3, r3, #2
 8022aaa:	2b00      	cmp	r3, #0
 8022aac:	d02b      	beq.n	8022b06 <XMC_DMA_IRQHandler+0x13e>
  {
    event = XMC_DMA_GetChannelsBlockCompleteStatus(dma);
 8022aae:	6878      	ldr	r0, [r7, #4]
 8022ab0:	f7ff fc5a 	bl	8022368 <XMC_DMA_GetChannelsBlockCompleteStatus>
 8022ab4:	6178      	str	r0, [r7, #20]
    while (event != 0)
 8022ab6:	e021      	b.n	8022afc <XMC_DMA_IRQHandler+0x134>
    {
      mask = (uint32_t)1U << channel;
 8022ab8:	2201      	movs	r2, #1
 8022aba:	69fb      	ldr	r3, [r7, #28]
 8022abc:	fa02 f303 	lsl.w	r3, r2, r3
 8022ac0:	613b      	str	r3, [r7, #16]
      if (event & mask)
 8022ac2:	697a      	ldr	r2, [r7, #20]
 8022ac4:	693b      	ldr	r3, [r7, #16]
 8022ac6:	4013      	ands	r3, r2
 8022ac8:	2b00      	cmp	r3, #0
 8022aca:	d014      	beq.n	8022af6 <XMC_DMA_IRQHandler+0x12e>
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)((uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE |
 8022acc:	69fb      	ldr	r3, [r7, #28]
 8022ace:	b2db      	uxtb	r3, r3
 8022ad0:	6878      	ldr	r0, [r7, #4]
 8022ad2:	4619      	mov	r1, r3
 8022ad4:	220e      	movs	r2, #14
 8022ad6:	f7ff ff3d 	bl	8022954 <XMC_DMA_CH_ClearEventStatus>
                                    (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE |
                                    (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE));

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
 8022ada:	69fb      	ldr	r3, [r7, #28]
 8022adc:	009b      	lsls	r3, r3, #2
 8022ade:	69ba      	ldr	r2, [r7, #24]
 8022ae0:	4413      	add	r3, r2
 8022ae2:	681b      	ldr	r3, [r3, #0]
 8022ae4:	60fb      	str	r3, [r7, #12]
        if (event_handler != NULL)
 8022ae6:	68fb      	ldr	r3, [r7, #12]
 8022ae8:	2b00      	cmp	r3, #0
 8022aea:	d003      	beq.n	8022af4 <XMC_DMA_IRQHandler+0x12c>
        {
          event_handler(XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE);
 8022aec:	68fb      	ldr	r3, [r7, #12]
 8022aee:	2002      	movs	r0, #2
 8022af0:	4798      	blx	r3
        }

        break;
 8022af2:	e007      	b.n	8022b04 <XMC_DMA_IRQHandler+0x13c>
 8022af4:	e006      	b.n	8022b04 <XMC_DMA_IRQHandler+0x13c>
      }
      ++channel;
 8022af6:	69fb      	ldr	r3, [r7, #28]
 8022af8:	3301      	adds	r3, #1
 8022afa:	61fb      	str	r3, [r7, #28]
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_BLOCK_TRANSFER_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsBlockCompleteStatus(dma);
    while (event != 0)
 8022afc:	697b      	ldr	r3, [r7, #20]
 8022afe:	2b00      	cmp	r3, #0
 8022b00:	d1da      	bne.n	8022ab8 <XMC_DMA_IRQHandler+0xf0>
 8022b02:	e061      	b.n	8022bc8 <XMC_DMA_IRQHandler+0x200>
 8022b04:	e060      	b.n	8022bc8 <XMC_DMA_IRQHandler+0x200>
        break;
      }
      ++channel;
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE) != (uint32_t)0UL)
 8022b06:	697b      	ldr	r3, [r7, #20]
 8022b08:	f003 0304 	and.w	r3, r3, #4
 8022b0c:	2b00      	cmp	r3, #0
 8022b0e:	d02b      	beq.n	8022b68 <XMC_DMA_IRQHandler+0x1a0>
  {
    event = XMC_DMA_GetChannelsSourceTransactionCompleteStatus(dma);
 8022b10:	6878      	ldr	r0, [r7, #4]
 8022b12:	f7ff fc37 	bl	8022384 <XMC_DMA_GetChannelsSourceTransactionCompleteStatus>
 8022b16:	6178      	str	r0, [r7, #20]
    while (event != 0)
 8022b18:	e021      	b.n	8022b5e <XMC_DMA_IRQHandler+0x196>
    {
      mask = (uint32_t)1U << channel;
 8022b1a:	2201      	movs	r2, #1
 8022b1c:	69fb      	ldr	r3, [r7, #28]
 8022b1e:	fa02 f303 	lsl.w	r3, r2, r3
 8022b22:	613b      	str	r3, [r7, #16]
      if (event & mask)
 8022b24:	697a      	ldr	r2, [r7, #20]
 8022b26:	693b      	ldr	r3, [r7, #16]
 8022b28:	4013      	ands	r3, r2
 8022b2a:	2b00      	cmp	r3, #0
 8022b2c:	d014      	beq.n	8022b58 <XMC_DMA_IRQHandler+0x190>
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE);
 8022b2e:	69fb      	ldr	r3, [r7, #28]
 8022b30:	b2db      	uxtb	r3, r3
 8022b32:	6878      	ldr	r0, [r7, #4]
 8022b34:	4619      	mov	r1, r3
 8022b36:	2204      	movs	r2, #4
 8022b38:	f7ff ff0c 	bl	8022954 <XMC_DMA_CH_ClearEventStatus>

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
 8022b3c:	69fb      	ldr	r3, [r7, #28]
 8022b3e:	009b      	lsls	r3, r3, #2
 8022b40:	69ba      	ldr	r2, [r7, #24]
 8022b42:	4413      	add	r3, r2
 8022b44:	681b      	ldr	r3, [r3, #0]
 8022b46:	60fb      	str	r3, [r7, #12]
        if (event_handler != NULL)
 8022b48:	68fb      	ldr	r3, [r7, #12]
 8022b4a:	2b00      	cmp	r3, #0
 8022b4c:	d003      	beq.n	8022b56 <XMC_DMA_IRQHandler+0x18e>
        {
          event_handler(XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE);
 8022b4e:	68fb      	ldr	r3, [r7, #12]
 8022b50:	2004      	movs	r0, #4
 8022b52:	4798      	blx	r3
        }

        break;
 8022b54:	e007      	b.n	8022b66 <XMC_DMA_IRQHandler+0x19e>
 8022b56:	e006      	b.n	8022b66 <XMC_DMA_IRQHandler+0x19e>
      }
      ++channel;
 8022b58:	69fb      	ldr	r3, [r7, #28]
 8022b5a:	3301      	adds	r3, #1
 8022b5c:	61fb      	str	r3, [r7, #28]
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_SRC_TRANSACTION_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsSourceTransactionCompleteStatus(dma);
    while (event != 0)
 8022b5e:	697b      	ldr	r3, [r7, #20]
 8022b60:	2b00      	cmp	r3, #0
 8022b62:	d1da      	bne.n	8022b1a <XMC_DMA_IRQHandler+0x152>
 8022b64:	e030      	b.n	8022bc8 <XMC_DMA_IRQHandler+0x200>
 8022b66:	e02f      	b.n	8022bc8 <XMC_DMA_IRQHandler+0x200>
        break;
      }
      ++channel;
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE) != (uint32_t)0UL)
 8022b68:	697b      	ldr	r3, [r7, #20]
 8022b6a:	f003 0308 	and.w	r3, r3, #8
 8022b6e:	2b00      	cmp	r3, #0
 8022b70:	d02a      	beq.n	8022bc8 <XMC_DMA_IRQHandler+0x200>
  {
    event = XMC_DMA_GetChannelsDestinationTransactionCompleteStatus(dma);
 8022b72:	6878      	ldr	r0, [r7, #4]
 8022b74:	f7ff fc14 	bl	80223a0 <XMC_DMA_GetChannelsDestinationTransactionCompleteStatus>
 8022b78:	6178      	str	r0, [r7, #20]
    while (event != 0)
 8022b7a:	e021      	b.n	8022bc0 <XMC_DMA_IRQHandler+0x1f8>
    {
      mask = (uint32_t)1U << channel;
 8022b7c:	2201      	movs	r2, #1
 8022b7e:	69fb      	ldr	r3, [r7, #28]
 8022b80:	fa02 f303 	lsl.w	r3, r2, r3
 8022b84:	613b      	str	r3, [r7, #16]
      if (event & mask)
 8022b86:	697a      	ldr	r2, [r7, #20]
 8022b88:	693b      	ldr	r3, [r7, #16]
 8022b8a:	4013      	ands	r3, r2
 8022b8c:	2b00      	cmp	r3, #0
 8022b8e:	d014      	beq.n	8022bba <XMC_DMA_IRQHandler+0x1f2>
      {
        XMC_DMA_CH_ClearEventStatus(dma, (uint8_t)channel, (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE);
 8022b90:	69fb      	ldr	r3, [r7, #28]
 8022b92:	b2db      	uxtb	r3, r3
 8022b94:	6878      	ldr	r0, [r7, #4]
 8022b96:	4619      	mov	r1, r3
 8022b98:	2208      	movs	r2, #8
 8022b9a:	f7ff fedb 	bl	8022954 <XMC_DMA_CH_ClearEventStatus>

        /* Call user callback to handle event */
        event_handler = dma_event_handlers[channel];
 8022b9e:	69fb      	ldr	r3, [r7, #28]
 8022ba0:	009b      	lsls	r3, r3, #2
 8022ba2:	69ba      	ldr	r2, [r7, #24]
 8022ba4:	4413      	add	r3, r2
 8022ba6:	681b      	ldr	r3, [r3, #0]
 8022ba8:	60fb      	str	r3, [r7, #12]
        if (event_handler != NULL)
 8022baa:	68fb      	ldr	r3, [r7, #12]
 8022bac:	2b00      	cmp	r3, #0
 8022bae:	d003      	beq.n	8022bb8 <XMC_DMA_IRQHandler+0x1f0>
        {
          event_handler(XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE);
 8022bb0:	68fb      	ldr	r3, [r7, #12]
 8022bb2:	2008      	movs	r0, #8
 8022bb4:	4798      	blx	r3
        }

        break;
 8022bb6:	e007      	b.n	8022bc8 <XMC_DMA_IRQHandler+0x200>
 8022bb8:	e006      	b.n	8022bc8 <XMC_DMA_IRQHandler+0x200>
      }
      ++channel;
 8022bba:	69fb      	ldr	r3, [r7, #28]
 8022bbc:	3301      	adds	r3, #1
 8022bbe:	61fb      	str	r3, [r7, #28]
    }
  }
  else if ((event & (uint32_t)XMC_DMA_CH_EVENT_DST_TRANSACTION_COMPLETE) != (uint32_t)0UL)
  {
    event = XMC_DMA_GetChannelsDestinationTransactionCompleteStatus(dma);
    while (event != 0)
 8022bc0:	697b      	ldr	r3, [r7, #20]
 8022bc2:	2b00      	cmp	r3, #0
 8022bc4:	d1da      	bne.n	8022b7c <XMC_DMA_IRQHandler+0x1b4>
 8022bc6:	e7ff      	b.n	8022bc8 <XMC_DMA_IRQHandler+0x200>
  else
  {
    /* no active interrupt was found? */
  }

}
 8022bc8:	3720      	adds	r7, #32
 8022bca:	46bd      	mov	sp, r7
 8022bcc:	bd80      	pop	{r7, pc}
 8022bce:	bf00      	nop
 8022bd0:	1fff17f4 	.word	0x1fff17f4

08022bd4 <XMC_ECAT_Enable>:
  ECAT0->MII_PDI_ACS_STATE = 0x0;
}

/* EtherCAT module clock ungating and deassert reset API (Enables ECAT) */
void XMC_ECAT_Enable(void)
{
 8022bd4:	b580      	push	{r7, lr}
 8022bd6:	af00      	add	r7, sp, #0
  XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_ECAT0);
 8022bd8:	4806      	ldr	r0, [pc, #24]	; (8022bf4 <XMC_ECAT_Enable+0x20>)
 8022bda:	f7ff f811 	bl	8021c00 <XMC_SCU_CLOCK_UngatePeripheralClock>
  XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_ECAT0);
 8022bde:	4805      	ldr	r0, [pc, #20]	; (8022bf4 <XMC_ECAT_Enable+0x20>)
 8022be0:	f7fe fe8a 	bl	80218f8 <XMC_SCU_RESET_DeassertPeripheralReset>

  while (XMC_SCU_RESET_IsPeripheralResetAsserted(XMC_SCU_PERIPHERAL_RESET_ECAT0) == true) {}
 8022be4:	bf00      	nop
 8022be6:	4803      	ldr	r0, [pc, #12]	; (8022bf4 <XMC_ECAT_Enable+0x20>)
 8022be8:	f7fe fea2 	bl	8021930 <XMC_SCU_RESET_IsPeripheralResetAsserted>
 8022bec:	4603      	mov	r3, r0
 8022bee:	2b00      	cmp	r3, #0
 8022bf0:	d1f9      	bne.n	8022be6 <XMC_ECAT_Enable+0x12>
}
 8022bf2:	bd80      	pop	{r7, pc}
 8022bf4:	20000400 	.word	0x20000400

08022bf8 <XMC_ECAT_Init>:
  XMC_SCU_CLOCK_GatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_ECAT0);
}

/* EtherCAT initialization function */
void XMC_ECAT_Init(XMC_ECAT_CONFIG_t *const config)
{
 8022bf8:	b580      	push	{r7, lr}
 8022bfa:	b082      	sub	sp, #8
 8022bfc:	af00      	add	r7, sp, #0
 8022bfe:	6078      	str	r0, [r7, #4]
  XMC_ECAT_Enable();
 8022c00:	f7ff ffe8 	bl	8022bd4 <XMC_ECAT_Enable>

  /* The process memory is not accessible until the ESC Configuration Area is loaded successfully. */

  /* words 0x0-0x3 */
  ECAT0->EEP_DATA[0U] = config->dword[0U];
 8022c04:	4a19      	ldr	r2, [pc, #100]	; (8022c6c <XMC_ECAT_Init+0x74>)
 8022c06:	687b      	ldr	r3, [r7, #4]
 8022c08:	681b      	ldr	r3, [r3, #0]
 8022c0a:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
  ECAT0->EEP_DATA[1U] = config->dword[1U];
 8022c0e:	4a17      	ldr	r2, [pc, #92]	; (8022c6c <XMC_ECAT_Init+0x74>)
 8022c10:	687b      	ldr	r3, [r7, #4]
 8022c12:	685b      	ldr	r3, [r3, #4]
 8022c14:	f8c2 350c 	str.w	r3, [r2, #1292]	; 0x50c
  ECAT0->EEP_CONT_STAT |= (uint16_t)((uint16_t)0x4U << (uint16_t)ECAT_EEP_CONT_STAT_CMD_REG_Pos);
 8022c18:	4a14      	ldr	r2, [pc, #80]	; (8022c6c <XMC_ECAT_Init+0x74>)
 8022c1a:	4b14      	ldr	r3, [pc, #80]	; (8022c6c <XMC_ECAT_Init+0x74>)
 8022c1c:	f8b3 3502 	ldrh.w	r3, [r3, #1282]	; 0x502
 8022c20:	b29b      	uxth	r3, r3
 8022c22:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8022c26:	b29b      	uxth	r3, r3
 8022c28:	f8a2 3502 	strh.w	r3, [r2, #1282]	; 0x502

  /* words 0x4-0x7 */
  ECAT0->EEP_DATA[0U] = config->dword[2U];
 8022c2c:	4a0f      	ldr	r2, [pc, #60]	; (8022c6c <XMC_ECAT_Init+0x74>)
 8022c2e:	687b      	ldr	r3, [r7, #4]
 8022c30:	689b      	ldr	r3, [r3, #8]
 8022c32:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
  ECAT0->EEP_DATA[1U] = config->dword[3U];
 8022c36:	4a0d      	ldr	r2, [pc, #52]	; (8022c6c <XMC_ECAT_Init+0x74>)
 8022c38:	687b      	ldr	r3, [r7, #4]
 8022c3a:	68db      	ldr	r3, [r3, #12]
 8022c3c:	f8c2 350c 	str.w	r3, [r2, #1292]	; 0x50c
  ECAT0->EEP_CONT_STAT |= (uint16_t)((uint16_t)0x4U << (uint16_t)ECAT_EEP_CONT_STAT_CMD_REG_Pos);
 8022c40:	4a0a      	ldr	r2, [pc, #40]	; (8022c6c <XMC_ECAT_Init+0x74>)
 8022c42:	4b0a      	ldr	r3, [pc, #40]	; (8022c6c <XMC_ECAT_Init+0x74>)
 8022c44:	f8b3 3502 	ldrh.w	r3, [r3, #1282]	; 0x502
 8022c48:	b29b      	uxth	r3, r3
 8022c4a:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8022c4e:	b29b      	uxth	r3, r3
 8022c50:	f8a2 3502 	strh.w	r3, [r2, #1282]	; 0x502

  while (ECAT0->EEP_CONT_STAT & ECAT_EEP_CONT_STAT_L_STAT_Msk)
 8022c54:	bf00      	nop
 8022c56:	4b05      	ldr	r3, [pc, #20]	; (8022c6c <XMC_ECAT_Init+0x74>)
 8022c58:	f8b3 3502 	ldrh.w	r3, [r3, #1282]	; 0x502
 8022c5c:	b29b      	uxth	r3, r3
 8022c5e:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8022c62:	2b00      	cmp	r3, #0
 8022c64:	d1f7      	bne.n	8022c56 <XMC_ECAT_Init+0x5e>
  {
    /* Wait until the EEPROM_Loaded signal is active */
  }

}
 8022c66:	3708      	adds	r7, #8
 8022c68:	46bd      	mov	sp, r7
 8022c6a:	bd80      	pop	{r7, pc}
 8022c6c:	54010000 	.word	0x54010000

08022c70 <XMC_ECAT_DisableEvent>:
{
  ECAT0->AL_EVENT_MASK |= event;
}
/* EtherCAT application event disable API */
void XMC_ECAT_DisableEvent(uint32_t event)
{
 8022c70:	b480      	push	{r7}
 8022c72:	b083      	sub	sp, #12
 8022c74:	af00      	add	r7, sp, #0
 8022c76:	6078      	str	r0, [r7, #4]
  ECAT0->AL_EVENT_MASK &= ~event;
 8022c78:	4906      	ldr	r1, [pc, #24]	; (8022c94 <XMC_ECAT_DisableEvent+0x24>)
 8022c7a:	4b06      	ldr	r3, [pc, #24]	; (8022c94 <XMC_ECAT_DisableEvent+0x24>)
 8022c7c:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 8022c80:	687b      	ldr	r3, [r7, #4]
 8022c82:	43db      	mvns	r3, r3
 8022c84:	4013      	ands	r3, r2
 8022c86:	f8c1 3204 	str.w	r3, [r1, #516]	; 0x204
}
 8022c8a:	370c      	adds	r7, #12
 8022c8c:	46bd      	mov	sp, r7
 8022c8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022c92:	4770      	bx	lr
 8022c94:	54010000 	.word	0x54010000

08022c98 <XMC_ECAT_DisableSyncManChannel>:
  return (ECAT0->AL_EVENT_REQ);
}

/* EtherCAT SyncManager channel disable function*/
void XMC_ECAT_DisableSyncManChannel(const uint8_t channel)
{
 8022c98:	b480      	push	{r7}
 8022c9a:	b083      	sub	sp, #12
 8022c9c:	af00      	add	r7, sp, #0
 8022c9e:	4603      	mov	r3, r0
 8022ca0:	71fb      	strb	r3, [r7, #7]
  ((ECAT0_SM_Type *)(void *)((uint8_t *)(void *)ECAT0_SM0 + (channel * 8U)))->SM_PDI_CTR |= 0x1U;
 8022ca2:	79fb      	ldrb	r3, [r7, #7]
 8022ca4:	00db      	lsls	r3, r3, #3
 8022ca6:	f103 43a8 	add.w	r3, r3, #1409286144	; 0x54000000
 8022caa:	f503 3384 	add.w	r3, r3, #67584	; 0x10800
 8022cae:	79fa      	ldrb	r2, [r7, #7]
 8022cb0:	00d2      	lsls	r2, r2, #3
 8022cb2:	f102 42a8 	add.w	r2, r2, #1409286144	; 0x54000000
 8022cb6:	f502 3284 	add.w	r2, r2, #67584	; 0x10800
 8022cba:	79d2      	ldrb	r2, [r2, #7]
 8022cbc:	b2d2      	uxtb	r2, r2
 8022cbe:	f042 0201 	orr.w	r2, r2, #1
 8022cc2:	b2d2      	uxtb	r2, r2
 8022cc4:	71da      	strb	r2, [r3, #7]
}
 8022cc6:	370c      	adds	r7, #12
 8022cc8:	46bd      	mov	sp, r7
 8022cca:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022cce:	4770      	bx	lr

08022cd0 <XMC_FCE_Init>:
/*
 * Initialize the FCE peripheral:
 * Update FCE configuration and initialize seed value
 */
XMC_FCE_STATUS_t XMC_FCE_Init(const XMC_FCE_t *const engine)
{
 8022cd0:	b480      	push	{r7}
 8022cd2:	b083      	sub	sp, #12
 8022cd4:	af00      	add	r7, sp, #0
 8022cd6:	6078      	str	r0, [r7, #4]
  engine->kernel_ptr->CFG = engine->fce_cfg_update.regval;
 8022cd8:	687b      	ldr	r3, [r7, #4]
 8022cda:	681b      	ldr	r3, [r3, #0]
 8022cdc:	687a      	ldr	r2, [r7, #4]
 8022cde:	6852      	ldr	r2, [r2, #4]
 8022ce0:	609a      	str	r2, [r3, #8]
  engine->kernel_ptr->CRC = engine->seedvalue;
 8022ce2:	687b      	ldr	r3, [r7, #4]
 8022ce4:	681b      	ldr	r3, [r3, #0]
 8022ce6:	687a      	ldr	r2, [r7, #4]
 8022ce8:	6892      	ldr	r2, [r2, #8]
 8022cea:	619a      	str	r2, [r3, #24]

  return XMC_FCE_STATUS_OK;
 8022cec:	2300      	movs	r3, #0
}
 8022cee:	4618      	mov	r0, r3
 8022cf0:	370c      	adds	r7, #12
 8022cf2:	46bd      	mov	sp, r7
 8022cf4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022cf8:	4770      	bx	lr
 8022cfa:	bf00      	nop

08022cfc <XMC_FCE_Enable>:

}

/* Enable FCE */
void XMC_FCE_Enable(void)
{
 8022cfc:	b580      	push	{r7, lr}
 8022cfe:	af00      	add	r7, sp, #0
#if defined(CLOCK_GATING_SUPPORTED)
  XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_FCE);
 8022d00:	4806      	ldr	r0, [pc, #24]	; (8022d1c <XMC_FCE_Enable+0x20>)
 8022d02:	f7fe ff7d 	bl	8021c00 <XMC_SCU_CLOCK_UngatePeripheralClock>
#endif

  XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_FCE);
 8022d06:	4805      	ldr	r0, [pc, #20]	; (8022d1c <XMC_FCE_Enable+0x20>)
 8022d08:	f7fe fdf6 	bl	80218f8 <XMC_SCU_RESET_DeassertPeripheralReset>

  FCE->CLC &= (uint32_t)~FCE_CLC_DISR_Msk;
 8022d0c:	4a04      	ldr	r2, [pc, #16]	; (8022d20 <XMC_FCE_Enable+0x24>)
 8022d0e:	4b04      	ldr	r3, [pc, #16]	; (8022d20 <XMC_FCE_Enable+0x24>)
 8022d10:	681b      	ldr	r3, [r3, #0]
 8022d12:	f023 0301 	bic.w	r3, r3, #1
 8022d16:	6013      	str	r3, [r2, #0]
}
 8022d18:	bd80      	pop	{r7, pc}
 8022d1a:	bf00      	nop
 8022d1c:	20000040 	.word	0x20000040
 8022d20:	50020000 	.word	0x50020000

08022d24 <XMC_FCE_CalculateCRC32>:
/* Calculate and return the IEEE 802.3 Ethernet CRC32 checksum */
XMC_FCE_STATUS_t XMC_FCE_CalculateCRC32(const XMC_FCE_t *const engine,
                                        const uint32_t *data,
                                        uint32_t length,
                                        uint32_t *result)
{
 8022d24:	b480      	push	{r7}
 8022d26:	b087      	sub	sp, #28
 8022d28:	af00      	add	r7, sp, #0
 8022d2a:	60f8      	str	r0, [r7, #12]
 8022d2c:	60b9      	str	r1, [r7, #8]
 8022d2e:	607a      	str	r2, [r7, #4]
 8022d30:	603b      	str	r3, [r7, #0]
  XMC_FCE_STATUS_t status = XMC_FCE_STATUS_OK;
 8022d32:	2300      	movs	r3, #0
 8022d34:	75fb      	strb	r3, [r7, #23]
             (engine->kernel_ptr == XMC_FCE_CRC32_1)));
  XMC_ASSERT("XMC_FCE_CalculateCRC32: Length field is empty", (length != 0));
  XMC_ASSERT("XMC_FCE_CalculateCRC32: Length is not aligned", ((length & 0x3U) == 0));

  /* Check length is a multiple of 4 */
  if ((length == 0) || ((length & 0x3U) != 0U))
 8022d36:	687b      	ldr	r3, [r7, #4]
 8022d38:	2b00      	cmp	r3, #0
 8022d3a:	d004      	beq.n	8022d46 <XMC_FCE_CalculateCRC32+0x22>
 8022d3c:	687b      	ldr	r3, [r7, #4]
 8022d3e:	f003 0303 	and.w	r3, r3, #3
 8022d42:	2b00      	cmp	r3, #0
 8022d44:	d002      	beq.n	8022d4c <XMC_FCE_CalculateCRC32+0x28>
  {
    status = XMC_FCE_STATUS_ERROR;
 8022d46:	2302      	movs	r3, #2
 8022d48:	75fb      	strb	r3, [r7, #23]
 8022d4a:	e013      	b.n	8022d74 <XMC_FCE_CalculateCRC32+0x50>
  }
  else
  {
    while (0UL != length)
 8022d4c:	e00a      	b.n	8022d64 <XMC_FCE_CalculateCRC32+0x40>
    {
      engine->kernel_ptr->IR = *data;
 8022d4e:	68fb      	ldr	r3, [r7, #12]
 8022d50:	681b      	ldr	r3, [r3, #0]
 8022d52:	68ba      	ldr	r2, [r7, #8]
 8022d54:	6812      	ldr	r2, [r2, #0]
 8022d56:	601a      	str	r2, [r3, #0]
      data++;
 8022d58:	68bb      	ldr	r3, [r7, #8]
 8022d5a:	3304      	adds	r3, #4
 8022d5c:	60bb      	str	r3, [r7, #8]
      length -= 4U;
 8022d5e:	687b      	ldr	r3, [r7, #4]
 8022d60:	3b04      	subs	r3, #4
 8022d62:	607b      	str	r3, [r7, #4]
  {
    status = XMC_FCE_STATUS_ERROR;
  }
  else
  {
    while (0UL != length)
 8022d64:	687b      	ldr	r3, [r7, #4]
 8022d66:	2b00      	cmp	r3, #0
 8022d68:	d1f1      	bne.n	8022d4e <XMC_FCE_CalculateCRC32+0x2a>
      engine->kernel_ptr->IR = *data;
      data++;
      length -= 4U;
    }

    *result = engine->kernel_ptr->CRC;
 8022d6a:	68fb      	ldr	r3, [r7, #12]
 8022d6c:	681b      	ldr	r3, [r3, #0]
 8022d6e:	699a      	ldr	r2, [r3, #24]
 8022d70:	683b      	ldr	r3, [r7, #0]
 8022d72:	601a      	str	r2, [r3, #0]
  }

  return status;
 8022d74:	7dfb      	ldrb	r3, [r7, #23]
}
 8022d76:	4618      	mov	r0, r3
 8022d78:	371c      	adds	r7, #28
 8022d7a:	46bd      	mov	sp, r7
 8022d7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022d80:	4770      	bx	lr
 8022d82:	bf00      	nop

08022d84 <XMC_GPIO_SetHardwareControl>:
  port->IOCR[(uint32_t)pin >> 2U] &= ~(uint32_t)((uint32_t)PORT_IOCR_PC_Msk << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U)));
  port->IOCR[(uint32_t)pin >> 2U] |= (uint32_t)mode << ((uint32_t)PORT_IOCR_PC_Size * ((uint32_t)pin & 0x3U));
}

void XMC_GPIO_SetHardwareControl(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_HWCTRL_t hwctrl)
{
 8022d84:	b480      	push	{r7}
 8022d86:	b083      	sub	sp, #12
 8022d88:	af00      	add	r7, sp, #0
 8022d8a:	6078      	str	r0, [r7, #4]
 8022d8c:	460b      	mov	r3, r1
 8022d8e:	70fb      	strb	r3, [r7, #3]
 8022d90:	4613      	mov	r3, r2
 8022d92:	70bb      	strb	r3, [r7, #2]
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid port", XMC_GPIO_CHECK_PORT(port));
  XMC_ASSERT("XMC_GPIO_SetHardwareControl: Invalid hwctrl", XMC_GPIO_CHECK_HWCTRL(hwctrl));

  port->HWSEL &= ~(uint32_t)((uint32_t)PORT_HWSEL_Msk << ((uint32_t)pin << 1U));
 8022d94:	687b      	ldr	r3, [r7, #4]
 8022d96:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8022d98:	78fb      	ldrb	r3, [r7, #3]
 8022d9a:	005b      	lsls	r3, r3, #1
 8022d9c:	4619      	mov	r1, r3
 8022d9e:	2303      	movs	r3, #3
 8022da0:	408b      	lsls	r3, r1
 8022da2:	43db      	mvns	r3, r3
 8022da4:	401a      	ands	r2, r3
 8022da6:	687b      	ldr	r3, [r7, #4]
 8022da8:	675a      	str	r2, [r3, #116]	; 0x74
  port->HWSEL |= (uint32_t)hwctrl << ((uint32_t)pin << 1U);
 8022daa:	687b      	ldr	r3, [r7, #4]
 8022dac:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8022dae:	78bb      	ldrb	r3, [r7, #2]
 8022db0:	78f9      	ldrb	r1, [r7, #3]
 8022db2:	0049      	lsls	r1, r1, #1
 8022db4:	408b      	lsls	r3, r1
 8022db6:	431a      	orrs	r2, r3
 8022db8:	687b      	ldr	r3, [r7, #4]
 8022dba:	675a      	str	r2, [r3, #116]	; 0x74
}
 8022dbc:	370c      	adds	r7, #12
 8022dbe:	46bd      	mov	sp, r7
 8022dc0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022dc4:	4770      	bx	lr
 8022dc6:	bf00      	nop

08022dc8 <XMC_SPI_CH_InitEx>:
 * API IMPLEMENTATION
 ********************************************************************************************************************/

/* Initializes the selected SPI channel with the config structure. */
void XMC_SPI_CH_InitEx(XMC_USIC_CH_t *const channel, const XMC_SPI_CH_CONFIG_t *const config, bool init_brg)
{
 8022dc8:	b580      	push	{r7, lr}
 8022dca:	b084      	sub	sp, #16
 8022dcc:	af00      	add	r7, sp, #0
 8022dce:	60f8      	str	r0, [r7, #12]
 8022dd0:	60b9      	str	r1, [r7, #8]
 8022dd2:	4613      	mov	r3, r2
 8022dd4:	71fb      	strb	r3, [r7, #7]
  XMC_USIC_CH_Enable(channel);
 8022dd6:	68f8      	ldr	r0, [r7, #12]
 8022dd8:	f000 f88c 	bl	8022ef4 <XMC_USIC_CH_Enable>

  if ((config->bus_mode == XMC_SPI_CH_BUS_MODE_MASTER) && init_brg)
 8022ddc:	68bb      	ldr	r3, [r7, #8]
 8022dde:	795b      	ldrb	r3, [r3, #5]
 8022de0:	2b00      	cmp	r3, #0
 8022de2:	d115      	bne.n	8022e10 <XMC_SPI_CH_InitEx+0x48>
 8022de4:	79fb      	ldrb	r3, [r7, #7]
 8022de6:	2b00      	cmp	r3, #0
 8022de8:	d012      	beq.n	8022e10 <XMC_SPI_CH_InitEx+0x48>
  {
    /* Configure baud rate */
    if (config->normal_divider_mode)
 8022dea:	68bb      	ldr	r3, [r7, #8]
 8022dec:	791b      	ldrb	r3, [r3, #4]
 8022dee:	2b00      	cmp	r3, #0
 8022df0:	d007      	beq.n	8022e02 <XMC_SPI_CH_InitEx+0x3a>
    {
      /* Normal divider mode */
      (void)XMC_USIC_CH_SetBaudrateEx(channel, config->baudrate, XMC_SPI_CH_OVERSAMPLING);
 8022df2:	68bb      	ldr	r3, [r7, #8]
 8022df4:	681b      	ldr	r3, [r3, #0]
 8022df6:	68f8      	ldr	r0, [r7, #12]
 8022df8:	4619      	mov	r1, r3
 8022dfa:	2202      	movs	r2, #2
 8022dfc:	f000 f926 	bl	802304c <XMC_USIC_CH_SetBaudrateEx>
 8022e00:	e006      	b.n	8022e10 <XMC_SPI_CH_InitEx+0x48>
    }
    else
    {
      /* Fractional divider mode */
      (void)XMC_USIC_CH_SetBaudrate(channel, config->baudrate, XMC_SPI_CH_OVERSAMPLING);
 8022e02:	68bb      	ldr	r3, [r7, #8]
 8022e04:	681b      	ldr	r3, [r3, #0]
 8022e06:	68f8      	ldr	r0, [r7, #12]
 8022e08:	4619      	mov	r1, r3
 8022e0a:	2202      	movs	r2, #2
 8022e0c:	f000 f8ac 	bl	8022f68 <XMC_USIC_CH_SetBaudrate>
  }

  /* Configuration of USIC Shift Control */
  /* Transmission Mode (TRM) = 1  */
  /* Passive Data Level (PDL) = 1 */
  channel->SCTR = USIC_CH_SCTR_PDL_Msk |
 8022e10:	68fb      	ldr	r3, [r7, #12]
 8022e12:	4a0f      	ldr	r2, [pc, #60]	; (8022e50 <XMC_SPI_CH_InitEx+0x88>)
 8022e14:	635a      	str	r2, [r3, #52]	; 0x34
                  (0x7UL << USIC_CH_SCTR_WLE_Pos);

  /* Configuration of USIC Transmit Control/Status Register */
  /* TBUF Data Enable (TDEN) = 1 */
  /* TBUF Data Single Shot Mode (TDSSM) = 1 */
  channel->TCSR = (uint32_t)(USIC_CH_TCSR_HPCMD_Msk |
 8022e16:	68fb      	ldr	r3, [r7, #12]
 8022e18:	f44f 62a2 	mov.w	r2, #1296	; 0x510
 8022e1c:	639a      	str	r2, [r3, #56]	; 0x38
                             (0x01UL  << USIC_CH_TCSR_TDEN_Pos) |
                             USIC_CH_TCSR_TDSSM_Msk);

  if (config->bus_mode == XMC_SPI_CH_BUS_MODE_MASTER)
 8022e1e:	68bb      	ldr	r3, [r7, #8]
 8022e20:	795b      	ldrb	r3, [r3, #5]
 8022e22:	2b00      	cmp	r3, #0
 8022e24:	d107      	bne.n	8022e36 <XMC_SPI_CH_InitEx+0x6e>
  {
    /* Configuration of Protocol Control Register */
    channel->PCR_SSCMode = (uint32_t)(USIC_CH_PCR_SSCMode_MSLSEN_Msk |
                                      USIC_CH_PCR_SSCMode_SELCTR_Msk |
                                      (uint32_t)config->selo_inversion |
 8022e26:	68bb      	ldr	r3, [r7, #8]
 8022e28:	799b      	ldrb	r3, [r3, #6]
                             USIC_CH_TCSR_TDSSM_Msk);

  if (config->bus_mode == XMC_SPI_CH_BUS_MODE_MASTER)
  {
    /* Configuration of Protocol Control Register */
    channel->PCR_SSCMode = (uint32_t)(USIC_CH_PCR_SSCMode_MSLSEN_Msk |
 8022e2a:	f043 030b 	orr.w	r3, r3, #11
 8022e2e:	b2db      	uxtb	r3, r3
 8022e30:	461a      	mov	r2, r3
 8022e32:	68fb      	ldr	r3, [r7, #12]
 8022e34:	63da      	str	r2, [r3, #60]	; 0x3c
                                      (uint32_t)config->selo_inversion |
                                      USIC_CH_PCR_SSCMode_FEM_Msk);
  }

  /* Clear protocol status */
  channel->PSCR = 0xFFFFFFFFUL;
 8022e36:	68fb      	ldr	r3, [r7, #12]
 8022e38:	f04f 32ff 	mov.w	r2, #4294967295
 8022e3c:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Set parity settings */
  channel->CCR = (uint32_t)config->parity_mode;
 8022e3e:	68bb      	ldr	r3, [r7, #8]
 8022e40:	891b      	ldrh	r3, [r3, #8]
 8022e42:	461a      	mov	r2, r3
 8022e44:	68fb      	ldr	r3, [r7, #12]
 8022e46:	641a      	str	r2, [r3, #64]	; 0x40
}
 8022e48:	3710      	adds	r7, #16
 8022e4a:	46bd      	mov	sp, r7
 8022e4c:	bd80      	pop	{r7, pc}
 8022e4e:	bf00      	nop
 8022e50:	073f0102 	.word	0x073f0102

08022e54 <XMC_SPI_CH_GetReceivedData>:
  }
}

/* Reads the data from the buffers based on the FIFO mode selection. */
uint16_t XMC_SPI_CH_GetReceivedData(XMC_USIC_CH_t *const channel)
{
 8022e54:	b480      	push	{r7}
 8022e56:	b085      	sub	sp, #20
 8022e58:	af00      	add	r7, sp, #0
 8022e5a:	6078      	str	r0, [r7, #4]
  uint16_t retval;

  /* Check FIFO size */
  if ((channel->RBCTR & USIC_CH_RBCTR_SIZE_Msk) == 0U)
 8022e5c:	687b      	ldr	r3, [r7, #4]
 8022e5e:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
 8022e62:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
 8022e66:	2b00      	cmp	r3, #0
 8022e68:	d103      	bne.n	8022e72 <XMC_SPI_CH_GetReceivedData+0x1e>
  {
    retval = (uint16_t)channel->RBUF;
 8022e6a:	687b      	ldr	r3, [r7, #4]
 8022e6c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8022e6e:	81fb      	strh	r3, [r7, #14]
 8022e70:	e003      	b.n	8022e7a <XMC_SPI_CH_GetReceivedData+0x26>
  }
  else
  {
    retval = (uint16_t)channel->OUTR;
 8022e72:	687b      	ldr	r3, [r7, #4]
 8022e74:	f8d3 311c 	ldr.w	r3, [r3, #284]	; 0x11c
 8022e78:	81fb      	strh	r3, [r7, #14]
  }

  return retval;
 8022e7a:	89fb      	ldrh	r3, [r7, #14]
}
 8022e7c:	4618      	mov	r0, r3
 8022e7e:	3714      	adds	r7, #20
 8022e80:	46bd      	mov	sp, r7
 8022e82:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022e86:	4770      	bx	lr

08022e88 <XMC_SPI_CH_EnableEvent>:

  return status;
}

void XMC_SPI_CH_EnableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
 8022e88:	b480      	push	{r7}
 8022e8a:	b083      	sub	sp, #12
 8022e8c:	af00      	add	r7, sp, #0
 8022e8e:	6078      	str	r0, [r7, #4]
 8022e90:	6039      	str	r1, [r7, #0]
  channel->CCR |= (event & 0x1fc00U);
 8022e92:	687b      	ldr	r3, [r7, #4]
 8022e94:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8022e96:	683b      	ldr	r3, [r7, #0]
 8022e98:	f403 33fe 	and.w	r3, r3, #130048	; 0x1fc00
 8022e9c:	431a      	orrs	r2, r3
 8022e9e:	687b      	ldr	r3, [r7, #4]
 8022ea0:	641a      	str	r2, [r3, #64]	; 0x40
  channel->PCR_SSCMode |= ((event << 13U) & 0xe000U);
 8022ea2:	687b      	ldr	r3, [r7, #4]
 8022ea4:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8022ea6:	683b      	ldr	r3, [r7, #0]
 8022ea8:	035b      	lsls	r3, r3, #13
 8022eaa:	b29b      	uxth	r3, r3
 8022eac:	431a      	orrs	r2, r3
 8022eae:	687b      	ldr	r3, [r7, #4]
 8022eb0:	63da      	str	r2, [r3, #60]	; 0x3c
}
 8022eb2:	370c      	adds	r7, #12
 8022eb4:	46bd      	mov	sp, r7
 8022eb6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022eba:	4770      	bx	lr

08022ebc <XMC_SPI_CH_DisableEvent>:

void XMC_SPI_CH_DisableEvent(XMC_USIC_CH_t *const channel, const uint32_t event)
{
 8022ebc:	b480      	push	{r7}
 8022ebe:	b083      	sub	sp, #12
 8022ec0:	af00      	add	r7, sp, #0
 8022ec2:	6078      	str	r0, [r7, #4]
 8022ec4:	6039      	str	r1, [r7, #0]
  channel->CCR &= (uint32_t)~(event & 0x1fc00U);
 8022ec6:	687b      	ldr	r3, [r7, #4]
 8022ec8:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8022eca:	683b      	ldr	r3, [r7, #0]
 8022ecc:	f403 33fe 	and.w	r3, r3, #130048	; 0x1fc00
 8022ed0:	43db      	mvns	r3, r3
 8022ed2:	401a      	ands	r2, r3
 8022ed4:	687b      	ldr	r3, [r7, #4]
 8022ed6:	641a      	str	r2, [r3, #64]	; 0x40
  channel->PCR_SSCMode &= (uint32_t)~((event << 13U) & 0xe000U);
 8022ed8:	687b      	ldr	r3, [r7, #4]
 8022eda:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8022edc:	683b      	ldr	r3, [r7, #0]
 8022ede:	035b      	lsls	r3, r3, #13
 8022ee0:	b29b      	uxth	r3, r3
 8022ee2:	43db      	mvns	r3, r3
 8022ee4:	401a      	ands	r2, r3
 8022ee6:	687b      	ldr	r3, [r7, #4]
 8022ee8:	63da      	str	r2, [r3, #60]	; 0x3c
}
 8022eea:	370c      	adds	r7, #12
 8022eec:	46bd      	mov	sp, r7
 8022eee:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022ef2:	4770      	bx	lr

08022ef4 <XMC_USIC_CH_Enable>:
/*******************************************************************************
 * API IMPLEMENTATION
 *******************************************************************************/

void XMC_USIC_CH_Enable(XMC_USIC_CH_t *const channel)
{
 8022ef4:	b580      	push	{r7, lr}
 8022ef6:	b082      	sub	sp, #8
 8022ef8:	af00      	add	r7, sp, #0
 8022efa:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_USIC_CH_Enable: channel not valid", XMC_USIC_IsChannelValid(channel));

  if ((channel == XMC_USIC0_CH0) || (channel == XMC_USIC0_CH1))
 8022efc:	687b      	ldr	r3, [r7, #4]
 8022efe:	4a14      	ldr	r2, [pc, #80]	; (8022f50 <XMC_USIC_CH_Enable+0x5c>)
 8022f00:	4293      	cmp	r3, r2
 8022f02:	d003      	beq.n	8022f0c <XMC_USIC_CH_Enable+0x18>
 8022f04:	687b      	ldr	r3, [r7, #4]
 8022f06:	4a13      	ldr	r2, [pc, #76]	; (8022f54 <XMC_USIC_CH_Enable+0x60>)
 8022f08:	4293      	cmp	r3, r2
 8022f0a:	d103      	bne.n	8022f14 <XMC_USIC_CH_Enable+0x20>
  {
    XMC_USIC_Enable(XMC_USIC0);
 8022f0c:	4812      	ldr	r0, [pc, #72]	; (8022f58 <XMC_USIC_CH_Enable+0x64>)
 8022f0e:	f000 f939 	bl	8023184 <XMC_USIC_Enable>
 8022f12:	e00a      	b.n	8022f2a <XMC_USIC_CH_Enable+0x36>
  }
#if defined(USIC1)
  else if ((channel == XMC_USIC1_CH0) || (channel == XMC_USIC1_CH1))
 8022f14:	687b      	ldr	r3, [r7, #4]
 8022f16:	4a11      	ldr	r2, [pc, #68]	; (8022f5c <XMC_USIC_CH_Enable+0x68>)
 8022f18:	4293      	cmp	r3, r2
 8022f1a:	d003      	beq.n	8022f24 <XMC_USIC_CH_Enable+0x30>
 8022f1c:	687b      	ldr	r3, [r7, #4]
 8022f1e:	4a10      	ldr	r2, [pc, #64]	; (8022f60 <XMC_USIC_CH_Enable+0x6c>)
 8022f20:	4293      	cmp	r3, r2
 8022f22:	d102      	bne.n	8022f2a <XMC_USIC_CH_Enable+0x36>
  {
    XMC_USIC_Enable(XMC_USIC1);
 8022f24:	480f      	ldr	r0, [pc, #60]	; (8022f64 <XMC_USIC_CH_Enable+0x70>)
 8022f26:	f000 f92d 	bl	8023184 <XMC_USIC_Enable>
  {
    XMC_ASSERT("USIC module not available", 0U/*Always*/);
  }

  /* USIC channel switched on*/
  channel->KSCFG = (USIC_CH_KSCFG_MODEN_Msk | USIC_CH_KSCFG_BPMODEN_Msk);
 8022f2a:	687b      	ldr	r3, [r7, #4]
 8022f2c:	2203      	movs	r2, #3
 8022f2e:	60da      	str	r2, [r3, #12]
  while ((channel->KSCFG & USIC_CH_KSCFG_MODEN_Msk) == 0U)
 8022f30:	bf00      	nop
 8022f32:	687b      	ldr	r3, [r7, #4]
 8022f34:	68db      	ldr	r3, [r3, #12]
 8022f36:	f003 0301 	and.w	r3, r3, #1
 8022f3a:	2b00      	cmp	r3, #0
 8022f3c:	d0f9      	beq.n	8022f32 <XMC_USIC_CH_Enable+0x3e>
  {
    /* Wait till the channel is enabled */
  }

  /* Set USIC channel in IDLE mode */
  channel->CCR &= (uint32_t)~USIC_CH_CCR_MODE_Msk;
 8022f3e:	687b      	ldr	r3, [r7, #4]
 8022f40:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8022f42:	f023 020f 	bic.w	r2, r3, #15
 8022f46:	687b      	ldr	r3, [r7, #4]
 8022f48:	641a      	str	r2, [r3, #64]	; 0x40
}
 8022f4a:	3708      	adds	r7, #8
 8022f4c:	46bd      	mov	sp, r7
 8022f4e:	bd80      	pop	{r7, pc}
 8022f50:	40030000 	.word	0x40030000
 8022f54:	40030200 	.word	0x40030200
 8022f58:	40030008 	.word	0x40030008
 8022f5c:	48020000 	.word	0x48020000
 8022f60:	48020200 	.word	0x48020200
 8022f64:	48020008 	.word	0x48020008

08022f68 <XMC_USIC_CH_SetBaudrate>:
{
  channel->KSCFG = (uint32_t)((channel->KSCFG & (~USIC_CH_KSCFG_MODEN_Msk)) | USIC_CH_KSCFG_BPMODEN_Msk);
}

XMC_USIC_CH_STATUS_t XMC_USIC_CH_SetBaudrate(XMC_USIC_CH_t *const channel, uint32_t rate, uint32_t oversampling)
{
 8022f68:	b580      	push	{r7, lr}
 8022f6a:	b08e      	sub	sp, #56	; 0x38
 8022f6c:	af00      	add	r7, sp, #0
 8022f6e:	60f8      	str	r0, [r7, #12]
 8022f70:	60b9      	str	r1, [r7, #8]
 8022f72:	607a      	str	r2, [r7, #4]

  uint32_t pdiv_frac;
  uint32_t pdiv_frac_min;

  /* The rate and peripheral clock are divided by 100 to be able to use only 32bit arithmetic */
  if ((rate >= 100U) && (oversampling != 0U))
 8022f74:	68bb      	ldr	r3, [r7, #8]
 8022f76:	2b63      	cmp	r3, #99	; 0x63
 8022f78:	d95a      	bls.n	8023030 <XMC_USIC_CH_SetBaudrate+0xc8>
 8022f7a:	687b      	ldr	r3, [r7, #4]
 8022f7c:	2b00      	cmp	r3, #0
 8022f7e:	d057      	beq.n	8023030 <XMC_USIC_CH_SetBaudrate+0xc8>
  {
    peripheral_clock = XMC_SCU_CLOCK_GetPeripheralClockFrequency() / 100U;
 8022f80:	f7fe fcfa 	bl	8021978 <XMC_SCU_CLOCK_GetPeripheralClockFrequency>
 8022f84:	4602      	mov	r2, r0
 8022f86:	4b2f      	ldr	r3, [pc, #188]	; (8023044 <XMC_USIC_CH_SetBaudrate+0xdc>)
 8022f88:	fba3 2302 	umull	r2, r3, r3, r2
 8022f8c:	095b      	lsrs	r3, r3, #5
 8022f8e:	623b      	str	r3, [r7, #32]
    rate = rate / 100U;
 8022f90:	68bb      	ldr	r3, [r7, #8]
 8022f92:	4a2c      	ldr	r2, [pc, #176]	; (8023044 <XMC_USIC_CH_SetBaudrate+0xdc>)
 8022f94:	fba2 2303 	umull	r2, r3, r2, r3
 8022f98:	095b      	lsrs	r3, r3, #5
 8022f9a:	60bb      	str	r3, [r7, #8]

    clock_divider_min = 1024U;
 8022f9c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8022fa0:	62fb      	str	r3, [r7, #44]	; 0x2c
    pdiv_int_min = 1U;
 8022fa2:	2301      	movs	r3, #1
 8022fa4:	62bb      	str	r3, [r7, #40]	; 0x28
    pdiv_frac_min = 0x3ffU;
 8022fa6:	f240 33ff 	movw	r3, #1023	; 0x3ff
 8022faa:	627b      	str	r3, [r7, #36]	; 0x24

    for (clock_divider = 1024U; clock_divider > 0U; --clock_divider)
 8022fac:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8022fb0:	633b      	str	r3, [r7, #48]	; 0x30
 8022fb2:	e022      	b.n	8022ffa <XMC_USIC_CH_SetBaudrate+0x92>
    {
      pdiv = ((peripheral_clock * clock_divider) / (rate * oversampling));
 8022fb4:	6a3b      	ldr	r3, [r7, #32]
 8022fb6:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8022fb8:	fb02 f203 	mul.w	r2, r2, r3
 8022fbc:	68bb      	ldr	r3, [r7, #8]
 8022fbe:	6879      	ldr	r1, [r7, #4]
 8022fc0:	fb01 f303 	mul.w	r3, r1, r3
 8022fc4:	fbb2 f3f3 	udiv	r3, r2, r3
 8022fc8:	61fb      	str	r3, [r7, #28]
      pdiv_int = pdiv >> 10U;
 8022fca:	69fb      	ldr	r3, [r7, #28]
 8022fcc:	0a9b      	lsrs	r3, r3, #10
 8022fce:	61bb      	str	r3, [r7, #24]
      pdiv_frac = pdiv & 0x3ffU;
 8022fd0:	69fb      	ldr	r3, [r7, #28]
 8022fd2:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8022fd6:	617b      	str	r3, [r7, #20]

      if ((pdiv_int <= 1024U) && (pdiv_frac < pdiv_frac_min))
 8022fd8:	69bb      	ldr	r3, [r7, #24]
 8022fda:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8022fde:	d809      	bhi.n	8022ff4 <XMC_USIC_CH_SetBaudrate+0x8c>
 8022fe0:	697a      	ldr	r2, [r7, #20]
 8022fe2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8022fe4:	429a      	cmp	r2, r3
 8022fe6:	d205      	bcs.n	8022ff4 <XMC_USIC_CH_SetBaudrate+0x8c>
      {
        pdiv_frac_min = pdiv_frac;
 8022fe8:	697b      	ldr	r3, [r7, #20]
 8022fea:	627b      	str	r3, [r7, #36]	; 0x24
        pdiv_int_min = pdiv_int;
 8022fec:	69bb      	ldr	r3, [r7, #24]
 8022fee:	62bb      	str	r3, [r7, #40]	; 0x28
        clock_divider_min = clock_divider;
 8022ff0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8022ff2:	62fb      	str	r3, [r7, #44]	; 0x2c

    clock_divider_min = 1024U;
    pdiv_int_min = 1U;
    pdiv_frac_min = 0x3ffU;

    for (clock_divider = 1024U; clock_divider > 0U; --clock_divider)
 8022ff4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8022ff6:	3b01      	subs	r3, #1
 8022ff8:	633b      	str	r3, [r7, #48]	; 0x30
 8022ffa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8022ffc:	2b00      	cmp	r3, #0
 8022ffe:	d1d9      	bne.n	8022fb4 <XMC_USIC_CH_SetBaudrate+0x4c>
        clock_divider_min = clock_divider;
      }
    }

    channel->FDR = XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_FRACTIONAL |
                   ((clock_divider_min - 1) << USIC_CH_FDR_STEP_Pos);
 8023000:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8023002:	3b01      	subs	r3, #1
        pdiv_int_min = pdiv_int;
        clock_divider_min = clock_divider;
      }
    }

    channel->FDR = XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_FRACTIONAL |
 8023004:	f443 4200 	orr.w	r2, r3, #32768	; 0x8000
 8023008:	68fb      	ldr	r3, [r7, #12]
 802300a:	611a      	str	r2, [r3, #16]
                   ((clock_divider_min - 1) << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
 802300c:	68fb      	ldr	r3, [r7, #12]
 802300e:	695a      	ldr	r2, [r3, #20]
 8023010:	4b0d      	ldr	r3, [pc, #52]	; (8023048 <XMC_USIC_CH_SetBaudrate+0xe0>)
 8023012:	4013      	ands	r3, r2
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
 8023014:	687a      	ldr	r2, [r7, #4]
 8023016:	3a01      	subs	r2, #1
 8023018:	0292      	lsls	r2, r2, #10
                   ((clock_divider_min - 1) << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
 802301a:	431a      	orrs	r2, r3
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
                   ((pdiv_int_min - 1U) << USIC_CH_BRG_PDIV_Pos);
 802301c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802301e:	3b01      	subs	r3, #1
 8023020:	041b      	lsls	r3, r3, #16

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
 8023022:	431a      	orrs	r2, r3
    }

    channel->FDR = XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_FRACTIONAL |
                   ((clock_divider_min - 1) << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
 8023024:	68fb      	ldr	r3, [r7, #12]
 8023026:	615a      	str	r2, [r3, #20]
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
                   ((pdiv_int_min - 1U) << USIC_CH_BRG_PDIV_Pos);

    status = XMC_USIC_CH_STATUS_OK;
 8023028:	2300      	movs	r3, #0
 802302a:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
 802302e:	e002      	b.n	8023036 <XMC_USIC_CH_SetBaudrate+0xce>
  }
  else
  {
    status = XMC_USIC_CH_STATUS_ERROR;
 8023030:	2301      	movs	r3, #1
 8023032:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
  }

  return status;
 8023036:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
}
 802303a:	4618      	mov	r0, r3
 802303c:	3738      	adds	r7, #56	; 0x38
 802303e:	46bd      	mov	sp, r7
 8023040:	bd80      	pop	{r7, pc}
 8023042:	bf00      	nop
 8023044:	51eb851f 	.word	0x51eb851f
 8023048:	fc0080ef 	.word	0xfc0080ef

0802304c <XMC_USIC_CH_SetBaudrateEx>:

XMC_USIC_CH_STATUS_t XMC_USIC_CH_SetBaudrateEx(XMC_USIC_CH_t *const channel, int32_t rate, int32_t oversampling)
{
 802304c:	b580      	push	{r7, lr}
 802304e:	b08c      	sub	sp, #48	; 0x30
 8023050:	af00      	add	r7, sp, #0
 8023052:	60f8      	str	r0, [r7, #12]
 8023054:	60b9      	str	r1, [r7, #8]
 8023056:	607a      	str	r2, [r7, #4]
  int32_t peripheral_clock = XMC_SCU_CLOCK_GetPeripheralClockFrequency();
 8023058:	f7fe fc8e 	bl	8021978 <XMC_SCU_CLOCK_GetPeripheralClockFrequency>
 802305c:	4603      	mov	r3, r0
 802305e:	623b      	str	r3, [r7, #32]
  int32_t brg_clock = rate * oversampling;
 8023060:	68bb      	ldr	r3, [r7, #8]
 8023062:	687a      	ldr	r2, [r7, #4]
 8023064:	fb02 f303 	mul.w	r3, r2, r3
 8023068:	61fb      	str	r3, [r7, #28]
  int32_t actual_rate_upper;
  int32_t actual_rate_lower;
  uint32_t pdiv = 1;
 802306a:	2301      	movs	r3, #1
 802306c:	62fb      	str	r3, [r7, #44]	; 0x2c
  uint32_t divider_step;
  XMC_USIC_CH_STATUS_t status;

  if (peripheral_clock > brg_clock)
 802306e:	6a3a      	ldr	r2, [r7, #32]
 8023070:	69fb      	ldr	r3, [r7, #28]
 8023072:	429a      	cmp	r2, r3
 8023074:	dd5f      	ble.n	8023136 <XMC_USIC_CH_SetBaudrateEx+0xea>
  {
    divider_step = peripheral_clock / brg_clock; // integer division gets truncated
 8023076:	6a3a      	ldr	r2, [r7, #32]
 8023078:	69fb      	ldr	r3, [r7, #28]
 802307a:	fb92 f3f3 	sdiv	r3, r2, r3
 802307e:	62bb      	str	r3, [r7, #40]	; 0x28
    while (divider_step >= 1023)
 8023080:	e010      	b.n	80230a4 <XMC_USIC_CH_SetBaudrateEx+0x58>
    {
      pdiv++;
 8023082:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8023084:	3301      	adds	r3, #1
 8023086:	62fb      	str	r3, [r7, #44]	; 0x2c
      brg_clock = rate * oversampling * pdiv;
 8023088:	68bb      	ldr	r3, [r7, #8]
 802308a:	687a      	ldr	r2, [r7, #4]
 802308c:	fb02 f303 	mul.w	r3, r2, r3
 8023090:	461a      	mov	r2, r3
 8023092:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8023094:	fb03 f302 	mul.w	r3, r3, r2
 8023098:	61fb      	str	r3, [r7, #28]
      divider_step = peripheral_clock / brg_clock; // integer division gets truncated
 802309a:	6a3a      	ldr	r2, [r7, #32]
 802309c:	69fb      	ldr	r3, [r7, #28]
 802309e:	fb92 f3f3 	sdiv	r3, r2, r3
 80230a2:	62bb      	str	r3, [r7, #40]	; 0x28
  XMC_USIC_CH_STATUS_t status;

  if (peripheral_clock > brg_clock)
  {
    divider_step = peripheral_clock / brg_clock; // integer division gets truncated
    while (divider_step >= 1023)
 80230a4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80230a6:	f240 32fe 	movw	r2, #1022	; 0x3fe
 80230aa:	4293      	cmp	r3, r2
 80230ac:	d8e9      	bhi.n	8023082 <XMC_USIC_CH_SetBaudrateEx+0x36>
    {
      pdiv++;
      brg_clock = rate * oversampling * pdiv;
      divider_step = peripheral_clock / brg_clock; // integer division gets truncated
    }
    actual_rate_upper = peripheral_clock / (divider_step * oversampling * pdiv);
 80230ae:	6a3a      	ldr	r2, [r7, #32]
 80230b0:	687b      	ldr	r3, [r7, #4]
 80230b2:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80230b4:	fb01 f303 	mul.w	r3, r1, r3
 80230b8:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 80230ba:	fb01 f303 	mul.w	r3, r1, r3
 80230be:	fbb2 f3f3 	udiv	r3, r2, r3
 80230c2:	61bb      	str	r3, [r7, #24]
    actual_rate_lower = peripheral_clock / ((divider_step + 1) * oversampling * pdiv);
 80230c4:	6a3a      	ldr	r2, [r7, #32]
 80230c6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80230c8:	3301      	adds	r3, #1
 80230ca:	6879      	ldr	r1, [r7, #4]
 80230cc:	fb01 f303 	mul.w	r3, r1, r3
 80230d0:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 80230d2:	fb01 f303 	mul.w	r3, r1, r3
 80230d6:	fbb2 f3f3 	udiv	r3, r2, r3
 80230da:	617b      	str	r3, [r7, #20]

    // choose better approximation if the peripheral frequency is not a multiple of the baudrate
    if (abs(rate - actual_rate_lower) < abs(rate - actual_rate_upper))
 80230dc:	68ba      	ldr	r2, [r7, #8]
 80230de:	697b      	ldr	r3, [r7, #20]
 80230e0:	1ad3      	subs	r3, r2, r3
 80230e2:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 80230e6:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
 80230ea:	68b9      	ldr	r1, [r7, #8]
 80230ec:	69bb      	ldr	r3, [r7, #24]
 80230ee:	1acb      	subs	r3, r1, r3
 80230f0:	2b00      	cmp	r3, #0
 80230f2:	bfb8      	it	lt
 80230f4:	425b      	neglt	r3, r3
 80230f6:	429a      	cmp	r2, r3
 80230f8:	da02      	bge.n	8023100 <XMC_USIC_CH_SetBaudrateEx+0xb4>
    {
      divider_step += 1;
 80230fa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80230fc:	3301      	adds	r3, #1
 80230fe:	62bb      	str	r3, [r7, #40]	; 0x28
    }

    divider_step = 1024 - divider_step;
 8023100:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8023102:	f5c3 6380 	rsb	r3, r3, #1024	; 0x400
 8023106:	62bb      	str	r3, [r7, #40]	; 0x28


    channel->FDR = XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_NORMAL |
 8023108:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802310a:	f443 4280 	orr.w	r2, r3, #16384	; 0x4000
 802310e:	68fb      	ldr	r3, [r7, #12]
 8023110:	611a      	str	r2, [r3, #16]
                   (divider_step << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
 8023112:	68fb      	ldr	r3, [r7, #12]
 8023114:	695a      	ldr	r2, [r3, #20]
 8023116:	4b0c      	ldr	r3, [pc, #48]	; (8023148 <XMC_USIC_CH_SetBaudrateEx+0xfc>)
 8023118:	4013      	ands	r3, r2
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
 802311a:	687a      	ldr	r2, [r7, #4]
 802311c:	3a01      	subs	r2, #1
 802311e:	0292      	lsls	r2, r2, #10
                   (divider_step << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
 8023120:	431a      	orrs	r2, r3
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
                   ((pdiv - 1) << USIC_CH_BRG_PDIV_Pos);
 8023122:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8023124:	3b01      	subs	r3, #1
 8023126:	041b      	lsls	r3, r3, #16

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
                                     USIC_CH_BRG_PDIV_Msk |
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
 8023128:	431a      	orrs	r2, r3


    channel->FDR = XMC_USIC_CH_BRG_CLOCK_DIVIDER_MODE_NORMAL |
                   (divider_step << USIC_CH_FDR_STEP_Pos);

    channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
 802312a:	68fb      	ldr	r3, [r7, #12]
 802312c:	615a      	str	r2, [r3, #20]
                                     USIC_CH_BRG_PCTQ_Msk |
                                     USIC_CH_BRG_PPPEN_Msk)) |
                   ((oversampling - 1U) << USIC_CH_BRG_DCTQ_Pos) |
                   ((pdiv - 1) << USIC_CH_BRG_PDIV_Pos);

    status = XMC_USIC_CH_STATUS_OK;
 802312e:	2300      	movs	r3, #0
 8023130:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
 8023134:	e002      	b.n	802313c <XMC_USIC_CH_SetBaudrateEx+0xf0>
  }
  else
  {
    status = XMC_USIC_CH_STATUS_ERROR;
 8023136:	2301      	movs	r3, #1
 8023138:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  }

  return status;
 802313c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
}
 8023140:	4618      	mov	r0, r3
 8023142:	3730      	adds	r7, #48	; 0x30
 8023144:	46bd      	mov	sp, r7
 8023146:	bd80      	pop	{r7, pc}
 8023148:	fc0080ef 	.word	0xfc0080ef

0802314c <XMC_USIC_CH_SetInterruptNodePointer>:
}

void XMC_USIC_CH_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
    const XMC_USIC_CH_INTERRUPT_NODE_POINTER_t interrupt_node,
    const uint32_t service_request)
{
 802314c:	b480      	push	{r7}
 802314e:	b085      	sub	sp, #20
 8023150:	af00      	add	r7, sp, #0
 8023152:	60f8      	str	r0, [r7, #12]
 8023154:	460b      	mov	r3, r1
 8023156:	607a      	str	r2, [r7, #4]
 8023158:	72fb      	strb	r3, [r7, #11]
  channel->INPR = (uint32_t)((channel->INPR & (~(uint32_t)(USIC_CH_INPR_Msk << (uint32_t)interrupt_node))) |
 802315a:	68fb      	ldr	r3, [r7, #12]
 802315c:	699a      	ldr	r2, [r3, #24]
 802315e:	7afb      	ldrb	r3, [r7, #11]
 8023160:	2107      	movs	r1, #7
 8023162:	fa01 f303 	lsl.w	r3, r1, r3
 8023166:	43db      	mvns	r3, r3
 8023168:	401a      	ands	r2, r3
                             (service_request << (uint32_t)interrupt_node));
 802316a:	7afb      	ldrb	r3, [r7, #11]
 802316c:	6879      	ldr	r1, [r7, #4]
 802316e:	fa01 f303 	lsl.w	r3, r1, r3

void XMC_USIC_CH_SetInterruptNodePointer(XMC_USIC_CH_t *const channel,
    const XMC_USIC_CH_INTERRUPT_NODE_POINTER_t interrupt_node,
    const uint32_t service_request)
{
  channel->INPR = (uint32_t)((channel->INPR & (~(uint32_t)(USIC_CH_INPR_Msk << (uint32_t)interrupt_node))) |
 8023172:	431a      	orrs	r2, r3
 8023174:	68fb      	ldr	r3, [r7, #12]
 8023176:	619a      	str	r2, [r3, #24]
                             (service_request << (uint32_t)interrupt_node));
}
 8023178:	3714      	adds	r7, #20
 802317a:	46bd      	mov	sp, r7
 802317c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023180:	4770      	bx	lr
 8023182:	bf00      	nop

08023184 <XMC_USIC_Enable>:
  channel->RBCTR = (uint32_t)((channel->RBCTR & (~(uint32_t)(USIC_CH_INPR_Msk << (uint32_t)interrupt_node))) |
                              (service_request << (uint32_t)interrupt_node));
}

void XMC_USIC_Enable(XMC_USIC_t *const usic)
{
 8023184:	b580      	push	{r7, lr}
 8023186:	b082      	sub	sp, #8
 8023188:	af00      	add	r7, sp, #0
 802318a:	6078      	str	r0, [r7, #4]
  if (usic == USIC0)
 802318c:	687b      	ldr	r3, [r7, #4]
 802318e:	4a1b      	ldr	r2, [pc, #108]	; (80231fc <XMC_USIC_Enable+0x78>)
 8023190:	4293      	cmp	r3, r2
 8023192:	d118      	bne.n	80231c6 <XMC_USIC_Enable+0x42>
  {
#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_USIC0);
 8023194:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8023198:	f7fe fd32 	bl	8021c00 <XMC_SCU_CLOCK_UngatePeripheralClock>
    while (XMC_SCU_CLOCK_IsPeripheralClockGated(XMC_SCU_PERIPHERAL_CLOCK_USIC0));
 802319c:	bf00      	nop
 802319e:	f44f 6000 	mov.w	r0, #2048	; 0x800
 80231a2:	f7fe fd49 	bl	8021c38 <XMC_SCU_CLOCK_IsPeripheralClockGated>
 80231a6:	4603      	mov	r3, r0
 80231a8:	2b00      	cmp	r3, #0
 80231aa:	d1f8      	bne.n	802319e <XMC_USIC_Enable+0x1a>
#endif
#if defined(PERIPHERAL_RESET_SUPPORTED)
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_USIC0);
 80231ac:	f44f 6000 	mov.w	r0, #2048	; 0x800
 80231b0:	f7fe fba2 	bl	80218f8 <XMC_SCU_RESET_DeassertPeripheralReset>
    while (XMC_SCU_RESET_IsPeripheralResetAsserted(XMC_SCU_PERIPHERAL_RESET_USIC0));
 80231b4:	bf00      	nop
 80231b6:	f44f 6000 	mov.w	r0, #2048	; 0x800
 80231ba:	f7fe fbb9 	bl	8021930 <XMC_SCU_RESET_IsPeripheralResetAsserted>
 80231be:	4603      	mov	r3, r0
 80231c0:	2b00      	cmp	r3, #0
 80231c2:	d1f8      	bne.n	80231b6 <XMC_USIC_Enable+0x32>
 80231c4:	e017      	b.n	80231f6 <XMC_USIC_Enable+0x72>
#endif
  }
#if defined(USIC1)
  else if (usic == USIC1)
 80231c6:	687b      	ldr	r3, [r7, #4]
 80231c8:	4a0d      	ldr	r2, [pc, #52]	; (8023200 <XMC_USIC_Enable+0x7c>)
 80231ca:	4293      	cmp	r3, r2
 80231cc:	d113      	bne.n	80231f6 <XMC_USIC_Enable+0x72>
  {
#if defined(CLOCK_GATING_SUPPORTED)
    XMC_SCU_CLOCK_UngatePeripheralClock(XMC_SCU_PERIPHERAL_CLOCK_USIC1);
 80231ce:	480d      	ldr	r0, [pc, #52]	; (8023204 <XMC_USIC_Enable+0x80>)
 80231d0:	f7fe fd16 	bl	8021c00 <XMC_SCU_CLOCK_UngatePeripheralClock>
    while (XMC_SCU_CLOCK_IsPeripheralClockGated(XMC_SCU_PERIPHERAL_CLOCK_USIC1));
 80231d4:	bf00      	nop
 80231d6:	480b      	ldr	r0, [pc, #44]	; (8023204 <XMC_USIC_Enable+0x80>)
 80231d8:	f7fe fd2e 	bl	8021c38 <XMC_SCU_CLOCK_IsPeripheralClockGated>
 80231dc:	4603      	mov	r3, r0
 80231de:	2b00      	cmp	r3, #0
 80231e0:	d1f9      	bne.n	80231d6 <XMC_USIC_Enable+0x52>
#endif
#if defined(PERIPHERAL_RESET_SUPPORTED)
    XMC_SCU_RESET_DeassertPeripheralReset(XMC_SCU_PERIPHERAL_RESET_USIC1);
 80231e2:	4808      	ldr	r0, [pc, #32]	; (8023204 <XMC_USIC_Enable+0x80>)
 80231e4:	f7fe fb88 	bl	80218f8 <XMC_SCU_RESET_DeassertPeripheralReset>
    while (XMC_SCU_RESET_IsPeripheralResetAsserted(XMC_SCU_PERIPHERAL_RESET_USIC1));
 80231e8:	bf00      	nop
 80231ea:	4806      	ldr	r0, [pc, #24]	; (8023204 <XMC_USIC_Enable+0x80>)
 80231ec:	f7fe fba0 	bl	8021930 <XMC_SCU_RESET_IsPeripheralResetAsserted>
 80231f0:	4603      	mov	r3, r0
 80231f2:	2b00      	cmp	r3, #0
 80231f4:	d1f9      	bne.n	80231ea <XMC_USIC_Enable+0x66>
#endif
  else
  {
    XMC_ASSERT("USIC module not available", 0/*Always*/);
  }
}
 80231f6:	3708      	adds	r7, #8
 80231f8:	46bd      	mov	sp, r7
 80231fa:	bd80      	pop	{r7, pc}
 80231fc:	40030008 	.word	0x40030008
 8023200:	48020008 	.word	0x48020008
 8023204:	10000080 	.word	0x10000080

08023208 <_init>:
  }
}

/* Init */
void _init(void)
{}
 8023208:	b480      	push	{r7}
 802320a:	af00      	add	r7, sp, #0
 802320c:	46bd      	mov	sp, r7
 802320e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023212:	4770      	bx	lr

08023214 <XMC_CCU4_EnableClock>:
 *
 * \par<b>Related APIs:</b><br>
 * XMC_CCU4_DisableClock()<BR> XMC_CCU4_EnableMultipleClocks()<BR> XMC_CCU4_StartPrescaler()<BR> XMC_CCU4_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU4_EnableClock(XMC_CCU4_MODULE_t *const module, const uint8_t slice_number)
{
 8023214:	b480      	push	{r7}
 8023216:	b083      	sub	sp, #12
 8023218:	af00      	add	r7, sp, #0
 802321a:	6078      	str	r0, [r7, #4]
 802321c:	460b      	mov	r3, r1
 802321e:	70fb      	strb	r3, [r7, #3]
  XMC_ASSERT("XMC_CCU4_EnableClock:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  XMC_ASSERT("XMC_CCU4_EnableClock:Invalid Slice Number", (slice_number < 4U));

  module->GIDLC = ((uint32_t) 1) << slice_number;
 8023220:	78fb      	ldrb	r3, [r7, #3]
 8023222:	2201      	movs	r2, #1
 8023224:	409a      	lsls	r2, r3
 8023226:	687b      	ldr	r3, [r7, #4]
 8023228:	60da      	str	r2, [r3, #12]
}
 802322a:	370c      	adds	r7, #12
 802322c:	46bd      	mov	sp, r7
 802322e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023232:	4770      	bx	lr

08023234 <XMC_CCU4_SLICE_StartTimer>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_StopTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_StartTimer(XMC_CCU4_SLICE_t *const slice)
{
 8023234:	b480      	push	{r7}
 8023236:	b083      	sub	sp, #12
 8023238:	af00      	add	r7, sp, #0
 802323a:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_SLICE_StartTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCSET = CCU4_CC4_TCSET_TRBS_Msk;
 802323c:	687b      	ldr	r3, [r7, #4]
 802323e:	2201      	movs	r2, #1
 8023240:	60da      	str	r2, [r3, #12]
}
 8023242:	370c      	adds	r7, #12
 8023244:	46bd      	mov	sp, r7
 8023246:	f85d 7b04 	ldr.w	r7, [sp], #4
 802324a:	4770      	bx	lr

0802324c <XMC_CCU4_SLICE_ClearTimer>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_StartTimer().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_ClearTimer(XMC_CCU4_SLICE_t *const slice)
{
 802324c:	b480      	push	{r7}
 802324e:	b083      	sub	sp, #12
 8023250:	af00      	add	r7, sp, #0
 8023252:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_SLICE_ClearTimer:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->TCCLR = (uint32_t) CCU4_CC4_TCCLR_TCC_Msk;
 8023254:	687b      	ldr	r3, [r7, #4]
 8023256:	2202      	movs	r2, #2
 8023258:	611a      	str	r2, [r3, #16]
}
 802325a:	370c      	adds	r7, #12
 802325c:	46bd      	mov	sp, r7
 802325e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023262:	4770      	bx	lr

08023264 <XMC_CCU4_SLICE_SetTimerPeriodMatch>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerPeriodMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t period_val)
{
 8023264:	b480      	push	{r7}
 8023266:	b083      	sub	sp, #12
 8023268:	af00      	add	r7, sp, #0
 802326a:	6078      	str	r0, [r7, #4]
 802326c:	460b      	mov	r3, r1
 802326e:	807b      	strh	r3, [r7, #2]
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerPeriodMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->PRS = (uint32_t) period_val;
 8023270:	887a      	ldrh	r2, [r7, #2]
 8023272:	687b      	ldr	r3, [r7, #4]
 8023274:	635a      	str	r2, [r3, #52]	; 0x34
}
 8023276:	370c      	adds	r7, #12
 8023278:	46bd      	mov	sp, r7
 802327a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802327e:	4770      	bx	lr

08023280 <XMC_CCU4_SLICE_SetTimerCompareMatch>:
 *
 * \par<b>Related APIs:</b><br>
 *  XMC_CCU4_SLICE_GetTimerPeriodMatch().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_SetTimerCompareMatch(XMC_CCU4_SLICE_t *const slice, const uint16_t compare_val)
{
 8023280:	b480      	push	{r7}
 8023282:	b083      	sub	sp, #12
 8023284:	af00      	add	r7, sp, #0
 8023286:	6078      	str	r0, [r7, #4]
 8023288:	460b      	mov	r3, r1
 802328a:	807b      	strh	r3, [r7, #2]
  XMC_ASSERT("XMC_CCU4_SLICE_SetTimerCompareMatch:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  slice->CRS = (uint32_t) compare_val;
 802328c:	887a      	ldrh	r2, [r7, #2]
 802328e:	687b      	ldr	r3, [r7, #4]
 8023290:	63da      	str	r2, [r3, #60]	; 0x3c
}
 8023292:	370c      	adds	r7, #12
 8023294:	46bd      	mov	sp, r7
 8023296:	f85d 7b04 	ldr.w	r7, [sp], #4
 802329a:	4770      	bx	lr

0802329c <XMC_CCU4_EnableShadowTransfer>:
 *
 * \par<b>Related APIs:</b><br>
 *  None.
 */
__STATIC_INLINE void XMC_CCU4_EnableShadowTransfer(XMC_CCU4_MODULE_t *const module, const uint32_t shadow_transfer_msk)
{
 802329c:	b480      	push	{r7}
 802329e:	b083      	sub	sp, #12
 80232a0:	af00      	add	r7, sp, #0
 80232a2:	6078      	str	r0, [r7, #4]
 80232a4:	6039      	str	r1, [r7, #0]
  XMC_ASSERT("XMC_CCU4_EnableShadowTransfer:Invalid Slice Pointer", XMC_CCU4_IsValidModule(module));
  module->GCSS = (uint32_t)shadow_transfer_msk;
 80232a6:	687b      	ldr	r3, [r7, #4]
 80232a8:	683a      	ldr	r2, [r7, #0]
 80232aa:	611a      	str	r2, [r3, #16]
}
 80232ac:	370c      	adds	r7, #12
 80232ae:	46bd      	mov	sp, r7
 80232b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80232b4:	4770      	bx	lr
 80232b6:	bf00      	nop

080232b8 <XMC_CCU4_SLICE_EnableEvent>:
 *  XMC_CCU4_SLICE_SetInterruptNode()<BR> XMC_CCU4_SLICE_EnableMultipleEvents()<BR> XMC_CCU4_SLICE_DisableEvent()<BR>
 *  XMC_CCU4_SLICE_DisableMultipleEvents().
 */
__STATIC_INLINE void XMC_CCU4_SLICE_EnableEvent(XMC_CCU4_SLICE_t *const slice,
    const XMC_CCU4_SLICE_IRQ_ID_t event)
{
 80232b8:	b480      	push	{r7}
 80232ba:	b083      	sub	sp, #12
 80232bc:	af00      	add	r7, sp, #0
 80232be:	6078      	str	r0, [r7, #4]
 80232c0:	460b      	mov	r3, r1
 80232c2:	70fb      	strb	r3, [r7, #3]
  XMC_ASSERT("XMC_CCU4_SLICE_EnableEvent:Invalid Slice Pointer", XMC_CCU4_IsValidSlice(slice));
  XMC_ASSERT("XMC_CCU4_SLICE_EnableEvent:Invalid SR event", XMC_CCU4_SLICE_CHECK_INTERRUPT(event));
  slice->INTE |= ((uint32_t) 1) << ((uint32_t) event);
 80232c4:	687b      	ldr	r3, [r7, #4]
 80232c6:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
 80232ca:	78fb      	ldrb	r3, [r7, #3]
 80232cc:	2101      	movs	r1, #1
 80232ce:	fa01 f303 	lsl.w	r3, r1, r3
 80232d2:	431a      	orrs	r2, r3
 80232d4:	687b      	ldr	r3, [r7, #4]
 80232d6:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
}
 80232da:	370c      	adds	r7, #12
 80232dc:	46bd      	mov	sp, r7
 80232de:	f85d 7b04 	ldr.w	r7, [sp], #4
 80232e2:	4770      	bx	lr

080232e4 <TIMER_Init>:
/*
 * This function initializes a TIMER APP based on user configuration.
 *
 */
TIMER_STATUS_t TIMER_Init(TIMER_t* const handle_ptr)
{
 80232e4:	b580      	push	{r7, lr}
 80232e6:	b084      	sub	sp, #16
 80232e8:	af00      	add	r7, sp, #0
 80232ea:	6078      	str	r0, [r7, #4]
  TIMER_STATUS_t status;

  XMC_ASSERT("TIMER_Init:handle_ptr NULL" , (handle_ptr != NULL));

  status = TIMER_STATUS_SUCCESS;
 80232ec:	2300      	movs	r3, #0
 80232ee:	73fb      	strb	r3, [r7, #15]
  /* Check for APP instance is initialized or not */
  if (false == handle_ptr->initialized)
 80232f0:	687b      	ldr	r3, [r7, #4]
 80232f2:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
 80232f6:	f083 0301 	eor.w	r3, r3, #1
 80232fa:	b2db      	uxtb	r3, r3
 80232fc:	2b00      	cmp	r3, #0
 80232fe:	d009      	beq.n	8023314 <TIMER_Init+0x30>
  {
#ifdef TIMER_CCU4_USED
    if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 8023300:	687b      	ldr	r3, [r7, #4]
 8023302:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 8023306:	2b00      	cmp	r3, #0
 8023308:	d104      	bne.n	8023314 <TIMER_Init+0x30>
    {
      /* Configure CCU4 timer for the required time tick settings */
      status = TIMER_CCU4_lInit(handle_ptr);
 802330a:	6878      	ldr	r0, [r7, #4]
 802330c:	f000 f826 	bl	802335c <TIMER_CCU4_lInit>
 8023310:	4603      	mov	r3, r0
 8023312:	73fb      	strb	r3, [r7, #15]
      status = TIMER_CCU8_lInit(handle_ptr);
    }
#endif
  }

  return (status);
 8023314:	7bfb      	ldrb	r3, [r7, #15]
}
 8023316:	4618      	mov	r0, r3
 8023318:	3710      	adds	r7, #16
 802331a:	46bd      	mov	sp, r7
 802331c:	bd80      	pop	{r7, pc}
 802331e:	bf00      	nop

08023320 <TIMER_Start>:

/*
 * This function starts the timer to generate the events for the specified time_interval value
 */
TIMER_STATUS_t TIMER_Start(TIMER_t  *const handle_ptr)
{
 8023320:	b580      	push	{r7, lr}
 8023322:	b084      	sub	sp, #16
 8023324:	af00      	add	r7, sp, #0
 8023326:	6078      	str	r0, [r7, #4]
  TIMER_STATUS_t status;

  XMC_ASSERT("TIMER_Start:handle_ptr NULL" , (handle_ptr != NULL));

  /* Check for APP instance is initialized or not */
  if (true == handle_ptr->initialized)
 8023328:	687b      	ldr	r3, [r7, #4]
 802332a:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
 802332e:	2b00      	cmp	r3, #0
 8023330:	d00c      	beq.n	802334c <TIMER_Start+0x2c>
  {
#ifdef TIMER_CCU4_USED
    if (TIMER_MODULE_CCU4 == handle_ptr->timer_module)
 8023332:	687b      	ldr	r3, [r7, #4]
 8023334:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 8023338:	2b00      	cmp	r3, #0
 802333a:	d104      	bne.n	8023346 <TIMER_Start+0x26>
    {
      /* Start the timer manually */
      XMC_CCU4_SLICE_StartTimer(handle_ptr->ccu4_slice_ptr);
 802333c:	687b      	ldr	r3, [r7, #4]
 802333e:	695b      	ldr	r3, [r3, #20]
 8023340:	4618      	mov	r0, r3
 8023342:	f7ff ff77 	bl	8023234 <XMC_CCU4_SLICE_StartTimer>
       {
      /* Start the timer manually */
      XMC_CCU8_SLICE_StartTimer(handle_ptr->ccu8_slice_ptr);
       }
#endif
    status = TIMER_STATUS_SUCCESS;
 8023346:	2300      	movs	r3, #0
 8023348:	73fb      	strb	r3, [r7, #15]
 802334a:	e001      	b.n	8023350 <TIMER_Start+0x30>
  }
  else
  {
    status = TIMER_STATUS_FAILURE;
 802334c:	2301      	movs	r3, #1
 802334e:	73fb      	strb	r3, [r7, #15]
  }

  return (status);
 8023350:	7bfb      	ldrb	r3, [r7, #15]
}
 8023352:	4618      	mov	r0, r3
 8023354:	3710      	adds	r7, #16
 8023356:	46bd      	mov	sp, r7
 8023358:	bd80      	pop	{r7, pc}
 802335a:	bf00      	nop

0802335c <TIMER_CCU4_lInit>:
#ifdef TIMER_CCU4_USED
/*
 * This function configures timer ccu4 timer with required time tick value
 */
TIMER_STATUS_t TIMER_CCU4_lInit(TIMER_t* const handle_ptr)
{
 802335c:	b580      	push	{r7, lr}
 802335e:	b084      	sub	sp, #16
 8023360:	af00      	add	r7, sp, #0
 8023362:	6078      	str	r0, [r7, #4]
  TIMER_STATUS_t status;
  /* Initialize the global registers */
  status = (TIMER_STATUS_t)GLOBAL_CCU4_Init(handle_ptr->global_ccu4_handler);
 8023364:	687b      	ldr	r3, [r7, #4]
 8023366:	691b      	ldr	r3, [r3, #16]
 8023368:	4618      	mov	r0, r3
 802336a:	f000 fe01 	bl	8023f70 <GLOBAL_CCU4_Init>
 802336e:	4603      	mov	r3, r0
 8023370:	73fb      	strb	r3, [r7, #15]

  /* Enable the clock for selected timer */
  XMC_CCU4_EnableClock(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->ccu4_slice_number);
 8023372:	687b      	ldr	r3, [r7, #4]
 8023374:	691b      	ldr	r3, [r3, #16]
 8023376:	689a      	ldr	r2, [r3, #8]
 8023378:	687b      	ldr	r3, [r7, #4]
 802337a:	7e1b      	ldrb	r3, [r3, #24]
 802337c:	4610      	mov	r0, r2
 802337e:	4619      	mov	r1, r3
 8023380:	f7ff ff48 	bl	8023214 <XMC_CCU4_EnableClock>
  /* Configure the timer with required settings */
  XMC_CCU4_SLICE_CompareInit(handle_ptr->ccu4_slice_ptr, handle_ptr->ccu4_slice_config_ptr);
 8023384:	687b      	ldr	r3, [r7, #4]
 8023386:	695a      	ldr	r2, [r3, #20]
 8023388:	687b      	ldr	r3, [r7, #4]
 802338a:	69db      	ldr	r3, [r3, #28]
 802338c:	4610      	mov	r0, r2
 802338e:	4619      	mov	r1, r3
 8023390:	f7fe ff34 	bl	80221fc <XMC_CCU4_SLICE_CompareInit>
  /* programs the timer period and compare register according to time interval value and do the shadow transfer */
  TIMER_CCU4_lShadowTransfer(handle_ptr);
 8023394:	6878      	ldr	r0, [r7, #4]
 8023396:	f000 f82d 	bl	80233f4 <TIMER_CCU4_lShadowTransfer>

#ifdef  TIMER_INTERRUPT
  if (true == handle_ptr->period_match_enable)
 802339a:	687b      	ldr	r3, [r7, #4]
 802339c:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 80233a0:	2b00      	cmp	r3, #0
 80233a2:	d00f      	beq.n	80233c4 <TIMER_CCU4_lInit+0x68>
  {
    /* Binds a period match event to an NVIC node  */
    XMC_CCU4_SLICE_SetInterruptNode(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH,
 80233a4:	687b      	ldr	r3, [r7, #4]
 80233a6:	695a      	ldr	r2, [r3, #20]
 80233a8:	687b      	ldr	r3, [r7, #4]
 80233aa:	f893 3020 	ldrb.w	r3, [r3, #32]
 80233ae:	4610      	mov	r0, r2
 80233b0:	2100      	movs	r1, #0
 80233b2:	461a      	mov	r2, r3
 80233b4:	f7fe ff58 	bl	8022268 <XMC_CCU4_SLICE_SetInterruptNode>
                                    handle_ptr->ccu4_period_match_node);
    /* Enables a timer(period match) event  */
    XMC_CCU4_SLICE_EnableEvent(handle_ptr->ccu4_slice_ptr, XMC_CCU4_SLICE_IRQ_ID_PERIOD_MATCH);
 80233b8:	687b      	ldr	r3, [r7, #4]
 80233ba:	695b      	ldr	r3, [r3, #20]
 80233bc:	4618      	mov	r0, r3
 80233be:	2100      	movs	r1, #0
 80233c0:	f7ff ff7a 	bl	80232b8 <XMC_CCU4_SLICE_EnableEvent>
  }
#endif
  /* Clears the timer register */
  XMC_CCU4_SLICE_ClearTimer(handle_ptr->ccu4_slice_ptr);
 80233c4:	687b      	ldr	r3, [r7, #4]
 80233c6:	695b      	ldr	r3, [r3, #20]
 80233c8:	4618      	mov	r0, r3
 80233ca:	f7ff ff3f 	bl	802324c <XMC_CCU4_SLICE_ClearTimer>

  /* update the initialization flag as true for particular instance*/
  handle_ptr->initialized = true;
 80233ce:	687b      	ldr	r3, [r7, #4]
 80233d0:	2201      	movs	r2, #1
 80233d2:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26

  /* Check whether the start of the timer is enabled during initialization or not */
  if (handle_ptr->start_control == true)
 80233d6:	687b      	ldr	r3, [r7, #4]
 80233d8:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 80233dc:	2b00      	cmp	r3, #0
 80233de:	d004      	beq.n	80233ea <TIMER_CCU4_lInit+0x8e>
  {
    /* Start the timer */
    XMC_CCU4_SLICE_StartTimer(handle_ptr->ccu4_slice_ptr);
 80233e0:	687b      	ldr	r3, [r7, #4]
 80233e2:	695b      	ldr	r3, [r3, #20]
 80233e4:	4618      	mov	r0, r3
 80233e6:	f7ff ff25 	bl	8023234 <XMC_CCU4_SLICE_StartTimer>
  }

  return (status);
 80233ea:	7bfb      	ldrb	r3, [r7, #15]
}
 80233ec:	4618      	mov	r0, r3
 80233ee:	3710      	adds	r7, #16
 80233f0:	46bd      	mov	sp, r7
 80233f2:	bd80      	pop	{r7, pc}

080233f4 <TIMER_CCU4_lShadowTransfer>:

/*
 * This function configures timer period and compare values and triggers the shadow transfer operation
 */
void TIMER_CCU4_lShadowTransfer(TIMER_t* const handle_ptr)
{
 80233f4:	b580      	push	{r7, lr}
 80233f6:	b082      	sub	sp, #8
 80233f8:	af00      	add	r7, sp, #0
 80233fa:	6078      	str	r0, [r7, #4]
  /* programs the timer period register according to time interval value */
  XMC_CCU4_SLICE_SetTimerPeriodMatch(handle_ptr->ccu4_slice_ptr, handle_ptr->period_value);
 80233fc:	687b      	ldr	r3, [r7, #4]
 80233fe:	695a      	ldr	r2, [r3, #20]
 8023400:	687b      	ldr	r3, [r7, #4]
 8023402:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 8023404:	4610      	mov	r0, r2
 8023406:	4619      	mov	r1, r3
 8023408:	f7ff ff2c 	bl	8023264 <XMC_CCU4_SLICE_SetTimerPeriodMatch>
  /* programs the timer compare register for 50% duty cycle */
  XMC_CCU4_SLICE_SetTimerCompareMatch(handle_ptr->ccu4_slice_ptr, TIMER_CMP_100_DUTY);
 802340c:	687b      	ldr	r3, [r7, #4]
 802340e:	695b      	ldr	r3, [r3, #20]
 8023410:	4618      	mov	r0, r3
 8023412:	2100      	movs	r1, #0
 8023414:	f7ff ff34 	bl	8023280 <XMC_CCU4_SLICE_SetTimerCompareMatch>
  /* Transfers value from shadow timer registers to actual timer registers */
  XMC_CCU4_EnableShadowTransfer(handle_ptr->global_ccu4_handler->module_ptr, handle_ptr->shadow_mask);
 8023418:	687b      	ldr	r3, [r7, #4]
 802341a:	691b      	ldr	r3, [r3, #16]
 802341c:	689a      	ldr	r2, [r3, #8]
 802341e:	687b      	ldr	r3, [r7, #4]
 8023420:	68db      	ldr	r3, [r3, #12]
 8023422:	4610      	mov	r0, r2
 8023424:	4619      	mov	r1, r3
 8023426:	f7ff ff39 	bl	802329c <XMC_CCU4_EnableShadowTransfer>
}
 802342a:	3708      	adds	r7, #8
 802342c:	46bd      	mov	sp, r7
 802342e:	bd80      	pop	{r7, pc}

08023430 <XMC_SPI_CH_SetTransmitMode>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_SPI_CH_Transmit()
 */
__STATIC_INLINE void XMC_SPI_CH_SetTransmitMode(XMC_USIC_CH_t *const channel, const XMC_SPI_CH_MODE_t mode)
{
 8023430:	b480      	push	{r7}
 8023432:	b083      	sub	sp, #12
 8023434:	af00      	add	r7, sp, #0
 8023436:	6078      	str	r0, [r7, #4]
 8023438:	460b      	mov	r3, r1
 802343a:	70fb      	strb	r3, [r7, #3]
  channel->CCR = (channel->CCR & (uint32_t)(~USIC_CH_CCR_HPCEN_Msk)) |
 802343c:	687b      	ldr	r3, [r7, #4]
 802343e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8023440:	f023 02c0 	bic.w	r2, r3, #192	; 0xc0
                 (((uint32_t) mode << USIC_CH_CCR_HPCEN_Pos) & (uint32_t)USIC_CH_CCR_HPCEN_Msk);
 8023444:	78fb      	ldrb	r3, [r7, #3]
 8023446:	019b      	lsls	r3, r3, #6
 8023448:	b2db      	uxtb	r3, r3
 * \par<b>Related APIs:</b><BR>
 * XMC_SPI_CH_Transmit()
 */
__STATIC_INLINE void XMC_SPI_CH_SetTransmitMode(XMC_USIC_CH_t *const channel, const XMC_SPI_CH_MODE_t mode)
{
  channel->CCR = (channel->CCR & (uint32_t)(~USIC_CH_CCR_HPCEN_Msk)) |
 802344a:	431a      	orrs	r2, r3
 802344c:	687b      	ldr	r3, [r7, #4]
 802344e:	641a      	str	r2, [r3, #64]	; 0x40
                 (((uint32_t) mode << USIC_CH_CCR_HPCEN_Pos) & (uint32_t)USIC_CH_CCR_HPCEN_Msk);
}
 8023450:	370c      	adds	r7, #12
 8023452:	46bd      	mov	sp, r7
 8023454:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023458:	4770      	bx	lr
 802345a:	bf00      	nop

0802345c <XMC_DMA_CH_Enable>:
 * The function sets the GPDMA's CHENREG register to enable a DMA channel. Please
 * ensure that the GPDMA module itself is enabled before calling this function.
 * See ::XMC_DMA_Enable() for details.
 */
__STATIC_INLINE void XMC_DMA_CH_Enable(XMC_DMA_t *const dma, const uint8_t channel)
{
 802345c:	b480      	push	{r7}
 802345e:	b083      	sub	sp, #12
 8023460:	af00      	add	r7, sp, #0
 8023462:	6078      	str	r0, [r7, #4]
 8023464:	460b      	mov	r3, r1
 8023466:	70fb      	strb	r3, [r7, #3]
  dma->CHENREG = (uint32_t)(0x101UL << channel);
 8023468:	78fb      	ldrb	r3, [r7, #3]
 802346a:	f240 1201 	movw	r2, #257	; 0x101
 802346e:	409a      	lsls	r2, r3
 8023470:	687b      	ldr	r3, [r7, #4]
 8023472:	f8c3 23a0 	str.w	r2, [r3, #928]	; 0x3a0
}
 8023476:	370c      	adds	r7, #12
 8023478:	46bd      	mov	sp, r7
 802347a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802347e:	4770      	bx	lr

08023480 <XMC_DMA_CH_SetSourceAddress>:
 *
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetDestinationAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetSourceAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
 8023480:	b480      	push	{r7}
 8023482:	b085      	sub	sp, #20
 8023484:	af00      	add	r7, sp, #0
 8023486:	60f8      	str	r0, [r7, #12]
 8023488:	460b      	mov	r3, r1
 802348a:	607a      	str	r2, [r7, #4]
 802348c:	72fb      	strb	r3, [r7, #11]
  dma->CH[channel].SAR = addr;
 802348e:	7afb      	ldrb	r3, [r7, #11]
 8023490:	68fa      	ldr	r2, [r7, #12]
 8023492:	2158      	movs	r1, #88	; 0x58
 8023494:	fb01 f303 	mul.w	r3, r1, r3
 8023498:	4413      	add	r3, r2
 802349a:	687a      	ldr	r2, [r7, #4]
 802349c:	601a      	str	r2, [r3, #0]
}
 802349e:	3714      	adds	r7, #20
 80234a0:	46bd      	mov	sp, r7
 80234a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80234a6:	4770      	bx	lr

080234a8 <XMC_DMA_CH_SetDestinationAddress>:
 *
 * \par<b>Related API: </b><br>
 * ::XMC_DMA_CH_SetSourceAddress() <br>
 */
__STATIC_INLINE void XMC_DMA_CH_SetDestinationAddress(XMC_DMA_t *const dma, const uint8_t channel, uint32_t addr)
{
 80234a8:	b480      	push	{r7}
 80234aa:	b085      	sub	sp, #20
 80234ac:	af00      	add	r7, sp, #0
 80234ae:	60f8      	str	r0, [r7, #12]
 80234b0:	460b      	mov	r3, r1
 80234b2:	607a      	str	r2, [r7, #4]
 80234b4:	72fb      	strb	r3, [r7, #11]
  dma->CH[channel].DAR = addr;
 80234b6:	7afb      	ldrb	r3, [r7, #11]
 80234b8:	68fa      	ldr	r2, [r7, #12]
 80234ba:	2158      	movs	r1, #88	; 0x58
 80234bc:	fb01 f303 	mul.w	r3, r1, r3
 80234c0:	4413      	add	r3, r2
 80234c2:	3308      	adds	r3, #8
 80234c4:	687a      	ldr	r2, [r7, #4]
 80234c6:	601a      	str	r2, [r3, #0]
}
 80234c8:	3714      	adds	r7, #20
 80234ca:	46bd      	mov	sp, r7
 80234cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80234d0:	4770      	bx	lr
 80234d2:	bf00      	nop

080234d4 <XMC_DMA_CH_SetBlockSize>:
 * The function may be called after enabling the DMA channel. Please
 * see ::XMC_DMA_CH_Enable() for more information.
 *
 */
__STATIC_INLINE void XMC_DMA_CH_SetBlockSize(XMC_DMA_t *const dma, const uint8_t channel, uint32_t block_size)
{
 80234d4:	b480      	push	{r7}
 80234d6:	b085      	sub	sp, #20
 80234d8:	af00      	add	r7, sp, #0
 80234da:	60f8      	str	r0, [r7, #12]
 80234dc:	460b      	mov	r3, r1
 80234de:	607a      	str	r2, [r7, #4]
 80234e0:	72fb      	strb	r3, [r7, #11]
  dma->CH[channel].CTLH = block_size;
 80234e2:	7afb      	ldrb	r3, [r7, #11]
 80234e4:	68fa      	ldr	r2, [r7, #12]
 80234e6:	2158      	movs	r1, #88	; 0x58
 80234e8:	fb01 f303 	mul.w	r3, r1, r3
 80234ec:	4413      	add	r3, r2
 80234ee:	3318      	adds	r3, #24
 80234f0:	687a      	ldr	r2, [r7, #4]
 80234f2:	605a      	str	r2, [r3, #4]
}
 80234f4:	3714      	adds	r7, #20
 80234f6:	46bd      	mov	sp, r7
 80234f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80234fc:	4770      	bx	lr
 80234fe:	bf00      	nop

08023500 <SPI_MASTER_Init>:

/*
 * This function initializes the SPI channel, based on UI configuration.
 */
SPI_MASTER_STATUS_t SPI_MASTER_Init(SPI_MASTER_t* const handle)
{
 8023500:	b580      	push	{r7, lr}
 8023502:	b084      	sub	sp, #16
 8023504:	af00      	add	r7, sp, #0
 8023506:	6078      	str	r0, [r7, #4]
  SPI_MASTER_STATUS_t status;

  XMC_ASSERT("SPI_MASTER_Init:handle NULL" , (handle != NULL));

  /* Configure the port registers and data input registers of SPI channel */
  status = handle->config->fptr_spi_master_config();
 8023508:	687b      	ldr	r3, [r7, #4]
 802350a:	685b      	ldr	r3, [r3, #4]
 802350c:	685b      	ldr	r3, [r3, #4]
 802350e:	4798      	blx	r3
 8023510:	4603      	mov	r3, r0
 8023512:	73fb      	strb	r3, [r7, #15]

  return status;
 8023514:	7bfb      	ldrb	r3, [r7, #15]
}
 8023516:	4618      	mov	r0, r3
 8023518:	3710      	adds	r7, #16
 802351a:	46bd      	mov	sp, r7
 802351c:	bd80      	pop	{r7, pc}
 802351e:	bf00      	nop

08023520 <SPI_MASTER_Transmit>:

  return status;
}

SPI_MASTER_STATUS_t SPI_MASTER_Transmit(const SPI_MASTER_t *const handle, uint8_t* dataptr, uint32_t count)
{
 8023520:	b580      	push	{r7, lr}
 8023522:	b086      	sub	sp, #24
 8023524:	af00      	add	r7, sp, #0
 8023526:	60f8      	str	r0, [r7, #12]
 8023528:	60b9      	str	r1, [r7, #8]
 802352a:	607a      	str	r2, [r7, #4]
  SPI_MASTER_STATUS_t status;
  
   status = SPI_MASTER_STATUS_FAILURE;
 802352c:	2301      	movs	r3, #1
 802352e:	75fb      	strb	r3, [r7, #23]
    status = SPI_MASTER_StartTransmitIRQ(handle, dataptr, count);
  }
#endif

#if (SPI_MASTER_DMA_TRANSMIT_MODE == 1U)
  if (handle->config->transmit_mode == SPI_MASTER_TRANSFER_MODE_DMA)
 8023530:	68fb      	ldr	r3, [r7, #12]
 8023532:	685b      	ldr	r3, [r3, #4]
 8023534:	f893 3084 	ldrb.w	r3, [r3, #132]	; 0x84
 8023538:	2b01      	cmp	r3, #1
 802353a:	d106      	bne.n	802354a <SPI_MASTER_Transmit+0x2a>
  {
    status = SPI_MASTER_StartTransmitDMA(handle, dataptr, count);
 802353c:	68f8      	ldr	r0, [r7, #12]
 802353e:	68b9      	ldr	r1, [r7, #8]
 8023540:	687a      	ldr	r2, [r7, #4]
 8023542:	f000 f807 	bl	8023554 <SPI_MASTER_StartTransmitDMA>
 8023546:	4603      	mov	r3, r0
 8023548:	75fb      	strb	r3, [r7, #23]
  {
    status = SPI_MASTER_lStartTransmitPolling(handle, dataptr, count);
  }
#endif

  return status;
 802354a:	7dfb      	ldrb	r3, [r7, #23]
}
 802354c:	4618      	mov	r0, r3
 802354e:	3718      	adds	r7, #24
 8023550:	46bd      	mov	sp, r7
 8023552:	bd80      	pop	{r7, pc}

08023554 <SPI_MASTER_StartTransmitDMA>:
}
#endif

#if(SPI_MASTER_DMA_TRANSMIT_MODE == 1U)
SPI_MASTER_STATUS_t SPI_MASTER_StartTransmitDMA(const SPI_MASTER_t *const handle, uint8_t *data_ptr, uint32_t block_size)
{
 8023554:	b580      	push	{r7, lr}
 8023556:	b088      	sub	sp, #32
 8023558:	af00      	add	r7, sp, #0
 802355a:	60f8      	str	r0, [r7, #12]
 802355c:	60b9      	str	r1, [r7, #8]
 802355e:	607a      	str	r2, [r7, #4]
  uint32_t dma_ctll;
  uint32_t mode;

  XMC_ASSERT("SPI_MASTER_StartTransmitDMA:handle NULL" , (handle != NULL));

  status = SPI_MASTER_STATUS_MODE_MISMATCH;
 8023560:	2304      	movs	r3, #4
 8023562:	77fb      	strb	r3, [r7, #31]
  runtime_handle = handle->runtime;
 8023564:	68fb      	ldr	r3, [r7, #12]
 8023566:	689b      	ldr	r3, [r3, #8]
 8023568:	617b      	str	r3, [r7, #20]

  if (handle->config->transmit_mode == SPI_MASTER_TRANSFER_MODE_DMA)
 802356a:	68fb      	ldr	r3, [r7, #12]
 802356c:	685b      	ldr	r3, [r3, #4]
 802356e:	f893 3084 	ldrb.w	r3, [r3, #132]	; 0x84
 8023572:	2b01      	cmp	r3, #1
 8023574:	f040 80bc 	bne.w	80236f0 <SPI_MASTER_StartTransmitDMA+0x19c>
  {
    /* Check whether SPI channel is free or not */
    if (false == runtime_handle->tx_busy)
 8023578:	697b      	ldr	r3, [r7, #20]
 802357a:	f893 3020 	ldrb.w	r3, [r3, #32]
 802357e:	b2db      	uxtb	r3, r3
 8023580:	f083 0301 	eor.w	r3, r3, #1
 8023584:	b2db      	uxtb	r3, r3
 8023586:	2b00      	cmp	r3, #0
 8023588:	f000 80b0 	beq.w	80236ec <SPI_MASTER_StartTransmitDMA+0x198>
    {
      /* Check data pointer is valid or not */
      if ((data_ptr != NULL) && (block_size > 0U) && (block_size <= SPI_MASTER_DMA_MAXCOUNT))
 802358c:	68bb      	ldr	r3, [r7, #8]
 802358e:	2b00      	cmp	r3, #0
 8023590:	f000 80a9 	beq.w	80236e6 <SPI_MASTER_StartTransmitDMA+0x192>
 8023594:	687b      	ldr	r3, [r7, #4]
 8023596:	2b00      	cmp	r3, #0
 8023598:	f000 80a5 	beq.w	80236e6 <SPI_MASTER_StartTransmitDMA+0x192>
 802359c:	687b      	ldr	r3, [r7, #4]
 802359e:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80235a2:	f080 80a0 	bcs.w	80236e6 <SPI_MASTER_StartTransmitDMA+0x192>
      {
        /* Obtain the address of data, size of data */
        runtime_handle->tx_data_count = block_size;
 80235a6:	697b      	ldr	r3, [r7, #20]
 80235a8:	687a      	ldr	r2, [r7, #4]
 80235aa:	605a      	str	r2, [r3, #4]
        /* Initialize to first index and set the busy flag */
        runtime_handle->tx_data_index = 0U;
 80235ac:	697b      	ldr	r3, [r7, #20]
 80235ae:	2200      	movs	r2, #0
 80235b0:	609a      	str	r2, [r3, #8]
        runtime_handle->tx_busy = true;
 80235b2:	697b      	ldr	r3, [r7, #20]
 80235b4:	2201      	movs	r2, #1
 80235b6:	f883 2020 	strb.w	r2, [r3, #32]

        if (runtime_handle->tx_data_dummy == true)
 80235ba:	697b      	ldr	r3, [r7, #20]
 80235bc:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
 80235c0:	b2db      	uxtb	r3, r3
 80235c2:	2b00      	cmp	r3, #0
 80235c4:	d029      	beq.n	802361a <SPI_MASTER_StartTransmitDMA+0xc6>
        {
          dma_ctll = (uint32_t)handle->global_dma->dma->CH[handle->dma_ch_tx_number].CTLL;
 80235c6:	68fb      	ldr	r3, [r7, #12]
 80235c8:	68db      	ldr	r3, [r3, #12]
 80235ca:	681a      	ldr	r2, [r3, #0]
 80235cc:	68fb      	ldr	r3, [r7, #12]
 80235ce:	7f5b      	ldrb	r3, [r3, #29]
 80235d0:	4619      	mov	r1, r3
 80235d2:	2358      	movs	r3, #88	; 0x58
 80235d4:	fb03 f301 	mul.w	r3, r3, r1
 80235d8:	4413      	add	r3, r2
 80235da:	3318      	adds	r3, #24
 80235dc:	681b      	ldr	r3, [r3, #0]
 80235de:	613b      	str	r3, [r7, #16]

          dma_ctll = (uint32_t)(dma_ctll & (uint32_t)(~(GPDMA0_CH_CTLL_SINC_Msk))) |
 80235e0:	693b      	ldr	r3, [r7, #16]
 80235e2:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 80235e6:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 80235ea:	613b      	str	r3, [r7, #16]
                               ((uint32_t)XMC_DMA_CH_ADDRESS_COUNT_MODE_NO_CHANGE << GPDMA0_CH_CTLL_SINC_Pos);

          handle->global_dma->dma->CH[handle->dma_ch_tx_number].CTLL = dma_ctll;
 80235ec:	68fb      	ldr	r3, [r7, #12]
 80235ee:	68db      	ldr	r3, [r3, #12]
 80235f0:	681a      	ldr	r2, [r3, #0]
 80235f2:	68fb      	ldr	r3, [r7, #12]
 80235f4:	7f5b      	ldrb	r3, [r3, #29]
 80235f6:	4619      	mov	r1, r3
 80235f8:	2358      	movs	r3, #88	; 0x58
 80235fa:	fb03 f301 	mul.w	r3, r3, r1
 80235fe:	4413      	add	r3, r2
 8023600:	3318      	adds	r3, #24
 8023602:	693a      	ldr	r2, [r7, #16]
 8023604:	601a      	str	r2, [r3, #0]
          mode = (uint32_t)((uint32_t)handle->runtime->spi_master_mode & 0xfffbU);
 8023606:	68fb      	ldr	r3, [r7, #12]
 8023608:	689b      	ldr	r3, [r3, #8]
 802360a:	7f1b      	ldrb	r3, [r3, #28]
 802360c:	b2db      	uxtb	r3, r3
 802360e:	461a      	mov	r2, r3
 8023610:	f64f 73fb 	movw	r3, #65531	; 0xfffb
 8023614:	4013      	ands	r3, r2
 8023616:	61bb      	str	r3, [r7, #24]
 8023618:	e025      	b.n	8023666 <SPI_MASTER_StartTransmitDMA+0x112>
        }
        else
        {
          runtime_handle->tx_data = data_ptr;
 802361a:	697b      	ldr	r3, [r7, #20]
 802361c:	68ba      	ldr	r2, [r7, #8]
 802361e:	619a      	str	r2, [r3, #24]
          dma_ctll = handle->global_dma->dma->CH[handle->dma_ch_tx_number].CTLL;
 8023620:	68fb      	ldr	r3, [r7, #12]
 8023622:	68db      	ldr	r3, [r3, #12]
 8023624:	681a      	ldr	r2, [r3, #0]
 8023626:	68fb      	ldr	r3, [r7, #12]
 8023628:	7f5b      	ldrb	r3, [r3, #29]
 802362a:	4619      	mov	r1, r3
 802362c:	2358      	movs	r3, #88	; 0x58
 802362e:	fb03 f301 	mul.w	r3, r3, r1
 8023632:	4413      	add	r3, r2
 8023634:	3318      	adds	r3, #24
 8023636:	681b      	ldr	r3, [r3, #0]
 8023638:	613b      	str	r3, [r7, #16]

          dma_ctll = (uint32_t)(dma_ctll & (~GPDMA0_CH_CTLL_SINC_Msk)) |
 802363a:	693b      	ldr	r3, [r7, #16]
 802363c:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 8023640:	613b      	str	r3, [r7, #16]
                               ((uint32_t)XMC_DMA_CH_ADDRESS_COUNT_MODE_INCREMENT << GPDMA0_CH_CTLL_SINC_Pos);

          handle->global_dma->dma->CH[handle->dma_ch_tx_number].CTLL = dma_ctll;
 8023642:	68fb      	ldr	r3, [r7, #12]
 8023644:	68db      	ldr	r3, [r3, #12]
 8023646:	681a      	ldr	r2, [r3, #0]
 8023648:	68fb      	ldr	r3, [r7, #12]
 802364a:	7f5b      	ldrb	r3, [r3, #29]
 802364c:	4619      	mov	r1, r3
 802364e:	2358      	movs	r3, #88	; 0x58
 8023650:	fb03 f301 	mul.w	r3, r3, r1
 8023654:	4413      	add	r3, r2
 8023656:	3318      	adds	r3, #24
 8023658:	693a      	ldr	r2, [r7, #16]
 802365a:	601a      	str	r2, [r3, #0]
          mode = (uint32_t)handle->runtime->spi_master_mode;
 802365c:	68fb      	ldr	r3, [r7, #12]
 802365e:	689b      	ldr	r3, [r3, #8]
 8023660:	7f1b      	ldrb	r3, [r3, #28]
 8023662:	b2db      	uxtb	r3, r3
 8023664:	61bb      	str	r3, [r7, #24]
        }

        /* Enable transmit event generation */
        XMC_SPI_CH_EnableEvent(handle->channel, (uint32_t)XMC_SPI_CH_EVENT_RECEIVE_START);
 8023666:	68fb      	ldr	r3, [r7, #12]
 8023668:	681b      	ldr	r3, [r3, #0]
 802366a:	4618      	mov	r0, r3
 802366c:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8023670:	f7ff fc0a 	bl	8022e88 <XMC_SPI_CH_EnableEvent>

        XMC_DMA_CH_SetBlockSize(handle->global_dma->dma, handle->dma_ch_tx_number, block_size);
 8023674:	68fb      	ldr	r3, [r7, #12]
 8023676:	68db      	ldr	r3, [r3, #12]
 8023678:	681a      	ldr	r2, [r3, #0]
 802367a:	68fb      	ldr	r3, [r7, #12]
 802367c:	7f5b      	ldrb	r3, [r3, #29]
 802367e:	4610      	mov	r0, r2
 8023680:	4619      	mov	r1, r3
 8023682:	687a      	ldr	r2, [r7, #4]
 8023684:	f7ff ff26 	bl	80234d4 <XMC_DMA_CH_SetBlockSize>

        XMC_DMA_CH_SetSourceAddress(handle->global_dma->dma, handle->dma_ch_tx_number, (uint32_t)runtime_handle->tx_data);
 8023688:	68fb      	ldr	r3, [r7, #12]
 802368a:	68db      	ldr	r3, [r3, #12]
 802368c:	6819      	ldr	r1, [r3, #0]
 802368e:	68fb      	ldr	r3, [r7, #12]
 8023690:	7f5a      	ldrb	r2, [r3, #29]
 8023692:	697b      	ldr	r3, [r7, #20]
 8023694:	699b      	ldr	r3, [r3, #24]
 8023696:	4608      	mov	r0, r1
 8023698:	4611      	mov	r1, r2
 802369a:	461a      	mov	r2, r3
 802369c:	f7ff fef0 	bl	8023480 <XMC_DMA_CH_SetSourceAddress>

        XMC_SPI_CH_SetTransmitMode(handle->channel, runtime_handle->spi_master_mode);
 80236a0:	68fb      	ldr	r3, [r7, #12]
 80236a2:	681a      	ldr	r2, [r3, #0]
 80236a4:	697b      	ldr	r3, [r7, #20]
 80236a6:	7f1b      	ldrb	r3, [r3, #28]
 80236a8:	b2db      	uxtb	r3, r3
 80236aa:	4610      	mov	r0, r2
 80236ac:	4619      	mov	r1, r3
 80236ae:	f7ff febf 	bl	8023430 <XMC_SPI_CH_SetTransmitMode>

        XMC_DMA_CH_SetDestinationAddress(handle->global_dma->dma,
 80236b2:	68fb      	ldr	r3, [r7, #12]
 80236b4:	68db      	ldr	r3, [r3, #12]
 80236b6:	6818      	ldr	r0, [r3, #0]
 80236b8:	68fb      	ldr	r3, [r7, #12]
 80236ba:	7f59      	ldrb	r1, [r3, #29]
                                         handle->dma_ch_tx_number,
                                         (uint32_t)&(handle->channel->TBUF[mode]));
 80236bc:	68fb      	ldr	r3, [r7, #12]
 80236be:	681a      	ldr	r2, [r3, #0]
 80236c0:	69bb      	ldr	r3, [r7, #24]
 80236c2:	3320      	adds	r3, #32
 80236c4:	009b      	lsls	r3, r3, #2
 80236c6:	4413      	add	r3, r2

        XMC_DMA_CH_SetSourceAddress(handle->global_dma->dma, handle->dma_ch_tx_number, (uint32_t)runtime_handle->tx_data);

        XMC_SPI_CH_SetTransmitMode(handle->channel, runtime_handle->spi_master_mode);

        XMC_DMA_CH_SetDestinationAddress(handle->global_dma->dma,
 80236c8:	461a      	mov	r2, r3
 80236ca:	f7ff feed 	bl	80234a8 <XMC_DMA_CH_SetDestinationAddress>
                                         handle->dma_ch_tx_number,
                                         (uint32_t)&(handle->channel->TBUF[mode]));

        status = SPI_MASTER_STATUS_SUCCESS;
 80236ce:	2300      	movs	r3, #0
 80236d0:	77fb      	strb	r3, [r7, #31]

        XMC_DMA_CH_Enable(handle->global_dma->dma, handle->dma_ch_tx_number);
 80236d2:	68fb      	ldr	r3, [r7, #12]
 80236d4:	68db      	ldr	r3, [r3, #12]
 80236d6:	681a      	ldr	r2, [r3, #0]
 80236d8:	68fb      	ldr	r3, [r7, #12]
 80236da:	7f5b      	ldrb	r3, [r3, #29]
 80236dc:	4610      	mov	r0, r2
 80236de:	4619      	mov	r1, r3
 80236e0:	f7ff febc 	bl	802345c <XMC_DMA_CH_Enable>
 80236e4:	e004      	b.n	80236f0 <SPI_MASTER_StartTransmitDMA+0x19c>
      }
      else
      {
        status = SPI_MASTER_STATUS_BUFFER_INVALID;
 80236e6:	2303      	movs	r3, #3
 80236e8:	77fb      	strb	r3, [r7, #31]
 80236ea:	e001      	b.n	80236f0 <SPI_MASTER_StartTransmitDMA+0x19c>
      }
    }
    else
    {
      status = SPI_MASTER_STATUS_BUSY;
 80236ec:	2302      	movs	r3, #2
 80236ee:	77fb      	strb	r3, [r7, #31]
    }
  }

  return status;
 80236f0:	7ffb      	ldrb	r3, [r7, #31]
}
 80236f2:	4618      	mov	r0, r3
 80236f4:	3720      	adds	r7, #32
 80236f6:	46bd      	mov	sp, r7
 80236f8:	bd80      	pop	{r7, pc}
 80236fa:	bf00      	nop

080236fc <SPI_MASTER_Transfer>:
 */
SPI_MASTER_STATUS_t SPI_MASTER_Transfer(const SPI_MASTER_t *const handle,
                                        uint8_t* tx_dataptr,
                                        uint8_t* rx_dataptr,
                                        uint32_t count)
{
 80236fc:	b580      	push	{r7, lr}
 80236fe:	b086      	sub	sp, #24
 8023700:	af00      	add	r7, sp, #0
 8023702:	60f8      	str	r0, [r7, #12]
 8023704:	60b9      	str	r1, [r7, #8]
 8023706:	607a      	str	r2, [r7, #4]
 8023708:	603b      	str	r3, [r7, #0]
  SPI_MASTER_STATUS_t status;
  SPI_MASTER_RUNTIME_t * runtime_handle;

  XMC_ASSERT("SPI_MASTER_Transfer:handle NULL" , (handle != NULL));

  status = SPI_MASTER_STATUS_BUSY;
 802370a:	2302      	movs	r3, #2
 802370c:	75fb      	strb	r3, [r7, #23]
  runtime_handle = handle->runtime;
 802370e:	68fb      	ldr	r3, [r7, #12]
 8023710:	689b      	ldr	r3, [r3, #8]
 8023712:	613b      	str	r3, [r7, #16]

  if (XMC_SPI_CH_MODE_STANDARD == runtime_handle->spi_master_mode)
 8023714:	693b      	ldr	r3, [r7, #16]
 8023716:	7f1b      	ldrb	r3, [r3, #28]
 8023718:	b2db      	uxtb	r3, r3
 802371a:	2b00      	cmp	r3, #0
 802371c:	d13f      	bne.n	802379e <SPI_MASTER_Transfer+0xa2>
  {
    /* Check whether SPI channel is free or not */
    if ((tx_dataptr != NULL) && (rx_dataptr != NULL) && (count > 0U))
 802371e:	68bb      	ldr	r3, [r7, #8]
 8023720:	2b00      	cmp	r3, #0
 8023722:	d038      	beq.n	8023796 <SPI_MASTER_Transfer+0x9a>
 8023724:	687b      	ldr	r3, [r7, #4]
 8023726:	2b00      	cmp	r3, #0
 8023728:	d035      	beq.n	8023796 <SPI_MASTER_Transfer+0x9a>
 802372a:	683b      	ldr	r3, [r7, #0]
 802372c:	2b00      	cmp	r3, #0
 802372e:	d032      	beq.n	8023796 <SPI_MASTER_Transfer+0x9a>
    {
      /*Check data pointer is valid or not*/
      if ((false == runtime_handle->rx_busy) && (false == runtime_handle->tx_busy))
 8023730:	693b      	ldr	r3, [r7, #16]
 8023732:	7fdb      	ldrb	r3, [r3, #31]
 8023734:	b2db      	uxtb	r3, r3
 8023736:	f083 0301 	eor.w	r3, r3, #1
 802373a:	b2db      	uxtb	r3, r3
 802373c:	2b00      	cmp	r3, #0
 802373e:	d029      	beq.n	8023794 <SPI_MASTER_Transfer+0x98>
 8023740:	693b      	ldr	r3, [r7, #16]
 8023742:	f893 3020 	ldrb.w	r3, [r3, #32]
 8023746:	b2db      	uxtb	r3, r3
 8023748:	f083 0301 	eor.w	r3, r3, #1
 802374c:	b2db      	uxtb	r3, r3
 802374e:	2b00      	cmp	r3, #0
 8023750:	d020      	beq.n	8023794 <SPI_MASTER_Transfer+0x98>
      {
        runtime_handle->rx_busy = true;
 8023752:	693b      	ldr	r3, [r7, #16]
 8023754:	2201      	movs	r2, #1
 8023756:	77da      	strb	r2, [r3, #31]
        runtime_handle->rx_data = rx_dataptr;
 8023758:	693b      	ldr	r3, [r7, #16]
 802375a:	687a      	ldr	r2, [r7, #4]
 802375c:	615a      	str	r2, [r3, #20]
        runtime_handle->tx_data = tx_dataptr;
 802375e:	693b      	ldr	r3, [r7, #16]
 8023760:	68ba      	ldr	r2, [r7, #8]
 8023762:	619a      	str	r2, [r3, #24]
        runtime_handle->tx_data_count = count;
 8023764:	693b      	ldr	r3, [r7, #16]
 8023766:	683a      	ldr	r2, [r7, #0]
 8023768:	605a      	str	r2, [r3, #4]
        runtime_handle->tx_data_dummy = false;
 802376a:	693b      	ldr	r3, [r7, #16]
 802376c:	2200      	movs	r2, #0
 802376e:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
        runtime_handle->rx_data_dummy = false;
 8023772:	693b      	ldr	r3, [r7, #16]
 8023774:	2200      	movs	r2, #0
 8023776:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
        {
          status = SPI_MASTER_lReceiveIRQ(handle, count);
        }
#endif
#if (SPI_MASTER_DMA_RECEIVE_MODE == 1U)
        if (handle->config->receive_mode == SPI_MASTER_TRANSFER_MODE_DMA)
 802377a:	68fb      	ldr	r3, [r7, #12]
 802377c:	685b      	ldr	r3, [r3, #4]
 802377e:	f893 3085 	ldrb.w	r3, [r3, #133]	; 0x85
 8023782:	2b01      	cmp	r3, #1
 8023784:	d106      	bne.n	8023794 <SPI_MASTER_Transfer+0x98>
        {
          status = SPI_MASTER_lReceiveDMA(handle, count);
 8023786:	68f8      	ldr	r0, [r7, #12]
 8023788:	6839      	ldr	r1, [r7, #0]
 802378a:	f000 f80f 	bl	80237ac <SPI_MASTER_lReceiveDMA>
 802378e:	4603      	mov	r3, r0
 8023790:	75fb      	strb	r3, [r7, #23]
  {
    /* Check whether SPI channel is free or not */
    if ((tx_dataptr != NULL) && (rx_dataptr != NULL) && (count > 0U))
    {
      /*Check data pointer is valid or not*/
      if ((false == runtime_handle->rx_busy) && (false == runtime_handle->tx_busy))
 8023792:	e003      	b.n	802379c <SPI_MASTER_Transfer+0xa0>
 8023794:	e002      	b.n	802379c <SPI_MASTER_Transfer+0xa0>
#endif
      }
    }
    else
    {
      status = SPI_MASTER_STATUS_BUFFER_INVALID;
 8023796:	2303      	movs	r3, #3
 8023798:	75fb      	strb	r3, [r7, #23]
 802379a:	e002      	b.n	80237a2 <SPI_MASTER_Transfer+0xa6>
 802379c:	e001      	b.n	80237a2 <SPI_MASTER_Transfer+0xa6>
    }
  }
  else
  {
    status = SPI_MASTER_STATUS_FAILURE;
 802379e:	2301      	movs	r3, #1
 80237a0:	75fb      	strb	r3, [r7, #23]
  }

  return status;
 80237a2:	7dfb      	ldrb	r3, [r7, #23]
}
 80237a4:	4618      	mov	r0, r3
 80237a6:	3718      	adds	r7, #24
 80237a8:	46bd      	mov	sp, r7
 80237aa:	bd80      	pop	{r7, pc}

080237ac <SPI_MASTER_lReceiveDMA>:
}
#endif

#if (SPI_MASTER_DMA_RECEIVE_MODE == 1U)
SPI_MASTER_STATUS_t SPI_MASTER_lReceiveDMA(const SPI_MASTER_t *const handle, uint32_t block_size)
{
 80237ac:	b580      	push	{r7, lr}
 80237ae:	b084      	sub	sp, #16
 80237b0:	af00      	add	r7, sp, #0
 80237b2:	6078      	str	r0, [r7, #4]
 80237b4:	6039      	str	r1, [r7, #0]
  SPI_MASTER_STATUS_t status;
  SPI_MASTER_RUNTIME_t * runtime_handle;

  runtime_handle = handle->runtime;
 80237b6:	687b      	ldr	r3, [r7, #4]
 80237b8:	689b      	ldr	r3, [r3, #8]
 80237ba:	60fb      	str	r3, [r7, #12]
  runtime_handle->rx_data_index = 0U;
 80237bc:	68fb      	ldr	r3, [r7, #12]
 80237be:	2200      	movs	r2, #0
 80237c0:	611a      	str	r2, [r3, #16]
  runtime_handle->rx_data_count = (uint32_t)block_size;
 80237c2:	68fb      	ldr	r3, [r7, #12]
 80237c4:	683a      	ldr	r2, [r7, #0]
 80237c6:	60da      	str	r2, [r3, #12]

  SPI_MASTER_lStdRBUFFlush(handle->channel);
 80237c8:	687b      	ldr	r3, [r7, #4]
 80237ca:	681b      	ldr	r3, [r3, #0]
 80237cc:	4618      	mov	r0, r3
 80237ce:	f000 f847 	bl	8023860 <SPI_MASTER_lStdRBUFFlush>

  XMC_SPI_CH_EnableEvent(handle->channel, (uint32_t)SPI_MASTER_RECEIVE_EVENT);
 80237d2:	687b      	ldr	r3, [r7, #4]
 80237d4:	681b      	ldr	r3, [r3, #0]
 80237d6:	4618      	mov	r0, r3
 80237d8:	f44f 4140 	mov.w	r1, #49152	; 0xc000
 80237dc:	f7ff fb54 	bl	8022e88 <XMC_SPI_CH_EnableEvent>

  XMC_DMA_CH_SetBlockSize(handle->global_dma->dma, handle->dma_ch_rx_number, runtime_handle->rx_data_count);
 80237e0:	687b      	ldr	r3, [r7, #4]
 80237e2:	68db      	ldr	r3, [r3, #12]
 80237e4:	6819      	ldr	r1, [r3, #0]
 80237e6:	687b      	ldr	r3, [r7, #4]
 80237e8:	7f1a      	ldrb	r2, [r3, #28]
 80237ea:	68fb      	ldr	r3, [r7, #12]
 80237ec:	68db      	ldr	r3, [r3, #12]
 80237ee:	4608      	mov	r0, r1
 80237f0:	4611      	mov	r1, r2
 80237f2:	461a      	mov	r2, r3
 80237f4:	f7ff fe6e 	bl	80234d4 <XMC_DMA_CH_SetBlockSize>

  XMC_DMA_CH_SetSourceAddress(handle->global_dma->dma,
 80237f8:	687b      	ldr	r3, [r7, #4]
 80237fa:	68db      	ldr	r3, [r3, #12]
 80237fc:	6819      	ldr	r1, [r3, #0]
 80237fe:	687b      	ldr	r3, [r7, #4]
 8023800:	7f1a      	ldrb	r2, [r3, #28]
                              handle->dma_ch_rx_number,
                              (uint32_t)&(handle->channel->RBUF));
 8023802:	687b      	ldr	r3, [r7, #4]
 8023804:	681b      	ldr	r3, [r3, #0]
 8023806:	3354      	adds	r3, #84	; 0x54

  XMC_SPI_CH_EnableEvent(handle->channel, (uint32_t)SPI_MASTER_RECEIVE_EVENT);

  XMC_DMA_CH_SetBlockSize(handle->global_dma->dma, handle->dma_ch_rx_number, runtime_handle->rx_data_count);

  XMC_DMA_CH_SetSourceAddress(handle->global_dma->dma,
 8023808:	4608      	mov	r0, r1
 802380a:	4611      	mov	r1, r2
 802380c:	461a      	mov	r2, r3
 802380e:	f7ff fe37 	bl	8023480 <XMC_DMA_CH_SetSourceAddress>
                              handle->dma_ch_rx_number,
                              (uint32_t)&(handle->channel->RBUF));

  XMC_DMA_CH_SetDestinationAddress(handle->global_dma->dma, handle->dma_ch_rx_number, (uint32_t)runtime_handle->rx_data);
 8023812:	687b      	ldr	r3, [r7, #4]
 8023814:	68db      	ldr	r3, [r3, #12]
 8023816:	6819      	ldr	r1, [r3, #0]
 8023818:	687b      	ldr	r3, [r7, #4]
 802381a:	7f1a      	ldrb	r2, [r3, #28]
 802381c:	68fb      	ldr	r3, [r7, #12]
 802381e:	695b      	ldr	r3, [r3, #20]
 8023820:	4608      	mov	r0, r1
 8023822:	4611      	mov	r1, r2
 8023824:	461a      	mov	r2, r3
 8023826:	f7ff fe3f 	bl	80234a8 <XMC_DMA_CH_SetDestinationAddress>

  status = SPI_MASTER_STATUS_SUCCESS;
 802382a:	2300      	movs	r3, #0
 802382c:	72fb      	strb	r3, [r7, #11]

  XMC_DMA_CH_Enable(handle->global_dma->dma, handle->dma_ch_rx_number);
 802382e:	687b      	ldr	r3, [r7, #4]
 8023830:	68db      	ldr	r3, [r3, #12]
 8023832:	681a      	ldr	r2, [r3, #0]
 8023834:	687b      	ldr	r3, [r7, #4]
 8023836:	7f1b      	ldrb	r3, [r3, #28]
 8023838:	4610      	mov	r0, r2
 802383a:	4619      	mov	r1, r3
 802383c:	f7ff fe0e 	bl	802345c <XMC_DMA_CH_Enable>

  /* Call the transmit, to receive the data synchronously */
  status = SPI_MASTER_Transmit(handle, runtime_handle->tx_data, runtime_handle->tx_data_count);
 8023840:	68fb      	ldr	r3, [r7, #12]
 8023842:	699a      	ldr	r2, [r3, #24]
 8023844:	68fb      	ldr	r3, [r7, #12]
 8023846:	685b      	ldr	r3, [r3, #4]
 8023848:	6878      	ldr	r0, [r7, #4]
 802384a:	4611      	mov	r1, r2
 802384c:	461a      	mov	r2, r3
 802384e:	f7ff fe67 	bl	8023520 <SPI_MASTER_Transmit>
 8023852:	4603      	mov	r3, r0
 8023854:	72fb      	strb	r3, [r7, #11]

  return status;
 8023856:	7afb      	ldrb	r3, [r7, #11]
}
 8023858:	4618      	mov	r0, r3
 802385a:	3710      	adds	r7, #16
 802385c:	46bd      	mov	sp, r7
 802385e:	bd80      	pop	{r7, pc}

08023860 <SPI_MASTER_lStdRBUFFlush>:

/*
 * Clears the receive buffers
 */
static void SPI_MASTER_lStdRBUFFlush(XMC_USIC_CH_t *const channel)
{
 8023860:	b580      	push	{r7, lr}
 8023862:	b082      	sub	sp, #8
 8023864:	af00      	add	r7, sp, #0
 8023866:	6078      	str	r0, [r7, #4]
  /* Clear RBF0 */
  (void)XMC_SPI_CH_GetReceivedData(channel);
 8023868:	6878      	ldr	r0, [r7, #4]
 802386a:	f7ff faf3 	bl	8022e54 <XMC_SPI_CH_GetReceivedData>
  /* Clear RBF1 */
  (void)XMC_SPI_CH_GetReceivedData(channel);
 802386e:	6878      	ldr	r0, [r7, #4]
 8023870:	f7ff faf0 	bl	8022e54 <XMC_SPI_CH_GetReceivedData>
}
 8023874:	3708      	adds	r7, #8
 8023876:	46bd      	mov	sp, r7
 8023878:	bd80      	pop	{r7, pc}
 802387a:	bf00      	nop

0802387c <XMC_USIC_CH_SetInputSource>:
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_EnableInputInversion(), XMC_USIC_CH_EnableInputDigitalFilter(), XMC_USIC_CH_EnableInputSync(),
 * XMC_USIC_CH_SetInputSamplingFreq()\n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_SetInputSource(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_INPUT_t input, const uint8_t source)
{
 802387c:	b480      	push	{r7}
 802387e:	b083      	sub	sp, #12
 8023880:	af00      	add	r7, sp, #0
 8023882:	6078      	str	r0, [r7, #4]
 8023884:	460b      	mov	r3, r1
 8023886:	70fb      	strb	r3, [r7, #3]
 8023888:	4613      	mov	r3, r2
 802388a:	70bb      	strb	r3, [r7, #2]
  channel->DXCR[input] = (uint32_t)((channel->DXCR[input] & (uint32_t)(~USIC_CH_DXCR_DSEL_Msk)) |
 802388c:	78f8      	ldrb	r0, [r7, #3]
 802388e:	78fb      	ldrb	r3, [r7, #3]
 8023890:	687a      	ldr	r2, [r7, #4]
 8023892:	3306      	adds	r3, #6
 8023894:	009b      	lsls	r3, r3, #2
 8023896:	4413      	add	r3, r2
 8023898:	685b      	ldr	r3, [r3, #4]
 802389a:	f023 0207 	bic.w	r2, r3, #7
                                    ((uint32_t)source << USIC_CH_DXCR_DSEL_Pos));
 802389e:	78bb      	ldrb	r3, [r7, #2]
 * XMC_USIC_CH_EnableInputInversion(), XMC_USIC_CH_EnableInputDigitalFilter(), XMC_USIC_CH_EnableInputSync(),
 * XMC_USIC_CH_SetInputSamplingFreq()\n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_SetInputSource(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_INPUT_t input, const uint8_t source)
{
  channel->DXCR[input] = (uint32_t)((channel->DXCR[input] & (uint32_t)(~USIC_CH_DXCR_DSEL_Msk)) |
 80238a0:	431a      	orrs	r2, r3
 80238a2:	6879      	ldr	r1, [r7, #4]
 80238a4:	1d83      	adds	r3, r0, #6
 80238a6:	009b      	lsls	r3, r3, #2
 80238a8:	440b      	add	r3, r1
 80238aa:	605a      	str	r2, [r3, #4]
                                    ((uint32_t)source << USIC_CH_DXCR_DSEL_Pos));
}
 80238ac:	370c      	adds	r7, #12
 80238ae:	46bd      	mov	sp, r7
 80238b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80238b4:	4770      	bx	lr
 80238b6:	bf00      	nop

080238b8 <XMC_USIC_CH_SetWordLength>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_SetFrameLength()\n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_SetWordLength(XMC_USIC_CH_t *const channel, const uint8_t word_length)
{
 80238b8:	b480      	push	{r7}
 80238ba:	b083      	sub	sp, #12
 80238bc:	af00      	add	r7, sp, #0
 80238be:	6078      	str	r0, [r7, #4]
 80238c0:	460b      	mov	r3, r1
 80238c2:	70fb      	strb	r3, [r7, #3]
  channel->SCTR = (uint32_t)(channel->SCTR & (~USIC_CH_SCTR_WLE_Msk)) |
 80238c4:	687b      	ldr	r3, [r7, #4]
 80238c6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80238c8:	f023 6270 	bic.w	r2, r3, #251658240	; 0xf000000
                  (uint32_t)(((uint32_t)word_length - 1UL)  << USIC_CH_SCTR_WLE_Pos);
 80238cc:	78fb      	ldrb	r3, [r7, #3]
 80238ce:	3b01      	subs	r3, #1
 80238d0:	061b      	lsls	r3, r3, #24
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_SetFrameLength()\n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_SetWordLength(XMC_USIC_CH_t *const channel, const uint8_t word_length)
{
  channel->SCTR = (uint32_t)(channel->SCTR & (~USIC_CH_SCTR_WLE_Msk)) |
 80238d2:	431a      	orrs	r2, r3
 80238d4:	687b      	ldr	r3, [r7, #4]
 80238d6:	635a      	str	r2, [r3, #52]	; 0x34
                  (uint32_t)(((uint32_t)word_length - 1UL)  << USIC_CH_SCTR_WLE_Pos);
}
 80238d8:	370c      	adds	r7, #12
 80238da:	46bd      	mov	sp, r7
 80238dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80238e0:	4770      	bx	lr
 80238e2:	bf00      	nop

080238e4 <XMC_USIC_CH_SetFrameLength>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_SetWordLength(), XMC_USIC_CH_EnableFrameLengthControl() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_SetFrameLength(XMC_USIC_CH_t *const channel, const uint8_t frame_length)
{
 80238e4:	b480      	push	{r7}
 80238e6:	b083      	sub	sp, #12
 80238e8:	af00      	add	r7, sp, #0
 80238ea:	6078      	str	r0, [r7, #4]
 80238ec:	460b      	mov	r3, r1
 80238ee:	70fb      	strb	r3, [r7, #3]
  channel->SCTR = (uint32_t)(channel->SCTR & (~USIC_CH_SCTR_FLE_Msk)) |
 80238f0:	687b      	ldr	r3, [r7, #4]
 80238f2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80238f4:	f423 127c 	bic.w	r2, r3, #4128768	; 0x3f0000
                  (((uint32_t)frame_length - 0x1U)  << USIC_CH_SCTR_FLE_Pos);
 80238f8:	78fb      	ldrb	r3, [r7, #3]
 80238fa:	3b01      	subs	r3, #1
 80238fc:	041b      	lsls	r3, r3, #16
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_SetWordLength(), XMC_USIC_CH_EnableFrameLengthControl() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_SetFrameLength(XMC_USIC_CH_t *const channel, const uint8_t frame_length)
{
  channel->SCTR = (uint32_t)(channel->SCTR & (~USIC_CH_SCTR_FLE_Msk)) |
 80238fe:	431a      	orrs	r2, r3
 8023900:	687b      	ldr	r3, [r7, #4]
 8023902:	635a      	str	r2, [r3, #52]	; 0x34
                  (((uint32_t)frame_length - 0x1U)  << USIC_CH_SCTR_FLE_Pos);
}
 8023904:	370c      	adds	r7, #12
 8023906:	46bd      	mov	sp, r7
 8023908:	f85d 7b04 	ldr.w	r7, [sp], #4
 802390c:	4770      	bx	lr
 802390e:	bf00      	nop

08023910 <XMC_USIC_CH_GetTransmitBufferStatus>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_SetDataOutputMode() \n\n\n
 */
__STATIC_INLINE XMC_USIC_CH_TBUF_STATUS_t XMC_USIC_CH_GetTransmitBufferStatus(XMC_USIC_CH_t *const channel)
{
 8023910:	b480      	push	{r7}
 8023912:	b083      	sub	sp, #12
 8023914:	af00      	add	r7, sp, #0
 8023916:	6078      	str	r0, [r7, #4]
  return (XMC_USIC_CH_TBUF_STATUS_t)(channel->TCSR & USIC_CH_TCSR_TDV_Msk);
 8023918:	687b      	ldr	r3, [r7, #4]
 802391a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802391c:	b2db      	uxtb	r3, r3
 802391e:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8023922:	b2db      	uxtb	r3, r3
}
 8023924:	4618      	mov	r0, r3
 8023926:	370c      	adds	r7, #12
 8023928:	46bd      	mov	sp, r7
 802392a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802392e:	4770      	bx	lr

08023930 <XMC_USIC_CH_TriggerServiceRequest>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_SetInterruptNodePointer() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_TriggerServiceRequest(XMC_USIC_CH_t *const channel, const uint32_t service_request_line)
{
 8023930:	b480      	push	{r7}
 8023932:	b083      	sub	sp, #12
 8023934:	af00      	add	r7, sp, #0
 8023936:	6078      	str	r0, [r7, #4]
 8023938:	6039      	str	r1, [r7, #0]
  channel->FMR = (uint32_t)(USIC_CH_FMR_SIO0_Msk << service_request_line);
 802393a:	683b      	ldr	r3, [r7, #0]
 802393c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8023940:	409a      	lsls	r2, r3
 8023942:	687b      	ldr	r3, [r7, #4]
 8023944:	669a      	str	r2, [r3, #104]	; 0x68
}
 8023946:	370c      	adds	r7, #12
 8023948:	46bd      	mov	sp, r7
 802394a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802394e:	4770      	bx	lr

08023950 <XMC_USIC_CH_ConfigureShiftClockOutput>:
 *
 */
__STATIC_INLINE void XMC_USIC_CH_ConfigureShiftClockOutput(XMC_USIC_CH_t *const channel,
    const XMC_USIC_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_t passive_level,
    const XMC_USIC_CH_BRG_SHIFT_CLOCK_OUTPUT_t clock_output)
{
 8023950:	b480      	push	{r7}
 8023952:	b085      	sub	sp, #20
 8023954:	af00      	add	r7, sp, #0
 8023956:	60f8      	str	r0, [r7, #12]
 8023958:	60b9      	str	r1, [r7, #8]
 802395a:	607a      	str	r2, [r7, #4]
  channel->BRG = (uint32_t)(channel->BRG & (~(USIC_CH_BRG_SCLKCFG_Msk |
 802395c:	68fb      	ldr	r3, [r7, #12]
 802395e:	695b      	ldr	r3, [r3, #20]
 8023960:	f023 4250 	bic.w	r2, r3, #3489660928	; 0xd0000000
                            USIC_CH_BRG_SCLKOSEL_Msk))) |
                 (uint32_t)passive_level |
 8023964:	68bb      	ldr	r3, [r7, #8]
__STATIC_INLINE void XMC_USIC_CH_ConfigureShiftClockOutput(XMC_USIC_CH_t *const channel,
    const XMC_USIC_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_t passive_level,
    const XMC_USIC_CH_BRG_SHIFT_CLOCK_OUTPUT_t clock_output)
{
  channel->BRG = (uint32_t)(channel->BRG & (~(USIC_CH_BRG_SCLKCFG_Msk |
                            USIC_CH_BRG_SCLKOSEL_Msk))) |
 8023966:	431a      	orrs	r2, r3
                 (uint32_t)passive_level |
 8023968:	687b      	ldr	r3, [r7, #4]
 802396a:	431a      	orrs	r2, r3
 */
__STATIC_INLINE void XMC_USIC_CH_ConfigureShiftClockOutput(XMC_USIC_CH_t *const channel,
    const XMC_USIC_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_t passive_level,
    const XMC_USIC_CH_BRG_SHIFT_CLOCK_OUTPUT_t clock_output)
{
  channel->BRG = (uint32_t)(channel->BRG & (~(USIC_CH_BRG_SCLKCFG_Msk |
 802396c:	68fb      	ldr	r3, [r7, #12]
 802396e:	615a      	str	r2, [r3, #20]
                            USIC_CH_BRG_SCLKOSEL_Msk))) |
                 (uint32_t)passive_level |
                 (uint32_t)clock_output;
}
 8023970:	3714      	adds	r7, #20
 8023972:	46bd      	mov	sp, r7
 8023974:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023978:	4770      	bx	lr
 802397a:	bf00      	nop

0802397c <XMC_USIC_CH_SetMode>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_Enable(), XMC_USIC_CH_Enable() \n\n\n
 */
__STATIC_INLINE void XMC_USIC_CH_SetMode(XMC_USIC_CH_t *const channel, const XMC_USIC_CH_OPERATING_MODE_t mode)
{
 802397c:	b480      	push	{r7}
 802397e:	b083      	sub	sp, #12
 8023980:	af00      	add	r7, sp, #0
 8023982:	6078      	str	r0, [r7, #4]
 8023984:	460b      	mov	r3, r1
 8023986:	70fb      	strb	r3, [r7, #3]
  channel->CCR = (uint32_t)(channel->CCR & (~(USIC_CH_CCR_MODE_Msk))) | (uint32_t)mode;
 8023988:	687b      	ldr	r3, [r7, #4]
 802398a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 802398c:	f023 020f 	bic.w	r2, r3, #15
 8023990:	78fb      	ldrb	r3, [r7, #3]
 8023992:	431a      	orrs	r2, r3
 8023994:	687b      	ldr	r3, [r7, #4]
 8023996:	641a      	str	r2, [r3, #64]	; 0x40
}
 8023998:	370c      	adds	r7, #12
 802399a:	46bd      	mov	sp, r7
 802399c:	f85d 7b04 	ldr.w	r7, [sp], #4
 80239a0:	4770      	bx	lr
 80239a2:	bf00      	nop

080239a4 <XMC_SPI_CH_Init>:
 * <li>Set polarity for the Slave signal,</li>
 * <li>Enable Frame end mode(MSLS signal is kept active after transmission of a frame)</li>
 * </ul>
 */
__STATIC_INLINE void XMC_SPI_CH_Init(XMC_USIC_CH_t *const channel, const XMC_SPI_CH_CONFIG_t *const config)
{
 80239a4:	b580      	push	{r7, lr}
 80239a6:	b082      	sub	sp, #8
 80239a8:	af00      	add	r7, sp, #0
 80239aa:	6078      	str	r0, [r7, #4]
 80239ac:	6039      	str	r1, [r7, #0]
  XMC_SPI_CH_InitEx(channel, config, true);
 80239ae:	6878      	ldr	r0, [r7, #4]
 80239b0:	6839      	ldr	r1, [r7, #0]
 80239b2:	2201      	movs	r2, #1
 80239b4:	f7ff fa08 	bl	8022dc8 <XMC_SPI_CH_InitEx>
}
 80239b8:	3708      	adds	r7, #8
 80239ba:	46bd      	mov	sp, r7
 80239bc:	bd80      	pop	{r7, pc}
 80239be:	bf00      	nop

080239c0 <XMC_SPI_CH_Start>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_SPI_CH_Init(), XMC_SPI_CH_Stop()
 */
__STATIC_INLINE void XMC_SPI_CH_Start(XMC_USIC_CH_t *const channel)
{
 80239c0:	b580      	push	{r7, lr}
 80239c2:	b082      	sub	sp, #8
 80239c4:	af00      	add	r7, sp, #0
 80239c6:	6078      	str	r0, [r7, #4]
  /* USIC channel in SPI mode */
  XMC_USIC_CH_SetMode(channel, XMC_USIC_CH_OPERATING_MODE_SPI);
 80239c8:	6878      	ldr	r0, [r7, #4]
 80239ca:	2101      	movs	r1, #1
 80239cc:	f7ff ffd6 	bl	802397c <XMC_USIC_CH_SetMode>
}
 80239d0:	3708      	adds	r7, #8
 80239d2:	46bd      	mov	sp, r7
 80239d4:	bd80      	pop	{r7, pc}
 80239d6:	bf00      	nop

080239d8 <XMC_SPI_CH_SetBitOrderMsbFirst>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_SPI_CH_SetBitOrderLsbFirst()
 */
__STATIC_INLINE void XMC_SPI_CH_SetBitOrderMsbFirst(XMC_USIC_CH_t *const channel)
{
 80239d8:	b480      	push	{r7}
 80239da:	b083      	sub	sp, #12
 80239dc:	af00      	add	r7, sp, #0
 80239de:	6078      	str	r0, [r7, #4]
  channel->SCTR |= (uint32_t)USIC_CH_SCTR_SDIR_Msk;
 80239e0:	687b      	ldr	r3, [r7, #4]
 80239e2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80239e4:	f043 0201 	orr.w	r2, r3, #1
 80239e8:	687b      	ldr	r3, [r7, #4]
 80239ea:	635a      	str	r2, [r3, #52]	; 0x34
}
 80239ec:	370c      	adds	r7, #12
 80239ee:	46bd      	mov	sp, r7
 80239f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80239f4:	4770      	bx	lr
 80239f6:	bf00      	nop

080239f8 <XMC_SPI_CH_SetSlaveSelectDelay>:
 * This delay is dependent on the peripheral clock. The maximum possible value supported by this API
 * is 30 clock cycles.
 *
 */
__STATIC_INLINE void XMC_SPI_CH_SetSlaveSelectDelay(XMC_USIC_CH_t *const channel, uint32_t sclk_period)
{
 80239f8:	b480      	push	{r7}
 80239fa:	b083      	sub	sp, #12
 80239fc:	af00      	add	r7, sp, #0
 80239fe:	6078      	str	r0, [r7, #4]
 8023a00:	6039      	str	r1, [r7, #0]

  channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
 8023a02:	687b      	ldr	r3, [r7, #4]
 8023a04:	695b      	ldr	r3, [r3, #20]
 8023a06:	f423 42fe 	bic.w	r2, r3, #32512	; 0x7f00
                                   USIC_CH_BRG_PCTQ_Msk)) |
                 (((sclk_period - 1U) << USIC_CH_BRG_DCTQ_Pos) | (0x01U << USIC_CH_BRG_PCTQ_Pos));
 8023a0a:	683b      	ldr	r3, [r7, #0]
 8023a0c:	3b01      	subs	r3, #1
 8023a0e:	029b      	lsls	r3, r3, #10
 */
__STATIC_INLINE void XMC_SPI_CH_SetSlaveSelectDelay(XMC_USIC_CH_t *const channel, uint32_t sclk_period)
{

  channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
                                   USIC_CH_BRG_PCTQ_Msk)) |
 8023a10:	4313      	orrs	r3, r2
 8023a12:	f443 7280 	orr.w	r2, r3, #256	; 0x100
 *
 */
__STATIC_INLINE void XMC_SPI_CH_SetSlaveSelectDelay(XMC_USIC_CH_t *const channel, uint32_t sclk_period)
{

  channel->BRG = (channel->BRG & ~(USIC_CH_BRG_DCTQ_Msk |
 8023a16:	687b      	ldr	r3, [r7, #4]
 8023a18:	615a      	str	r2, [r3, #20]
                                   USIC_CH_BRG_PCTQ_Msk)) |
                 (((sclk_period - 1U) << USIC_CH_BRG_DCTQ_Pos) | (0x01U << USIC_CH_BRG_PCTQ_Pos));
}
 8023a1a:	370c      	adds	r7, #12
 8023a1c:	46bd      	mov	sp, r7
 8023a1e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023a22:	4770      	bx	lr

08023a24 <XMC_SPI_CH_ConfigureShiftClockOutput>:
 * period. These settings are applicable only in master mode.
 */
__STATIC_INLINE void XMC_SPI_CH_ConfigureShiftClockOutput(XMC_USIC_CH_t *const channel,
    const XMC_SPI_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_t passive_level,
    const XMC_SPI_CH_BRG_SHIFT_CLOCK_OUTPUT_t clock_output)
{
 8023a24:	b580      	push	{r7, lr}
 8023a26:	b084      	sub	sp, #16
 8023a28:	af00      	add	r7, sp, #0
 8023a2a:	60f8      	str	r0, [r7, #12]
 8023a2c:	60b9      	str	r1, [r7, #8]
 8023a2e:	607a      	str	r2, [r7, #4]
  XMC_USIC_CH_ConfigureShiftClockOutput(channel, (XMC_USIC_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_t)passive_level,
 8023a30:	68f8      	ldr	r0, [r7, #12]
 8023a32:	68b9      	ldr	r1, [r7, #8]
 8023a34:	687a      	ldr	r2, [r7, #4]
 8023a36:	f7ff ff8b 	bl	8023950 <XMC_USIC_CH_ConfigureShiftClockOutput>
                                        (XMC_USIC_CH_BRG_SHIFT_CLOCK_OUTPUT_t)clock_output);
}
 8023a3a:	3710      	adds	r7, #16
 8023a3c:	46bd      	mov	sp, r7
 8023a3e:	bd80      	pop	{r7, pc}

08023a40 <XMC_SPI_CH_SetWordLength>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_SPI_CH_SetFrameLength()
 */
__STATIC_INLINE void XMC_SPI_CH_SetWordLength(XMC_USIC_CH_t *const channel, const uint8_t word_length)
{
 8023a40:	b580      	push	{r7, lr}
 8023a42:	b082      	sub	sp, #8
 8023a44:	af00      	add	r7, sp, #0
 8023a46:	6078      	str	r0, [r7, #4]
 8023a48:	460b      	mov	r3, r1
 8023a4a:	70fb      	strb	r3, [r7, #3]
  XMC_USIC_CH_SetWordLength(channel, word_length);
 8023a4c:	78fb      	ldrb	r3, [r7, #3]
 8023a4e:	6878      	ldr	r0, [r7, #4]
 8023a50:	4619      	mov	r1, r3
 8023a52:	f7ff ff31 	bl	80238b8 <XMC_USIC_CH_SetWordLength>
}
 8023a56:	3708      	adds	r7, #8
 8023a58:	46bd      	mov	sp, r7
 8023a5a:	bd80      	pop	{r7, pc}

08023a5c <XMC_SPI_CH_SetFrameLength>:
 *
 * \par<b>Related APIs:</b><BR>
 * XMC_USIC_CH_SetWordLength(), XMC_USIC_CH_EnableFrameLengthControl(), XMC_SPI_CH_DisableSlaveSelect()
 */
__STATIC_INLINE void XMC_SPI_CH_SetFrameLength(XMC_USIC_CH_t *const channel, const uint8_t frame_length)
{
 8023a5c:	b580      	push	{r7, lr}
 8023a5e:	b082      	sub	sp, #8
 8023a60:	af00      	add	r7, sp, #0
 8023a62:	6078      	str	r0, [r7, #4]
 8023a64:	460b      	mov	r3, r1
 8023a66:	70fb      	strb	r3, [r7, #3]
  XMC_USIC_CH_SetFrameLength(channel, frame_length);
 8023a68:	78fb      	ldrb	r3, [r7, #3]
 8023a6a:	6878      	ldr	r0, [r7, #4]
 8023a6c:	4619      	mov	r1, r3
 8023a6e:	f7ff ff39 	bl	80238e4 <XMC_USIC_CH_SetFrameLength>
}
 8023a72:	3708      	adds	r7, #8
 8023a74:	46bd      	mov	sp, r7
 8023a76:	bd80      	pop	{r7, pc}

08023a78 <XMC_SPI_CH_SetInputSource>:
 * the SPI communication.
 */
__STATIC_INLINE void XMC_SPI_CH_SetInputSource(XMC_USIC_CH_t *const channel,
    const XMC_SPI_CH_INPUT_t input,
    const uint8_t source)
{
 8023a78:	b580      	push	{r7, lr}
 8023a7a:	b082      	sub	sp, #8
 8023a7c:	af00      	add	r7, sp, #0
 8023a7e:	6078      	str	r0, [r7, #4]
 8023a80:	460b      	mov	r3, r1
 8023a82:	70fb      	strb	r3, [r7, #3]
 8023a84:	4613      	mov	r3, r2
 8023a86:	70bb      	strb	r3, [r7, #2]
  channel->DXCR[input] = (uint32_t)(channel->DXCR[input] & (~USIC_CH_DX0CR_DSEN_Msk)) | USIC_CH_DX0CR_INSW_Msk;
 8023a88:	78f8      	ldrb	r0, [r7, #3]
 8023a8a:	78fb      	ldrb	r3, [r7, #3]
 8023a8c:	687a      	ldr	r2, [r7, #4]
 8023a8e:	3306      	adds	r3, #6
 8023a90:	009b      	lsls	r3, r3, #2
 8023a92:	4413      	add	r3, r2
 8023a94:	685b      	ldr	r3, [r3, #4]
 8023a96:	f023 0350 	bic.w	r3, r3, #80	; 0x50
 8023a9a:	f043 0210 	orr.w	r2, r3, #16
 8023a9e:	6879      	ldr	r1, [r7, #4]
 8023aa0:	1d83      	adds	r3, r0, #6
 8023aa2:	009b      	lsls	r3, r3, #2
 8023aa4:	440b      	add	r3, r1
 8023aa6:	605a      	str	r2, [r3, #4]
  XMC_USIC_CH_SetInputSource(channel, (XMC_USIC_CH_INPUT_t)input, source);
 8023aa8:	78fa      	ldrb	r2, [r7, #3]
 8023aaa:	78bb      	ldrb	r3, [r7, #2]
 8023aac:	6878      	ldr	r0, [r7, #4]
 8023aae:	4611      	mov	r1, r2
 8023ab0:	461a      	mov	r2, r3
 8023ab2:	f7ff fee3 	bl	802387c <XMC_USIC_CH_SetInputSource>
}
 8023ab6:	3708      	adds	r7, #8
 8023ab8:	46bd      	mov	sp, r7
 8023aba:	bd80      	pop	{r7, pc}

08023abc <SPI_MASTER_0_lInit>:
 * @brief Configure the port registers and data input registers of SPI channel
 *
 * @param[in] handle Pointer to an object of SPI_MASTER configuration
 */
static SPI_MASTER_STATUS_t SPI_MASTER_0_lInit(void)
{
 8023abc:	b580      	push	{r7, lr}
 8023abe:	b082      	sub	sp, #8
 8023ac0:	af00      	add	r7, sp, #0
  SPI_MASTER_STATUS_t status;
  status = SPI_MASTER_STATUS_SUCCESS; 
 8023ac2:	2300      	movs	r3, #0
 8023ac4:	71fb      	strb	r3, [r7, #7]
  status =  (SPI_MASTER_STATUS_t)GLOBAL_DMA_Init(&GLOBAL_DMA_0);
 8023ac6:	4839      	ldr	r0, [pc, #228]	; (8023bac <SPI_MASTER_0_lInit+0xf0>)
 8023ac8:	f000 fa06 	bl	8023ed8 <GLOBAL_DMA_Init>
 8023acc:	4603      	mov	r3, r0
 8023ace:	71fb      	strb	r3, [r7, #7]
  if (status == SPI_MASTER_STATUS_SUCCESS)
 8023ad0:	79fb      	ldrb	r3, [r7, #7]
 8023ad2:	2b00      	cmp	r3, #0
 8023ad4:	d164      	bne.n	8023ba0 <SPI_MASTER_0_lInit+0xe4>
  {            
                            
  (void)XMC_DMA_CH_Init(XMC_DMA0, 1U, &SPI_MASTER_0_dma_ch_tx_config);
 8023ad6:	4836      	ldr	r0, [pc, #216]	; (8023bb0 <SPI_MASTER_0_lInit+0xf4>)
 8023ad8:	2101      	movs	r1, #1
 8023ada:	4a36      	ldr	r2, [pc, #216]	; (8023bb4 <SPI_MASTER_0_lInit+0xf8>)
 8023adc:	f7fe fd22 	bl	8022524 <XMC_DMA_CH_Init>
  /*"Interrupt Settings" configuration for "transmit" and/or "receive"*/
  XMC_DMA_CH_EnableEvent(XMC_DMA0, 1U, (uint32_t)XMC_DMA_CH_EVENT_TRANSFER_COMPLETE);
 8023ae0:	4833      	ldr	r0, [pc, #204]	; (8023bb0 <SPI_MASTER_0_lInit+0xf4>)
 8023ae2:	2101      	movs	r1, #1
 8023ae4:	2201      	movs	r2, #1
 8023ae6:	f7fe ff0d 	bl	8022904 <XMC_DMA_CH_EnableEvent>
  XMC_DMA_CH_SetEventHandler(XMC_DMA0, 1U, SPI_MASTER_0_DMA_tx_handler);
 8023aea:	4831      	ldr	r0, [pc, #196]	; (8023bb0 <SPI_MASTER_0_lInit+0xf4>)
 8023aec:	2101      	movs	r1, #1
 8023aee:	4a32      	ldr	r2, [pc, #200]	; (8023bb8 <SPI_MASTER_0_lInit+0xfc>)
 8023af0:	f7fe ff56 	bl	80229a0 <XMC_DMA_CH_SetEventHandler>
                             
  (void)XMC_DMA_CH_Init(XMC_DMA0, 0U, &SPI_MASTER_0_dma_ch_rx_config);
 8023af4:	482e      	ldr	r0, [pc, #184]	; (8023bb0 <SPI_MASTER_0_lInit+0xf4>)
 8023af6:	2100      	movs	r1, #0
 8023af8:	4a30      	ldr	r2, [pc, #192]	; (8023bbc <SPI_MASTER_0_lInit+0x100>)
 8023afa:	f7fe fd13 	bl	8022524 <XMC_DMA_CH_Init>
  /*"Interrupt Settings" configuration for "transmit" and/or "receive"*/
  XMC_DMA_CH_EnableEvent(XMC_DMA0, 0U, (uint32_t)XMC_DMA_CH_EVENT_TRANSFER_COMPLETE);
 8023afe:	482c      	ldr	r0, [pc, #176]	; (8023bb0 <SPI_MASTER_0_lInit+0xf4>)
 8023b00:	2100      	movs	r1, #0
 8023b02:	2201      	movs	r2, #1
 8023b04:	f7fe fefe 	bl	8022904 <XMC_DMA_CH_EnableEvent>
  XMC_DMA_CH_SetEventHandler(XMC_DMA0, 0U, SPI_MASTER_0_DMA_rx_handler);
 8023b08:	4829      	ldr	r0, [pc, #164]	; (8023bb0 <SPI_MASTER_0_lInit+0xf4>)
 8023b0a:	2100      	movs	r1, #0
 8023b0c:	4a2c      	ldr	r2, [pc, #176]	; (8023bc0 <SPI_MASTER_0_lInit+0x104>)
 8023b0e:	f7fe ff47 	bl	80229a0 <XMC_DMA_CH_SetEventHandler>
                             
  /* LLD initialization */
  XMC_SPI_CH_Init(XMC_SPI1_CH0, &SPI_MASTER_0_Channel_Config);
 8023b12:	482c      	ldr	r0, [pc, #176]	; (8023bc4 <SPI_MASTER_0_lInit+0x108>)
 8023b14:	492c      	ldr	r1, [pc, #176]	; (8023bc8 <SPI_MASTER_0_lInit+0x10c>)
 8023b16:	f7ff ff45 	bl	80239a4 <XMC_SPI_CH_Init>
                             
  XMC_SPI_CH_SetBitOrderMsbFirst(XMC_SPI1_CH0);
 8023b1a:	482a      	ldr	r0, [pc, #168]	; (8023bc4 <SPI_MASTER_0_lInit+0x108>)
 8023b1c:	f7ff ff5c 	bl	80239d8 <XMC_SPI_CH_SetBitOrderMsbFirst>
          
  XMC_SPI_CH_SetWordLength(XMC_SPI1_CH0, (uint8_t)8);
 8023b20:	4828      	ldr	r0, [pc, #160]	; (8023bc4 <SPI_MASTER_0_lInit+0x108>)
 8023b22:	2108      	movs	r1, #8
 8023b24:	f7ff ff8c 	bl	8023a40 <XMC_SPI_CH_SetWordLength>

  XMC_SPI_CH_SetFrameLength(XMC_SPI1_CH0, (uint8_t)48);
 8023b28:	4826      	ldr	r0, [pc, #152]	; (8023bc4 <SPI_MASTER_0_lInit+0x108>)
 8023b2a:	2130      	movs	r1, #48	; 0x30
 8023b2c:	f7ff ff96 	bl	8023a5c <XMC_SPI_CH_SetFrameLength>

  /* Configure the clock polarity and clock delay */
  XMC_SPI_CH_ConfigureShiftClockOutput(XMC_SPI1_CH0,
 8023b30:	4824      	ldr	r0, [pc, #144]	; (8023bc4 <SPI_MASTER_0_lInit+0x108>)
 8023b32:	2100      	movs	r1, #0
 8023b34:	2200      	movs	r2, #0
 8023b36:	f7ff ff75 	bl	8023a24 <XMC_SPI_CH_ConfigureShiftClockOutput>
                                       XMC_SPI_CH_BRG_SHIFT_CLOCK_PASSIVE_LEVEL_0_DELAY_DISABLED,
                                       XMC_SPI_CH_BRG_SHIFT_CLOCK_OUTPUT_SCLK);
  /* Configure Leading/Trailing delay */
  XMC_SPI_CH_SetSlaveSelectDelay(XMC_SPI1_CH0, 2U);
 8023b3a:	4822      	ldr	r0, [pc, #136]	; (8023bc4 <SPI_MASTER_0_lInit+0x108>)
 8023b3c:	2102      	movs	r1, #2
 8023b3e:	f7ff ff5b 	bl	80239f8 <XMC_SPI_CH_SetSlaveSelectDelay>

               
  /* Configure the input pin properties */
  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT0_BASE, (uint8_t)4, &SPI_MASTER_0_MISO_Config.port_config);
 8023b42:	4822      	ldr	r0, [pc, #136]	; (8023bcc <SPI_MASTER_0_lInit+0x110>)
 8023b44:	2104      	movs	r1, #4
 8023b46:	4a22      	ldr	r2, [pc, #136]	; (8023bd0 <SPI_MASTER_0_lInit+0x114>)
 8023b48:	f7fd fd60 	bl	802160c <XMC_GPIO_Init>

  /* Configure the data input line selected */
  XMC_SPI_CH_SetInputSource(XMC_SPI1_CH0, XMC_SPI_CH_INPUT_DIN0, (uint8_t)SPI_MASTER_INPUT_A);
 8023b4c:	481d      	ldr	r0, [pc, #116]	; (8023bc4 <SPI_MASTER_0_lInit+0x108>)
 8023b4e:	2100      	movs	r1, #0
 8023b50:	2200      	movs	r2, #0
 8023b52:	f7ff ff91 	bl	8023a78 <XMC_SPI_CH_SetInputSource>
  /* Start the SPI_Channel */
  XMC_SPI_CH_Start(XMC_SPI1_CH0);
 8023b56:	481b      	ldr	r0, [pc, #108]	; (8023bc4 <SPI_MASTER_0_lInit+0x108>)
 8023b58:	f7ff ff32 	bl	80239c0 <XMC_SPI_CH_Start>

  /* Configure the output pin properties */
  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT0_BASE, (uint8_t)5, &SPI_MASTER_0_MOSI_Config.port_config);
 8023b5c:	481b      	ldr	r0, [pc, #108]	; (8023bcc <SPI_MASTER_0_lInit+0x110>)
 8023b5e:	2105      	movs	r1, #5
 8023b60:	4a1c      	ldr	r2, [pc, #112]	; (8023bd4 <SPI_MASTER_0_lInit+0x118>)
 8023b62:	f7fd fd53 	bl	802160c <XMC_GPIO_Init>
    
  /* Initialize SPI SCLK out pin */
  XMC_GPIO_Init((XMC_GPIO_PORT_t *)PORT0_BASE, (uint8_t)11, &SPI_MASTER_0_SCLKOUT_Config.port_config);
 8023b66:	4819      	ldr	r0, [pc, #100]	; (8023bcc <SPI_MASTER_0_lInit+0x110>)
 8023b68:	210b      	movs	r1, #11
 8023b6a:	4a1b      	ldr	r2, [pc, #108]	; (8023bd8 <SPI_MASTER_0_lInit+0x11c>)
 8023b6c:	f7fd fd4e 	bl	802160c <XMC_GPIO_Init>

  XMC_USIC_CH_SetInterruptNodePointer(XMC_SPI1_CH0,
 8023b70:	4814      	ldr	r0, [pc, #80]	; (8023bc4 <SPI_MASTER_0_lInit+0x108>)
 8023b72:	2104      	movs	r1, #4
 8023b74:	2200      	movs	r2, #0
 8023b76:	f7ff fae9 	bl	802314c <XMC_USIC_CH_SetInterruptNodePointer>
                                      XMC_USIC_CH_INTERRUPT_NODE_POINTER_TRANSMIT_BUFFER,
                                      (uint32_t)SPI_MASTER_SR_ID_0);
  XMC_USIC_CH_SetInterruptNodePointer(XMC_SPI1_CH0,
 8023b7a:	4812      	ldr	r0, [pc, #72]	; (8023bc4 <SPI_MASTER_0_lInit+0x108>)
 8023b7c:	2108      	movs	r1, #8
 8023b7e:	2201      	movs	r2, #1
 8023b80:	f7ff fae4 	bl	802314c <XMC_USIC_CH_SetInterruptNodePointer>
                                      XMC_USIC_CH_INTERRUPT_NODE_POINTER_RECEIVE,
                                      (uint32_t)SPI_MASTER_SR_ID_1);
  XMC_USIC_CH_SetInterruptNodePointer(XMC_SPI1_CH0,
 8023b84:	480f      	ldr	r0, [pc, #60]	; (8023bc4 <SPI_MASTER_0_lInit+0x108>)
 8023b86:	210c      	movs	r1, #12
 8023b88:	2201      	movs	r2, #1
 8023b8a:	f7ff fadf 	bl	802314c <XMC_USIC_CH_SetInterruptNodePointer>
                                      XMC_USIC_CH_INTERRUPT_NODE_POINTER_ALTERNATE_RECEIVE,
                                      (uint32_t)SPI_MASTER_SR_ID_1);
  XMC_USIC_CH_SetInterruptNodePointer(XMC_SPI1_CH0,
 8023b8e:	480d      	ldr	r0, [pc, #52]	; (8023bc4 <SPI_MASTER_0_lInit+0x108>)
 8023b90:	2110      	movs	r1, #16
 8023b92:	2202      	movs	r2, #2
 8023b94:	f7ff fada 	bl	802314c <XMC_USIC_CH_SetInterruptNodePointer>
                                      XMC_USIC_CH_INTERRUPT_NODE_POINTER_PROTOCOL,
                                      (uint32_t)SPI_MASTER_SR_ID_2);
            
  XMC_USIC_CH_TriggerServiceRequest(XMC_SPI1_CH0, (uint32_t)SPI_MASTER_SR_ID_0);
 8023b98:	480a      	ldr	r0, [pc, #40]	; (8023bc4 <SPI_MASTER_0_lInit+0x108>)
 8023b9a:	2100      	movs	r1, #0
 8023b9c:	f7ff fec8 	bl	8023930 <XMC_USIC_CH_TriggerServiceRequest>
}            

  return status;
 8023ba0:	79fb      	ldrb	r3, [r7, #7]
}
 8023ba2:	4618      	mov	r0, r3
 8023ba4:	3708      	adds	r7, #8
 8023ba6:	46bd      	mov	sp, r7
 8023ba8:	bd80      	pop	{r7, pc}
 8023baa:	bf00      	nop
 8023bac:	1fff17b4 	.word	0x1fff17b4
 8023bb0:	50014000 	.word	0x50014000
 8023bb4:	1fff1724 	.word	0x1fff1724
 8023bb8:	08023bdd 	.word	0x08023bdd
 8023bbc:	1fff1748 	.word	0x1fff1748
 8023bc0:	08023c15 	.word	0x08023c15
 8023bc4:	48020000 	.word	0x48020000
 8023bc8:	1fff1718 	.word	0x1fff1718
 8023bcc:	48028000 	.word	0x48028000
 8023bd0:	1fff1704 	.word	0x1fff1704
 8023bd4:	1fff16f0 	.word	0x1fff16f0
 8023bd8:	08025b64 	.word	0x08025b64

08023bdc <SPI_MASTER_0_DMA_tx_handler>:
/*Transmit ISR*/
void SPI_MASTER_0_DMA_tx_handler(XMC_DMA_CH_EVENT_t event)
{
 8023bdc:	b580      	push	{r7, lr}
 8023bde:	b082      	sub	sp, #8
 8023be0:	af00      	add	r7, sp, #0
 8023be2:	4603      	mov	r3, r0
 8023be4:	71fb      	strb	r3, [r7, #7]
  if (event == XMC_DMA_CH_EVENT_TRANSFER_COMPLETE)
 8023be6:	79fb      	ldrb	r3, [r7, #7]
 8023be8:	2b01      	cmp	r3, #1
 8023bea:	d10b      	bne.n	8023c04 <SPI_MASTER_0_DMA_tx_handler+0x28>
  {
    while(XMC_USIC_CH_GetTransmitBufferStatus(XMC_SPI1_CH0) == XMC_USIC_CH_TBUF_STATUS_BUSY);
 8023bec:	bf00      	nop
 8023bee:	4807      	ldr	r0, [pc, #28]	; (8023c0c <SPI_MASTER_0_DMA_tx_handler+0x30>)
 8023bf0:	f7ff fe8e 	bl	8023910 <XMC_USIC_CH_GetTransmitBufferStatus>
 8023bf4:	4603      	mov	r3, r0
 8023bf6:	2b80      	cmp	r3, #128	; 0x80
 8023bf8:	d0f9      	beq.n	8023bee <SPI_MASTER_0_DMA_tx_handler+0x12>
    SPI_MASTER_0.runtime->tx_busy = false;
 8023bfa:	4b05      	ldr	r3, [pc, #20]	; (8023c10 <SPI_MASTER_0_DMA_tx_handler+0x34>)
 8023bfc:	689b      	ldr	r3, [r3, #8]
 8023bfe:	2200      	movs	r2, #0
 8023c00:	f883 2020 	strb.w	r2, [r3, #32]
  }
}
 8023c04:	3708      	adds	r7, #8
 8023c06:	46bd      	mov	sp, r7
 8023c08:	bd80      	pop	{r7, pc}
 8023c0a:	bf00      	nop
 8023c0c:	48020000 	.word	0x48020000
 8023c10:	1fff1790 	.word	0x1fff1790

08023c14 <SPI_MASTER_0_DMA_rx_handler>:

/*Receive ISR*/
void SPI_MASTER_0_DMA_rx_handler(XMC_DMA_CH_EVENT_t event)
{
 8023c14:	b580      	push	{r7, lr}
 8023c16:	b082      	sub	sp, #8
 8023c18:	af00      	add	r7, sp, #0
 8023c1a:	4603      	mov	r3, r0
 8023c1c:	71fb      	strb	r3, [r7, #7]
  if (event == XMC_DMA_CH_EVENT_TRANSFER_COMPLETE)
 8023c1e:	79fb      	ldrb	r3, [r7, #7]
 8023c20:	2b01      	cmp	r3, #1
 8023c22:	d112      	bne.n	8023c4a <SPI_MASTER_0_DMA_rx_handler+0x36>
  {
    XMC_SPI_CH_DisableEvent(XMC_SPI1_CH0, (uint32_t)((uint32_t)XMC_SPI_CH_EVENT_STANDARD_RECEIVE | (uint32_t)XMC_SPI_CH_EVENT_ALTERNATIVE_RECEIVE));
 8023c24:	480a      	ldr	r0, [pc, #40]	; (8023c50 <SPI_MASTER_0_DMA_rx_handler+0x3c>)
 8023c26:	f44f 4140 	mov.w	r1, #49152	; 0xc000
 8023c2a:	f7ff f947 	bl	8022ebc <XMC_SPI_CH_DisableEvent>
    SPI_MASTER_0.runtime->tx_data_dummy = false;
 8023c2e:	4b09      	ldr	r3, [pc, #36]	; (8023c54 <SPI_MASTER_0_DMA_rx_handler+0x40>)
 8023c30:	689b      	ldr	r3, [r3, #8]
 8023c32:	2200      	movs	r2, #0
 8023c34:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
    SPI_MASTER_0.runtime->rx_data_dummy = true;
 8023c38:	4b06      	ldr	r3, [pc, #24]	; (8023c54 <SPI_MASTER_0_DMA_rx_handler+0x40>)
 8023c3a:	689b      	ldr	r3, [r3, #8]
 8023c3c:	2201      	movs	r2, #1
 8023c3e:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
    SPI_MASTER_0.runtime->rx_busy = false;
 8023c42:	4b04      	ldr	r3, [pc, #16]	; (8023c54 <SPI_MASTER_0_DMA_rx_handler+0x40>)
 8023c44:	689b      	ldr	r3, [r3, #8]
 8023c46:	2200      	movs	r2, #0
 8023c48:	77da      	strb	r2, [r3, #31]
  }
}
 8023c4a:	3708      	adds	r7, #8
 8023c4c:	46bd      	mov	sp, r7
 8023c4e:	bd80      	pop	{r7, pc}
 8023c50:	48020000 	.word	0x48020000
 8023c54:	1fff1790 	.word	0x1fff1790

08023c58 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 8023c58:	b480      	push	{r7}
 8023c5a:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8023c5c:	4b04      	ldr	r3, [pc, #16]	; (8023c70 <__NVIC_GetPriorityGrouping+0x18>)
 8023c5e:	68db      	ldr	r3, [r3, #12]
 8023c60:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8023c64:	0a1b      	lsrs	r3, r3, #8
}
 8023c66:	4618      	mov	r0, r3
 8023c68:	46bd      	mov	sp, r7
 8023c6a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023c6e:	4770      	bx	lr
 8023c70:	e000ed00 	.word	0xe000ed00

08023c74 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8023c74:	b480      	push	{r7}
 8023c76:	b083      	sub	sp, #12
 8023c78:	af00      	add	r7, sp, #0
 8023c7a:	4603      	mov	r3, r0
 8023c7c:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8023c7e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8023c82:	2b00      	cmp	r3, #0
 8023c84:	db0b      	blt.n	8023c9e <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8023c86:	4908      	ldr	r1, [pc, #32]	; (8023ca8 <__NVIC_EnableIRQ+0x34>)
 8023c88:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8023c8c:	095b      	lsrs	r3, r3, #5
 8023c8e:	79fa      	ldrb	r2, [r7, #7]
 8023c90:	f002 021f 	and.w	r2, r2, #31
 8023c94:	2001      	movs	r0, #1
 8023c96:	fa00 f202 	lsl.w	r2, r0, r2
 8023c9a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
 8023c9e:	370c      	adds	r7, #12
 8023ca0:	46bd      	mov	sp, r7
 8023ca2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023ca6:	4770      	bx	lr
 8023ca8:	e000e100 	.word	0xe000e100

08023cac <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8023cac:	b480      	push	{r7}
 8023cae:	b083      	sub	sp, #12
 8023cb0:	af00      	add	r7, sp, #0
 8023cb2:	4603      	mov	r3, r0
 8023cb4:	6039      	str	r1, [r7, #0]
 8023cb6:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8023cb8:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8023cbc:	2b00      	cmp	r3, #0
 8023cbe:	db0a      	blt.n	8023cd6 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8023cc0:	490d      	ldr	r1, [pc, #52]	; (8023cf8 <__NVIC_SetPriority+0x4c>)
 8023cc2:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8023cc6:	683a      	ldr	r2, [r7, #0]
 8023cc8:	b2d2      	uxtb	r2, r2
 8023cca:	0092      	lsls	r2, r2, #2
 8023ccc:	b2d2      	uxtb	r2, r2
 8023cce:	440b      	add	r3, r1
 8023cd0:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
 8023cd4:	e00a      	b.n	8023cec <__NVIC_SetPriority+0x40>
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8023cd6:	4909      	ldr	r1, [pc, #36]	; (8023cfc <__NVIC_SetPriority+0x50>)
 8023cd8:	79fb      	ldrb	r3, [r7, #7]
 8023cda:	f003 030f 	and.w	r3, r3, #15
 8023cde:	3b04      	subs	r3, #4
 8023ce0:	683a      	ldr	r2, [r7, #0]
 8023ce2:	b2d2      	uxtb	r2, r2
 8023ce4:	0092      	lsls	r2, r2, #2
 8023ce6:	b2d2      	uxtb	r2, r2
 8023ce8:	440b      	add	r3, r1
 8023cea:	761a      	strb	r2, [r3, #24]
  }
}
 8023cec:	370c      	adds	r7, #12
 8023cee:	46bd      	mov	sp, r7
 8023cf0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023cf4:	4770      	bx	lr
 8023cf6:	bf00      	nop
 8023cf8:	e000e100 	.word	0xe000e100
 8023cfc:	e000ed00 	.word	0xe000ed00

08023d00 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8023d00:	b480      	push	{r7}
 8023d02:	b089      	sub	sp, #36	; 0x24
 8023d04:	af00      	add	r7, sp, #0
 8023d06:	60f8      	str	r0, [r7, #12]
 8023d08:	60b9      	str	r1, [r7, #8]
 8023d0a:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8023d0c:	68fb      	ldr	r3, [r7, #12]
 8023d0e:	f003 0307 	and.w	r3, r3, #7
 8023d12:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8023d14:	69fb      	ldr	r3, [r7, #28]
 8023d16:	f1c3 0307 	rsb	r3, r3, #7
 8023d1a:	2b06      	cmp	r3, #6
 8023d1c:	bf28      	it	cs
 8023d1e:	2306      	movcs	r3, #6
 8023d20:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8023d22:	69fb      	ldr	r3, [r7, #28]
 8023d24:	3306      	adds	r3, #6
 8023d26:	2b06      	cmp	r3, #6
 8023d28:	d902      	bls.n	8023d30 <NVIC_EncodePriority+0x30>
 8023d2a:	69fb      	ldr	r3, [r7, #28]
 8023d2c:	3b01      	subs	r3, #1
 8023d2e:	e000      	b.n	8023d32 <NVIC_EncodePriority+0x32>
 8023d30:	2300      	movs	r3, #0
 8023d32:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8023d34:	69bb      	ldr	r3, [r7, #24]
 8023d36:	2201      	movs	r2, #1
 8023d38:	fa02 f303 	lsl.w	r3, r2, r3
 8023d3c:	1e5a      	subs	r2, r3, #1
 8023d3e:	68bb      	ldr	r3, [r7, #8]
 8023d40:	401a      	ands	r2, r3
 8023d42:	697b      	ldr	r3, [r7, #20]
 8023d44:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8023d46:	697b      	ldr	r3, [r7, #20]
 8023d48:	2101      	movs	r1, #1
 8023d4a:	fa01 f303 	lsl.w	r3, r1, r3
 8023d4e:	1e59      	subs	r1, r3, #1
 8023d50:	687b      	ldr	r3, [r7, #4]
 8023d52:	400b      	ands	r3, r1
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 8023d54:	4313      	orrs	r3, r2
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
         );
}
 8023d56:	4618      	mov	r0, r3
 8023d58:	3724      	adds	r7, #36	; 0x24
 8023d5a:	46bd      	mov	sp, r7
 8023d5c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023d60:	4770      	bx	lr
 8023d62:	bf00      	nop

08023d64 <INTERRUPT_Enable>:
 *    return 0;
 *  }
 * @endcode<BR> </p>
 */
__STATIC_INLINE void INTERRUPT_Enable(const INTERRUPT_t *const handler)
{
 8023d64:	b580      	push	{r7, lr}
 8023d66:	b082      	sub	sp, #8
 8023d68:	af00      	add	r7, sp, #0
 8023d6a:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("Handler NULL", (handler != NULL));
  NVIC_EnableIRQ(handler->node);
 8023d6c:	687b      	ldr	r3, [r7, #4]
 8023d6e:	781b      	ldrb	r3, [r3, #0]
 8023d70:	b25b      	sxtb	r3, r3
 8023d72:	4618      	mov	r0, r3
 8023d74:	f7ff ff7e 	bl	8023c74 <__NVIC_EnableIRQ>
}
 8023d78:	3708      	adds	r7, #8
 8023d7a:	46bd      	mov	sp, r7
 8023d7c:	bd80      	pop	{r7, pc}
 8023d7e:	bf00      	nop

08023d80 <INTERRUPT_Init>:

/*
 * API to initialize the INTERRUPT APP
 */
INTERRUPT_STATUS_t INTERRUPT_Init(const INTERRUPT_t *const handler)
{
 8023d80:	b590      	push	{r4, r7, lr}
 8023d82:	b083      	sub	sp, #12
 8023d84:	af00      	add	r7, sp, #0
 8023d86:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("INTERRUPT_Init:HandlePtr NULL", (handler != NULL));
  
#if(UC_FAMILY == XMC4)

  NVIC_SetPriority(handler->node,
 8023d88:	687b      	ldr	r3, [r7, #4]
 8023d8a:	781c      	ldrb	r4, [r3, #0]
 8023d8c:	f7ff ff64 	bl	8023c58 <__NVIC_GetPriorityGrouping>
 8023d90:	4601      	mov	r1, r0
                   NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
                                       handler->priority,
 8023d92:	687b      	ldr	r3, [r7, #4]
 8023d94:	785b      	ldrb	r3, [r3, #1]
{
  XMC_ASSERT("INTERRUPT_Init:HandlePtr NULL", (handler != NULL));
  
#if(UC_FAMILY == XMC4)

  NVIC_SetPriority(handler->node,
 8023d96:	461a      	mov	r2, r3
                   NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
                                       handler->priority,
                                       handler->subpriority));
 8023d98:	687b      	ldr	r3, [r7, #4]
 8023d9a:	789b      	ldrb	r3, [r3, #2]
{
  XMC_ASSERT("INTERRUPT_Init:HandlePtr NULL", (handler != NULL));
  
#if(UC_FAMILY == XMC4)

  NVIC_SetPriority(handler->node,
 8023d9c:	4608      	mov	r0, r1
 8023d9e:	4611      	mov	r1, r2
 8023da0:	461a      	mov	r2, r3
 8023da2:	f7ff ffad 	bl	8023d00 <NVIC_EncodePriority>
 8023da6:	4602      	mov	r2, r0
 8023da8:	b263      	sxtb	r3, r4
 8023daa:	4618      	mov	r0, r3
 8023dac:	4611      	mov	r1, r2
 8023dae:	f7ff ff7d 	bl	8023cac <__NVIC_SetPriority>
                   NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
                                       handler->priority,
                                       handler->subpriority));
  if (handler->enable_at_init == true)
 8023db2:	687b      	ldr	r3, [r7, #4]
 8023db4:	78db      	ldrb	r3, [r3, #3]
 8023db6:	2b00      	cmp	r3, #0
 8023db8:	d002      	beq.n	8023dc0 <INTERRUPT_Init+0x40>
  {
    INTERRUPT_Enable(handler);
 8023dba:	6878      	ldr	r0, [r7, #4]
 8023dbc:	f7ff ffd2 	bl	8023d64 <INTERRUPT_Enable>
  {
    INTERRUPT_Enable(handler);
  }
#endif

  return (INTERRUPT_STATUS_SUCCESS);
 8023dc0:	2300      	movs	r3, #0
}
 8023dc2:	4618      	mov	r0, r3
 8023dc4:	370c      	adds	r7, #12
 8023dc6:	46bd      	mov	sp, r7
 8023dc8:	bd90      	pop	{r4, r7, pc}
 8023dca:	bf00      	nop

08023dcc <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 8023dcc:	b480      	push	{r7}
 8023dce:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8023dd0:	4b04      	ldr	r3, [pc, #16]	; (8023de4 <__NVIC_GetPriorityGrouping+0x18>)
 8023dd2:	68db      	ldr	r3, [r3, #12]
 8023dd4:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8023dd8:	0a1b      	lsrs	r3, r3, #8
}
 8023dda:	4618      	mov	r0, r3
 8023ddc:	46bd      	mov	sp, r7
 8023dde:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023de2:	4770      	bx	lr
 8023de4:	e000ed00 	.word	0xe000ed00

08023de8 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8023de8:	b480      	push	{r7}
 8023dea:	b083      	sub	sp, #12
 8023dec:	af00      	add	r7, sp, #0
 8023dee:	4603      	mov	r3, r0
 8023df0:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8023df2:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8023df6:	2b00      	cmp	r3, #0
 8023df8:	db0b      	blt.n	8023e12 <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8023dfa:	4908      	ldr	r1, [pc, #32]	; (8023e1c <__NVIC_EnableIRQ+0x34>)
 8023dfc:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8023e00:	095b      	lsrs	r3, r3, #5
 8023e02:	79fa      	ldrb	r2, [r7, #7]
 8023e04:	f002 021f 	and.w	r2, r2, #31
 8023e08:	2001      	movs	r0, #1
 8023e0a:	fa00 f202 	lsl.w	r2, r0, r2
 8023e0e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
 8023e12:	370c      	adds	r7, #12
 8023e14:	46bd      	mov	sp, r7
 8023e16:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023e1a:	4770      	bx	lr
 8023e1c:	e000e100 	.word	0xe000e100

08023e20 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8023e20:	b480      	push	{r7}
 8023e22:	b083      	sub	sp, #12
 8023e24:	af00      	add	r7, sp, #0
 8023e26:	4603      	mov	r3, r0
 8023e28:	6039      	str	r1, [r7, #0]
 8023e2a:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8023e2c:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8023e30:	2b00      	cmp	r3, #0
 8023e32:	db0a      	blt.n	8023e4a <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8023e34:	490d      	ldr	r1, [pc, #52]	; (8023e6c <__NVIC_SetPriority+0x4c>)
 8023e36:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8023e3a:	683a      	ldr	r2, [r7, #0]
 8023e3c:	b2d2      	uxtb	r2, r2
 8023e3e:	0092      	lsls	r2, r2, #2
 8023e40:	b2d2      	uxtb	r2, r2
 8023e42:	440b      	add	r3, r1
 8023e44:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
 8023e48:	e00a      	b.n	8023e60 <__NVIC_SetPriority+0x40>
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8023e4a:	4909      	ldr	r1, [pc, #36]	; (8023e70 <__NVIC_SetPriority+0x50>)
 8023e4c:	79fb      	ldrb	r3, [r7, #7]
 8023e4e:	f003 030f 	and.w	r3, r3, #15
 8023e52:	3b04      	subs	r3, #4
 8023e54:	683a      	ldr	r2, [r7, #0]
 8023e56:	b2d2      	uxtb	r2, r2
 8023e58:	0092      	lsls	r2, r2, #2
 8023e5a:	b2d2      	uxtb	r2, r2
 8023e5c:	440b      	add	r3, r1
 8023e5e:	761a      	strb	r2, [r3, #24]
  }
}
 8023e60:	370c      	adds	r7, #12
 8023e62:	46bd      	mov	sp, r7
 8023e64:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023e68:	4770      	bx	lr
 8023e6a:	bf00      	nop
 8023e6c:	e000e100 	.word	0xe000e100
 8023e70:	e000ed00 	.word	0xe000ed00

08023e74 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8023e74:	b480      	push	{r7}
 8023e76:	b089      	sub	sp, #36	; 0x24
 8023e78:	af00      	add	r7, sp, #0
 8023e7a:	60f8      	str	r0, [r7, #12]
 8023e7c:	60b9      	str	r1, [r7, #8]
 8023e7e:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8023e80:	68fb      	ldr	r3, [r7, #12]
 8023e82:	f003 0307 	and.w	r3, r3, #7
 8023e86:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8023e88:	69fb      	ldr	r3, [r7, #28]
 8023e8a:	f1c3 0307 	rsb	r3, r3, #7
 8023e8e:	2b06      	cmp	r3, #6
 8023e90:	bf28      	it	cs
 8023e92:	2306      	movcs	r3, #6
 8023e94:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8023e96:	69fb      	ldr	r3, [r7, #28]
 8023e98:	3306      	adds	r3, #6
 8023e9a:	2b06      	cmp	r3, #6
 8023e9c:	d902      	bls.n	8023ea4 <NVIC_EncodePriority+0x30>
 8023e9e:	69fb      	ldr	r3, [r7, #28]
 8023ea0:	3b01      	subs	r3, #1
 8023ea2:	e000      	b.n	8023ea6 <NVIC_EncodePriority+0x32>
 8023ea4:	2300      	movs	r3, #0
 8023ea6:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8023ea8:	69bb      	ldr	r3, [r7, #24]
 8023eaa:	2201      	movs	r2, #1
 8023eac:	fa02 f303 	lsl.w	r3, r2, r3
 8023eb0:	1e5a      	subs	r2, r3, #1
 8023eb2:	68bb      	ldr	r3, [r7, #8]
 8023eb4:	401a      	ands	r2, r3
 8023eb6:	697b      	ldr	r3, [r7, #20]
 8023eb8:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8023eba:	697b      	ldr	r3, [r7, #20]
 8023ebc:	2101      	movs	r1, #1
 8023ebe:	fa01 f303 	lsl.w	r3, r1, r3
 8023ec2:	1e59      	subs	r1, r3, #1
 8023ec4:	687b      	ldr	r3, [r7, #4]
 8023ec6:	400b      	ands	r3, r1
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 8023ec8:	4313      	orrs	r3, r2
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
         );
}
 8023eca:	4618      	mov	r0, r3
 8023ecc:	3724      	adds	r7, #36	; 0x24
 8023ece:	46bd      	mov	sp, r7
 8023ed0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023ed4:	4770      	bx	lr
 8023ed6:	bf00      	nop

08023ed8 <GLOBAL_DMA_Init>:
  return version;
}

/* GLOBAL_DMA initialization function */
GLOBAL_DMA_STATUS_t GLOBAL_DMA_Init(GLOBAL_DMA_t *const obj)
{
 8023ed8:	b590      	push	{r4, r7, lr}
 8023eda:	b083      	sub	sp, #12
 8023edc:	af00      	add	r7, sp, #0
 8023ede:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("DMA_GLOBAL_Init: NULL DMA_GLOBAL_t object", (obj != NULL));

  if (obj->initialized == false)
 8023ee0:	687b      	ldr	r3, [r7, #4]
 8023ee2:	7a1b      	ldrb	r3, [r3, #8]
 8023ee4:	f083 0301 	eor.w	r3, r3, #1
 8023ee8:	b2db      	uxtb	r3, r3
 8023eea:	2b00      	cmp	r3, #0
 8023eec:	d024      	beq.n	8023f38 <GLOBAL_DMA_Init+0x60>
  {
    /* Enable DMA module */
    XMC_DMA_Init(obj->dma);
 8023eee:	687b      	ldr	r3, [r7, #4]
 8023ef0:	681b      	ldr	r3, [r3, #0]
 8023ef2:	4618      	mov	r0, r3
 8023ef4:	f7fe fa70 	bl	80223d8 <XMC_DMA_Init>

    /* Enable DMA event handling */
    NVIC_SetPriority(obj->irq_node, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
 8023ef8:	687b      	ldr	r3, [r7, #4]
 8023efa:	7a5c      	ldrb	r4, [r3, #9]
 8023efc:	f7ff ff66 	bl	8023dcc <__NVIC_GetPriorityGrouping>
 8023f00:	4601      	mov	r1, r0
                                                        obj->config->priority,
 8023f02:	687b      	ldr	r3, [r7, #4]
 8023f04:	685b      	ldr	r3, [r3, #4]
 8023f06:	781b      	ldrb	r3, [r3, #0]
  {
    /* Enable DMA module */
    XMC_DMA_Init(obj->dma);

    /* Enable DMA event handling */
    NVIC_SetPriority(obj->irq_node, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
 8023f08:	461a      	mov	r2, r3
                                                        obj->config->priority,
                                                        obj->config->sub_priority));
 8023f0a:	687b      	ldr	r3, [r7, #4]
 8023f0c:	685b      	ldr	r3, [r3, #4]
 8023f0e:	785b      	ldrb	r3, [r3, #1]
  {
    /* Enable DMA module */
    XMC_DMA_Init(obj->dma);

    /* Enable DMA event handling */
    NVIC_SetPriority(obj->irq_node, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
 8023f10:	4608      	mov	r0, r1
 8023f12:	4611      	mov	r1, r2
 8023f14:	461a      	mov	r2, r3
 8023f16:	f7ff ffad 	bl	8023e74 <NVIC_EncodePriority>
 8023f1a:	4602      	mov	r2, r0
 8023f1c:	b263      	sxtb	r3, r4
 8023f1e:	4618      	mov	r0, r3
 8023f20:	4611      	mov	r1, r2
 8023f22:	f7ff ff7d 	bl	8023e20 <__NVIC_SetPriority>
                                                        obj->config->priority,
                                                        obj->config->sub_priority));
    NVIC_EnableIRQ(obj->irq_node);
 8023f26:	687b      	ldr	r3, [r7, #4]
 8023f28:	7a5b      	ldrb	r3, [r3, #9]
 8023f2a:	b25b      	sxtb	r3, r3
 8023f2c:	4618      	mov	r0, r3
 8023f2e:	f7ff ff5b 	bl	8023de8 <__NVIC_EnableIRQ>
    obj->initialized = true;
 8023f32:	687b      	ldr	r3, [r7, #4]
 8023f34:	2201      	movs	r2, #1
 8023f36:	721a      	strb	r2, [r3, #8]
  }

  return GLOBAL_DMA_STATUS_SUCCESS;
 8023f38:	2300      	movs	r3, #0
}
 8023f3a:	4618      	mov	r0, r3
 8023f3c:	370c      	adds	r7, #12
 8023f3e:	46bd      	mov	sp, r7
 8023f40:	bd90      	pop	{r4, r7, pc}
 8023f42:	bf00      	nop

08023f44 <GPDMA0_0_IRQHandler>:
  .initialized = (bool)0U, /* Is DMA initialized yet? */
  .irq_node = (IRQn_Type)105U /* Allotted DMA IRQ node */
};

void GPDMA0_0_IRQHandler(void)
{
 8023f44:	b580      	push	{r7, lr}
 8023f46:	af00      	add	r7, sp, #0
  XMC_DMA_IRQHandler(XMC_DMA0);
 8023f48:	4801      	ldr	r0, [pc, #4]	; (8023f50 <GPDMA0_0_IRQHandler+0xc>)
 8023f4a:	f7fe fd3d 	bl	80229c8 <XMC_DMA_IRQHandler>
}
 8023f4e:	bd80      	pop	{r7, pc}
 8023f50:	50014000 	.word	0x50014000

08023f54 <XMC_CCU4_StartPrescaler>:
 * \par<b>Related APIs:</b><br>
 * XMC_CCU4_Init()<BR> XMC_CCU4_EnableClock()<BR> XMC_CCU4_DisableClock()<BR> XMC_CCU4_StartPrescaler()<BR>
 * XMC_CCU4_StopPrescaler().
 */
__STATIC_INLINE void XMC_CCU4_StartPrescaler(XMC_CCU4_MODULE_t *const module)
{
 8023f54:	b480      	push	{r7}
 8023f56:	b083      	sub	sp, #12
 8023f58:	af00      	add	r7, sp, #0
 8023f5a:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("XMC_CCU4_StartPrescaler:Invalid Module Pointer", XMC_CCU4_IsValidModule(module));
  module->GIDLC = (uint32_t) CCU4_GIDLC_SPRB_Msk;
 8023f5c:	687b      	ldr	r3, [r7, #4]
 8023f5e:	f44f 7280 	mov.w	r2, #256	; 0x100
 8023f62:	60da      	str	r2, [r3, #12]
}
 8023f64:	370c      	adds	r7, #12
 8023f66:	46bd      	mov	sp, r7
 8023f68:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023f6c:	4770      	bx	lr
 8023f6e:	bf00      	nop

08023f70 <GLOBAL_CCU4_Init>:
  return version;
}

/* Initializes the slice with the generated configuration */
GLOBAL_CCU4_STATUS_t GLOBAL_CCU4_Init(GLOBAL_CCU4_t* handle)
{
 8023f70:	b580      	push	{r7, lr}
 8023f72:	b082      	sub	sp, #8
 8023f74:	af00      	add	r7, sp, #0
 8023f76:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("GLOBAL_CCU4_Init:NULL handler", (NULL != handle));

  if (false == handle->is_initialized)
 8023f78:	687b      	ldr	r3, [r7, #4]
 8023f7a:	7b5b      	ldrb	r3, [r3, #13]
 8023f7c:	f083 0301 	eor.w	r3, r3, #1
 8023f80:	b2db      	uxtb	r3, r3
 8023f82:	2b00      	cmp	r3, #0
 8023f84:	d00f      	beq.n	8023fa6 <GLOBAL_CCU4_Init+0x36>
  {
    /* Enable CCU4 module */
    XMC_CCU4_Init(handle->module_ptr,handle->mcs_action);
 8023f86:	687b      	ldr	r3, [r7, #4]
 8023f88:	689a      	ldr	r2, [r3, #8]
 8023f8a:	687b      	ldr	r3, [r7, #4]
 8023f8c:	7b1b      	ldrb	r3, [r3, #12]
 8023f8e:	4610      	mov	r0, r2
 8023f90:	4619      	mov	r1, r3
 8023f92:	f7fe f915 	bl	80221c0 <XMC_CCU4_Init>
    /* Start the prescaler */
    XMC_CCU4_StartPrescaler(handle->module_ptr);
 8023f96:	687b      	ldr	r3, [r7, #4]
 8023f98:	689b      	ldr	r3, [r3, #8]
 8023f9a:	4618      	mov	r0, r3
 8023f9c:	f7ff ffda 	bl	8023f54 <XMC_CCU4_StartPrescaler>
    /* Restricts multiple initializations */
    handle->is_initialized = true;
 8023fa0:	687b      	ldr	r3, [r7, #4]
 8023fa2:	2201      	movs	r2, #1
 8023fa4:	735a      	strb	r2, [r3, #13]
  }

  return (GLOBAL_CCU4_STATUS_SUCCESS);
 8023fa6:	2300      	movs	r3, #0
}
 8023fa8:	4618      	mov	r0, r3
 8023faa:	3708      	adds	r7, #8
 8023fac:	46bd      	mov	sp, r7
 8023fae:	bd80      	pop	{r7, pc}

08023fb0 <XMC_FLASH_SetMargin>:
 *
 * \par<b>Related APIs:</b><BR>
 * None
 */
__STATIC_INLINE void XMC_FLASH_SetMargin(const XMC_FLASH_MARGIN_t margin)
{
 8023fb0:	b480      	push	{r7}
 8023fb2:	b083      	sub	sp, #12
 8023fb4:	af00      	add	r7, sp, #0
 8023fb6:	4603      	mov	r3, r0
 8023fb8:	71fb      	strb	r3, [r7, #7]
  FLASH0->MARP = (FLASH0->MARP & (uint32_t)~FLASH_MARP_MARGIN_Msk) | margin;
 8023fba:	4909      	ldr	r1, [pc, #36]	; (8023fe0 <XMC_FLASH_SetMargin+0x30>)
 8023fbc:	4b08      	ldr	r3, [pc, #32]	; (8023fe0 <XMC_FLASH_SetMargin+0x30>)
 8023fbe:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8023fc2:	3318      	adds	r3, #24
 8023fc4:	681b      	ldr	r3, [r3, #0]
 8023fc6:	f023 020f 	bic.w	r2, r3, #15
 8023fca:	79fb      	ldrb	r3, [r7, #7]
 8023fcc:	431a      	orrs	r2, r3
 8023fce:	f501 5380 	add.w	r3, r1, #4096	; 0x1000
 8023fd2:	3318      	adds	r3, #24
 8023fd4:	601a      	str	r2, [r3, #0]
}
 8023fd6:	370c      	adds	r7, #12
 8023fd8:	46bd      	mov	sp, r7
 8023fda:	f85d 7b04 	ldr.w	r7, [sp], #4
 8023fde:	4770      	bx	lr
 8023fe0:	58001000 	.word	0x58001000

08023fe4 <XMC_FLASH_EnableDoubleBitErrorTrap>:
 *
 * \par<b>Related APIs:</b><BR>
 * None
 */
__STATIC_INLINE void XMC_FLASH_EnableDoubleBitErrorTrap(void)
{
 8023fe4:	b480      	push	{r7}
 8023fe6:	af00      	add	r7, sp, #0
  FLASH0->MARP &= (uint32_t)~FLASH_MARP_TRAPDIS_Msk;
 8023fe8:	4907      	ldr	r1, [pc, #28]	; (8024008 <XMC_FLASH_EnableDoubleBitErrorTrap+0x24>)
 8023fea:	4b07      	ldr	r3, [pc, #28]	; (8024008 <XMC_FLASH_EnableDoubleBitErrorTrap+0x24>)
 8023fec:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8023ff0:	3318      	adds	r3, #24
 8023ff2:	681b      	ldr	r3, [r3, #0]
 8023ff4:	f423 4200 	bic.w	r2, r3, #32768	; 0x8000
 8023ff8:	f501 5380 	add.w	r3, r1, #4096	; 0x1000
 8023ffc:	3318      	adds	r3, #24
 8023ffe:	601a      	str	r2, [r3, #0]
}
 8024000:	46bd      	mov	sp, r7
 8024002:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024006:	4770      	bx	lr
 8024008:	58001000 	.word	0x58001000

0802400c <XMC_FLASH_DisableDoubleBitErrorTrap>:
 *
 * \par<b>Related APIs:</b><BR>
 * None
 */
__STATIC_INLINE void XMC_FLASH_DisableDoubleBitErrorTrap(void)
{
 802400c:	b480      	push	{r7}
 802400e:	af00      	add	r7, sp, #0
  FLASH0->MARP |= FLASH_MARP_TRAPDIS_Msk;
 8024010:	4907      	ldr	r1, [pc, #28]	; (8024030 <XMC_FLASH_DisableDoubleBitErrorTrap+0x24>)
 8024012:	4b07      	ldr	r3, [pc, #28]	; (8024030 <XMC_FLASH_DisableDoubleBitErrorTrap+0x24>)
 8024014:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8024018:	3318      	adds	r3, #24
 802401a:	681b      	ldr	r3, [r3, #0]
 802401c:	f443 4200 	orr.w	r2, r3, #32768	; 0x8000
 8024020:	f501 5380 	add.w	r3, r1, #4096	; 0x1000
 8024024:	3318      	adds	r3, #24
 8024026:	601a      	str	r2, [r3, #0]
}
 8024028:	46bd      	mov	sp, r7
 802402a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802402e:	4770      	bx	lr
 8024030:	58001000 	.word	0x58001000

08024034 <XMC_FCE_InitializeSeedValue>:
 *
 * \par
 * The function sets the initial CRC (seed) value in the CRC register.
 */
__STATIC_INLINE void XMC_FCE_InitializeSeedValue(const XMC_FCE_t *const engine, uint32_t seedvalue)
{
 8024034:	b480      	push	{r7}
 8024036:	b083      	sub	sp, #12
 8024038:	af00      	add	r7, sp, #0
 802403a:	6078      	str	r0, [r7, #4]
 802403c:	6039      	str	r1, [r7, #0]
  engine->kernel_ptr->CRC = seedvalue;
 802403e:	687b      	ldr	r3, [r7, #4]
 8024040:	681b      	ldr	r3, [r3, #0]
 8024042:	683a      	ldr	r2, [r7, #0]
 8024044:	619a      	str	r2, [r3, #24]
}
 8024046:	370c      	adds	r7, #12
 8024048:	46bd      	mov	sp, r7
 802404a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802404e:	4770      	bx	lr

08024050 <E_EEPROM_XMC4_Init>:

  return (version);
}

E_EEPROM_XMC4_STATUS_t E_EEPROM_XMC4_Init(E_EEPROM_XMC4_t *const handle)
{
 8024050:	b580      	push	{r7, lr}
 8024052:	b084      	sub	sp, #16
 8024054:	af00      	add	r7, sp, #0
 8024056:	6078      	str	r0, [r7, #4]
  uint32_t sector_count;
  E_EEPROM_XMC4_STATUS_t status ;

  XMC_ASSERT("E_EEPROM_XMC4_Init:Invalid handle Pointer", (handle != NULL));

  status = E_EEPROM_XMC4_STATUS_OK;
 8024058:	2300      	movs	r3, #0
 802405a:	72fb      	strb	r3, [r7, #11]
  
  if (handle->initialized == (bool)false)
 802405c:	687b      	ldr	r3, [r7, #4]
 802405e:	781b      	ldrb	r3, [r3, #0]
 8024060:	f083 0301 	eor.w	r3, r3, #1
 8024064:	b2db      	uxtb	r3, r3
 8024066:	2b00      	cmp	r3, #0
 8024068:	d04c      	beq.n	8024104 <E_EEPROM_XMC4_Init+0xb4>
  {
    e_eeprom_xmc4_data_buffer.block_cycle_count = 0U;
 802406a:	4b29      	ldr	r3, [pc, #164]	; (8024110 <E_EEPROM_XMC4_Init+0xc0>)
 802406c:	2200      	movs	r2, #0
 802406e:	605a      	str	r2, [r3, #4]
    e_eeprom_xmc4_sector_info.flash_data_addr = E_EEPROM_XMC4_EMPTY;
 8024070:	4b28      	ldr	r3, [pc, #160]	; (8024114 <E_EEPROM_XMC4_Init+0xc4>)
 8024072:	2200      	movs	r2, #0
 8024074:	605a      	str	r2, [r3, #4]
  
    XMC_FLASH_SetMargin(XMC_FLASH_MARGIN_TIGHT0);
 8024076:	2001      	movs	r0, #1
 8024078:	f7ff ff9a 	bl	8023fb0 <XMC_FLASH_SetMargin>
    XMC_FLASH_DisableDoubleBitErrorTrap();
 802407c:	f7ff ffc6 	bl	802400c <XMC_FLASH_DisableDoubleBitErrorTrap>
  
    XMC_FCE_Enable();
 8024080:	f7fe fe3c 	bl	8022cfc <XMC_FCE_Enable>

    /* Initialize FCE module for Hardware calculations */
    (void)XMC_FCE_Init(&e_eeprom_xmc4_fce);
 8024084:	4824      	ldr	r0, [pc, #144]	; (8024118 <E_EEPROM_XMC4_Init+0xc8>)
 8024086:	f7fe fe23 	bl	8022cd0 <XMC_FCE_Init>
  
    /* Iterate all 4 sectors to find out which is the active sector having the latest data block*/
    for (sector_count = 0U; sector_count < E_EEPROM_XMC4_MAX_SECTORS ; sector_count++)
 802408a:	2300      	movs	r3, #0
 802408c:	60fb      	str	r3, [r7, #12]
 802408e:	e005      	b.n	802409c <E_EEPROM_XMC4_Init+0x4c>
    {
      E_EEPROM_XMC4_lInitReadSectorInfo(sector_count);
 8024090:	68f8      	ldr	r0, [r7, #12]
 8024092:	f000 f943 	bl	802431c <E_EEPROM_XMC4_lInitReadSectorInfo>

    /* Initialize FCE module for Hardware calculations */
    (void)XMC_FCE_Init(&e_eeprom_xmc4_fce);
  
    /* Iterate all 4 sectors to find out which is the active sector having the latest data block*/
    for (sector_count = 0U; sector_count < E_EEPROM_XMC4_MAX_SECTORS ; sector_count++)
 8024096:	68fb      	ldr	r3, [r7, #12]
 8024098:	3301      	adds	r3, #1
 802409a:	60fb      	str	r3, [r7, #12]
 802409c:	68fb      	ldr	r3, [r7, #12]
 802409e:	2b03      	cmp	r3, #3
 80240a0:	d9f6      	bls.n	8024090 <E_EEPROM_XMC4_Init+0x40>
    {
      E_EEPROM_XMC4_lInitReadSectorInfo(sector_count);
    }  
  
    XMC_FLASH_SetMargin(XMC_FLASH_MARGIN_DEFAULT);
 80240a2:	2000      	movs	r0, #0
 80240a4:	f7ff ff84 	bl	8023fb0 <XMC_FLASH_SetMargin>
  
    /* Implement the OVER ERASE CHECK code here and return the status*/
  
    /* If Read was successful*/
    if (status == E_EEPROM_XMC4_STATUS_OK)
 80240a8:	7afb      	ldrb	r3, [r7, #11]
 80240aa:	2b00      	cmp	r3, #0
 80240ac:	d125      	bne.n	80240fa <E_EEPROM_XMC4_Init+0xaa>
    {
      /* Execute erase state machine to free up the unwanted sectors and keep
       * only the sector which has latest valid block. If no valid block found then all sectors are emptied.
       */
      status = E_EEPROM_XMC4_lInitEraseStateMachine();
 80240ae:	f000 f98b 	bl	80243c8 <E_EEPROM_XMC4_lInitEraseStateMachine>
 80240b2:	4603      	mov	r3, r0
 80240b4:	72fb      	strb	r3, [r7, #11]
  
      /* If erase operations were successful, continue block data updates to RAM buffer */
      if (status == E_EEPROM_XMC4_STATUS_OK)
 80240b6:	7afb      	ldrb	r3, [r7, #11]
 80240b8:	2b00      	cmp	r3, #0
 80240ba:	d11e      	bne.n	80240fa <E_EEPROM_XMC4_Init+0xaa>
      {
  
        /* If a valid latest block were not detected, we shall assume that all sectors may be empty.
         * Then make Sector-0 as current sector and next free address as Sector0 start address
         */
        if (e_eeprom_xmc4_sector_info.flash_data_addr == E_EEPROM_XMC4_EMPTY)
 80240bc:	4b15      	ldr	r3, [pc, #84]	; (8024114 <E_EEPROM_XMC4_Init+0xc4>)
 80240be:	685b      	ldr	r3, [r3, #4]
 80240c0:	2b00      	cmp	r3, #0
 80240c2:	d106      	bne.n	80240d2 <E_EEPROM_XMC4_Init+0x82>
        {
          e_eeprom_xmc4_sector_info.current_sector = E_EEPROM_XMC4_SECTOR_0;
 80240c4:	4b13      	ldr	r3, [pc, #76]	; (8024114 <E_EEPROM_XMC4_Init+0xc4>)
 80240c6:	2200      	movs	r2, #0
 80240c8:	609a      	str	r2, [r3, #8]
          e_eeprom_xmc4_sector_info.next_free_start_addr =  E_EEPROM_XMC4_SECTOR0_START_ADDR;
 80240ca:	4b12      	ldr	r3, [pc, #72]	; (8024114 <E_EEPROM_XMC4_Init+0xc4>)
 80240cc:	4a13      	ldr	r2, [pc, #76]	; (802411c <E_EEPROM_XMC4_Init+0xcc>)
 80240ce:	601a      	str	r2, [r3, #0]
 80240d0:	e013      	b.n	80240fa <E_EEPROM_XMC4_Init+0xaa>
        }
        else
        {
          /* If a valid latest block was detected, copy the valid block from flash to RAM. */
          E_EEPROM_XMC4_lCopyFlashToRam();
 80240d2:	f000 f9d1 	bl	8024478 <E_EEPROM_XMC4_lCopyFlashToRam>
  
          if ((e_eeprom_xmc4_sector_info.next_free_start_addr - e_eeprom_xmc4_sector_info.flash_data_addr) !=
 80240d6:	4b0f      	ldr	r3, [pc, #60]	; (8024114 <E_EEPROM_XMC4_Init+0xc4>)
 80240d8:	681a      	ldr	r2, [r3, #0]
 80240da:	4b0e      	ldr	r3, [pc, #56]	; (8024114 <E_EEPROM_XMC4_Init+0xc4>)
 80240dc:	685b      	ldr	r3, [r3, #4]
 80240de:	1ad3      	subs	r3, r2, r3
 80240e0:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80240e4:	d001      	beq.n	80240ea <E_EEPROM_XMC4_Init+0x9a>
              E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE)
          {
            status = E_EEPROM_XMC4_STATUS_ERROR_OLD_DATA;
 80240e6:	2301      	movs	r3, #1
 80240e8:	72fb      	strb	r3, [r7, #11]
          }
  
          if (e_eeprom_xmc4_sector_info.next_free_start_addr >= E_EEPROM_XMC4_SECTOR4_START_ADDR)
 80240ea:	4b0a      	ldr	r3, [pc, #40]	; (8024114 <E_EEPROM_XMC4_Init+0xc4>)
 80240ec:	681b      	ldr	r3, [r3, #0]
 80240ee:	4a0c      	ldr	r2, [pc, #48]	; (8024120 <E_EEPROM_XMC4_Init+0xd0>)
 80240f0:	4293      	cmp	r3, r2
 80240f2:	d902      	bls.n	80240fa <E_EEPROM_XMC4_Init+0xaa>
          {
            e_eeprom_xmc4_sector_info.next_free_start_addr =  E_EEPROM_XMC4_SECTOR0_START_ADDR;
 80240f4:	4b07      	ldr	r3, [pc, #28]	; (8024114 <E_EEPROM_XMC4_Init+0xc4>)
 80240f6:	4a09      	ldr	r2, [pc, #36]	; (802411c <E_EEPROM_XMC4_Init+0xcc>)
 80240f8:	601a      	str	r2, [r3, #0]
  
        }
      }
    }

    XMC_FLASH_EnableDoubleBitErrorTrap();
 80240fa:	f7ff ff73 	bl	8023fe4 <XMC_FLASH_EnableDoubleBitErrorTrap>

    handle->initialized = (bool)true;
 80240fe:	687b      	ldr	r3, [r7, #4]
 8024100:	2201      	movs	r2, #1
 8024102:	701a      	strb	r2, [r3, #0]
  }

  return (status);
 8024104:	7afb      	ldrb	r3, [r7, #11]
}
 8024106:	4618      	mov	r0, r3
 8024108:	3710      	adds	r7, #16
 802410a:	46bd      	mov	sp, r7
 802410c:	bd80      	pop	{r7, pc}
 802410e:	bf00      	nop
 8024110:	1fff1814 	.word	0x1fff1814
 8024114:	1fff17d0 	.word	0x1fff17d0
 8024118:	08025c08 	.word	0x08025c08
 802411c:	0c010000 	.word	0x0c010000
 8024120:	0c01ffff 	.word	0x0c01ffff

08024124 <E_EEPROM_XMC4_WriteArray>:



/* Update a set of bytes to RAM buffer*/
bool E_EEPROM_XMC4_WriteArray(const uint16_t offset_address, const uint8_t *const data, const uint16_t length)
{
 8024124:	b580      	push	{r7, lr}
 8024126:	b086      	sub	sp, #24
 8024128:	af00      	add	r7, sp, #0
 802412a:	4603      	mov	r3, r0
 802412c:	6039      	str	r1, [r7, #0]
 802412e:	80fb      	strh	r3, [r7, #6]
 8024130:	4613      	mov	r3, r2
 8024132:	80bb      	strh	r3, [r7, #4]
  bool status;

  XMC_ASSERT("E_EEPROM_XMC4_WriteArray: Wrong offset address", (offset_address  < E_EEPROM_XMC4_DATA_BLOCK_SIZE));
  XMC_ASSERT("E_EEPROM_XMC4_WriteArray: Wrong length", ((offset_address + length)  < E_EEPROM_XMC4_DATA_BLOCK_SIZE));

  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;
 8024134:	88fb      	ldrh	r3, [r7, #6]
 8024136:	3308      	adds	r3, #8
 8024138:	4a12      	ldr	r2, [pc, #72]	; (8024184 <E_EEPROM_XMC4_WriteArray+0x60>)
 802413a:	4413      	add	r3, r2
 802413c:	613b      	str	r3, [r7, #16]
  status = (memcmp(address_ptr, data, length) != 0);
 802413e:	88bb      	ldrh	r3, [r7, #4]
 8024140:	6938      	ldr	r0, [r7, #16]
 8024142:	6839      	ldr	r1, [r7, #0]
 8024144:	461a      	mov	r2, r3
 8024146:	f000 ffe9 	bl	802511c <memcmp>
 802414a:	4603      	mov	r3, r0
 802414c:	2b00      	cmp	r3, #0
 802414e:	bf14      	ite	ne
 8024150:	2301      	movne	r3, #1
 8024152:	2300      	moveq	r3, #0
 8024154:	73fb      	strb	r3, [r7, #15]

  for (i = 0U; i < length; i++)
 8024156:	2300      	movs	r3, #0
 8024158:	82fb      	strh	r3, [r7, #22]
 802415a:	e00a      	b.n	8024172 <E_EEPROM_XMC4_WriteArray+0x4e>
  {
      *(address_ptr + i) = *(data + i);
 802415c:	8afb      	ldrh	r3, [r7, #22]
 802415e:	693a      	ldr	r2, [r7, #16]
 8024160:	4413      	add	r3, r2
 8024162:	8afa      	ldrh	r2, [r7, #22]
 8024164:	6839      	ldr	r1, [r7, #0]
 8024166:	440a      	add	r2, r1
 8024168:	7812      	ldrb	r2, [r2, #0]
 802416a:	701a      	strb	r2, [r3, #0]
  XMC_ASSERT("E_EEPROM_XMC4_WriteArray: Wrong length", ((offset_address + length)  < E_EEPROM_XMC4_DATA_BLOCK_SIZE));

  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;
  status = (memcmp(address_ptr, data, length) != 0);

  for (i = 0U; i < length; i++)
 802416c:	8afb      	ldrh	r3, [r7, #22]
 802416e:	3301      	adds	r3, #1
 8024170:	82fb      	strh	r3, [r7, #22]
 8024172:	8afa      	ldrh	r2, [r7, #22]
 8024174:	88bb      	ldrh	r3, [r7, #4]
 8024176:	429a      	cmp	r2, r3
 8024178:	d3f0      	bcc.n	802415c <E_EEPROM_XMC4_WriteArray+0x38>
  {
      *(address_ptr + i) = *(data + i);
  }

  return status;
 802417a:	7bfb      	ldrb	r3, [r7, #15]
}
 802417c:	4618      	mov	r0, r3
 802417e:	3718      	adds	r7, #24
 8024180:	46bd      	mov	sp, r7
 8024182:	bd80      	pop	{r7, pc}
 8024184:	1fff1814 	.word	0x1fff1814

08024188 <E_EEPROM_XMC4_ReadArray>:



/* Read a set of bytes from RAM Buffer */
void E_EEPROM_XMC4_ReadArray(const uint16_t offset_address, uint8_t *const data, const uint16_t length)
{
 8024188:	b480      	push	{r7}
 802418a:	b085      	sub	sp, #20
 802418c:	af00      	add	r7, sp, #0
 802418e:	4603      	mov	r3, r0
 8024190:	6039      	str	r1, [r7, #0]
 8024192:	80fb      	strh	r3, [r7, #6]
 8024194:	4613      	mov	r3, r2
 8024196:	80bb      	strh	r3, [r7, #4]
  uint16_t i;
  uint8_t  *address_ptr;
  XMC_ASSERT("E_EEPROM_XMC4_ReadArray: Wrong offset address", (offset_address  < E_EEPROM_XMC4_DATA_BLOCK_SIZE));
  XMC_ASSERT("E_EEPROM_XMC4_ReadArray: Wrong length", ((offset_address + length)  < E_EEPROM_XMC4_DATA_BLOCK_SIZE));
  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;
 8024198:	88fb      	ldrh	r3, [r7, #6]
 802419a:	3308      	adds	r3, #8
 802419c:	4a0c      	ldr	r2, [pc, #48]	; (80241d0 <E_EEPROM_XMC4_ReadArray+0x48>)
 802419e:	4413      	add	r3, r2
 80241a0:	60bb      	str	r3, [r7, #8]

  for (i=0U; i<length; i++)
 80241a2:	2300      	movs	r3, #0
 80241a4:	81fb      	strh	r3, [r7, #14]
 80241a6:	e00a      	b.n	80241be <E_EEPROM_XMC4_ReadArray+0x36>
  {
    *(data + i) = *(address_ptr + i);
 80241a8:	89fb      	ldrh	r3, [r7, #14]
 80241aa:	683a      	ldr	r2, [r7, #0]
 80241ac:	4413      	add	r3, r2
 80241ae:	89fa      	ldrh	r2, [r7, #14]
 80241b0:	68b9      	ldr	r1, [r7, #8]
 80241b2:	440a      	add	r2, r1
 80241b4:	7812      	ldrb	r2, [r2, #0]
 80241b6:	701a      	strb	r2, [r3, #0]
  uint8_t  *address_ptr;
  XMC_ASSERT("E_EEPROM_XMC4_ReadArray: Wrong offset address", (offset_address  < E_EEPROM_XMC4_DATA_BLOCK_SIZE));
  XMC_ASSERT("E_EEPROM_XMC4_ReadArray: Wrong length", ((offset_address + length)  < E_EEPROM_XMC4_DATA_BLOCK_SIZE));
  address_ptr = (uint8_t*)(void*)(&e_eeprom_xmc4_data_buffer.eeprom_data) + (uint32_t)offset_address;

  for (i=0U; i<length; i++)
 80241b8:	89fb      	ldrh	r3, [r7, #14]
 80241ba:	3301      	adds	r3, #1
 80241bc:	81fb      	strh	r3, [r7, #14]
 80241be:	89fa      	ldrh	r2, [r7, #14]
 80241c0:	88bb      	ldrh	r3, [r7, #4]
 80241c2:	429a      	cmp	r2, r3
 80241c4:	d3f0      	bcc.n	80241a8 <E_EEPROM_XMC4_ReadArray+0x20>
  {
    *(data + i) = *(address_ptr + i);
  }
}
 80241c6:	3714      	adds	r7, #20
 80241c8:	46bd      	mov	sp, r7
 80241ca:	f85d 7b04 	ldr.w	r7, [sp], #4
 80241ce:	4770      	bx	lr
 80241d0:	1fff1814 	.word	0x1fff1814

080241d4 <E_EEPROM_XMC4_UpdateFlashContents>:



/* Copy data blocks from RAM to FLASH */
E_EEPROM_XMC4_STATUS_t E_EEPROM_XMC4_UpdateFlashContents(void)
{
 80241d4:	b580      	push	{r7, lr}
 80241d6:	b082      	sub	sp, #8
 80241d8:	af00      	add	r7, sp, #0
  E_EEPROM_XMC4_STATUS_t status;
  uint32_t sector_start_addr;

  status = E_EEPROM_XMC4_STATUS_OK;
 80241da:	2300      	movs	r3, #0
 80241dc:	71fb      	strb	r3, [r7, #7]

  /* Calculate the starting address of the active sector from where the first write started for the current cycle*/
  sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR +
                     (E_EEPROM_XMC4_SECTOR_SIZE * e_eeprom_xmc4_sector_info.current_sector);
 80241de:	4b22      	ldr	r3, [pc, #136]	; (8024268 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 80241e0:	689b      	ldr	r3, [r3, #8]
  uint32_t sector_start_addr;

  status = E_EEPROM_XMC4_STATUS_OK;

  /* Calculate the starting address of the active sector from where the first write started for the current cycle*/
  sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR +
 80241e2:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 80241e6:	3304      	adds	r3, #4
 80241e8:	039b      	lsls	r3, r3, #14
 80241ea:	603b      	str	r3, [r7, #0]
                     (E_EEPROM_XMC4_SECTOR_SIZE * e_eeprom_xmc4_sector_info.current_sector);

  /* If the next free address crosses current active sector starting address, then all the sectors are fully written*/
  if ((e_eeprom_xmc4_sector_info.next_free_start_addr == sector_start_addr) &&
 80241ec:	4b1e      	ldr	r3, [pc, #120]	; (8024268 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 80241ee:	681a      	ldr	r2, [r3, #0]
 80241f0:	683b      	ldr	r3, [r7, #0]
 80241f2:	429a      	cmp	r2, r3
 80241f4:	d111      	bne.n	802421a <E_EEPROM_XMC4_UpdateFlashContents+0x46>
     (e_eeprom_xmc4_data_buffer.block_cycle_count != 0U))
 80241f6:	4b1d      	ldr	r3, [pc, #116]	; (802426c <E_EEPROM_XMC4_UpdateFlashContents+0x98>)
 80241f8:	685b      	ldr	r3, [r3, #4]
  /* Calculate the starting address of the active sector from where the first write started for the current cycle*/
  sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR +
                     (E_EEPROM_XMC4_SECTOR_SIZE * e_eeprom_xmc4_sector_info.current_sector);

  /* If the next free address crosses current active sector starting address, then all the sectors are fully written*/
  if ((e_eeprom_xmc4_sector_info.next_free_start_addr == sector_start_addr) &&
 80241fa:	2b00      	cmp	r3, #0
 80241fc:	d00d      	beq.n	802421a <E_EEPROM_XMC4_UpdateFlashContents+0x46>
     (e_eeprom_xmc4_data_buffer.block_cycle_count != 0U))
  {
    /* Update the current sector to the latest sector on which the last write was executed. */
    e_eeprom_xmc4_sector_info.current_sector =  ((e_eeprom_xmc4_sector_info.flash_data_addr &
 80241fe:	4b1a      	ldr	r3, [pc, #104]	; (8024268 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 8024200:	685b      	ldr	r3, [r3, #4]
 8024202:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
                                                E_EEPROM_XMC4_SECTOR_POSITION_MASK) >>
 8024206:	0b9b      	lsrs	r3, r3, #14
  /* If the next free address crosses current active sector starting address, then all the sectors are fully written*/
  if ((e_eeprom_xmc4_sector_info.next_free_start_addr == sector_start_addr) &&
     (e_eeprom_xmc4_data_buffer.block_cycle_count != 0U))
  {
    /* Update the current sector to the latest sector on which the last write was executed. */
    e_eeprom_xmc4_sector_info.current_sector =  ((e_eeprom_xmc4_sector_info.flash_data_addr &
 8024208:	4a17      	ldr	r2, [pc, #92]	; (8024268 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 802420a:	6093      	str	r3, [r2, #8]
                                                E_EEPROM_XMC4_SECTOR_POSITION_MASK) >>
                                                E_EEPROM_XMC4_SECTOR_POSITION);

    /* Mark all the sectors as filled with data */
    e_eeprom_xmc4_sector_info.erase_state = E_EEPROM_XMC4_ALL_SECTORS_FILLED ;
 802420c:	4b16      	ldr	r3, [pc, #88]	; (8024268 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 802420e:	220f      	movs	r2, #15
 8024210:	60da      	str	r2, [r3, #12]

    /* Execute erase state machine to free up the unwanted sectors and keep only the sector which has latest block*/
    status = E_EEPROM_XMC4_lInitEraseStateMachine();
 8024212:	f000 f8d9 	bl	80243c8 <E_EEPROM_XMC4_lInitEraseStateMachine>
 8024216:	4603      	mov	r3, r0
 8024218:	71fb      	strb	r3, [r7, #7]
  }

  if (status ==  E_EEPROM_XMC4_STATUS_OK)
 802421a:	79fb      	ldrb	r3, [r7, #7]
 802421c:	2b00      	cmp	r3, #0
 802421e:	d11d      	bne.n	802425c <E_EEPROM_XMC4_UpdateFlashContents+0x88>
  {
    e_eeprom_xmc4_data_buffer.block_cycle_count++;
 8024220:	4b12      	ldr	r3, [pc, #72]	; (802426c <E_EEPROM_XMC4_UpdateFlashContents+0x98>)
 8024222:	685b      	ldr	r3, [r3, #4]
 8024224:	3301      	adds	r3, #1
 8024226:	4a11      	ldr	r2, [pc, #68]	; (802426c <E_EEPROM_XMC4_UpdateFlashContents+0x98>)
 8024228:	6053      	str	r3, [r2, #4]

    status = E_EEPROM_XMC4_lWriteToFlash();
 802422a:	f000 f839 	bl	80242a0 <E_EEPROM_XMC4_lWriteToFlash>
 802422e:	4603      	mov	r3, r0
 8024230:	71fb      	strb	r3, [r7, #7]

    /* If the flash write succeeds, update the latest flash data location in RAM for reference */
    if (status == E_EEPROM_XMC4_STATUS_OK)
 8024232:	79fb      	ldrb	r3, [r7, #7]
 8024234:	2b00      	cmp	r3, #0
 8024236:	d103      	bne.n	8024240 <E_EEPROM_XMC4_UpdateFlashContents+0x6c>
    {
      e_eeprom_xmc4_sector_info.flash_data_addr = e_eeprom_xmc4_sector_info.next_free_start_addr;
 8024238:	4b0b      	ldr	r3, [pc, #44]	; (8024268 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 802423a:	681b      	ldr	r3, [r3, #0]
 802423c:	4a0a      	ldr	r2, [pc, #40]	; (8024268 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 802423e:	6053      	str	r3, [r2, #4]
    }

    /* Update the next free address to write the new data block*/
    e_eeprom_xmc4_sector_info.next_free_start_addr += E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE;
 8024240:	4b09      	ldr	r3, [pc, #36]	; (8024268 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 8024242:	681b      	ldr	r3, [r3, #0]
 8024244:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8024248:	4a07      	ldr	r2, [pc, #28]	; (8024268 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 802424a:	6013      	str	r3, [r2, #0]

    /* If the next free address crosses 3rd sector end address relocate the address to 0th sector starting address*/
    if (e_eeprom_xmc4_sector_info.next_free_start_addr >= E_EEPROM_XMC4_SECTOR4_START_ADDR)
 802424c:	4b06      	ldr	r3, [pc, #24]	; (8024268 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 802424e:	681b      	ldr	r3, [r3, #0]
 8024250:	4a07      	ldr	r2, [pc, #28]	; (8024270 <E_EEPROM_XMC4_UpdateFlashContents+0x9c>)
 8024252:	4293      	cmp	r3, r2
 8024254:	d902      	bls.n	802425c <E_EEPROM_XMC4_UpdateFlashContents+0x88>
    {
      e_eeprom_xmc4_sector_info.next_free_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR;
 8024256:	4b04      	ldr	r3, [pc, #16]	; (8024268 <E_EEPROM_XMC4_UpdateFlashContents+0x94>)
 8024258:	4a06      	ldr	r2, [pc, #24]	; (8024274 <E_EEPROM_XMC4_UpdateFlashContents+0xa0>)
 802425a:	601a      	str	r2, [r3, #0]
    }
  }

  return (status);
 802425c:	79fb      	ldrb	r3, [r7, #7]
}
 802425e:	4618      	mov	r0, r3
 8024260:	3708      	adds	r7, #8
 8024262:	46bd      	mov	sp, r7
 8024264:	bd80      	pop	{r7, pc}
 8024266:	bf00      	nop
 8024268:	1fff17d0 	.word	0x1fff17d0
 802426c:	1fff1814 	.word	0x1fff1814
 8024270:	0c01ffff 	.word	0x0c01ffff
 8024274:	0c010000 	.word	0x0c010000

08024278 <E_EEPROM_XMC4_IsFlashEmpty>:


/* Check the availability data in the flash emulated EEPROM area */
bool E_EEPROM_XMC4_IsFlashEmpty(void)
{
 8024278:	b480      	push	{r7}
 802427a:	b083      	sub	sp, #12
 802427c:	af00      	add	r7, sp, #0
  bool status = false;
 802427e:	2300      	movs	r3, #0
 8024280:	71fb      	strb	r3, [r7, #7]

  /* If data available flash_data_addr will have a valid address*/
  if (e_eeprom_xmc4_sector_info.flash_data_addr == 0U)
 8024282:	4b06      	ldr	r3, [pc, #24]	; (802429c <E_EEPROM_XMC4_IsFlashEmpty+0x24>)
 8024284:	685b      	ldr	r3, [r3, #4]
 8024286:	2b00      	cmp	r3, #0
 8024288:	d101      	bne.n	802428e <E_EEPROM_XMC4_IsFlashEmpty+0x16>
  {
    status = true;
 802428a:	2301      	movs	r3, #1
 802428c:	71fb      	strb	r3, [r7, #7]
  }
  return (status);
 802428e:	79fb      	ldrb	r3, [r7, #7]
}
 8024290:	4618      	mov	r0, r3
 8024292:	370c      	adds	r7, #12
 8024294:	46bd      	mov	sp, r7
 8024296:	f85d 7b04 	ldr.w	r7, [sp], #4
 802429a:	4770      	bx	lr
 802429c:	1fff17d0 	.word	0x1fff17d0

080242a0 <E_EEPROM_XMC4_lWriteToFlash>:
 * LOCAL ROUTINES
 ********************************************************************************************************************/

/* Local function to program data blocks from RAM into FLASH */
static E_EEPROM_XMC4_STATUS_t E_EEPROM_XMC4_lWriteToFlash(void)
{
 80242a0:	b580      	push	{r7, lr}
 80242a2:	b084      	sub	sp, #16
 80242a4:	af00      	add	r7, sp, #0
  uint32_t *flash_addr_ptr;
  uint32_t *ram_addr_ptr;
  uint32_t  page_index;
  E_EEPROM_XMC4_STATUS_t status;

  status = E_EEPROM_XMC4_STATUS_OK;
 80242a6:	2300      	movs	r3, #0
 80242a8:	70fb      	strb	r3, [r7, #3]
  flash_addr_ptr = (uint32_t*)e_eeprom_xmc4_sector_info.next_free_start_addr;
 80242aa:	4b18      	ldr	r3, [pc, #96]	; (802430c <E_EEPROM_XMC4_lWriteToFlash+0x6c>)
 80242ac:	681b      	ldr	r3, [r3, #0]
 80242ae:	60fb      	str	r3, [r7, #12]
  ram_addr_ptr   = (uint32_t*)(void*)&e_eeprom_xmc4_data_buffer;
 80242b0:	4b17      	ldr	r3, [pc, #92]	; (8024310 <E_EEPROM_XMC4_lWriteToFlash+0x70>)
 80242b2:	60bb      	str	r3, [r7, #8]

  e_eeprom_xmc4_data_buffer.crc = E_EEPROM_XMC4_lCalculateCRC((uint32_t*)(void*)
 80242b4:	4817      	ldr	r0, [pc, #92]	; (8024314 <E_EEPROM_XMC4_lWriteToFlash+0x74>)
 80242b6:	f000 f8c7 	bl	8024448 <E_EEPROM_XMC4_lCalculateCRC>
 80242ba:	4602      	mov	r2, r0
 80242bc:	4b14      	ldr	r3, [pc, #80]	; (8024310 <E_EEPROM_XMC4_lWriteToFlash+0x70>)
 80242be:	601a      	str	r2, [r3, #0]
                                                             (&(e_eeprom_xmc4_data_buffer.block_cycle_count)));

  for (page_index = 0U ; page_index < E_EEPROM_XMC4_MAX_PAGES; page_index++)
 80242c0:	2300      	movs	r3, #0
 80242c2:	607b      	str	r3, [r7, #4]
 80242c4:	e01a      	b.n	80242fc <E_EEPROM_XMC4_lWriteToFlash+0x5c>
  {
    XMC_FLASH_ClearStatus();
 80242c6:	f7fd f941 	bl	802154c <XMC_FLASH_ClearStatus>

    XMC_FLASH_ProgramPage(flash_addr_ptr,ram_addr_ptr);
 80242ca:	68f8      	ldr	r0, [r7, #12]
 80242cc:	68b9      	ldr	r1, [r7, #8]
 80242ce:	f7fd f951 	bl	8021574 <XMC_FLASH_ProgramPage>

    if ((XMC_FLASH_GetStatus() & (uint32_t)(XMC_FLASH_STATUS_VERIFY_ERROR | XMC_FLASH_STATUS_OPERATION_ERROR)) != 0)
 80242d2:	f7fd f941 	bl	8021558 <XMC_FLASH_GetStatus>
 80242d6:	4602      	mov	r2, r0
 80242d8:	4b0f      	ldr	r3, [pc, #60]	; (8024318 <E_EEPROM_XMC4_lWriteToFlash+0x78>)
 80242da:	4013      	ands	r3, r2
 80242dc:	2b00      	cmp	r3, #0
 80242de:	d002      	beq.n	80242e6 <E_EEPROM_XMC4_lWriteToFlash+0x46>
    {
      status = E_EEPROM_XMC4_STATUS_WRITE_ERROR;
 80242e0:	2303      	movs	r3, #3
 80242e2:	70fb      	strb	r3, [r7, #3]
      break;
 80242e4:	e00d      	b.n	8024302 <E_EEPROM_XMC4_lWriteToFlash+0x62>
    }
    ram_addr_ptr   += E_EEPROM_XMC4_MIN_WORDS_PER_PAGE ;
 80242e6:	68bb      	ldr	r3, [r7, #8]
 80242e8:	f503 7380 	add.w	r3, r3, #256	; 0x100
 80242ec:	60bb      	str	r3, [r7, #8]
    flash_addr_ptr += E_EEPROM_XMC4_MIN_WORDS_PER_PAGE ;
 80242ee:	68fb      	ldr	r3, [r7, #12]
 80242f0:	f503 7380 	add.w	r3, r3, #256	; 0x100
 80242f4:	60fb      	str	r3, [r7, #12]
  ram_addr_ptr   = (uint32_t*)(void*)&e_eeprom_xmc4_data_buffer;

  e_eeprom_xmc4_data_buffer.crc = E_EEPROM_XMC4_lCalculateCRC((uint32_t*)(void*)
                                                             (&(e_eeprom_xmc4_data_buffer.block_cycle_count)));

  for (page_index = 0U ; page_index < E_EEPROM_XMC4_MAX_PAGES; page_index++)
 80242f6:	687b      	ldr	r3, [r7, #4]
 80242f8:	3301      	adds	r3, #1
 80242fa:	607b      	str	r3, [r7, #4]
 80242fc:	687b      	ldr	r3, [r7, #4]
 80242fe:	2b0f      	cmp	r3, #15
 8024300:	d9e1      	bls.n	80242c6 <E_EEPROM_XMC4_lWriteToFlash+0x26>
    }
    ram_addr_ptr   += E_EEPROM_XMC4_MIN_WORDS_PER_PAGE ;
    flash_addr_ptr += E_EEPROM_XMC4_MIN_WORDS_PER_PAGE ;
  }

  return (status);
 8024302:	78fb      	ldrb	r3, [r7, #3]
}
 8024304:	4618      	mov	r0, r3
 8024306:	3710      	adds	r7, #16
 8024308:	46bd      	mov	sp, r7
 802430a:	bd80      	pop	{r7, pc}
 802430c:	1fff17d0 	.word	0x1fff17d0
 8024310:	1fff1814 	.word	0x1fff1814
 8024314:	1fff1818 	.word	0x1fff1818
 8024318:	80000100 	.word	0x80000100

0802431c <E_EEPROM_XMC4_lInitReadSectorInfo>:



static void E_EEPROM_XMC4_lInitReadSectorInfo(const uint32_t sector)
{
 802431c:	b580      	push	{r7, lr}
 802431e:	b08a      	sub	sp, #40	; 0x28
 8024320:	af00      	add	r7, sp, #0
 8024322:	6078      	str	r0, [r7, #4]
  uint32_t block_cycle_count;
  uint32_t written_crc;
  uint32_t calculated_crc;

  /* Initialize starting address and last block address of the sector. */
  sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR + (E_EEPROM_XMC4_SECTOR_SIZE * (uint32_t)sector);
 8024324:	687b      	ldr	r3, [r7, #4]
 8024326:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 802432a:	3304      	adds	r3, #4
 802432c:	039b      	lsls	r3, r3, #14
 802432e:	61fb      	str	r3, [r7, #28]
  block_read_addr = (sector_start_addr + E_EEPROM_XMC4_SECTOR_SIZE) - E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE;
 8024330:	69fb      	ldr	r3, [r7, #28]
 8024332:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8024336:	627b      	str	r3, [r7, #36]	; 0x24
  free_block_addr = E_EEPROM_XMC4_EMPTY;
 8024338:	2300      	movs	r3, #0
 802433a:	623b      	str	r3, [r7, #32]

  do
  {
    /* Read first 32 bit data from the block which indicates the block cycle counter. */
    data_ptr = (uint32_t*)block_read_addr;
 802433c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802433e:	61bb      	str	r3, [r7, #24]
    block_cycle_count = *(data_ptr + E_EEPROM_XMC4_BCC_OFFSET);
 8024340:	69bb      	ldr	r3, [r7, #24]
 8024342:	685b      	ldr	r3, [r3, #4]
 8024344:	617b      	str	r3, [r7, #20]

    /* Check if block cycle count is a non zero value*/
    if (block_cycle_count != E_EEPROM_XMC4_EMPTY)
 8024346:	697b      	ldr	r3, [r7, #20]
 8024348:	2b00      	cmp	r3, #0
 802434a:	d02e      	beq.n	80243aa <E_EEPROM_XMC4_lInitReadSectorInfo+0x8e>
    {
      /* Mark sector as non-empty sector*/
      e_eeprom_xmc4_sector_info.erase_state |= ((uint32_t)1U << sector);
 802434c:	4b1c      	ldr	r3, [pc, #112]	; (80243c0 <E_EEPROM_XMC4_lInitReadSectorInfo+0xa4>)
 802434e:	68da      	ldr	r2, [r3, #12]
 8024350:	687b      	ldr	r3, [r7, #4]
 8024352:	2101      	movs	r1, #1
 8024354:	fa01 f303 	lsl.w	r3, r1, r3
 8024358:	4313      	orrs	r3, r2
 802435a:	4a19      	ldr	r2, [pc, #100]	; (80243c0 <E_EEPROM_XMC4_lInitReadSectorInfo+0xa4>)
 802435c:	60d3      	str	r3, [r2, #12]

      /* If this is the first non empty block identified, then store the address as next free address */
      if (free_block_addr == E_EEPROM_XMC4_EMPTY)
 802435e:	6a3b      	ldr	r3, [r7, #32]
 8024360:	2b00      	cmp	r3, #0
 8024362:	d103      	bne.n	802436c <E_EEPROM_XMC4_lInitReadSectorInfo+0x50>
      {
        free_block_addr = block_read_addr + E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE;
 8024364:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8024366:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 802436a:	623b      	str	r3, [r7, #32]
      }

      /* Read the second 32bit data which indicates the CRC */
      written_crc = *data_ptr;
 802436c:	69bb      	ldr	r3, [r7, #24]
 802436e:	681b      	ldr	r3, [r3, #0]
 8024370:	613b      	str	r3, [r7, #16]
      /* Calculate the CRC for the written data in flash (3rd word to the last word)*/
      calculated_crc = E_EEPROM_XMC4_lCalculateCRC(data_ptr + E_EEPROM_XMC4_BCC_OFFSET);
 8024372:	69bb      	ldr	r3, [r7, #24]
 8024374:	3304      	adds	r3, #4
 8024376:	4618      	mov	r0, r3
 8024378:	f000 f866 	bl	8024448 <E_EEPROM_XMC4_lCalculateCRC>
 802437c:	60f8      	str	r0, [r7, #12]

      if (calculated_crc == written_crc)
 802437e:	68fa      	ldr	r2, [r7, #12]
 8024380:	693b      	ldr	r3, [r7, #16]
 8024382:	429a      	cmp	r2, r3
 8024384:	d111      	bne.n	80243aa <E_EEPROM_XMC4_lInitReadSectorInfo+0x8e>
      {
        /* If both CRC matches and the current block cycle counter is greater than the previous recorded value,
         * Update the Data structure with the current block as the "latest" one and the current sector as "active".
         * Exit from the function.
         */
        if (block_cycle_count > e_eeprom_xmc4_data_buffer.block_cycle_count)
 8024386:	4b0f      	ldr	r3, [pc, #60]	; (80243c4 <E_EEPROM_XMC4_lInitReadSectorInfo+0xa8>)
 8024388:	685a      	ldr	r2, [r3, #4]
 802438a:	697b      	ldr	r3, [r7, #20]
 802438c:	429a      	cmp	r2, r3
 802438e:	d20c      	bcs.n	80243aa <E_EEPROM_XMC4_lInitReadSectorInfo+0x8e>
        {
          e_eeprom_xmc4_data_buffer.block_cycle_count = block_cycle_count;
 8024390:	4a0c      	ldr	r2, [pc, #48]	; (80243c4 <E_EEPROM_XMC4_lInitReadSectorInfo+0xa8>)
 8024392:	697b      	ldr	r3, [r7, #20]
 8024394:	6053      	str	r3, [r2, #4]
          e_eeprom_xmc4_sector_info.current_sector = sector;
 8024396:	4a0a      	ldr	r2, [pc, #40]	; (80243c0 <E_EEPROM_XMC4_lInitReadSectorInfo+0xa4>)
 8024398:	687b      	ldr	r3, [r7, #4]
 802439a:	6093      	str	r3, [r2, #8]
          e_eeprom_xmc4_sector_info.flash_data_addr = block_read_addr;
 802439c:	4a08      	ldr	r2, [pc, #32]	; (80243c0 <E_EEPROM_XMC4_lInitReadSectorInfo+0xa4>)
 802439e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80243a0:	6053      	str	r3, [r2, #4]
          e_eeprom_xmc4_sector_info.next_free_start_addr = free_block_addr;
 80243a2:	4a07      	ldr	r2, [pc, #28]	; (80243c0 <E_EEPROM_XMC4_lInitReadSectorInfo+0xa4>)
 80243a4:	6a3b      	ldr	r3, [r7, #32]
 80243a6:	6013      	str	r3, [r2, #0]
          break;
 80243a8:	e007      	b.n	80243ba <E_EEPROM_XMC4_lInitReadSectorInfo+0x9e>
        }
      }
    }
    /* Move the block read address to one block size up starting from the bottom of sector */
    block_read_addr -= E_EEPROM_XMC4_ACTUAL_FLASH_BLOCK_SIZE;
 80243aa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80243ac:	f5a3 5380 	sub.w	r3, r3, #4096	; 0x1000
 80243b0:	627b      	str	r3, [r7, #36]	; 0x24

  /* Iterate the read process until the block read address crosses sector start address or a
   * latest valid block is identified.
   */
  } while ( block_read_addr >= sector_start_addr );
 80243b2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80243b4:	69fb      	ldr	r3, [r7, #28]
 80243b6:	429a      	cmp	r2, r3
 80243b8:	d2c0      	bcs.n	802433c <E_EEPROM_XMC4_lInitReadSectorInfo+0x20>

}
 80243ba:	3728      	adds	r7, #40	; 0x28
 80243bc:	46bd      	mov	sp, r7
 80243be:	bd80      	pop	{r7, pc}
 80243c0:	1fff17d0 	.word	0x1fff17d0
 80243c4:	1fff1814 	.word	0x1fff1814

080243c8 <E_EEPROM_XMC4_lInitEraseStateMachine>:



static E_EEPROM_XMC4_STATUS_t E_EEPROM_XMC4_lInitEraseStateMachine(void)
{
 80243c8:	b580      	push	{r7, lr}
 80243ca:	b084      	sub	sp, #16
 80243cc:	af00      	add	r7, sp, #0
  uint32_t sector_count;
  uint32_t sector_start_addr;
  E_EEPROM_XMC4_STATUS_t status ;

  status = E_EEPROM_XMC4_STATUS_OK;
 80243ce:	2300      	movs	r3, #0
 80243d0:	72fb      	strb	r3, [r7, #11]
  sector_count = 0U;
 80243d2:	2300      	movs	r3, #0
 80243d4:	60fb      	str	r3, [r7, #12]

  do
  {
    /* If the non empty sector is the current active sector, then do not erase it*/
    if (e_eeprom_xmc4_sector_info.current_sector != sector_count)
 80243d6:	4b1b      	ldr	r3, [pc, #108]	; (8024444 <E_EEPROM_XMC4_lInitEraseStateMachine+0x7c>)
 80243d8:	689a      	ldr	r2, [r3, #8]
 80243da:	68fb      	ldr	r3, [r7, #12]
 80243dc:	429a      	cmp	r2, r3
 80243de:	d026      	beq.n	802442e <E_EEPROM_XMC4_lInitEraseStateMachine+0x66>
    {
      /* Check if the sector was previously identified as non-empty. i.e It is having old data or corrupted data
       * If so erase the sector and mark it as erase attempted.
       */
      if ((e_eeprom_xmc4_sector_info.erase_state >> sector_count) & ((uint32_t)1U))
 80243e0:	4b18      	ldr	r3, [pc, #96]	; (8024444 <E_EEPROM_XMC4_lInitEraseStateMachine+0x7c>)
 80243e2:	68da      	ldr	r2, [r3, #12]
 80243e4:	68fb      	ldr	r3, [r7, #12]
 80243e6:	fa22 f303 	lsr.w	r3, r2, r3
 80243ea:	f003 0301 	and.w	r3, r3, #1
 80243ee:	2b00      	cmp	r3, #0
 80243f0:	d01d      	beq.n	802442e <E_EEPROM_XMC4_lInitEraseStateMachine+0x66>
      {
        sector_start_addr = E_EEPROM_XMC4_SECTOR0_START_ADDR + (E_EEPROM_XMC4_SECTOR_SIZE * (uint32_t)sector_count);
 80243f2:	68fb      	ldr	r3, [r7, #12]
 80243f4:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 80243f8:	3304      	adds	r3, #4
 80243fa:	039b      	lsls	r3, r3, #14
 80243fc:	607b      	str	r3, [r7, #4]

        XMC_FLASH_ClearStatus();
 80243fe:	f7fd f8a5 	bl	802154c <XMC_FLASH_ClearStatus>
        XMC_FLASH_EraseSector((uint32_t*)sector_start_addr);
 8024402:	687b      	ldr	r3, [r7, #4]
 8024404:	4618      	mov	r0, r3
 8024406:	f7fd f8e9 	bl	80215dc <XMC_FLASH_EraseSector>

        if (XMC_FLASH_GetStatus() != (uint32_t)XMC_FLASH_STATUS_ERASE_STATE)
 802440a:	f7fd f8a5 	bl	8021558 <XMC_FLASH_GetStatus>
 802440e:	4603      	mov	r3, r0
 8024410:	2b20      	cmp	r3, #32
 8024412:	d002      	beq.n	802441a <E_EEPROM_XMC4_lInitEraseStateMachine+0x52>
        {
          status = E_EEPROM_XMC4_STATUS_ERASE_ERROR;
 8024414:	2304      	movs	r3, #4
 8024416:	72fb      	strb	r3, [r7, #11]
          break;
 8024418:	e00f      	b.n	802443a <E_EEPROM_XMC4_lInitEraseStateMachine+0x72>
        }
        e_eeprom_xmc4_sector_info.erase_state &= ~(((uint32_t)1U << sector_count));
 802441a:	4b0a      	ldr	r3, [pc, #40]	; (8024444 <E_EEPROM_XMC4_lInitEraseStateMachine+0x7c>)
 802441c:	68da      	ldr	r2, [r3, #12]
 802441e:	68fb      	ldr	r3, [r7, #12]
 8024420:	2101      	movs	r1, #1
 8024422:	fa01 f303 	lsl.w	r3, r1, r3
 8024426:	43db      	mvns	r3, r3
 8024428:	4013      	ands	r3, r2
 802442a:	4a06      	ldr	r2, [pc, #24]	; (8024444 <E_EEPROM_XMC4_lInitEraseStateMachine+0x7c>)
 802442c:	60d3      	str	r3, [r2, #12]
      }
    }
    sector_count++;
 802442e:	68fb      	ldr	r3, [r7, #12]
 8024430:	3301      	adds	r3, #1
 8024432:	60fb      	str	r3, [r7, #12]
    /* Iterate the erase loop until all 4 sectors are checked. Break and return failure on any sector erase errors.*/
  } while ( sector_count < E_EEPROM_XMC4_MAX_SECTORS );
 8024434:	68fb      	ldr	r3, [r7, #12]
 8024436:	2b03      	cmp	r3, #3
 8024438:	d9cd      	bls.n	80243d6 <E_EEPROM_XMC4_lInitEraseStateMachine+0xe>

  return (status);
 802443a:	7afb      	ldrb	r3, [r7, #11]
}
 802443c:	4618      	mov	r0, r3
 802443e:	3710      	adds	r7, #16
 8024440:	46bd      	mov	sp, r7
 8024442:	bd80      	pop	{r7, pc}
 8024444:	1fff17d0 	.word	0x1fff17d0

08024448 <E_EEPROM_XMC4_lCalculateCRC>:

/* Local function to CRC */
static uint32_t E_EEPROM_XMC4_lCalculateCRC(const uint32_t *data_start_addr)
{
 8024448:	b580      	push	{r7, lr}
 802444a:	b084      	sub	sp, #16
 802444c:	af00      	add	r7, sp, #0
 802444e:	6078      	str	r0, [r7, #4]
  uint32_t result;

  /* Reset the CRC result register before new CRC calculation */
  XMC_FCE_InitializeSeedValue(&e_eeprom_xmc4_fce, 0U);
 8024450:	4808      	ldr	r0, [pc, #32]	; (8024474 <E_EEPROM_XMC4_lCalculateCRC+0x2c>)
 8024452:	2100      	movs	r1, #0
 8024454:	f7ff fdee 	bl	8024034 <XMC_FCE_InitializeSeedValue>

  (void)XMC_FCE_CalculateCRC32(&e_eeprom_xmc4_fce, data_start_addr, E_EEPROM_XMC4_DATA_SIZE_FOR_CRC, &result);
 8024458:	f107 030c 	add.w	r3, r7, #12
 802445c:	4805      	ldr	r0, [pc, #20]	; (8024474 <E_EEPROM_XMC4_lCalculateCRC+0x2c>)
 802445e:	6879      	ldr	r1, [r7, #4]
 8024460:	f640 72fc 	movw	r2, #4092	; 0xffc
 8024464:	f7fe fc5e 	bl	8022d24 <XMC_FCE_CalculateCRC32>

  return (result);
 8024468:	68fb      	ldr	r3, [r7, #12]
}
 802446a:	4618      	mov	r0, r3
 802446c:	3710      	adds	r7, #16
 802446e:	46bd      	mov	sp, r7
 8024470:	bd80      	pop	{r7, pc}
 8024472:	bf00      	nop
 8024474:	08025c08 	.word	0x08025c08

08024478 <E_EEPROM_XMC4_lCopyFlashToRam>:



/* Local function to copy data blocks from FLASH to RAM */
static void E_EEPROM_XMC4_lCopyFlashToRam(void)
{
 8024478:	b480      	push	{r7}
 802447a:	b085      	sub	sp, #20
 802447c:	af00      	add	r7, sp, #0
  uint32_t *flash_addr_ptr;
  uint32_t *ram_addr_ptr;
  uint32_t byte_index;

  flash_addr_ptr = (uint32_t*)e_eeprom_xmc4_sector_info.flash_data_addr;
 802447e:	4b0f      	ldr	r3, [pc, #60]	; (80244bc <E_EEPROM_XMC4_lCopyFlashToRam+0x44>)
 8024480:	685b      	ldr	r3, [r3, #4]
 8024482:	60bb      	str	r3, [r7, #8]
  ram_addr_ptr = (uint32_t*)(void*)&e_eeprom_xmc4_data_buffer;
 8024484:	4b0e      	ldr	r3, [pc, #56]	; (80244c0 <E_EEPROM_XMC4_lCopyFlashToRam+0x48>)
 8024486:	607b      	str	r3, [r7, #4]

  for(byte_index = 0U ; byte_index < E_EEPROM_XMC4_MAX_WORDS; byte_index++)
 8024488:	2300      	movs	r3, #0
 802448a:	60fb      	str	r3, [r7, #12]
 802448c:	e00c      	b.n	80244a8 <E_EEPROM_XMC4_lCopyFlashToRam+0x30>
  {
    *(ram_addr_ptr + byte_index) = *(flash_addr_ptr + byte_index);
 802448e:	68fb      	ldr	r3, [r7, #12]
 8024490:	009b      	lsls	r3, r3, #2
 8024492:	687a      	ldr	r2, [r7, #4]
 8024494:	4413      	add	r3, r2
 8024496:	68fa      	ldr	r2, [r7, #12]
 8024498:	0092      	lsls	r2, r2, #2
 802449a:	68b9      	ldr	r1, [r7, #8]
 802449c:	440a      	add	r2, r1
 802449e:	6812      	ldr	r2, [r2, #0]
 80244a0:	601a      	str	r2, [r3, #0]
  uint32_t byte_index;

  flash_addr_ptr = (uint32_t*)e_eeprom_xmc4_sector_info.flash_data_addr;
  ram_addr_ptr = (uint32_t*)(void*)&e_eeprom_xmc4_data_buffer;

  for(byte_index = 0U ; byte_index < E_EEPROM_XMC4_MAX_WORDS; byte_index++)
 80244a2:	68fb      	ldr	r3, [r7, #12]
 80244a4:	3301      	adds	r3, #1
 80244a6:	60fb      	str	r3, [r7, #12]
 80244a8:	68fb      	ldr	r3, [r7, #12]
 80244aa:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80244ae:	d3ee      	bcc.n	802448e <E_EEPROM_XMC4_lCopyFlashToRam+0x16>
  {
    *(ram_addr_ptr + byte_index) = *(flash_addr_ptr + byte_index);
  }
}
 80244b0:	3714      	adds	r7, #20
 80244b2:	46bd      	mov	sp, r7
 80244b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80244b8:	4770      	bx	lr
 80244ba:	bf00      	nop
 80244bc:	1fff17d0 	.word	0x1fff17d0
 80244c0:	1fff1814 	.word	0x1fff1814

080244c4 <ECAT_SSC_Init>:

/*
 * This function intialize's the EtherCAT slave controller.
 */
ECAT_SSC_STATUS_t ECAT_SSC_Init(ECAT_SSC_t *handle)
{
 80244c4:	b580      	push	{r7, lr}
 80244c6:	b084      	sub	sp, #16
 80244c8:	af00      	add	r7, sp, #0
 80244ca:	6078      	str	r0, [r7, #4]
  uint32_t status;

  status = (uint32_t)ECAT_SSC_STATUS_FAILURE;
 80244cc:	2301      	movs	r3, #1
 80244ce:	60fb      	str	r3, [r7, #12]

  /* Initialize the Flash Emulated EEPROM and copy the latest content to the internal working RAM buffer*/
  status = (uint32_t)E_EEPROM_XMC4_Init(handle->eeprom);
 80244d0:	687b      	ldr	r3, [r7, #4]
 80244d2:	681b      	ldr	r3, [r3, #0]
 80244d4:	4618      	mov	r0, r3
 80244d6:	f7ff fdbb 	bl	8024050 <E_EEPROM_XMC4_Init>
 80244da:	4603      	mov	r3, r0
 80244dc:	60fb      	str	r3, [r7, #12]

  if (status == (uint32_t)ECAT_SSC_STATUS_SUCCESS)
 80244de:	68fb      	ldr	r3, [r7, #12]
 80244e0:	2b00      	cmp	r3, #0
 80244e2:	d147      	bne.n	8024574 <ECAT_SSC_Init+0xb0>
  {
    /* Check if the slave configuration data is available in the Flash Emulated EEPROM*/
    if (E_EEPROM_XMC4_IsFlashEmpty())
 80244e4:	f7ff fec8 	bl	8024278 <E_EEPROM_XMC4_IsFlashEmpty>
 80244e8:	4603      	mov	r3, r0
 80244ea:	2b00      	cmp	r3, #0
 80244ec:	d00a      	beq.n	8024504 <ECAT_SSC_Init+0x40>
    {
      /* Prepare the default configuration out of the SSC for EEPROM */
      E_EEPROM_XMC4_WriteArray(0U, aEepromData, (uint16_t)ESC_EEPROM_SIZE);
 80244ee:	2000      	movs	r0, #0
 80244f0:	4923      	ldr	r1, [pc, #140]	; (8024580 <ECAT_SSC_Init+0xbc>)
 80244f2:	f44f 6200 	mov.w	r2, #2048	; 0x800
 80244f6:	f7ff fe15 	bl	8024124 <E_EEPROM_XMC4_WriteArray>

      /* Program the RAM contents to Emulated EEPROM*/
      status = (uint32_t)E_EEPROM_XMC4_UpdateFlashContents();
 80244fa:	f7ff fe6b 	bl	80241d4 <E_EEPROM_XMC4_UpdateFlashContents>
 80244fe:	4603      	mov	r3, r0
 8024500:	60fb      	str	r3, [r7, #12]
 8024502:	e005      	b.n	8024510 <ECAT_SSC_Init+0x4c>
    }
    else
    {
      /* Read the latest contents from RAM buffer which has the latest contents of EEPROM */
      E_EEPROM_XMC4_ReadArray(0U,aEepromData,(uint16_t)ESC_EEPROM_SIZE);
 8024504:	2000      	movs	r0, #0
 8024506:	491e      	ldr	r1, [pc, #120]	; (8024580 <ECAT_SSC_Init+0xbc>)
 8024508:	f44f 6200 	mov.w	r2, #2048	; 0x800
 802450c:	f7ff fe3c 	bl	8024188 <E_EEPROM_XMC4_ReadArray>
    }

    /* Initialize the 1 millisecond timer module*/
    if (status == (uint32_t)ECAT_SSC_STATUS_SUCCESS)
 8024510:	68fb      	ldr	r3, [r7, #12]
 8024512:	2b00      	cmp	r3, #0
 8024514:	d12e      	bne.n	8024574 <ECAT_SSC_Init+0xb0>
    {
      status = (uint32_t)TIMER_Init(handle->timer);
 8024516:	687b      	ldr	r3, [r7, #4]
 8024518:	685b      	ldr	r3, [r3, #4]
 802451a:	4618      	mov	r0, r3
 802451c:	f7fe fee2 	bl	80232e4 <TIMER_Init>
 8024520:	4603      	mov	r3, r0
 8024522:	60fb      	str	r3, [r7, #12]
      /* Initialize the timer interrupt handler*/
      if (status == (uint32_t)ECAT_SSC_STATUS_SUCCESS)
 8024524:	68fb      	ldr	r3, [r7, #12]
 8024526:	2b00      	cmp	r3, #0
 8024528:	d124      	bne.n	8024574 <ECAT_SSC_Init+0xb0>
      {
        status = (uint32_t)INTERRUPT_Init(handle->timer_irqhandler);
 802452a:	687b      	ldr	r3, [r7, #4]
 802452c:	689b      	ldr	r3, [r3, #8]
 802452e:	4618      	mov	r0, r3
 8024530:	f7ff fc26 	bl	8023d80 <INTERRUPT_Init>
 8024534:	4603      	mov	r3, r0
 8024536:	60fb      	str	r3, [r7, #12]
        /* Call Beckhoff HW abstraction layer API to initialize the XMC4800 ESC and supporting functions*/
        if (status == (uint32_t)ECAT_SSC_STATUS_SUCCESS)
 8024538:	68fb      	ldr	r3, [r7, #12]
 802453a:	2b00      	cmp	r3, #0
 802453c:	d11a      	bne.n	8024574 <ECAT_SSC_Init+0xb0>
        {
          status = HW_Init();
 802453e:	f000 f93b 	bl	80247b8 <HW_Init>
 8024542:	4603      	mov	r3, r0
 8024544:	60fb      	str	r3, [r7, #12]
          /* Call Beckhoff HW abstraction layer API to start the stack interface initialization*/
          if (status == (uint32_t)ECAT_SSC_STATUS_SUCCESS)
 8024546:	68fb      	ldr	r3, [r7, #12]
 8024548:	2b00      	cmp	r3, #0
 802454a:	d113      	bne.n	8024574 <ECAT_SSC_Init+0xb0>
          {
            status = MainInit();
 802454c:	f7fc fc08 	bl	8020d60 <MainInit>
 8024550:	4603      	mov	r3, r0
 8024552:	60fb      	str	r3, [r7, #12]
            if (status == (uint32_t)ECAT_SSC_STATUS_SUCCESS)
 8024554:	68fb      	ldr	r3, [r7, #12]
 8024556:	2b00      	cmp	r3, #0
 8024558:	d10c      	bne.n	8024574 <ECAT_SSC_Init+0xb0>
            {
           	  pAPPL_EEPROM_Reload = HW_EepromReload;
 802455a:	4b0a      	ldr	r3, [pc, #40]	; (8024584 <ECAT_SSC_Init+0xc0>)
 802455c:	4a0a      	ldr	r2, [pc, #40]	; (8024588 <ECAT_SSC_Init+0xc4>)
 802455e:	601a      	str	r2, [r3, #0]
              pAPPL_EEPROM_Write  = HW_EepromWrite;
 8024560:	4b0a      	ldr	r3, [pc, #40]	; (802458c <ECAT_SSC_Init+0xc8>)
 8024562:	4a0b      	ldr	r2, [pc, #44]	; (8024590 <ECAT_SSC_Init+0xcc>)
 8024564:	601a      	str	r2, [r3, #0]

              /*Start the 1 millisec timer*/
              status = (uint32_t)TIMER_Start(handle->timer);
 8024566:	687b      	ldr	r3, [r7, #4]
 8024568:	685b      	ldr	r3, [r3, #4]
 802456a:	4618      	mov	r0, r3
 802456c:	f7fe fed8 	bl	8023320 <TIMER_Start>
 8024570:	4603      	mov	r3, r0
 8024572:	60fb      	str	r3, [r7, #12]
          }
        }
      }
    }
  }
  return ((ECAT_SSC_STATUS_t)status);
 8024574:	68fb      	ldr	r3, [r7, #12]
 8024576:	b2db      	uxtb	r3, r3
}
 8024578:	4618      	mov	r0, r3
 802457a:	3710      	adds	r7, #16
 802457c:	46bd      	mov	sp, r7
 802457e:	bd80      	pop	{r7, pc}
 8024580:	1fff0bcc 	.word	0x1fff0bcc
 8024584:	1fff29a4 	.word	0x1fff29a4
 8024588:	08024aad 	.word	0x08024aad
 802458c:	1fff283c 	.word	0x1fff283c
 8024590:	08024a19 	.word	0x08024a19

08024594 <ENABLE_ESC_INT_USER>:

__WEAK void ENABLE_ESC_INT_USER(void)
{
 8024594:	b480      	push	{r7}
 8024596:	af00      	add	r7, sp, #0
}
 8024598:	46bd      	mov	sp, r7
 802459a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802459e:	4770      	bx	lr

080245a0 <DISABLE_ESC_INT_USER>:

__WEAK void DISABLE_ESC_INT_USER(void)
{
 80245a0:	b480      	push	{r7}
 80245a2:	af00      	add	r7, sp, #0
}
 80245a4:	46bd      	mov	sp, r7
 80245a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80245aa:	4770      	bx	lr

080245ac <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 80245ac:	b480      	push	{r7}
 80245ae:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80245b0:	4b04      	ldr	r3, [pc, #16]	; (80245c4 <__NVIC_GetPriorityGrouping+0x18>)
 80245b2:	68db      	ldr	r3, [r3, #12]
 80245b4:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 80245b8:	0a1b      	lsrs	r3, r3, #8
}
 80245ba:	4618      	mov	r0, r3
 80245bc:	46bd      	mov	sp, r7
 80245be:	f85d 7b04 	ldr.w	r7, [sp], #4
 80245c2:	4770      	bx	lr
 80245c4:	e000ed00 	.word	0xe000ed00

080245c8 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 80245c8:	b480      	push	{r7}
 80245ca:	b083      	sub	sp, #12
 80245cc:	af00      	add	r7, sp, #0
 80245ce:	4603      	mov	r3, r0
 80245d0:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 80245d2:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80245d6:	2b00      	cmp	r3, #0
 80245d8:	db0b      	blt.n	80245f2 <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80245da:	4908      	ldr	r1, [pc, #32]	; (80245fc <__NVIC_EnableIRQ+0x34>)
 80245dc:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80245e0:	095b      	lsrs	r3, r3, #5
 80245e2:	79fa      	ldrb	r2, [r7, #7]
 80245e4:	f002 021f 	and.w	r2, r2, #31
 80245e8:	2001      	movs	r0, #1
 80245ea:	fa00 f202 	lsl.w	r2, r0, r2
 80245ee:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
 80245f2:	370c      	adds	r7, #12
 80245f4:	46bd      	mov	sp, r7
 80245f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80245fa:	4770      	bx	lr
 80245fc:	e000e100 	.word	0xe000e100

08024600 <__NVIC_DisableIRQ>:
  \details Disables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
 8024600:	b480      	push	{r7}
 8024602:	b083      	sub	sp, #12
 8024604:	af00      	add	r7, sp, #0
 8024606:	4603      	mov	r3, r0
 8024608:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 802460a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 802460e:	2b00      	cmp	r3, #0
 8024610:	db10      	blt.n	8024634 <__NVIC_DisableIRQ+0x34>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8024612:	490b      	ldr	r1, [pc, #44]	; (8024640 <__NVIC_DisableIRQ+0x40>)
 8024614:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8024618:	095b      	lsrs	r3, r3, #5
 802461a:	79fa      	ldrb	r2, [r7, #7]
 802461c:	f002 021f 	and.w	r2, r2, #31
 8024620:	2001      	movs	r0, #1
 8024622:	fa00 f202 	lsl.w	r2, r0, r2
 8024626:	3320      	adds	r3, #32
 8024628:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 802462c:	f3bf 8f4f 	dsb	sy
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__STATIC_FORCEINLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 8024630:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
  }
}
 8024634:	370c      	adds	r7, #12
 8024636:	46bd      	mov	sp, r7
 8024638:	f85d 7b04 	ldr.w	r7, [sp], #4
 802463c:	4770      	bx	lr
 802463e:	bf00      	nop
 8024640:	e000e100 	.word	0xe000e100

08024644 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8024644:	b480      	push	{r7}
 8024646:	b083      	sub	sp, #12
 8024648:	af00      	add	r7, sp, #0
 802464a:	4603      	mov	r3, r0
 802464c:	6039      	str	r1, [r7, #0]
 802464e:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8024650:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8024654:	2b00      	cmp	r3, #0
 8024656:	db0a      	blt.n	802466e <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8024658:	490d      	ldr	r1, [pc, #52]	; (8024690 <__NVIC_SetPriority+0x4c>)
 802465a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 802465e:	683a      	ldr	r2, [r7, #0]
 8024660:	b2d2      	uxtb	r2, r2
 8024662:	0092      	lsls	r2, r2, #2
 8024664:	b2d2      	uxtb	r2, r2
 8024666:	440b      	add	r3, r1
 8024668:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
 802466c:	e00a      	b.n	8024684 <__NVIC_SetPriority+0x40>
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 802466e:	4909      	ldr	r1, [pc, #36]	; (8024694 <__NVIC_SetPriority+0x50>)
 8024670:	79fb      	ldrb	r3, [r7, #7]
 8024672:	f003 030f 	and.w	r3, r3, #15
 8024676:	3b04      	subs	r3, #4
 8024678:	683a      	ldr	r2, [r7, #0]
 802467a:	b2d2      	uxtb	r2, r2
 802467c:	0092      	lsls	r2, r2, #2
 802467e:	b2d2      	uxtb	r2, r2
 8024680:	440b      	add	r3, r1
 8024682:	761a      	strb	r2, [r3, #24]
  }
}
 8024684:	370c      	adds	r7, #12
 8024686:	46bd      	mov	sp, r7
 8024688:	f85d 7b04 	ldr.w	r7, [sp], #4
 802468c:	4770      	bx	lr
 802468e:	bf00      	nop
 8024690:	e000e100 	.word	0xe000e100
 8024694:	e000ed00 	.word	0xe000ed00

08024698 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8024698:	b480      	push	{r7}
 802469a:	b089      	sub	sp, #36	; 0x24
 802469c:	af00      	add	r7, sp, #0
 802469e:	60f8      	str	r0, [r7, #12]
 80246a0:	60b9      	str	r1, [r7, #8]
 80246a2:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 80246a4:	68fb      	ldr	r3, [r7, #12]
 80246a6:	f003 0307 	and.w	r3, r3, #7
 80246aa:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80246ac:	69fb      	ldr	r3, [r7, #28]
 80246ae:	f1c3 0307 	rsb	r3, r3, #7
 80246b2:	2b06      	cmp	r3, #6
 80246b4:	bf28      	it	cs
 80246b6:	2306      	movcs	r3, #6
 80246b8:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80246ba:	69fb      	ldr	r3, [r7, #28]
 80246bc:	3306      	adds	r3, #6
 80246be:	2b06      	cmp	r3, #6
 80246c0:	d902      	bls.n	80246c8 <NVIC_EncodePriority+0x30>
 80246c2:	69fb      	ldr	r3, [r7, #28]
 80246c4:	3b01      	subs	r3, #1
 80246c6:	e000      	b.n	80246ca <NVIC_EncodePriority+0x32>
 80246c8:	2300      	movs	r3, #0
 80246ca:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80246cc:	69bb      	ldr	r3, [r7, #24]
 80246ce:	2201      	movs	r2, #1
 80246d0:	fa02 f303 	lsl.w	r3, r2, r3
 80246d4:	1e5a      	subs	r2, r3, #1
 80246d6:	68bb      	ldr	r3, [r7, #8]
 80246d8:	401a      	ands	r2, r3
 80246da:	697b      	ldr	r3, [r7, #20]
 80246dc:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 80246de:	697b      	ldr	r3, [r7, #20]
 80246e0:	2101      	movs	r1, #1
 80246e2:	fa01 f303 	lsl.w	r3, r1, r3
 80246e6:	1e59      	subs	r1, r3, #1
 80246e8:	687b      	ldr	r3, [r7, #4]
 80246ea:	400b      	ands	r3, r1
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 80246ec:	4313      	orrs	r3, r2
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
         );
}
 80246ee:	4618      	mov	r0, r3
 80246f0:	3724      	adds	r7, #36	; 0x24
 80246f2:	46bd      	mov	sp, r7
 80246f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80246f8:	4770      	bx	lr
 80246fa:	bf00      	nop

080246fc <XMC_ECAT_SetPortControl>:
 * \par
 * The function sets the port control by writing the configuration into the ECAT CON register.
 *
 */
__STATIC_INLINE void XMC_ECAT_SetPortControl(const XMC_ECAT_PORT_CTRL_t port_ctrl)
{
 80246fc:	b480      	push	{r7}
 80246fe:	b085      	sub	sp, #20
 8024700:	af00      	add	r7, sp, #0
 8024702:	1d3b      	adds	r3, r7, #4
 8024704:	e883 0007 	stmia.w	r3, {r0, r1, r2}
  ECAT0_CON->CON = (uint32_t)port_ctrl.common.raw;
 8024708:	4a06      	ldr	r2, [pc, #24]	; (8024724 <XMC_ECAT_SetPortControl+0x28>)
 802470a:	687b      	ldr	r3, [r7, #4]
 802470c:	6013      	str	r3, [r2, #0]
  ECAT0_CON->CONP0 = (uint32_t)port_ctrl.port0.raw;
 802470e:	4a05      	ldr	r2, [pc, #20]	; (8024724 <XMC_ECAT_SetPortControl+0x28>)
 8024710:	68bb      	ldr	r3, [r7, #8]
 8024712:	6053      	str	r3, [r2, #4]
  ECAT0_CON->CONP1 = (uint32_t)port_ctrl.port1.raw;
 8024714:	4a03      	ldr	r2, [pc, #12]	; (8024724 <XMC_ECAT_SetPortControl+0x28>)
 8024716:	68fb      	ldr	r3, [r7, #12]
 8024718:	6093      	str	r3, [r2, #8]
}
 802471a:	3714      	adds	r7, #20
 802471c:	46bd      	mov	sp, r7
 802471e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024722:	4770      	bx	lr
 8024724:	500041b0 	.word	0x500041b0

08024728 <HW_EscRead>:
 * \par<b>Description:</b><br>
 * Reads from the EtherCAT Slave Controller. This function is used to access ESC registers and the DPRAM area.
 *
 */
__STATIC_INLINE void HW_EscRead(MEM_ADDR *pData, UINT16 Address, UINT16 Len)
{
 8024728:	b580      	push	{r7, lr}
 802472a:	b082      	sub	sp, #8
 802472c:	af00      	add	r7, sp, #0
 802472e:	6078      	str	r0, [r7, #4]
 8024730:	460b      	mov	r3, r1
 8024732:	807b      	strh	r3, [r7, #2]
 8024734:	4613      	mov	r3, r2
 8024736:	803b      	strh	r3, [r7, #0]
  memcpy(pData, &pEsc[Address], Len);
 8024738:	887b      	ldrh	r3, [r7, #2]
 802473a:	f103 43a8 	add.w	r3, r3, #1409286144	; 0x54000000
 802473e:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 8024742:	883a      	ldrh	r2, [r7, #0]
 8024744:	6878      	ldr	r0, [r7, #4]
 8024746:	4619      	mov	r1, r3
 8024748:	f000 fcf8 	bl	802513c <memcpy>
}
 802474c:	3708      	adds	r7, #8
 802474e:	46bd      	mov	sp, r7
 8024750:	bd80      	pop	{r7, pc}
 8024752:	bf00      	nop

08024754 <HW_EscWrite>:
 * \par<b>Description:</b><br>
 * Writes from the EtherCAT Slave Controller. This function is used to access ESC registers and the DPRAM area.
 *
 */
__STATIC_INLINE void HW_EscWrite(MEM_ADDR *pData, UINT16 Address, UINT16 Len)
{
 8024754:	b580      	push	{r7, lr}
 8024756:	b082      	sub	sp, #8
 8024758:	af00      	add	r7, sp, #0
 802475a:	6078      	str	r0, [r7, #4]
 802475c:	460b      	mov	r3, r1
 802475e:	807b      	strh	r3, [r7, #2]
 8024760:	4613      	mov	r3, r2
 8024762:	803b      	strh	r3, [r7, #0]
  memcpy(&pEsc[Address], pData, Len);
 8024764:	887b      	ldrh	r3, [r7, #2]
 8024766:	f103 43a8 	add.w	r3, r3, #1409286144	; 0x54000000
 802476a:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 802476e:	883a      	ldrh	r2, [r7, #0]
 8024770:	4618      	mov	r0, r3
 8024772:	6879      	ldr	r1, [r7, #4]
 8024774:	f000 fce2 	bl	802513c <memcpy>
}
 8024778:	3708      	adds	r7, #8
 802477a:	46bd      	mov	sp, r7
 802477c:	bd80      	pop	{r7, pc}
 802477e:	bf00      	nop

08024780 <INTERRUPT_Enable>:
 *    return 0;
 *  }
 * @endcode<BR> </p>
 */
__STATIC_INLINE void INTERRUPT_Enable(const INTERRUPT_t *const handler)
{
 8024780:	b580      	push	{r7, lr}
 8024782:	b082      	sub	sp, #8
 8024784:	af00      	add	r7, sp, #0
 8024786:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("Handler NULL", (handler != NULL));
  NVIC_EnableIRQ(handler->node);
 8024788:	687b      	ldr	r3, [r7, #4]
 802478a:	781b      	ldrb	r3, [r3, #0]
 802478c:	b25b      	sxtb	r3, r3
 802478e:	4618      	mov	r0, r3
 8024790:	f7ff ff1a 	bl	80245c8 <__NVIC_EnableIRQ>
}
 8024794:	3708      	adds	r7, #8
 8024796:	46bd      	mov	sp, r7
 8024798:	bd80      	pop	{r7, pc}
 802479a:	bf00      	nop

0802479c <INTERRUPT_Disable>:
 *    return 0;
 *  }
 * @endcode<BR> </p>
 */
__STATIC_INLINE void INTERRUPT_Disable(const INTERRUPT_t *const handler)
{
 802479c:	b580      	push	{r7, lr}
 802479e:	b082      	sub	sp, #8
 80247a0:	af00      	add	r7, sp, #0
 80247a2:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("Handler NULL", (handler != NULL));
  NVIC_DisableIRQ(handler->node);
 80247a4:	687b      	ldr	r3, [r7, #4]
 80247a6:	781b      	ldrb	r3, [r3, #0]
 80247a8:	b25b      	sxtb	r3, r3
 80247aa:	4618      	mov	r0, r3
 80247ac:	f7ff ff28 	bl	8024600 <__NVIC_DisableIRQ>
}
 80247b0:	3708      	adds	r7, #8
 80247b2:	46bd      	mov	sp, r7
 80247b4:	bd80      	pop	{r7, pc}
 80247b6:	bf00      	nop

080247b8 <HW_Init>:
  __set_PRIMASK(status);
}

/* EtherCAT Beckhoff HW abstraction layer interface API to initialize XMC ESC */
UINT16 HW_Init(void)
{
 80247b8:	b580      	push	{r7, lr}
 80247ba:	b088      	sub	sp, #32
 80247bc:	af00      	add	r7, sp, #0
  uint8_t i;
  XMC_ECAT_PORT_CTRL_t port_control;
  port_control.common.raw = 0;
 80247be:	2300      	movs	r3, #0
 80247c0:	613b      	str	r3, [r7, #16]
  port_control.port0.raw = 0;
 80247c2:	2300      	movs	r3, #0
 80247c4:	617b      	str	r3, [r7, #20]
  port_control.port1.raw = 0;
 80247c6:	2300      	movs	r3, #0
 80247c8:	61bb      	str	r3, [r7, #24]

  XMC_GPIO_CONFIG_t gpio_config;

  /* EEPROM interface API registration */
  pEEPROM = &aEepromData[0U];
 80247ca:	4b8c      	ldr	r3, [pc, #560]	; (80249fc <HW_Init+0x244>)
 80247cc:	4a8c      	ldr	r2, [pc, #560]	; (8024a00 <HW_Init+0x248>)
 80247ce:	601a      	str	r2, [r3, #0]

  /* EtherCAT slave physical layer pin settings */
  gpio_config.mode = XMC_GPIO_MODE_INPUT_TRISTATE;
 80247d0:	2300      	movs	r3, #0
 80247d2:	713b      	strb	r3, [r7, #4]
  XMC_GPIO_Init(ECAT_P0_LINK_STATUS, &gpio_config);
 80247d4:	1d3b      	adds	r3, r7, #4
 80247d6:	488b      	ldr	r0, [pc, #556]	; (8024a04 <HW_Init+0x24c>)
 80247d8:	2101      	movs	r1, #1
 80247da:	461a      	mov	r2, r3
 80247dc:	f7fc ff16 	bl	802160c <XMC_GPIO_Init>
  XMC_GPIO_Init(ECAT_P0_RXD3, &gpio_config);
 80247e0:	1d3b      	adds	r3, r7, #4
 80247e2:	4889      	ldr	r0, [pc, #548]	; (8024a08 <HW_Init+0x250>)
 80247e4:	2107      	movs	r1, #7
 80247e6:	461a      	mov	r2, r3
 80247e8:	f7fc ff10 	bl	802160c <XMC_GPIO_Init>
  XMC_GPIO_Init(ECAT_P0_RXD2, &gpio_config);
 80247ec:	1d3b      	adds	r3, r7, #4
 80247ee:	4886      	ldr	r0, [pc, #536]	; (8024a08 <HW_Init+0x250>)
 80247f0:	2102      	movs	r1, #2
 80247f2:	461a      	mov	r2, r3
 80247f4:	f7fc ff0a 	bl	802160c <XMC_GPIO_Init>
  XMC_GPIO_Init(ECAT_P0_RXD1, &gpio_config);
 80247f8:	1d3b      	adds	r3, r7, #4
 80247fa:	4883      	ldr	r0, [pc, #524]	; (8024a08 <HW_Init+0x250>)
 80247fc:	2101      	movs	r1, #1
 80247fe:	461a      	mov	r2, r3
 8024800:	f7fc ff04 	bl	802160c <XMC_GPIO_Init>
  XMC_GPIO_Init(ECAT_P0_RXD0, &gpio_config);
 8024804:	1d3b      	adds	r3, r7, #4
 8024806:	4880      	ldr	r0, [pc, #512]	; (8024a08 <HW_Init+0x250>)
 8024808:	2100      	movs	r1, #0
 802480a:	461a      	mov	r2, r3
 802480c:	f7fc fefe 	bl	802160c <XMC_GPIO_Init>
  XMC_GPIO_Init(ECAT_P0_RX_DV, &gpio_config);
 8024810:	1d3b      	adds	r3, r7, #4
 8024812:	487e      	ldr	r0, [pc, #504]	; (8024a0c <HW_Init+0x254>)
 8024814:	2109      	movs	r1, #9
 8024816:	461a      	mov	r2, r3
 8024818:	f7fc fef8 	bl	802160c <XMC_GPIO_Init>
  XMC_GPIO_Init(ECAT_P0_RX_CLK, &gpio_config);
 802481c:	1d3b      	adds	r3, r7, #4
 802481e:	487b      	ldr	r0, [pc, #492]	; (8024a0c <HW_Init+0x254>)
 8024820:	2101      	movs	r1, #1
 8024822:	461a      	mov	r2, r3
 8024824:	f7fc fef2 	bl	802160c <XMC_GPIO_Init>
  XMC_GPIO_Init(ECAT_P0_RX_ERR, &gpio_config);
 8024828:	1d3b      	adds	r3, r7, #4
 802482a:	4879      	ldr	r0, [pc, #484]	; (8024a10 <HW_Init+0x258>)
 802482c:	2106      	movs	r1, #6
 802482e:	461a      	mov	r2, r3
 8024830:	f7fc feec 	bl	802160c <XMC_GPIO_Init>
  XMC_GPIO_Init(ECAT_P0_TX_CLK, &gpio_config);
 8024834:	1d3b      	adds	r3, r7, #4
 8024836:	4875      	ldr	r0, [pc, #468]	; (8024a0c <HW_Init+0x254>)
 8024838:	2100      	movs	r1, #0
 802483a:	461a      	mov	r2, r3
 802483c:	f7fc fee6 	bl	802160c <XMC_GPIO_Init>

  /* If an ESC MII interface is not used, LINK_MII has to be tied to the logic value high which indicates no link */
  gpio_config.mode = XMC_GPIO_MODE_INPUT_PULL_UP;
 8024840:	2310      	movs	r3, #16
 8024842:	713b      	strb	r3, [r7, #4]
  XMC_GPIO_Init(ECAT_P1_LINK_STATUS, &gpio_config);
 8024844:	1d3b      	adds	r3, r7, #4
 8024846:	4873      	ldr	r0, [pc, #460]	; (8024a14 <HW_Init+0x25c>)
 8024848:	2103      	movs	r1, #3
 802484a:	461a      	mov	r2, r3
 802484c:	f7fc fede 	bl	802160c <XMC_GPIO_Init>
  port_control.common.enable_rstreq = false;
 8024850:	7c3b      	ldrb	r3, [r7, #16]
 8024852:	f36f 0300 	bfc	r3, #0, #1
 8024856:	743b      	strb	r3, [r7, #16]
  port_control.common.mdio = XMC_ECAT_PORT_CTRL_MDIO_P0_12;
 8024858:	7cbb      	ldrb	r3, [r7, #18]
 802485a:	f36f 1387 	bfc	r3, #6, #2
 802485e:	74bb      	strb	r3, [r7, #18]
  port_control.common.phyaddr_offset = 0;
 8024860:	7cbb      	ldrb	r3, [r7, #18]
 8024862:	f36f 0304 	bfc	r3, #0, #5
 8024866:	74bb      	strb	r3, [r7, #18]
  port_control.common.latch_input0 = XMC_ECAT_PORT_CTRL_LATCHIN0_P14_5;
 8024868:	7c7b      	ldrb	r3, [r7, #17]
 802486a:	f36f 0301 	bfc	r3, #0, #2
 802486e:	747b      	strb	r3, [r7, #17]
  port_control.common.latch_input1 = XMC_ECAT_PORT_CTRL_LATCHIN1_P14_4;
 8024870:	7c7b      	ldrb	r3, [r7, #17]
 8024872:	f36f 1305 	bfc	r3, #4, #2
 8024876:	747b      	strb	r3, [r7, #17]
  port_control.port0.rxd0 = XMC_ECAT_PORT0_CTRL_RXD0_P5_0;
 8024878:	7d3b      	ldrb	r3, [r7, #20]
 802487a:	2201      	movs	r2, #1
 802487c:	f362 0301 	bfi	r3, r2, #0, #2
 8024880:	753b      	strb	r3, [r7, #20]
  port_control.port0.rxd1 = XMC_ECAT_PORT0_CTRL_RXD1_P5_1;
 8024882:	7d3b      	ldrb	r3, [r7, #20]
 8024884:	2201      	movs	r2, #1
 8024886:	f362 0383 	bfi	r3, r2, #2, #2
 802488a:	753b      	strb	r3, [r7, #20]
  port_control.port0.rxd2 = XMC_ECAT_PORT0_CTRL_RXD2_P5_2;
 802488c:	7d3b      	ldrb	r3, [r7, #20]
 802488e:	2201      	movs	r2, #1
 8024890:	f362 1305 	bfi	r3, r2, #4, #2
 8024894:	753b      	strb	r3, [r7, #20]
  port_control.port0.rxd3 = XMC_ECAT_PORT0_CTRL_RXD3_P5_7;
 8024896:	7d3b      	ldrb	r3, [r7, #20]
 8024898:	2201      	movs	r2, #1
 802489a:	f362 1387 	bfi	r3, r2, #6, #2
 802489e:	753b      	strb	r3, [r7, #20]
  port_control.port0.rx_clk = XMC_ECAT_PORT0_CTRL_RX_CLK_P1_1;
 80248a0:	7d7b      	ldrb	r3, [r7, #21]
 80248a2:	f36f 1305 	bfc	r3, #4, #2
 80248a6:	757b      	strb	r3, [r7, #21]
  port_control.port0.rx_dv = XMC_ECAT_PORT0_CTRL_RX_DV_P1_9;
 80248a8:	7d7b      	ldrb	r3, [r7, #21]
 80248aa:	f36f 0383 	bfc	r3, #2, #2
 80248ae:	757b      	strb	r3, [r7, #21]
  port_control.port0.rx_err = XMC_ECAT_PORT0_CTRL_RX_ERR_P2_6;
 80248b0:	7d7b      	ldrb	r3, [r7, #21]
 80248b2:	2201      	movs	r2, #1
 80248b4:	f362 0301 	bfi	r3, r2, #0, #2
 80248b8:	757b      	strb	r3, [r7, #21]
  port_control.port0.link = XMC_ECAT_PORT0_CTRL_LINK_P4_1;
 80248ba:	7dbb      	ldrb	r3, [r7, #22]
 80248bc:	f36f 0301 	bfc	r3, #0, #2
 80248c0:	75bb      	strb	r3, [r7, #22]
  port_control.port0.tx_clk = XMC_ECAT_PORT0_CTRL_TX_CLK_P1_0;
 80248c2:	7dfb      	ldrb	r3, [r7, #23]
 80248c4:	f36f 1305 	bfc	r3, #4, #2
 80248c8:	75fb      	strb	r3, [r7, #23]
  port_control.port0.tx_shift = XMC_ECAT_PORT0_CTRL_TX_SHIFT_0NS; 
 80248ca:	7dfb      	ldrb	r3, [r7, #23]
 80248cc:	f36f 1387 	bfc	r3, #6, #2
 80248d0:	75fb      	strb	r3, [r7, #23]
  /* If an ESC MII interface is not used, RX_CLK, RXD, RX_ER, and especially RX_DV have to be tied to GND.                   For this purpose you can select a input position in register ECAT0_CONPx of these signals which are not connected to a pin on the XMC4800 */
  port_control.port1.rxd0 = 3;
 80248d2:	7e3b      	ldrb	r3, [r7, #24]
 80248d4:	f043 0303 	orr.w	r3, r3, #3
 80248d8:	763b      	strb	r3, [r7, #24]
  port_control.port1.rxd1 = 3;
 80248da:	7e3b      	ldrb	r3, [r7, #24]
 80248dc:	f043 030c 	orr.w	r3, r3, #12
 80248e0:	763b      	strb	r3, [r7, #24]
  port_control.port1.rxd2 = 3;
 80248e2:	7e3b      	ldrb	r3, [r7, #24]
 80248e4:	f043 0330 	orr.w	r3, r3, #48	; 0x30
 80248e8:	763b      	strb	r3, [r7, #24]
  port_control.port1.rxd3 = 3;
 80248ea:	7e3b      	ldrb	r3, [r7, #24]
 80248ec:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 80248f0:	763b      	strb	r3, [r7, #24]
  port_control.port1.rx_clk = 3;
 80248f2:	7e7b      	ldrb	r3, [r7, #25]
 80248f4:	f043 0330 	orr.w	r3, r3, #48	; 0x30
 80248f8:	767b      	strb	r3, [r7, #25]
  port_control.port1.rx_dv = 3;
 80248fa:	7e7b      	ldrb	r3, [r7, #25]
 80248fc:	f043 030c 	orr.w	r3, r3, #12
 8024900:	767b      	strb	r3, [r7, #25]
  port_control.port1.rx_err = 3;
 8024902:	7e7b      	ldrb	r3, [r7, #25]
 8024904:	f043 0303 	orr.w	r3, r3, #3
 8024908:	767b      	strb	r3, [r7, #25]
  port_control.port1.link = XMC_ECAT_PORT1_CTRL_LINK_P15_3;
 802490a:	7ebb      	ldrb	r3, [r7, #26]
 802490c:	2201      	movs	r2, #1
 802490e:	f362 0301 	bfi	r3, r2, #0, #2
 8024912:	76bb      	strb	r3, [r7, #26]
  port_control.port1.tx_clk = 3;
 8024914:	7efb      	ldrb	r3, [r7, #27]
 8024916:	f043 0330 	orr.w	r3, r3, #48	; 0x30
 802491a:	76fb      	strb	r3, [r7, #27]
  port_control.port1.tx_shift = XMC_ECAT_PORT1_CTRL_TX_SHIFT_0NS;
 802491c:	7efb      	ldrb	r3, [r7, #27]
 802491e:	f36f 1387 	bfc	r3, #6, #2
 8024922:	76fb      	strb	r3, [r7, #27]
  XMC_ECAT_SetPortControl(port_control);
 8024924:	f107 0310 	add.w	r3, r7, #16
 8024928:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 802492c:	f7ff fee6 	bl	80246fc <XMC_ECAT_SetPortControl>

  /* EtherCAT slave enable and intialization using LLD function */
  XMC_ECAT_Init((XMC_ECAT_CONFIG_t *)(void*)aEepromData);
 8024930:	4833      	ldr	r0, [pc, #204]	; (8024a00 <HW_Init+0x248>)
 8024932:	f7fe f961 	bl	8022bf8 <XMC_ECAT_Init>

  /* EtherCAT slave physical layer pin configurations */
  gpio_config.output_level = XMC_GPIO_OUTPUT_LEVEL_LOW;
 8024936:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 802493a:	60bb      	str	r3, [r7, #8]
  gpio_config.output_strength = XMC_GPIO_OUTPUT_STRENGTH_STRONG_SOFT_EDGE;
 802493c:	2302      	movs	r3, #2
 802493e:	733b      	strb	r3, [r7, #12]
  gpio_config.mode = XMC_GPIO_MODE_OUTPUT_PUSH_PULL_ALT1;
 8024940:	2388      	movs	r3, #136	; 0x88
 8024942:	713b      	strb	r3, [r7, #4]
  XMC_GPIO_Init(ECAT_P0_TXD3, &gpio_config);
 8024944:	1d3b      	adds	r3, r7, #4
 8024946:	4831      	ldr	r0, [pc, #196]	; (8024a0c <HW_Init+0x254>)
 8024948:	2102      	movs	r1, #2
 802494a:	461a      	mov	r2, r3
 802494c:	f7fc fe5e 	bl	802160c <XMC_GPIO_Init>
  gpio_config.mode = XMC_GPIO_MODE_OUTPUT_PUSH_PULL_ALT1;
 8024950:	2388      	movs	r3, #136	; 0x88
 8024952:	713b      	strb	r3, [r7, #4]
  XMC_GPIO_Init(ECAT_P0_TXD2, &gpio_config);
 8024954:	1d3b      	adds	r3, r7, #4
 8024956:	482d      	ldr	r0, [pc, #180]	; (8024a0c <HW_Init+0x254>)
 8024958:	2108      	movs	r1, #8
 802495a:	461a      	mov	r2, r3
 802495c:	f7fc fe56 	bl	802160c <XMC_GPIO_Init>
  gpio_config.mode = XMC_GPIO_MODE_OUTPUT_PUSH_PULL_ALT1;
 8024960:	2388      	movs	r3, #136	; 0x88
 8024962:	713b      	strb	r3, [r7, #4]
  XMC_GPIO_Init(ECAT_P0_TXD1, &gpio_config);
 8024964:	1d3b      	adds	r3, r7, #4
 8024966:	4829      	ldr	r0, [pc, #164]	; (8024a0c <HW_Init+0x254>)
 8024968:	2107      	movs	r1, #7
 802496a:	461a      	mov	r2, r3
 802496c:	f7fc fe4e 	bl	802160c <XMC_GPIO_Init>
  gpio_config.mode = XMC_GPIO_MODE_OUTPUT_PUSH_PULL_ALT1;
 8024970:	2388      	movs	r3, #136	; 0x88
 8024972:	713b      	strb	r3, [r7, #4]
  XMC_GPIO_Init(ECAT_P0_TXD0, &gpio_config);
 8024974:	1d3b      	adds	r3, r7, #4
 8024976:	4825      	ldr	r0, [pc, #148]	; (8024a0c <HW_Init+0x254>)
 8024978:	2106      	movs	r1, #6
 802497a:	461a      	mov	r2, r3
 802497c:	f7fc fe46 	bl	802160c <XMC_GPIO_Init>
  gpio_config.mode = XMC_GPIO_MODE_OUTPUT_PUSH_PULL_ALT1;
 8024980:	2388      	movs	r3, #136	; 0x88
 8024982:	713b      	strb	r3, [r7, #4]
  XMC_GPIO_Init(ECAT_P0_TX_EN, &gpio_config);
 8024984:	1d3b      	adds	r3, r7, #4
 8024986:	4821      	ldr	r0, [pc, #132]	; (8024a0c <HW_Init+0x254>)
 8024988:	2103      	movs	r1, #3
 802498a:	461a      	mov	r2, r3
 802498c:	f7fc fe3e 	bl	802160c <XMC_GPIO_Init>

  gpio_config.mode = XMC_GPIO_MODE_OUTPUT_PUSH_PULL_ALT4;
 8024990:	23a0      	movs	r3, #160	; 0xa0
 8024992:	713b      	strb	r3, [r7, #4]
  XMC_GPIO_Init(ECAT_CLK25, &gpio_config);
 8024994:	1d3b      	adds	r3, r7, #4
 8024996:	481d      	ldr	r0, [pc, #116]	; (8024a0c <HW_Init+0x254>)
 8024998:	210d      	movs	r1, #13
 802499a:	461a      	mov	r2, r3
 802499c:	f7fc fe36 	bl	802160c <XMC_GPIO_Init>

  gpio_config.mode = XMC_GPIO_MODE_OUTPUT_PUSH_PULL_ALT3;
 80249a0:	2398      	movs	r3, #152	; 0x98
 80249a2:	713b      	strb	r3, [r7, #4]
  XMC_GPIO_Init(ECAT_PHY_RESET, &gpio_config);
 80249a4:	1d3b      	adds	r3, r7, #4
 80249a6:	481a      	ldr	r0, [pc, #104]	; (8024a10 <HW_Init+0x258>)
 80249a8:	210a      	movs	r1, #10
 80249aa:	461a      	mov	r2, r3
 80249ac:	f7fc fe2e 	bl	802160c <XMC_GPIO_Init>

  /* Disable all supported sync manager channels */
  for (i = 0U; i < MAX_SYNC_MAN; i++)
 80249b0:	2300      	movs	r3, #0
 80249b2:	77fb      	strb	r3, [r7, #31]
 80249b4:	e006      	b.n	80249c4 <HW_Init+0x20c>
  {
    XMC_ECAT_DisableSyncManChannel(i);
 80249b6:	7ffb      	ldrb	r3, [r7, #31]
 80249b8:	4618      	mov	r0, r3
 80249ba:	f7fe f96d 	bl	8022c98 <XMC_ECAT_DisableSyncManChannel>

  gpio_config.mode = XMC_GPIO_MODE_OUTPUT_PUSH_PULL_ALT3;
  XMC_GPIO_Init(ECAT_PHY_RESET, &gpio_config);

  /* Disable all supported sync manager channels */
  for (i = 0U; i < MAX_SYNC_MAN; i++)
 80249be:	7ffb      	ldrb	r3, [r7, #31]
 80249c0:	3301      	adds	r3, #1
 80249c2:	77fb      	strb	r3, [r7, #31]
 80249c4:	7ffb      	ldrb	r3, [r7, #31]
 80249c6:	2b07      	cmp	r3, #7
 80249c8:	d9f5      	bls.n	80249b6 <HW_Init+0x1fe>
  {
    XMC_ECAT_DisableSyncManChannel(i);
  }

  /* EtherCAT slave event disable */
  XMC_ECAT_DisableEvent(0xffffffffU);
 80249ca:	f04f 30ff 	mov.w	r0, #4294967295
 80249ce:	f7fe f94f 	bl	8022c70 <XMC_ECAT_DisableEvent>

  /* ECAT interrupt priority settings */
  NVIC_SetPriority(ECAT0_0_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),
 80249d2:	f7ff fdeb 	bl	80245ac <__NVIC_GetPriorityGrouping>
 80249d6:	4603      	mov	r3, r0
 80249d8:	4618      	mov	r0, r3
 80249da:	213f      	movs	r1, #63	; 0x3f
 80249dc:	2200      	movs	r2, #0
 80249de:	f7ff fe5b 	bl	8024698 <NVIC_EncodePriority>
 80249e2:	4603      	mov	r3, r0
 80249e4:	206d      	movs	r0, #109	; 0x6d
 80249e6:	4619      	mov	r1, r3
 80249e8:	f7ff fe2c 	bl	8024644 <__NVIC_SetPriority>
                                                     63U,
                                                     0U));

  /* EtherCAT slave interrupt enable */
  ENABLE_ESC_INT();
 80249ec:	f000 f8b6 	bl	8024b5c <ENABLE_ESC_INT>

  return ((uint16_t)0U);
 80249f0:	2300      	movs	r3, #0
}
 80249f2:	4618      	mov	r0, r3
 80249f4:	3720      	adds	r7, #32
 80249f6:	46bd      	mov	sp, r7
 80249f8:	bd80      	pop	{r7, pc}
 80249fa:	bf00      	nop
 80249fc:	1fff299c 	.word	0x1fff299c
 8024a00:	1fff0bcc 	.word	0x1fff0bcc
 8024a04:	48028400 	.word	0x48028400
 8024a08:	48028500 	.word	0x48028500
 8024a0c:	48028100 	.word	0x48028100
 8024a10:	48028200 	.word	0x48028200
 8024a14:	48028f00 	.word	0x48028f00

08024a18 <HW_EepromWrite>:
}


/* Beckhoff Hw abstraction layer interface API to write new configuration parameters to slave EEPROM area */
UINT16 HW_EepromWrite(UINT32 wordaddr)
{
 8024a18:	b580      	push	{r7, lr}
 8024a1a:	b086      	sub	sp, #24
 8024a1c:	af00      	add	r7, sp, #0
 8024a1e:	6078      	str	r0, [r7, #4]
  UINT32 status;
  UINT16 EEPROMReg = 0U; /* Regvalue 0x502 - 0x5003 */
 8024a20:	2300      	movs	r3, #0
 8024a22:	827b      	strh	r3, [r7, #18]
  status = 0U;
 8024a24:	2300      	movs	r3, #0
 8024a26:	617b      	str	r3, [r7, #20]
  if ((wordaddr <= (uint32_t)ESC_EEPROM_SIZE) && (pEEPROM != NULL))
 8024a28:	687b      	ldr	r3, [r7, #4]
 8024a2a:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8024a2e:	d830      	bhi.n	8024a92 <HW_EepromWrite+0x7a>
 8024a30:	4b1b      	ldr	r3, [pc, #108]	; (8024aa0 <HW_EepromWrite+0x88>)
 8024a32:	681b      	ldr	r3, [r3, #0]
 8024a34:	2b00      	cmp	r3, #0
 8024a36:	d02c      	beq.n	8024a92 <HW_EepromWrite+0x7a>
  {
     UINT16 *pData = (UINT16 *)(void*)pEEPROM;
 8024a38:	4b19      	ldr	r3, [pc, #100]	; (8024aa0 <HW_EepromWrite+0x88>)
 8024a3a:	681b      	ldr	r3, [r3, #0]
 8024a3c:	60fb      	str	r3, [r7, #12]
     HW_EscRead((MEM_ADDR *)(void*)&pData[(wordaddr)], (uint16_t)ESC_EEPROM_DATA_OFFSET, (uint16_t)EEPROM_WRITE_SIZE);
 8024a3e:	687b      	ldr	r3, [r7, #4]
 8024a40:	005b      	lsls	r3, r3, #1
 8024a42:	68fa      	ldr	r2, [r7, #12]
 8024a44:	4413      	add	r3, r2
 8024a46:	4618      	mov	r0, r3
 8024a48:	f44f 61a1 	mov.w	r1, #1288	; 0x508
 8024a4c:	2202      	movs	r2, #2
 8024a4e:	f7ff fe6b 	bl	8024728 <HW_EscRead>
     if ( (wordaddr == (uint32_t)7U) || (wordaddr ==  (((uint32_t)ESC_EEPROM_SIZE >> (uint32_t)1U) - (uint32_t)1U)) )
 8024a52:	687b      	ldr	r3, [r7, #4]
 8024a54:	2b07      	cmp	r3, #7
 8024a56:	d004      	beq.n	8024a62 <HW_EepromWrite+0x4a>
 8024a58:	687b      	ldr	r3, [r7, #4]
 8024a5a:	f240 32ff 	movw	r2, #1023	; 0x3ff
 8024a5e:	4293      	cmp	r3, r2
 8024a60:	d117      	bne.n	8024a92 <HW_EepromWrite+0x7a>
     {
       /*lets program the complete EEPROM new prepare Data for EEPROM */
       if (E_EEPROM_XMC4_WriteArray((uint16_t)0U,aEepromData,(uint16_t)ESC_EEPROM_SIZE) == true)
 8024a62:	2000      	movs	r0, #0
 8024a64:	490f      	ldr	r1, [pc, #60]	; (8024aa4 <HW_EepromWrite+0x8c>)
 8024a66:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8024a6a:	f7ff fb5b 	bl	8024124 <E_EEPROM_XMC4_WriteArray>
 8024a6e:	4603      	mov	r3, r0
 8024a70:	2b00      	cmp	r3, #0
 8024a72:	d00e      	beq.n	8024a92 <HW_EepromWrite+0x7a>
       {
         HW_EscReadWord(EEPROMReg,ESC_EEPROM_CONTROL_OFFSET);
 8024a74:	4b0c      	ldr	r3, [pc, #48]	; (8024aa8 <HW_EepromWrite+0x90>)
 8024a76:	881b      	ldrh	r3, [r3, #0]
 8024a78:	827b      	strh	r3, [r7, #18]
         HW_EscWriteWord(EEPROMReg & (~ESC_EEPROM_BUSY_MASK),ESC_EEPROM_CONTROL_OFFSET);
 8024a7a:	4a0b      	ldr	r2, [pc, #44]	; (8024aa8 <HW_EepromWrite+0x90>)
 8024a7c:	8a7b      	ldrh	r3, [r7, #18]
 8024a7e:	f3c3 030e 	ubfx	r3, r3, #0, #15
 8024a82:	b29b      	uxth	r3, r3
 8024a84:	8013      	strh	r3, [r2, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8024a86:	b672      	cpsid	i

         __disable_irq();
         /* Program the RAM contents to Emulated EEPROM*/
         status = (uint32_t)E_EEPROM_XMC4_UpdateFlashContents();
 8024a88:	f7ff fba4 	bl	80241d4 <E_EEPROM_XMC4_UpdateFlashContents>
 8024a8c:	4603      	mov	r3, r0
 8024a8e:	617b      	str	r3, [r7, #20]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8024a90:	b662      	cpsie	i
         __enable_irq();
       }
     }
   }

   return (uint16_t)status;
 8024a92:	697b      	ldr	r3, [r7, #20]
 8024a94:	b29b      	uxth	r3, r3
}
 8024a96:	4618      	mov	r0, r3
 8024a98:	3718      	adds	r7, #24
 8024a9a:	46bd      	mov	sp, r7
 8024a9c:	bd80      	pop	{r7, pc}
 8024a9e:	bf00      	nop
 8024aa0:	1fff299c 	.word	0x1fff299c
 8024aa4:	1fff0bcc 	.word	0x1fff0bcc
 8024aa8:	54010502 	.word	0x54010502

08024aac <HW_EepromReload>:

/* Beckhoff Hw abstraction layer interface API to reload slave EEPROM area */
UINT16 HW_EepromReload(void)
{
 8024aac:	b580      	push	{r7, lr}
 8024aae:	b084      	sub	sp, #16
 8024ab0:	af00      	add	r7, sp, #0
  UINT16 EEPROMReg = 0U; /* Regvalue 0x502 - 0x5003 */
 8024ab2:	2300      	movs	r3, #0
 8024ab4:	81fb      	strh	r3, [r7, #14]
  UINT32 cmd = (uint32_t)EEPROMReg  & (uint32_t)ESC_EEPROM_CMD_MASK;
 8024ab6:	89fb      	ldrh	r3, [r7, #14]
 8024ab8:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8024abc:	607b      	str	r3, [r7, #4]
  UINT32 addr;
  HW_EscReadDWord(addr,(uint32_t)ESC_EEPROM_ADDRESS_OFFSET);
 8024abe:	4b1b      	ldr	r3, [pc, #108]	; (8024b2c <HW_EepromReload+0x80>)
 8024ac0:	681b      	ldr	r3, [r3, #0]
 8024ac2:	60bb      	str	r3, [r7, #8]
  addr = SWAPDWORD(addr);

  /* EEPROM emulation ( 8Bytes EEPROM data) */
  if ((addr <= (uint32_t)ESC_EEPROM_SIZE) && (pEEPROM != NULL))
 8024ac4:	68bb      	ldr	r3, [r7, #8]
 8024ac6:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 8024aca:	d826      	bhi.n	8024b1a <HW_EepromReload+0x6e>
 8024acc:	4b18      	ldr	r3, [pc, #96]	; (8024b30 <HW_EepromReload+0x84>)
 8024ace:	681b      	ldr	r3, [r3, #0]
 8024ad0:	2b00      	cmp	r3, #0
 8024ad2:	d022      	beq.n	8024b1a <HW_EepromReload+0x6e>
  {
    UINT16 *pData = (UINT16 *)(void*)pEEPROM;
 8024ad4:	4b16      	ldr	r3, [pc, #88]	; (8024b30 <HW_EepromReload+0x84>)
 8024ad6:	681b      	ldr	r3, [r3, #0]
 8024ad8:	603b      	str	r3, [r7, #0]
    do
    {
    HW_EscWrite((MEM_ADDR *)(void*)&pData[(addr)], (uint16_t)ESC_EEPROM_DATA_OFFSET, (uint16_t)EEPROM_READ_SIZE);
 8024ada:	68bb      	ldr	r3, [r7, #8]
 8024adc:	005b      	lsls	r3, r3, #1
 8024ade:	683a      	ldr	r2, [r7, #0]
 8024ae0:	4413      	add	r3, r2
 8024ae2:	4618      	mov	r0, r3
 8024ae4:	f44f 61a1 	mov.w	r1, #1288	; 0x508
 8024ae8:	2208      	movs	r2, #8
 8024aea:	f7ff fe33 	bl	8024754 <HW_EscWrite>

     /*Clear error bits */
     EEPROMReg &= (uint16_t)(~(uint16_t)(ESC_EEPROM_ERROR_MASK));
 8024aee:	89fb      	ldrh	r3, [r7, #14]
 8024af0:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 8024af4:	81fb      	strh	r3, [r7, #14]

     /*ack current reload segment */
     HW_EscWriteWord(EEPROMReg,(uint32_t)ESC_EEPROM_CONTROL_OFFSET);
 8024af6:	4a0f      	ldr	r2, [pc, #60]	; (8024b34 <HW_EepromReload+0x88>)
 8024af8:	89fb      	ldrh	r3, [r7, #14]
 8024afa:	8013      	strh	r3, [r2, #0]

     /* read EEPROM control (to check if the reload is still pending) */
     HW_EscReadWord(EEPROMReg,ESC_EEPROM_CONTROL_OFFSET);
 8024afc:	4b0d      	ldr	r3, [pc, #52]	; (8024b34 <HW_EepromReload+0x88>)
 8024afe:	881b      	ldrh	r3, [r3, #0]
 8024b00:	81fb      	strh	r3, [r7, #14]
     cmd = (uint32_t)EEPROMReg  & (uint32_t)ESC_EEPROM_CMD_MASK;
 8024b02:	89fb      	ldrh	r3, [r7, #14]
 8024b04:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8024b08:	607b      	str	r3, [r7, #4]

     HW_EscReadDWord(addr,(uint32_t)ESC_EEPROM_ADDRESS_OFFSET);
 8024b0a:	4b08      	ldr	r3, [pc, #32]	; (8024b2c <HW_EepromReload+0x80>)
 8024b0c:	681b      	ldr	r3, [r3, #0]
 8024b0e:	60bb      	str	r3, [r7, #8]

    } while(cmd == (uint32_t)ESC_EEPROM_CMD_RELOAD_MASK);
 8024b10:	687b      	ldr	r3, [r7, #4]
 8024b12:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8024b16:	d0e0      	beq.n	8024ada <HW_EepromReload+0x2e>
  HW_EscReadDWord(addr,(uint32_t)ESC_EEPROM_ADDRESS_OFFSET);
  addr = SWAPDWORD(addr);

  /* EEPROM emulation ( 8Bytes EEPROM data) */
  if ((addr <= (uint32_t)ESC_EEPROM_SIZE) && (pEEPROM != NULL))
  {
 8024b18:	e003      	b.n	8024b22 <HW_EepromReload+0x76>
    } while(cmd == (uint32_t)ESC_EEPROM_CMD_RELOAD_MASK);
  }
  else
  {
    /* Set Error  */
    EEPROMReg |= (uint16_t)ESC_EEPROM_ERROR_CMD_ACK;
 8024b1a:	89fb      	ldrh	r3, [r7, #14]
 8024b1c:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8024b20:	81fb      	strh	r3, [r7, #14]
  }
  return 0U;
 8024b22:	2300      	movs	r3, #0
}
 8024b24:	4618      	mov	r0, r3
 8024b26:	3710      	adds	r7, #16
 8024b28:	46bd      	mov	sp, r7
 8024b2a:	bd80      	pop	{r7, pc}
 8024b2c:	54010504 	.word	0x54010504
 8024b30:	1fff299c 	.word	0x1fff299c
 8024b34:	54010502 	.word	0x54010502

08024b38 <ECAT0_0_IRQHandler>:

/* ECAT slave interrupt handler function */
void ECAT0_0_IRQHandler(void)
{
 8024b38:	b580      	push	{r7, lr}
 8024b3a:	af00      	add	r7, sp, #0
  PDI_Isr();
 8024b3c:	f7fb ff64 	bl	8020a08 <PDI_Isr>
}
 8024b40:	bd80      	pop	{r7, pc}
 8024b42:	bf00      	nop

08024b44 <CCU41_1_IRQHandler>:

/* ECAT slave timer interrupt handler function */
void ecat_ssc_timer_handler(void)
{
 8024b44:	b580      	push	{r7, lr}
 8024b46:	af00      	add	r7, sp, #0
  ticks++;
 8024b48:	4b03      	ldr	r3, [pc, #12]	; (8024b58 <CCU41_1_IRQHandler+0x14>)
 8024b4a:	681b      	ldr	r3, [r3, #0]
 8024b4c:	3301      	adds	r3, #1
 8024b4e:	4a02      	ldr	r2, [pc, #8]	; (8024b58 <CCU41_1_IRQHandler+0x14>)
 8024b50:	6013      	str	r3, [r2, #0]
#if ECAT_TIMER_INT == 1
  ECAT_CheckTimer();
 8024b52:	f7fb fe65 	bl	8020820 <ECAT_CheckTimer>
#endif
}
 8024b56:	bd80      	pop	{r7, pc}
 8024b58:	1fff2818 	.word	0x1fff2818

08024b5c <ENABLE_ESC_INT>:
{
  ticks = 0;
}

void ENABLE_ESC_INT(void)
{
 8024b5c:	b580      	push	{r7, lr}
 8024b5e:	af00      	add	r7, sp, #0
  ENABLE_ESC_INT_USER();
 8024b60:	f7ff fd18 	bl	8024594 <ENABLE_ESC_INT_USER>

  NVIC_EnableIRQ(ECAT0_0_IRQn);
 8024b64:	206d      	movs	r0, #109	; 0x6d
 8024b66:	f7ff fd2f 	bl	80245c8 <__NVIC_EnableIRQ>
  INTERRUPT_Enable(&INTERRUPT_0);
 8024b6a:	4802      	ldr	r0, [pc, #8]	; (8024b74 <ENABLE_ESC_INT+0x18>)
 8024b6c:	f7ff fe08 	bl	8024780 <INTERRUPT_Enable>
}
 8024b70:	bd80      	pop	{r7, pc}
 8024b72:	bf00      	nop
 8024b74:	08025c04 	.word	0x08025c04

08024b78 <DISABLE_ESC_INT>:

void DISABLE_ESC_INT(void)
{
 8024b78:	b580      	push	{r7, lr}
 8024b7a:	b086      	sub	sp, #24
 8024b7c:	af00      	add	r7, sp, #0
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8024b7e:	f3ef 8310 	mrs	r3, PRIMASK
 8024b82:	613b      	str	r3, [r7, #16]
  return(result);
 8024b84:	693b      	ldr	r3, [r7, #16]
extern void DISABLE_ESC_INT_USER(void);

__attribute__((always_inline)) __STATIC_INLINE uint32_t critical_section_enter(void)
{
  uint32_t status;
  status = __get_PRIMASK();
 8024b86:	60fb      	str	r3, [r7, #12]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8024b88:	b672      	cpsid	i
  __disable_irq ();
  return status;
 8024b8a:	68fb      	ldr	r3, [r7, #12]
}

void DISABLE_ESC_INT(void)
{
  uint32_t ics;
  ics = critical_section_enter();
 8024b8c:	617b      	str	r3, [r7, #20]

  DISABLE_ESC_INT_USER();
 8024b8e:	f7ff fd07 	bl	80245a0 <DISABLE_ESC_INT_USER>

  NVIC_DisableIRQ(ECAT0_0_IRQn);
 8024b92:	206d      	movs	r0, #109	; 0x6d
 8024b94:	f7ff fd34 	bl	8024600 <__NVIC_DisableIRQ>
  INTERRUPT_Disable(&INTERRUPT_0);
 8024b98:	4806      	ldr	r0, [pc, #24]	; (8024bb4 <DISABLE_ESC_INT+0x3c>)
 8024b9a:	f7ff fdff 	bl	802479c <INTERRUPT_Disable>
 8024b9e:	697b      	ldr	r3, [r7, #20]
 8024ba0:	60bb      	str	r3, [r7, #8]
 8024ba2:	68bb      	ldr	r3, [r7, #8]
 8024ba4:	607b      	str	r3, [r7, #4]
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 */
__STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 8024ba6:	687b      	ldr	r3, [r7, #4]
 8024ba8:	f383 8810 	msr	PRIMASK, r3

  critical_section_exit(ics);
}
 8024bac:	3718      	adds	r7, #24
 8024bae:	46bd      	mov	sp, r7
 8024bb0:	bd80      	pop	{r7, pc}
 8024bb2:	bf00      	nop
 8024bb4:	08025c04 	.word	0x08025c04

08024bb8 <DIGITAL_IO_Init>:
* @param handler Pointer pointing to APP data structure.
* @return DIGITAL_IO_STATUS_t DIGITAL_IO APP status.
*/

DIGITAL_IO_STATUS_t DIGITAL_IO_Init(const DIGITAL_IO_t *const handler)
{
 8024bb8:	b580      	push	{r7, lr}
 8024bba:	b082      	sub	sp, #8
 8024bbc:	af00      	add	r7, sp, #0
 8024bbe:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("DIGITAL_IO_Init: handler null pointer", handler != NULL);

  /* Initializes input / output characteristics */
  XMC_GPIO_Init(handler->gpio_port, handler->gpio_pin, &handler->gpio_config);
 8024bc0:	687b      	ldr	r3, [r7, #4]
 8024bc2:	6819      	ldr	r1, [r3, #0]
 8024bc4:	687b      	ldr	r3, [r7, #4]
 8024bc6:	7c1a      	ldrb	r2, [r3, #16]
 8024bc8:	687b      	ldr	r3, [r7, #4]
 8024bca:	3304      	adds	r3, #4
 8024bcc:	4608      	mov	r0, r1
 8024bce:	4611      	mov	r1, r2
 8024bd0:	461a      	mov	r2, r3
 8024bd2:	f7fc fd1b 	bl	802160c <XMC_GPIO_Init>

  /*Configure hardware port control*/
  XMC_GPIO_SetHardwareControl(handler->gpio_port, handler->gpio_pin, handler->hwctrl);
 8024bd6:	687b      	ldr	r3, [r7, #4]
 8024bd8:	6819      	ldr	r1, [r3, #0]
 8024bda:	687b      	ldr	r3, [r7, #4]
 8024bdc:	7c1a      	ldrb	r2, [r3, #16]
 8024bde:	687b      	ldr	r3, [r7, #4]
 8024be0:	7c5b      	ldrb	r3, [r3, #17]
 8024be2:	4608      	mov	r0, r1
 8024be4:	4611      	mov	r1, r2
 8024be6:	461a      	mov	r2, r3
 8024be8:	f7fe f8cc 	bl	8022d84 <XMC_GPIO_SetHardwareControl>

  return (DIGITAL_IO_STATUS_OK);
 8024bec:	2300      	movs	r3, #0
}
 8024bee:	4618      	mov	r0, r3
 8024bf0:	3708      	adds	r7, #8
 8024bf2:	46bd      	mov	sp, r7
 8024bf4:	bd80      	pop	{r7, pc}
 8024bf6:	bf00      	nop

08024bf8 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8024bf8:	b480      	push	{r7}
 8024bfa:	b085      	sub	sp, #20
 8024bfc:	af00      	add	r7, sp, #0
 8024bfe:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8024c00:	687b      	ldr	r3, [r7, #4]
 8024c02:	f003 0307 	and.w	r3, r3, #7
 8024c06:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8024c08:	4b0c      	ldr	r3, [pc, #48]	; (8024c3c <__NVIC_SetPriorityGrouping+0x44>)
 8024c0a:	68db      	ldr	r3, [r3, #12]
 8024c0c:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8024c0e:	68ba      	ldr	r2, [r7, #8]
 8024c10:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8024c14:	4013      	ands	r3, r2
 8024c16:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8024c18:	68fb      	ldr	r3, [r7, #12]
 8024c1a:	021a      	lsls	r2, r3, #8
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8024c1c:	68bb      	ldr	r3, [r7, #8]
 8024c1e:	4313      	orrs	r3, r2
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8024c20:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8024c24:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8024c28:	60bb      	str	r3, [r7, #8]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
  SCB->AIRCR =  reg_value;
 8024c2a:	4a04      	ldr	r2, [pc, #16]	; (8024c3c <__NVIC_SetPriorityGrouping+0x44>)
 8024c2c:	68bb      	ldr	r3, [r7, #8]
 8024c2e:	60d3      	str	r3, [r2, #12]
}
 8024c30:	3714      	adds	r7, #20
 8024c32:	46bd      	mov	sp, r7
 8024c34:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024c38:	4770      	bx	lr
 8024c3a:	bf00      	nop
 8024c3c:	e000ed00 	.word	0xe000ed00

08024c40 <SystemCoreSetup>:
  .initialized = false
};	


void SystemCoreSetup(void)
{
 8024c40:	b580      	push	{r7, lr}
 8024c42:	b082      	sub	sp, #8
 8024c44:	af00      	add	r7, sp, #0
  uint32_t temp;

  NVIC_SetPriorityGrouping(1U);
 8024c46:	2001      	movs	r0, #1
 8024c48:	f7ff ffd6 	bl	8024bf8 <__NVIC_SetPriorityGrouping>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8024c4c:	b672      	cpsid	i
	
  /* relocate vector table */
  __disable_irq();

#if !defined(__TASKING__)
  SCB->VTOR = (uint32_t)(&__Vectors);
 8024c4e:	4b21      	ldr	r3, [pc, #132]	; (8024cd4 <SystemCoreSetup+0x94>)
 8024c50:	4a21      	ldr	r2, [pc, #132]	; (8024cd8 <SystemCoreSetup+0x98>)
 8024c52:	609a      	str	r2, [r3, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8024c54:	f3bf 8f4f 	dsb	sy
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8024c58:	b662      	cpsie	i

  __DSB();
  __enable_irq();
	
#if ((__FPU_PRESENT == 1) && (__FPU_USED == 1))
  SCB->CPACR |= ((3UL << 10*2) |                 /* set CP10 Full Access */
 8024c5a:	4a1e      	ldr	r2, [pc, #120]	; (8024cd4 <SystemCoreSetup+0x94>)
 8024c5c:	4b1d      	ldr	r3, [pc, #116]	; (8024cd4 <SystemCoreSetup+0x94>)
 8024c5e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8024c62:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8024c66:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
				 (3UL << 11*2)  );               /* set CP11 Full Access */
#endif
  /* Set flash wait states */
  temp = FLASH0->FCON;
 8024c6a:	4b1c      	ldr	r3, [pc, #112]	; (8024cdc <SystemCoreSetup+0x9c>)
 8024c6c:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8024c70:	3314      	adds	r3, #20
 8024c72:	681b      	ldr	r3, [r3, #0]
 8024c74:	607b      	str	r3, [r7, #4]
  temp &= ~FLASH_FCON_WSPFLASH_Msk;
 8024c76:	687b      	ldr	r3, [r7, #4]
 8024c78:	f023 030f 	bic.w	r3, r3, #15
 8024c7c:	607b      	str	r3, [r7, #4]
  temp |= PMU_FLASH_WS;
 8024c7e:	687b      	ldr	r3, [r7, #4]
 8024c80:	f043 0304 	orr.w	r3, r3, #4
 8024c84:	607b      	str	r3, [r7, #4]
  FLASH0->FCON = temp;
 8024c86:	4b15      	ldr	r3, [pc, #84]	; (8024cdc <SystemCoreSetup+0x9c>)
 8024c88:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8024c8c:	3314      	adds	r3, #20
 8024c8e:	687a      	ldr	r2, [r7, #4]
 8024c90:	601a      	str	r2, [r3, #0]


  /* Disable divide by zero trap */
  SCB->CCR &= ~SCB_CCR_DIV_0_TRP_Msk; 
 8024c92:	4a10      	ldr	r2, [pc, #64]	; (8024cd4 <SystemCoreSetup+0x94>)
 8024c94:	4b0f      	ldr	r3, [pc, #60]	; (8024cd4 <SystemCoreSetup+0x94>)
 8024c96:	695b      	ldr	r3, [r3, #20]
 8024c98:	f023 0310 	bic.w	r3, r3, #16
 8024c9c:	6153      	str	r3, [r2, #20]

  /* Disable unaligned memory access trap */
  SCB->CCR &= ~SCB_CCR_UNALIGN_TRP_Msk; 
 8024c9e:	4a0d      	ldr	r2, [pc, #52]	; (8024cd4 <SystemCoreSetup+0x94>)
 8024ca0:	4b0c      	ldr	r3, [pc, #48]	; (8024cd4 <SystemCoreSetup+0x94>)
 8024ca2:	695b      	ldr	r3, [r3, #20]
 8024ca4:	f023 0308 	bic.w	r3, r3, #8
 8024ca8:	6153      	str	r3, [r2, #20]

  /* Disable memory management fault */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 8024caa:	4a0a      	ldr	r2, [pc, #40]	; (8024cd4 <SystemCoreSetup+0x94>)
 8024cac:	4b09      	ldr	r3, [pc, #36]	; (8024cd4 <SystemCoreSetup+0x94>)
 8024cae:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8024cb0:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8024cb4:	6253      	str	r3, [r2, #36]	; 0x24

  /* Disable bus fault */
  SCB->SHCSR &= ~SCB_SHCSR_BUSFAULTENA_Msk;
 8024cb6:	4a07      	ldr	r2, [pc, #28]	; (8024cd4 <SystemCoreSetup+0x94>)
 8024cb8:	4b06      	ldr	r3, [pc, #24]	; (8024cd4 <SystemCoreSetup+0x94>)
 8024cba:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8024cbc:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8024cc0:	6253      	str	r3, [r2, #36]	; 0x24

  /* Disable usage fault */
  SCB->SHCSR &= ~SCB_SHCSR_USGFAULTENA_Msk;
 8024cc2:	4a04      	ldr	r2, [pc, #16]	; (8024cd4 <SystemCoreSetup+0x94>)
 8024cc4:	4b03      	ldr	r3, [pc, #12]	; (8024cd4 <SystemCoreSetup+0x94>)
 8024cc6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8024cc8:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8024ccc:	6253      	str	r3, [r2, #36]	; 0x24
}
 8024cce:	3708      	adds	r7, #8
 8024cd0:	46bd      	mov	sp, r7
 8024cd2:	bd80      	pop	{r7, pc}
 8024cd4:	e000ed00 	.word	0xe000ed00
 8024cd8:	08000000 	.word	0x08000000
 8024cdc:	58001000 	.word	0x58001000

08024ce0 <CLOCK_XMC4_Init>:

/*
 * API to initialize the CLOCK_XMC4 APP TRAP events
 */
CLOCK_XMC4_STATUS_t CLOCK_XMC4_Init(CLOCK_XMC4_t *handle)
{
 8024ce0:	b480      	push	{r7}
 8024ce2:	b085      	sub	sp, #20
 8024ce4:	af00      	add	r7, sp, #0
 8024ce6:	6078      	str	r0, [r7, #4]
  CLOCK_XMC4_STATUS_t status = CLOCK_XMC4_STATUS_SUCCESS;
 8024ce8:	2300      	movs	r3, #0
 8024cea:	73fb      	strb	r3, [r7, #15]

  XMC_ASSERT("CLOCK_XMC4 APP handle function pointer uninitialized", (handle != NULL));

  handle->init_status = true;
 8024cec:	687b      	ldr	r3, [r7, #4]
 8024cee:	2201      	movs	r2, #1
 8024cf0:	701a      	strb	r2, [r3, #0]

  return (status);
 8024cf2:	7bfb      	ldrb	r3, [r7, #15]
}
 8024cf4:	4618      	mov	r0, r3
 8024cf6:	3714      	adds	r7, #20
 8024cf8:	46bd      	mov	sp, r7
 8024cfa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024cfe:	4770      	bx	lr

08024d00 <OSCHP_GetFrequency>:

#ifdef CLOCK_XMC4_OSCHP_ENABLED
/*  API to retrieve high precision external oscillator frequency */
uint32_t OSCHP_GetFrequency(void)
{
 8024d00:	b480      	push	{r7}
 8024d02:	af00      	add	r7, sp, #0
  return (CLOCK_XMC4_OSCHP_FREQUENCY);
 8024d04:	4b02      	ldr	r3, [pc, #8]	; (8024d10 <OSCHP_GetFrequency+0x10>)
}
 8024d06:	4618      	mov	r0, r3
 8024d08:	46bd      	mov	sp, r7
 8024d0a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024d0e:	4770      	bx	lr
 8024d10:	016e3600 	.word	0x016e3600

08024d14 <XMC_SCU_CLOCK_SetECATClockSource>:
 * The value is configured to \a ECATSEL bit of \a ECATCLKCR register.
 * \par<b>Related APIs:</b><BR>
 * XMC_SCU_CLOCK_GetECATClockSource() \n\n\n
 */
__STATIC_INLINE void XMC_SCU_CLOCK_SetECATClockSource(const XMC_SCU_CLOCK_ECATCLKSRC_t source)
{
 8024d14:	b480      	push	{r7}
 8024d16:	b083      	sub	sp, #12
 8024d18:	af00      	add	r7, sp, #0
 8024d1a:	6078      	str	r0, [r7, #4]
  SCU_CLK->ECATCLKCR = (SCU_CLK->ECATCLKCR & ((uint32_t)~SCU_CLK_ECATCLKCR_ECATSEL_Msk)) |
 8024d1c:	4906      	ldr	r1, [pc, #24]	; (8024d38 <XMC_SCU_CLOCK_SetECATClockSource+0x24>)
 8024d1e:	4b06      	ldr	r3, [pc, #24]	; (8024d38 <XMC_SCU_CLOCK_SetECATClockSource+0x24>)
 8024d20:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8024d22:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 8024d26:	687b      	ldr	r3, [r7, #4]
 8024d28:	4313      	orrs	r3, r2
 8024d2a:	638b      	str	r3, [r1, #56]	; 0x38
                       ((uint32_t)source);
}
 8024d2c:	370c      	adds	r7, #12
 8024d2e:	46bd      	mov	sp, r7
 8024d30:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024d34:	4770      	bx	lr
 8024d36:	bf00      	nop
 8024d38:	50004600 	.word	0x50004600

08024d3c <SystemCoreClockSetup>:
* @note   -
* @param  None
* @retval None
*/
void SystemCoreClockSetup(void)
{
 8024d3c:	b5b0      	push	{r4, r5, r7, lr}
 8024d3e:	b086      	sub	sp, #24
 8024d40:	af00      	add	r7, sp, #0
  /* Local data structure for initializing the clock functional block */
  const XMC_SCU_CLOCK_CONFIG_t CLOCK_XMC4_0_CONFIG =
 8024d42:	4b15      	ldr	r3, [pc, #84]	; (8024d98 <SystemCoreClockSetup+0x5c>)
 8024d44:	1d3c      	adds	r4, r7, #4
 8024d46:	461d      	mov	r5, r3
 8024d48:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8024d4a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8024d4c:	682b      	ldr	r3, [r5, #0]
 8024d4e:	6023      	str	r3, [r4, #0]
#endif
    /* Peripheral Clock Divider Value */
    .fperipheral_clkdiv = 1U
  };
  /* Initialize the SCU clock */
  XMC_SCU_CLOCK_Init(&CLOCK_XMC4_0_CONFIG);
 8024d50:	1d3b      	adds	r3, r7, #4
 8024d52:	4618      	mov	r0, r3
 8024d54:	f7fc fd54 	bl	8021800 <XMC_SCU_CLOCK_Init>
  /* RTC source clock */
  XMC_SCU_HIB_SetRtcClockSource(XMC_SCU_HIB_RTCCLKSRC_OSI);
 8024d58:	2000      	movs	r0, #0
 8024d5a:	f7fc fe79 	bl	8021a50 <XMC_SCU_HIB_SetRtcClockSource>
  
#ifdef CLOCK_XMC4_USBCLK_ENABLED  
  /* USB/SDMMC source clock */
  XMC_SCU_CLOCK_SetUsbClockSource(XMC_SCU_CLOCK_USBCLKSRC_SYSPLL);
 8024d5e:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 8024d62:	f7fc fe2d 	bl	80219c0 <XMC_SCU_CLOCK_SetUsbClockSource>
  /* USB/SDMMC divider setting */
  XMC_SCU_CLOCK_SetUsbClockDivider(6U);
 8024d66:	2006      	movs	r0, #6
 8024d68:	f7fc fefe 	bl	8021b68 <XMC_SCU_CLOCK_SetUsbClockDivider>
#endif
  /* Start USB PLL */
  XMC_SCU_CLOCK_EnableUsbPll();
 8024d6c:	f7fc ff88 	bl	8021c80 <XMC_SCU_CLOCK_EnableUsbPll>
  XMC_SCU_CLOCK_StartUsbPll(3U, 50U);
 8024d70:	2003      	movs	r0, #3
 8024d72:	2132      	movs	r1, #50	; 0x32
 8024d74:	f7fc ff94 	bl	8021ca0 <XMC_SCU_CLOCK_StartUsbPll>
  
#ifdef CLOCK_XMC4_ECATCLK_ENABLED    
  /* ECAT source clock */
  XMC_SCU_CLOCK_SetECATClockSource(XMC_SCU_CLOCK_ECATCLKSRC_USBPLL);
 8024d78:	2000      	movs	r0, #0
 8024d7a:	f7ff ffcb 	bl	8024d14 <XMC_SCU_CLOCK_SetECATClockSource>
  /* ECAT divider setting */
  XMC_SCU_CLOCK_SetECATClockDivider(2U);
 8024d7e:	2002      	movs	r0, #2
 8024d80:	f7fc ff1a 	bl	8021bb8 <XMC_SCU_CLOCK_SetECATClockDivider>
#endif

#ifdef CLOCK_XMC4_WDTCLK_ENABLED    
  /* WDT source clock */
  XMC_SCU_CLOCK_SetWdtClockSource(XMC_SCU_CLOCK_WDTCLKSRC_OFI);
 8024d84:	2000      	movs	r0, #0
 8024d86:	f7fc fe2f 	bl	80219e8 <XMC_SCU_CLOCK_SetWdtClockSource>
  /* WDT divider setting */
  XMC_SCU_CLOCK_SetWdtClockDivider(1U);
 8024d8a:	2001      	movs	r0, #1
 8024d8c:	f7fc ff00 	bl	8021b90 <XMC_SCU_CLOCK_SetWdtClockDivider>
#endif

}
 8024d90:	3718      	adds	r7, #24
 8024d92:	46bd      	mov	sp, r7
 8024d94:	bdb0      	pop	{r4, r5, r7, pc}
 8024d96:	bf00      	nop
 8024d98:	08025c5c 	.word	0x08025c5c

08024d9c <DAVE_Init>:
 * @param[in]  None
 *
 * @return  DAVE_STATUS_t <BR>
 ******************************************************************************/
__WEAK DAVE_STATUS_t DAVE_Init(void)
{
 8024d9c:	b580      	push	{r7, lr}
 8024d9e:	b082      	sub	sp, #8
 8024da0:	af00      	add	r7, sp, #0
  DAVE_STATUS_t init_status;
  
  init_status = DAVE_STATUS_SUCCESS;
 8024da2:	2300      	movs	r3, #0
 8024da4:	71fb      	strb	r3, [r7, #7]
     /** @Initialization of APPs Init Functions */
     init_status = (DAVE_STATUS_t)CLOCK_XMC4_Init(&CLOCK_XMC4_0);
 8024da6:	4819      	ldr	r0, [pc, #100]	; (8024e0c <DAVE_Init+0x70>)
 8024da8:	f7ff ff9a 	bl	8024ce0 <CLOCK_XMC4_Init>
 8024dac:	4603      	mov	r3, r0
 8024dae:	71fb      	strb	r3, [r7, #7]

  if (init_status == DAVE_STATUS_SUCCESS)
 8024db0:	79fb      	ldrb	r3, [r7, #7]
 8024db2:	2b00      	cmp	r3, #0
 8024db4:	d104      	bne.n	8024dc0 <DAVE_Init+0x24>
  {
	 /**  Initialization of DIGITAL_IO APP instance LED */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&LED); 
 8024db6:	4816      	ldr	r0, [pc, #88]	; (8024e10 <DAVE_Init+0x74>)
 8024db8:	f7ff fefe 	bl	8024bb8 <DIGITAL_IO_Init>
 8024dbc:	4603      	mov	r3, r0
 8024dbe:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8024dc0:	79fb      	ldrb	r3, [r7, #7]
 8024dc2:	2b00      	cmp	r3, #0
 8024dc4:	d104      	bne.n	8024dd0 <DAVE_Init+0x34>
  {
	 /**  Initialization of DIGITAL_IO APP instance SLEEPN5 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&SLEEPN5); 
 8024dc6:	4813      	ldr	r0, [pc, #76]	; (8024e14 <DAVE_Init+0x78>)
 8024dc8:	f7ff fef6 	bl	8024bb8 <DIGITAL_IO_Init>
 8024dcc:	4603      	mov	r3, r0
 8024dce:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8024dd0:	79fb      	ldrb	r3, [r7, #7]
 8024dd2:	2b00      	cmp	r3, #0
 8024dd4:	d104      	bne.n	8024de0 <DAVE_Init+0x44>
  {
	 /**  Initialization of DIGITAL_IO APP instance CS_5 */
	 init_status = (DAVE_STATUS_t)DIGITAL_IO_Init(&CS_5); 
 8024dd6:	4810      	ldr	r0, [pc, #64]	; (8024e18 <DAVE_Init+0x7c>)
 8024dd8:	f7ff feee 	bl	8024bb8 <DIGITAL_IO_Init>
 8024ddc:	4603      	mov	r3, r0
 8024dde:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8024de0:	79fb      	ldrb	r3, [r7, #7]
 8024de2:	2b00      	cmp	r3, #0
 8024de4:	d104      	bne.n	8024df0 <DAVE_Init+0x54>
  {
	 /**  Initialization of SPI_MASTER APP instance SPI_MASTER_0 */
	 init_status = (DAVE_STATUS_t)SPI_MASTER_Init(&SPI_MASTER_0); 
 8024de6:	480d      	ldr	r0, [pc, #52]	; (8024e1c <DAVE_Init+0x80>)
 8024de8:	f7fe fb8a 	bl	8023500 <SPI_MASTER_Init>
 8024dec:	4603      	mov	r3, r0
 8024dee:	71fb      	strb	r3, [r7, #7]
   } 
  if (init_status == DAVE_STATUS_SUCCESS)
 8024df0:	79fb      	ldrb	r3, [r7, #7]
 8024df2:	2b00      	cmp	r3, #0
 8024df4:	d104      	bne.n	8024e00 <DAVE_Init+0x64>
  {
	 /**  Initialization of ECAT_SSC APP instance ECAT_SSC_0 */
	 init_status = (DAVE_STATUS_t)ECAT_SSC_Init(&ECAT_SSC_0); 
 8024df6:	480a      	ldr	r0, [pc, #40]	; (8024e20 <DAVE_Init+0x84>)
 8024df8:	f7ff fb64 	bl	80244c4 <ECAT_SSC_Init>
 8024dfc:	4603      	mov	r3, r0
 8024dfe:	71fb      	strb	r3, [r7, #7]
   }  
  return init_status;
 8024e00:	79fb      	ldrb	r3, [r7, #7]
} /**  End of function DAVE_Init */
 8024e02:	4618      	mov	r0, r3
 8024e04:	3708      	adds	r7, #8
 8024e06:	46bd      	mov	sp, r7
 8024e08:	bd80      	pop	{r7, pc}
 8024e0a:	bf00      	nop
 8024e0c:	1fff281c 	.word	0x1fff281c
 8024e10:	08025c20 	.word	0x08025c20
 8024e14:	08025c34 	.word	0x08025c34
 8024e18:	08025c48 	.word	0x08025c48
 8024e1c:	1fff1790 	.word	0x1fff1790
 8024e20:	08025c14 	.word	0x08025c14

08024e24 <XMC_GPIO_SetOutputHigh>:
 * Register Pn_OMR is virtual and does not contain any flip-flop. A read action delivers the value of 0.
 *
 */

__STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
 8024e24:	b480      	push	{r7}
 8024e26:	b083      	sub	sp, #12
 8024e28:	af00      	add	r7, sp, #0
 8024e2a:	6078      	str	r0, [r7, #4]
 8024e2c:	460b      	mov	r3, r1
 8024e2e:	70fb      	strb	r3, [r7, #3]
  XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = (uint32_t)0x1U << pin;
 8024e30:	78fb      	ldrb	r3, [r7, #3]
 8024e32:	2201      	movs	r2, #1
 8024e34:	409a      	lsls	r2, r3
 8024e36:	687b      	ldr	r3, [r7, #4]
 8024e38:	605a      	str	r2, [r3, #4]
}
 8024e3a:	370c      	adds	r7, #12
 8024e3c:	46bd      	mov	sp, r7
 8024e3e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024e42:	4770      	bx	lr

08024e44 <XMC_GPIO_SetOutputLow>:
 * Register Pn_OMR is virtual and does not contain any flip-flop. A read action delivers the value of 0.\n
 *
 */

__STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
{
 8024e44:	b480      	push	{r7}
 8024e46:	b083      	sub	sp, #12
 8024e48:	af00      	add	r7, sp, #0
 8024e4a:	6078      	str	r0, [r7, #4]
 8024e4c:	460b      	mov	r3, r1
 8024e4e:	70fb      	strb	r3, [r7, #3]
  XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));

  port->OMR = 0x10000U << pin;
 8024e50:	78fb      	ldrb	r3, [r7, #3]
 8024e52:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8024e56:	409a      	lsls	r2, r3
 8024e58:	687b      	ldr	r3, [r7, #4]
 8024e5a:	605a      	str	r2, [r3, #4]
}
 8024e5c:	370c      	adds	r7, #12
 8024e5e:	46bd      	mov	sp, r7
 8024e60:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024e64:	4770      	bx	lr
 8024e66:	bf00      	nop

08024e68 <DIGITAL_IO_SetOutputHigh>:
* }
*  @endcode
*/

__STATIC_INLINE void DIGITAL_IO_SetOutputHigh(const DIGITAL_IO_t *const handler)
{
 8024e68:	b580      	push	{r7, lr}
 8024e6a:	b082      	sub	sp, #8
 8024e6c:	af00      	add	r7, sp, #0
 8024e6e:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("DIGITAL_IO_SetOutputHigh: handler null pointer", handler != NULL);
  XMC_GPIO_SetOutputHigh(handler->gpio_port, handler->gpio_pin);
 8024e70:	687b      	ldr	r3, [r7, #4]
 8024e72:	681a      	ldr	r2, [r3, #0]
 8024e74:	687b      	ldr	r3, [r7, #4]
 8024e76:	7c1b      	ldrb	r3, [r3, #16]
 8024e78:	4610      	mov	r0, r2
 8024e7a:	4619      	mov	r1, r3
 8024e7c:	f7ff ffd2 	bl	8024e24 <XMC_GPIO_SetOutputHigh>
}
 8024e80:	3708      	adds	r7, #8
 8024e82:	46bd      	mov	sp, r7
 8024e84:	bd80      	pop	{r7, pc}
 8024e86:	bf00      	nop

08024e88 <DIGITAL_IO_SetOutputLow>:
* }
*  @endcode
*/

__STATIC_INLINE void DIGITAL_IO_SetOutputLow(const DIGITAL_IO_t *const handler)
{
 8024e88:	b580      	push	{r7, lr}
 8024e8a:	b082      	sub	sp, #8
 8024e8c:	af00      	add	r7, sp, #0
 8024e8e:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("DIGITAL_IO_SetOutputLow: handler null pointer", handler != NULL);
  XMC_GPIO_SetOutputLow(handler->gpio_port,handler->gpio_pin);
 8024e90:	687b      	ldr	r3, [r7, #4]
 8024e92:	681a      	ldr	r2, [r3, #0]
 8024e94:	687b      	ldr	r3, [r7, #4]
 8024e96:	7c1b      	ldrb	r3, [r3, #16]
 8024e98:	4610      	mov	r0, r2
 8024e9a:	4619      	mov	r1, r3
 8024e9c:	f7ff ffd2 	bl	8024e44 <XMC_GPIO_SetOutputLow>
}
 8024ea0:	3708      	adds	r7, #8
 8024ea2:	46bd      	mov	sp, r7
 8024ea4:	bd80      	pop	{r7, pc}
 8024ea6:	bf00      	nop

08024ea8 <SPI_MASTER_IsTxBusy>:
 * }
 * @endcode<BR> </p>
 *
 */
__STATIC_INLINE bool SPI_MASTER_IsTxBusy(const SPI_MASTER_t* const handle)
{
 8024ea8:	b480      	push	{r7}
 8024eaa:	b083      	sub	sp, #12
 8024eac:	af00      	add	r7, sp, #0
 8024eae:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("SPI_MASTER_IsTxBusy:handle NULL", (handle != NULL))
  return (handle->runtime->tx_busy);
 8024eb0:	687b      	ldr	r3, [r7, #4]
 8024eb2:	689b      	ldr	r3, [r3, #8]
 8024eb4:	f893 3020 	ldrb.w	r3, [r3, #32]
 8024eb8:	b2db      	uxtb	r3, r3
}
 8024eba:	4618      	mov	r0, r3
 8024ebc:	370c      	adds	r7, #12
 8024ebe:	46bd      	mov	sp, r7
 8024ec0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024ec4:	4770      	bx	lr
 8024ec6:	bf00      	nop

08024ec8 <SPI_MASTER_IsRxBusy>:
 *    return 1U;
 * }
 * @endcode<BR>
 */
__STATIC_INLINE bool SPI_MASTER_IsRxBusy(const SPI_MASTER_t* const handle)
{
 8024ec8:	b480      	push	{r7}
 8024eca:	b083      	sub	sp, #12
 8024ecc:	af00      	add	r7, sp, #0
 8024ece:	6078      	str	r0, [r7, #4]
  XMC_ASSERT("SPI_MASTER_IsTxBusy:handle NULL", (handle != NULL))
  return (handle->runtime->rx_busy);
 8024ed0:	687b      	ldr	r3, [r7, #4]
 8024ed2:	689b      	ldr	r3, [r3, #8]
 8024ed4:	7fdb      	ldrb	r3, [r3, #31]
 8024ed6:	b2db      	uxtb	r3, r3
}
 8024ed8:	4618      	mov	r0, r3
 8024eda:	370c      	adds	r7, #12
 8024edc:	46bd      	mov	sp, r7
 8024ede:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024ee2:	4770      	bx	lr

08024ee4 <Delay_us>:
/**
 * @brief  
 * @param  us:  XMC4300 @ 144MHz
 */
 void Delay_us(uint32_t us)
{
 8024ee4:	b480      	push	{r7}
 8024ee6:	b085      	sub	sp, #20
 8024ee8:	af00      	add	r7, sp, #0
 8024eea:	6078      	str	r0, [r7, #4]
    volatile uint32_t count = us * 50;
 8024eec:	687b      	ldr	r3, [r7, #4]
 8024eee:	2232      	movs	r2, #50	; 0x32
 8024ef0:	fb02 f303 	mul.w	r3, r2, r3
 8024ef4:	60fb      	str	r3, [r7, #12]
    while (count--);
 8024ef6:	bf00      	nop
 8024ef8:	68fb      	ldr	r3, [r7, #12]
 8024efa:	1e5a      	subs	r2, r3, #1
 8024efc:	60fa      	str	r2, [r7, #12]
 8024efe:	2b00      	cmp	r3, #0
 8024f00:	d1fa      	bne.n	8024ef8 <Delay_us+0x14>
}
 8024f02:	3714      	adds	r7, #20
 8024f04:	46bd      	mov	sp, r7
 8024f06:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024f0a:	4770      	bx	lr

08024f0c <SPI_DMA_GenericTransfer>:
 SPI_MASTER_STATUS_t SPI_DMA_GenericTransfer(const SPI_MASTER_t *const handle,
                                            const DIGITAL_IO_t *const cs_pin,
                                            uint8_t *tx_data,
                                            uint8_t *rx_data,
                                            uint32_t length)
 {
 8024f0c:	b580      	push	{r7, lr}
 8024f0e:	b086      	sub	sp, #24
 8024f10:	af00      	add	r7, sp, #0
 8024f12:	60f8      	str	r0, [r7, #12]
 8024f14:	60b9      	str	r1, [r7, #8]
 8024f16:	607a      	str	r2, [r7, #4]
 8024f18:	603b      	str	r3, [r7, #0]
     SPI_MASTER_STATUS_t status;

     // 1. 
     if (handle == NULL || cs_pin == NULL || tx_data == NULL || rx_data == NULL || length == 0) {
 8024f1a:	68fb      	ldr	r3, [r7, #12]
 8024f1c:	2b00      	cmp	r3, #0
 8024f1e:	d00b      	beq.n	8024f38 <SPI_DMA_GenericTransfer+0x2c>
 8024f20:	68bb      	ldr	r3, [r7, #8]
 8024f22:	2b00      	cmp	r3, #0
 8024f24:	d008      	beq.n	8024f38 <SPI_DMA_GenericTransfer+0x2c>
 8024f26:	687b      	ldr	r3, [r7, #4]
 8024f28:	2b00      	cmp	r3, #0
 8024f2a:	d005      	beq.n	8024f38 <SPI_DMA_GenericTransfer+0x2c>
 8024f2c:	683b      	ldr	r3, [r7, #0]
 8024f2e:	2b00      	cmp	r3, #0
 8024f30:	d002      	beq.n	8024f38 <SPI_DMA_GenericTransfer+0x2c>
 8024f32:	6a3b      	ldr	r3, [r7, #32]
 8024f34:	2b00      	cmp	r3, #0
 8024f36:	d101      	bne.n	8024f3c <SPI_DMA_GenericTransfer+0x30>
         return SPI_MASTER_STATUS_BUFFER_INVALID;
 8024f38:	2303      	movs	r3, #3
 8024f3a:	e01f      	b.n	8024f7c <SPI_DMA_GenericTransfer+0x70>
     }

     // 2.  ()
     DIGITAL_IO_SetOutputLow(cs_pin);
 8024f3c:	68b8      	ldr	r0, [r7, #8]
 8024f3e:	f7ff ffa3 	bl	8024e88 <DIGITAL_IO_SetOutputLow>

     // 3.  DMA 
     //  DMA 
     status = SPI_MASTER_Transfer(handle, tx_data, rx_data, length);
 8024f42:	68f8      	ldr	r0, [r7, #12]
 8024f44:	6879      	ldr	r1, [r7, #4]
 8024f46:	683a      	ldr	r2, [r7, #0]
 8024f48:	6a3b      	ldr	r3, [r7, #32]
 8024f4a:	f7fe fbd7 	bl	80236fc <SPI_MASTER_Transfer>
 8024f4e:	4603      	mov	r3, r0
 8024f50:	75fb      	strb	r3, [r7, #23]

     if (status == SPI_MASTER_STATUS_SUCCESS) {
 8024f52:	7dfb      	ldrb	r3, [r7, #23]
 8024f54:	2b00      	cmp	r3, #0
 8024f56:	d10d      	bne.n	8024f74 <SPI_DMA_GenericTransfer+0x68>
         // 4.  DMA 
         //  tx_busy  rx_busy
         while (SPI_MASTER_IsTxBusy(handle));
 8024f58:	bf00      	nop
 8024f5a:	68f8      	ldr	r0, [r7, #12]
 8024f5c:	f7ff ffa4 	bl	8024ea8 <SPI_MASTER_IsTxBusy>
 8024f60:	4603      	mov	r3, r0
 8024f62:	2b00      	cmp	r3, #0
 8024f64:	d1f9      	bne.n	8024f5a <SPI_DMA_GenericTransfer+0x4e>
         while (SPI_MASTER_IsRxBusy(handle));
 8024f66:	bf00      	nop
 8024f68:	68f8      	ldr	r0, [r7, #12]
 8024f6a:	f7ff ffad 	bl	8024ec8 <SPI_MASTER_IsRxBusy>
 8024f6e:	4603      	mov	r3, r0
 8024f70:	2b00      	cmp	r3, #0
 8024f72:	d1f9      	bne.n	8024f68 <SPI_DMA_GenericTransfer+0x5c>
     }

     // 5.  ()
     DIGITAL_IO_SetOutputHigh(cs_pin);
 8024f74:	68b8      	ldr	r0, [r7, #8]
 8024f76:	f7ff ff77 	bl	8024e68 <DIGITAL_IO_SetOutputHigh>

     return status;
 8024f7a:	7dfb      	ldrb	r3, [r7, #23]
 }
 8024f7c:	4618      	mov	r0, r3
 8024f7e:	3718      	adds	r7, #24
 8024f80:	46bd      	mov	sp, r7
 8024f82:	bd80      	pop	{r7, pc}

08024f84 <SPI_TMC6460_ReadRegister>:
  * @return uint32_t  32 
  */
 uint32_t SPI_TMC6460_ReadRegister(const SPI_MASTER_t *const handle,
                                   const DIGITAL_IO_t *const cs_pin,
                                   uint16_t addr)
 {
 8024f84:	b590      	push	{r4, r7, lr}
 8024f86:	b08d      	sub	sp, #52	; 0x34
 8024f88:	af02      	add	r7, sp, #8
 8024f8a:	60f8      	str	r0, [r7, #12]
 8024f8c:	60b9      	str	r1, [r7, #8]
 8024f8e:	4613      	mov	r3, r2
 8024f90:	80fb      	strh	r3, [r7, #6]
     uint8_t tx_buf[6] = {0};
 8024f92:	2300      	movs	r3, #0
 8024f94:	61bb      	str	r3, [r7, #24]
 8024f96:	2300      	movs	r3, #0
 8024f98:	83bb      	strh	r3, [r7, #28]
     uint8_t rx_buf[6] = {0};
 8024f9a:	2300      	movs	r3, #0
 8024f9c:	613b      	str	r3, [r7, #16]
 8024f9e:	2300      	movs	r3, #0
 8024fa0:	82bb      	strh	r3, [r7, #20]
     uint32_t reg_value = 0;
 8024fa2:	2300      	movs	r3, #0
 8024fa4:	627b      	str	r3, [r7, #36]	; 0x24
     SPI_MASTER_STATUS_t status;

     /* ---  --- */
     /*  main.c  0 */
     tx_buf[0] = (uint8_t)((addr >> 8) & 0x03);
 8024fa6:	88fb      	ldrh	r3, [r7, #6]
 8024fa8:	0a1b      	lsrs	r3, r3, #8
 8024faa:	b29b      	uxth	r3, r3
 8024fac:	b2db      	uxtb	r3, r3
 8024fae:	f003 0303 	and.w	r3, r3, #3
 8024fb2:	b2db      	uxtb	r3, r3
 8024fb4:	763b      	strb	r3, [r7, #24]
     tx_buf[1] = (uint8_t)(addr & 0xFF);
 8024fb6:	88fb      	ldrh	r3, [r7, #6]
 8024fb8:	b2db      	uxtb	r3, r3
 8024fba:	767b      	strb	r3, [r7, #25]

     /*  DMA  */
     status = SPI_DMA_GenericTransfer(handle, cs_pin, tx_buf, rx_buf, 6);
 8024fbc:	f107 0218 	add.w	r2, r7, #24
 8024fc0:	f107 0410 	add.w	r4, r7, #16
 8024fc4:	2306      	movs	r3, #6
 8024fc6:	9300      	str	r3, [sp, #0]
 8024fc8:	68f8      	ldr	r0, [r7, #12]
 8024fca:	68b9      	ldr	r1, [r7, #8]
 8024fcc:	4623      	mov	r3, r4
 8024fce:	f7ff ff9d 	bl	8024f0c <SPI_DMA_GenericTransfer>
 8024fd2:	4603      	mov	r3, r0
 8024fd4:	77fb      	strb	r3, [r7, #31]

     if (status != SPI_MASTER_STATUS_SUCCESS) {
 8024fd6:	7ffb      	ldrb	r3, [r7, #31]
 8024fd8:	2b00      	cmp	r3, #0
 8024fda:	d001      	beq.n	8024fe0 <SPI_TMC6460_ReadRegister+0x5c>
         return 0; //  0
 8024fdc:	2300      	movs	r3, #0
 8024fde:	e02d      	b.n	802503c <SPI_TMC6460_ReadRegister+0xb8>
     }

     /*  TMC  */
     Delay_us(5);
 8024fe0:	2005      	movs	r0, #5
 8024fe2:	f7ff ff7f 	bl	8024ee4 <Delay_us>

     /* --- (Dummy) --- */
     /*  */
     for(int i = 0; i < 6; i++) {
 8024fe6:	2300      	movs	r3, #0
 8024fe8:	623b      	str	r3, [r7, #32]
 8024fea:	e008      	b.n	8024ffe <SPI_TMC6460_ReadRegister+0x7a>
         tx_buf[i] = 0;
 8024fec:	f107 0218 	add.w	r2, r7, #24
 8024ff0:	6a3b      	ldr	r3, [r7, #32]
 8024ff2:	4413      	add	r3, r2
 8024ff4:	2200      	movs	r2, #0
 8024ff6:	701a      	strb	r2, [r3, #0]
     /*  TMC  */
     Delay_us(5);

     /* --- (Dummy) --- */
     /*  */
     for(int i = 0; i < 6; i++) {
 8024ff8:	6a3b      	ldr	r3, [r7, #32]
 8024ffa:	3301      	adds	r3, #1
 8024ffc:	623b      	str	r3, [r7, #32]
 8024ffe:	6a3b      	ldr	r3, [r7, #32]
 8025000:	2b05      	cmp	r3, #5
 8025002:	ddf3      	ble.n	8024fec <SPI_TMC6460_ReadRegister+0x68>
         tx_buf[i] = 0;
     }

     /*  DMA  rx_buf  */
     status = SPI_DMA_GenericTransfer(handle, cs_pin, tx_buf, rx_buf, 6);
 8025004:	f107 0218 	add.w	r2, r7, #24
 8025008:	f107 0410 	add.w	r4, r7, #16
 802500c:	2306      	movs	r3, #6
 802500e:	9300      	str	r3, [sp, #0]
 8025010:	68f8      	ldr	r0, [r7, #12]
 8025012:	68b9      	ldr	r1, [r7, #8]
 8025014:	4623      	mov	r3, r4
 8025016:	f7ff ff79 	bl	8024f0c <SPI_DMA_GenericTransfer>
 802501a:	4603      	mov	r3, r0
 802501c:	77fb      	strb	r3, [r7, #31]

     if (status == SPI_MASTER_STATUS_SUCCESS) {
 802501e:	7ffb      	ldrb	r3, [r7, #31]
 8025020:	2b00      	cmp	r3, #0
 8025022:	d10a      	bne.n	802503a <SPI_TMC6460_ReadRegister+0xb6>
         /* ---  32  --- */
         /*  main.c  [2]  [5]  */
         reg_value = ((uint32_t)rx_buf[2] << 24) |
 8025024:	7cbb      	ldrb	r3, [r7, #18]
 8025026:	061a      	lsls	r2, r3, #24
                     ((uint32_t)rx_buf[3] << 16) |
 8025028:	7cfb      	ldrb	r3, [r7, #19]
 802502a:	041b      	lsls	r3, r3, #16
     status = SPI_DMA_GenericTransfer(handle, cs_pin, tx_buf, rx_buf, 6);

     if (status == SPI_MASTER_STATUS_SUCCESS) {
         /* ---  32  --- */
         /*  main.c  [2]  [5]  */
         reg_value = ((uint32_t)rx_buf[2] << 24) |
 802502c:	431a      	orrs	r2, r3
                     ((uint32_t)rx_buf[3] << 16) |
                     ((uint32_t)rx_buf[4] << 8)  |
 802502e:	7d3b      	ldrb	r3, [r7, #20]
 8025030:	021b      	lsls	r3, r3, #8

     if (status == SPI_MASTER_STATUS_SUCCESS) {
         /* ---  32  --- */
         /*  main.c  [2]  [5]  */
         reg_value = ((uint32_t)rx_buf[2] << 24) |
                     ((uint32_t)rx_buf[3] << 16) |
 8025032:	4313      	orrs	r3, r2
                     ((uint32_t)rx_buf[4] << 8)  |
                     ((uint32_t)rx_buf[5]);
 8025034:	7d7a      	ldrb	r2, [r7, #21]
     status = SPI_DMA_GenericTransfer(handle, cs_pin, tx_buf, rx_buf, 6);

     if (status == SPI_MASTER_STATUS_SUCCESS) {
         /* ---  32  --- */
         /*  main.c  [2]  [5]  */
         reg_value = ((uint32_t)rx_buf[2] << 24) |
 8025036:	4313      	orrs	r3, r2
 8025038:	627b      	str	r3, [r7, #36]	; 0x24
                     ((uint32_t)rx_buf[3] << 16) |
                     ((uint32_t)rx_buf[4] << 8)  |
                     ((uint32_t)rx_buf[5]);
     }

     return reg_value;
 802503a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 }
 802503c:	4618      	mov	r0, r3
 802503e:	372c      	adds	r7, #44	; 0x2c
 8025040:	46bd      	mov	sp, r7
 8025042:	bd90      	pop	{r4, r7, pc}

08025044 <main>:
int main(void)
{
 8025044:	b580      	push	{r7, lr}
 8025046:	b082      	sub	sp, #8
 8025048:	af00      	add	r7, sp, #0
  DAVE_STATUS_t status;
  uint32_t chip_id;

  status = DAVE_Init();           /* Initialization of DAVE APPs  */
 802504a:	f7ff fea7 	bl	8024d9c <DAVE_Init>
 802504e:	4603      	mov	r3, r0
 8025050:	71fb      	strb	r3, [r7, #7]

  if (status != DAVE_STATUS_SUCCESS)
 8025052:	79fb      	ldrb	r3, [r7, #7]
 8025054:	2b00      	cmp	r3, #0
 8025056:	d000      	beq.n	802505a <main+0x16>
    XMC_DEBUG("DAVE APPs initialization failed\n");

    while(1U)
    {

    }
 8025058:	e7fe      	b.n	8025058 <main+0x14>
  }
  else
  {
	  DIGITAL_IO_SetOutputLow(&LED);
 802505a:	4817      	ldr	r0, [pc, #92]	; (80250b8 <main+0x74>)
 802505c:	f7ff ff14 	bl	8024e88 <DIGITAL_IO_SetOutputLow>
	  Delay_us(200000);
 8025060:	4816      	ldr	r0, [pc, #88]	; (80250bc <main+0x78>)
 8025062:	f7ff ff3f 	bl	8024ee4 <Delay_us>
	  DIGITAL_IO_SetOutputHigh(&LED);
 8025066:	4814      	ldr	r0, [pc, #80]	; (80250b8 <main+0x74>)
 8025068:	f7ff fefe 	bl	8024e68 <DIGITAL_IO_SetOutputHigh>
	  Delay_us(200000);
 802506c:	4813      	ldr	r0, [pc, #76]	; (80250bc <main+0x78>)
 802506e:	f7ff ff39 	bl	8024ee4 <Delay_us>
  }

  DIGITAL_IO_SetOutputHigh(&SLEEPN5);
 8025072:	4813      	ldr	r0, [pc, #76]	; (80250c0 <main+0x7c>)
 8025074:	f7ff fef8 	bl	8024e68 <DIGITAL_IO_SetOutputHigh>
  Delay_us(4000);
 8025078:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
 802507c:	f7ff ff32 	bl	8024ee4 <Delay_us>

  chip_id = SPI_TMC6460_ReadRegister(&SPI_MASTER_0, &CS_5, 0x00);
 8025080:	4810      	ldr	r0, [pc, #64]	; (80250c4 <main+0x80>)
 8025082:	4911      	ldr	r1, [pc, #68]	; (80250c8 <main+0x84>)
 8025084:	2200      	movs	r2, #0
 8025086:	f7ff ff7d 	bl	8024f84 <SPI_TMC6460_ReadRegister>
 802508a:	6038      	str	r0, [r7, #0]

    //master_rec_data = TMC6460_SPI_Read(TMC6460_CHIP_ID);

        if (chip_id != TMC6460_CHIP_ID_VALUE)
 802508c:	683b      	ldr	r3, [r7, #0]
 802508e:	4a0f      	ldr	r2, [pc, #60]	; (80250cc <main+0x88>)
 8025090:	4293      	cmp	r3, r2
 8025092:	d00c      	beq.n	80250ae <main+0x6a>
        {
            /* SPI LED  */
            while (1) {
                DIGITAL_IO_SetOutputLow(&LED);
 8025094:	4808      	ldr	r0, [pc, #32]	; (80250b8 <main+0x74>)
 8025096:	f7ff fef7 	bl	8024e88 <DIGITAL_IO_SetOutputLow>
                Delay_us(200000);
 802509a:	4808      	ldr	r0, [pc, #32]	; (80250bc <main+0x78>)
 802509c:	f7ff ff22 	bl	8024ee4 <Delay_us>
                DIGITAL_IO_SetOutputHigh(&LED);
 80250a0:	4805      	ldr	r0, [pc, #20]	; (80250b8 <main+0x74>)
 80250a2:	f7ff fee1 	bl	8024e68 <DIGITAL_IO_SetOutputHigh>
                Delay_us(200000);
 80250a6:	4805      	ldr	r0, [pc, #20]	; (80250bc <main+0x78>)
 80250a8:	f7ff ff1c 	bl	8024ee4 <Delay_us>
            }
 80250ac:	e7f2      	b.n	8025094 <main+0x50>
        }
        /* SPI LED  */
        DIGITAL_IO_SetOutputLow(&LED);
 80250ae:	4802      	ldr	r0, [pc, #8]	; (80250b8 <main+0x74>)
 80250b0:	f7ff feea 	bl	8024e88 <DIGITAL_IO_SetOutputLow>
  /* Placeholder for user application code. The while loop below can be replaced with user application code. */
  while(1U)
  {


  }
 80250b4:	e7fe      	b.n	80250b4 <main+0x70>
 80250b6:	bf00      	nop
 80250b8:	08025c20 	.word	0x08025c20
 80250bc:	00030d40 	.word	0x00030d40
 80250c0:	08025c34 	.word	0x08025c34
 80250c4:	1fff1790 	.word	0x1fff1790
 80250c8:	08025c48 	.word	0x08025c48
 80250cc:	36343630 	.word	0x36343630

080250d0 <__libc_init_array>:
 80250d0:	b570      	push	{r4, r5, r6, lr}
 80250d2:	4b0e      	ldr	r3, [pc, #56]	; (802510c <__libc_init_array+0x3c>)
 80250d4:	4c0e      	ldr	r4, [pc, #56]	; (8025110 <__libc_init_array+0x40>)
 80250d6:	1ae4      	subs	r4, r4, r3
 80250d8:	10a4      	asrs	r4, r4, #2
 80250da:	2500      	movs	r5, #0
 80250dc:	461e      	mov	r6, r3
 80250de:	42a5      	cmp	r5, r4
 80250e0:	d004      	beq.n	80250ec <__libc_init_array+0x1c>
 80250e2:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80250e6:	4798      	blx	r3
 80250e8:	3501      	adds	r5, #1
 80250ea:	e7f8      	b.n	80250de <__libc_init_array+0xe>
 80250ec:	f7fe f88c 	bl	8023208 <_init>
 80250f0:	4c08      	ldr	r4, [pc, #32]	; (8025114 <__libc_init_array+0x44>)
 80250f2:	4b09      	ldr	r3, [pc, #36]	; (8025118 <__libc_init_array+0x48>)
 80250f4:	1ae4      	subs	r4, r4, r3
 80250f6:	10a4      	asrs	r4, r4, #2
 80250f8:	2500      	movs	r5, #0
 80250fa:	461e      	mov	r6, r3
 80250fc:	42a5      	cmp	r5, r4
 80250fe:	d004      	beq.n	802510a <__libc_init_array+0x3a>
 8025100:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8025104:	4798      	blx	r3
 8025106:	3501      	adds	r5, #1
 8025108:	e7f8      	b.n	80250fc <__libc_init_array+0x2c>
 802510a:	bd70      	pop	{r4, r5, r6, pc}
 802510c:	1fff17e0 	.word	0x1fff17e0
 8025110:	1fff17e0 	.word	0x1fff17e0
 8025114:	1fff17e0 	.word	0x1fff17e0
 8025118:	1fff17e0 	.word	0x1fff17e0

0802511c <memcmp>:
 802511c:	b510      	push	{r4, lr}
 802511e:	440a      	add	r2, r1
 8025120:	1e44      	subs	r4, r0, #1
 8025122:	4291      	cmp	r1, r2
 8025124:	d008      	beq.n	8025138 <memcmp+0x1c>
 8025126:	f814 3f01 	ldrb.w	r3, [r4, #1]!
 802512a:	7808      	ldrb	r0, [r1, #0]
 802512c:	4283      	cmp	r3, r0
 802512e:	d001      	beq.n	8025134 <memcmp+0x18>
 8025130:	1a18      	subs	r0, r3, r0
 8025132:	bd10      	pop	{r4, pc}
 8025134:	3101      	adds	r1, #1
 8025136:	e7f4      	b.n	8025122 <memcmp+0x6>
 8025138:	2000      	movs	r0, #0
 802513a:	bd10      	pop	{r4, pc}

0802513c <memcpy>:
 802513c:	b510      	push	{r4, lr}
 802513e:	1e43      	subs	r3, r0, #1
 8025140:	440a      	add	r2, r1
 8025142:	4291      	cmp	r1, r2
 8025144:	d004      	beq.n	8025150 <memcpy+0x14>
 8025146:	f811 4b01 	ldrb.w	r4, [r1], #1
 802514a:	f803 4f01 	strb.w	r4, [r3, #1]!
 802514e:	e7f8      	b.n	8025142 <memcpy+0x6>
 8025150:	bd10      	pop	{r4, pc}
	...

08025154 <asEntryDesc0x1600>:
 8025154:	0005 0008 0007 0007 0020 0007 0007 0020     ........ ..... .
 8025164:	0007 0007 0020 0007 0007 0020 0007 0007     .... ..... .....
 8025174:	0020 0007 0007 0020 0007 0007 0020 0007      ..... ..... ...
 8025184:	0007 0020 0007 0007 0020 0007 0007 0020     .. ..... ..... .
 8025194:	0007 0007 0020 0007 0007 0020 0007 0000     .... ..... .....

080251a4 <aName0x1600>:
 80251a4:	7852 6470 206f 7270 636f 7365 2073 6164     Rxpdo process da
 80251b4:	6174 6d20 7061 6970 676e 5300 6275 6e49     ta mapping.SubIn
 80251c4:	6564 2078 3030 0031 7553 4962 646e 7865     dex 001.SubIndex
 80251d4:	3020 3230 5300 6275 6e49 6564 2078 3030      002.SubIndex 00
 80251e4:	0033 7553 4962 646e 7865 3020 3430 5300     3.SubIndex 004.S
 80251f4:	6275 6e49 6564 2078 3030 0035 7553 4962     ubIndex 005.SubI
 8025204:	646e 7865 3020 3630 5300 6275 6e49 6564     ndex 006.SubInde
 8025214:	2078 3030 0037 7553 4962 646e 7865 3020     x 007.SubIndex 0
 8025224:	3830 5300 6275 6e49 6564 2078 3030 0039     08.SubIndex 009.
 8025234:	7553 4962 646e 7865 3020 3031 5300 6275     SubIndex 010.Sub
 8025244:	6e49 6564 2078 3130 0031 7553 4962 646e     Index 011.SubInd
 8025254:	7865 3020 3231 ff00 0000 0000               ex 012......

08025260 <asEntryDesc0x1A00>:
 8025260:	0005 0008 0007 0007 0020 0007 0007 0020     ........ ..... .
 8025270:	0007 0007 0020 0007 0007 0020 0007 0007     .... ..... .....
 8025280:	0020 0007 0007 0020 0007 0007 0020 0007      ..... ..... ...
 8025290:	0007 0020 0007 0007 0020 0007 0007 0020     .. ..... ..... .
 80252a0:	0007 0007 0020 0007 0007 0020 0007 0000     .... ..... .....

080252b0 <aName0x1A00>:
 80252b0:	7854 6470 206f 7270 636f 7365 2073 6164     Txpdo process da
 80252c0:	6174 6d20 7061 6970 676e 5300 6275 6e49     ta mapping.SubIn
 80252d0:	6564 2078 3030 0031 7553 4962 646e 7865     dex 001.SubIndex
 80252e0:	3020 3230 5300 6275 6e49 6564 2078 3030      002.SubIndex 00
 80252f0:	0033 7553 4962 646e 7865 3020 3430 5300     3.SubIndex 004.S
 8025300:	6275 6e49 6564 2078 3030 0035 7553 4962     ubIndex 005.SubI
 8025310:	646e 7865 3020 3630 5300 6275 6e49 6564     ndex 006.SubInde
 8025320:	2078 3030 0037 7553 4962 646e 7865 3020     x 007.SubIndex 0
 8025330:	3830 5300 6275 6e49 6564 2078 3030 0039     08.SubIndex 009.
 8025340:	7553 4962 646e 7865 3020 3031 5300 6275     SubIndex 010.Sub
 8025350:	6e49 6564 2078 3130 0031 7553 4962 646e     Index 011.SubInd
 8025360:	7865 3020 3231 ff00 0000 0000               ex 012......

0802536c <asEntryDesc0x1C12>:
 802536c:	0005 0008 0007 0006 0010 0007               ............

08025378 <aName0x1C12>:
 8025378:	7953 636e 614d 616e 6567 2072 2032 7361     SyncManager 2 as
 8025388:	6973 6e67 656d 746e ff00 0000               signment....

08025394 <asEntryDesc0x1C13>:
 8025394:	0005 0008 0007 0006 0010 0007               ............

080253a0 <aName0x1C13>:
 80253a0:	7953 636e 614d 616e 6567 2072 2033 7361     SyncManager 3 as
 80253b0:	6973 6e67 656d 746e ff00 0000               signment....

080253bc <asEntryDesc0x6000>:
 80253bc:	0005 0008 0007 0006 0010 0087 0009 00c0     ................
 80253cc:	0087 0006 0010 0087 0009 00c0 0087 0006     ................
 80253dc:	0010 0087 0009 00c0 0087 0006 0010 0087     ................
 80253ec:	0009 00c0 0087 0006 0010 0087 0009 00c0     ................
 80253fc:	0087 0006 0010 0087 0009 00c0 0087 0000     ................

0802540c <aName0x6000>:
 802540c:	7854 6470 006f 7852 656c 5f6e 0031 7852     Txpdo.Rxlen_1.Rx
 802541c:	6144 6174 315f 5200 6c78 6e65 325f 5200     Data_1.Rxlen_2.R
 802542c:	4478 7461 5f61 0032 7852 656c 5f6e 0033     xData_2.Rxlen_3.
 802543c:	7852 6144 6174 335f 5200 6c78 6e65 345f     RxData_3.Rxlen_4
 802544c:	5200 4478 7461 5f61 0034 7852 656c 5f6e     .RxData_4.Rxlen_
 802545c:	0035 7852 6144 6174 355f 5200 6c78 6e65     5.RxData_5.Rxlen
 802546c:	365f 5200 4478 7461 5f61 0036 00ff 0000     _6.RxData_6.....

0802547c <asEntryDesc0x7000>:
 802547c:	0005 0008 0007 0006 0010 007f 0009 00c0     ................
 802548c:	007f 0006 0010 007f 0009 00c0 007f 0006     ................
 802549c:	0010 007f 0009 00c0 007f 0006 0010 007f     ................
 80254ac:	0009 00c0 007f 0006 0010 007f 0009 00c0     ................
 80254bc:	007f 0006 0010 007f 0009 00c0 007f 0000     ................

080254cc <aName0x7000>:
 80254cc:	7852 6470 006f 7854 656c 5f6e 0031 7854     Rxpdo.Txlen_1.Tx
 80254dc:	6144 6174 315f 5400 6c78 6e65 325f 5400     Data_1.Txlen_2.T
 80254ec:	4478 7461 5f61 0032 7854 656c 5f6e 0033     xData_2.Txlen_3.
 80254fc:	7854 6144 6174 335f 5400 6c78 6e65 345f     TxData_3.Txlen_4
 802550c:	5400 4478 7461 5f61 0034 7854 656c 5f6e     .TxData_4.Txlen_
 802551c:	0035 7854 6144 6174 355f 5400 6c78 6e65     5.TxData_5.Txlen
 802552c:	365f 5400 4478 7461 5f61 0036 00ff 0000     _6.TxData_6.....

0802553c <asEntryDesc0x8000>:
 802553c:	0005 0008 003f 0009 0100 0007 0009 0100     ....?...........
 802554c:	0007 0009 0100 0007 0009 0100 003f 0007     ............?...
 802555c:	0020 0007 0007 0020 003f 0007 0020 003f      ..... .?... .?.
 802556c:	0007 0020 003f 0005 0008 003f 0005 0008     .. .?.....?.....
 802557c:	003f 0005 0008 003f 0005 0008 003f 0009     ?.....?.....?...
 802558c:	0030 003f                                   0.?.

08025590 <aName0x8000>:
 8025590:	6544 4976 666e 006f 614e 656d 4800 0076     DevInfo.Name.Hv.
 80255a0:	7653 5300 006e 7542 6c69 5464 6d69 0065     Sv.Sn.BuildTime.
 80255b0:	5242 635f 6e61 6466 635f 7274 006c 5242     BR_canfd_ctrl.BR
 80255c0:	635f 6e61 6466 645f 7461 0061 5242 345f     _canfd_data.BR_4
 80255d0:	3538 5500 6573 3231 0030 7355 3465 3538     85.Use120.Use485
 80255e0:	5500 6573 6f4d 6264 7375 5300 6275 6e49     .UseModbus.SubIn
 80255f0:	6564 2078 3130 0032 6544 4976 0044 00ff     dex 012.DevID...

08025600 <asEntryDesc0x9000>:
 8025600:	0005 0008 0007 0006 0010 003f 0006 0010     ..........?.....
 8025610:	003f 0006 0010 003f 0009 0200 003f 0006     ?.....?.....?...
 8025620:	0010 003f 0006 0010 003f 0006 0010 003f     ..?.....?.....?.
 8025630:	0009 0200 003f 0000                         ....?...

08025638 <aName0x9000>:
 8025638:	6953 756d 616c 6574 4143 464e 0044 7854     SimulateCANFD.Tx
 8025648:	6e49 6564 0078 7854 4449 5400 4c78 6e65     Index.TxID.TxLen
 8025658:	5400 4478 7461 0061 7852 6e49 6564 0078     .TxData.RxIndex.
 8025668:	7852 4449 5200 4c78 6e65 5200 4478 7461     RxID.RxLen.RxDat
 8025678:	0061 00ff                                   a...

0802567c <sEntryDesc0x9001>:
 802567c:	0006 0010 003f 0000                         ....?...

08025684 <aName0x9001>:
 8025684:	6150 6172 206d 6341 6974 6e6f ff00 0000     Param Action....

08025694 <asEntryDesc0xF000>:
 8025694:	0005 0008 0007 0006 0010 0007 0006 0010     ................
 80256a4:	0007 0000                                   ....

080256a8 <aName0xF000>:
 80256a8:	6f4d 7564 616c 2072 6544 6976 6563 5020     Modular Device P
 80256b8:	6f72 6966 656c 4900 646e 7865 6420 7369     rofile.Index dis
 80256c8:	6174 636e 2065 4d00 7861 6d69 6d75 6e20     tance .Maximum n
 80256d8:	6d75 6562 2072 666f 6d20 646f 6c75 7365     umber of modules
 80256e8:	0020 00ff                                    ...

080256ec <sEntryDesc0x1000>:
 80256ec:	0007 0020 0007 0000                         .. .....

080256f4 <aName0x1000>:
 80256f4:	6544 6976 6563 7420 7079 0065               Device type.

08025700 <sEntryDesc0x1001>:
 8025700:	0005 0008 0007 0000                         ........

08025708 <aName0x1001>:
 8025708:	7245 6f72 2072 6572 6967 7473 7265 0000     Error register..

08025718 <sEntryDesc0x1008>:
 8025718:	0009 0030 0007 0000                         ..0.....

08025720 <aName0x1008>:
 8025720:	6544 6976 6563 6e20 6d61 0065               Device name.

0802572c <sEntryDesc0x1009>:
 802572c:	0009 0018 0007 0000                         ........

08025734 <aName0x1009>:
 8025734:	614d 756e 6166 7463 7275 7265 4820 7261     Manufacturer Har
 8025744:	7764 7261 2065 6576 7372 6f69 006e 0000     dware version...

08025754 <sEntryDesc0x100A>:
 8025754:	0009 0020 0007 0000                         .. .....

0802575c <aName0x100A>:
 802575c:	614d 756e 6166 7463 7275 7265 5320 666f     Manufacturer Sof
 802576c:	7774 7261 2065 6576 7372 6f69 006e 0000     tware version...

0802577c <asEntryDesc0x1018>:
 802577c:	0005 0008 0007 0007 0020 0007 0007 0020     ........ ..... .
 802578c:	0007 0007 0020 0007 0007 0020 0007 0000     .... ..... .....

0802579c <aName0x1018>:
 802579c:	6449 6e65 6974 7974 4f20 6a62 6365 0074     Identity Object.
 80257ac:	6556 646e 726f 4920 0044 7250 646f 6375     Vendor ID.Produc
 80257bc:	2074 6f43 6564 5200 7665 7369 6f69 206e     t Code.Revision 
 80257cc:	754e 626d 7265 5300 7265 6169 206c 754e     Number.Serial Nu
 80257dc:	626d 7265 ff00 0000                         mber....

080257e4 <asEntryDesc0x10F1>:
 80257e4:	0005 0008 0007 0007 0020 0007 0006 0010     ........ .......
 80257f4:	003f 0000                                   ?...

080257f8 <aName0x10F1>:
 80257f8:	7245 6f72 2072 6553 7474 6e69 7367 4c00     Error Settings.L
 8025808:	636f 6c61 4520 7272 726f 5220 6165 7463     ocal Error React
 8025818:	6f69 006e 7953 636e 4520 7272 726f 4320     ion.Sync Error C
 8025828:	756f 746e 7265 4c20 6d69 7469 ff00 0000     ounter Limit....

08025838 <sEntryDesc0x10F8>:
 8025838:	001b 0040 00bf 0000                         ..@.....

08025840 <aName0x10F8>:
 8025840:	6954 656d 7473 6d61 2070 624f 656a 7463     Timestamp Object
 8025850:	ff00 0000                                   ....

08025854 <asEntryDesc0x1C00>:
 8025854:	0005 0008 0007 0005 0008 0007               ............

08025860 <aName0x1C00>:
 8025860:	7953 636e 6d20 6e61 6761 7265 7420 7079     Sync manager typ
 8025870:	0065 0000                                   e...

08025874 <asEntryDesc0x1C3x>:
 8025874:	0005 0008 0007 0006 0010 000f 0007 0020     .............. .
 8025884:	0007 0000 0020 0000 0006 0010 0007 0007     .... ...........
 8025894:	0020 0007 0007 0020 0007 0000 0020 0000      ..... ..... ...
 80258a4:	0006 0010 003f 0007 0020 0007 0007 0020     ....?... ..... .
 80258b4:	003f 0006 0010 0007 0006 0010 0007 0006     ?...............
 80258c4:	0010 0007 0000 0010 0000 0000 0020 0000     ............ ...
 80258d4:	0000 0020 0000 0000 0020 0000 0000 0020     .. ..... ..... .
	...
 8025934:	0001 0001 0007 0000                         ........

0802593c <aName0x1C32>:
 802593c:	4d53 6f20 7475 7570 2074 6170 6172 656d     SM output parame
 802594c:	6574 0072 7953 636e 7268 6e6f 7a69 7461     ter.Synchronizat
 802595c:	6f69 206e 7954 6570 4300 6379 656c 5420     ion Type.Cycle T
 802596c:	6d69 0065 5300 6e79 6863 6f72 696e 617a     ime..Synchroniza
 802597c:	6974 6e6f 5420 7079 7365 7320 7075 6f70     tion Types suppo
 802598c:	7472 6465 4d00 6e69 6d69 6d75 4320 6379     rted.Minimum Cyc
 802599c:	656c 5420 6d69 0065 6143 636c 6120 646e     le Time.Calc and
 80259ac:	4320 706f 2079 6954 656d 0000 6547 2074      Copy Time..Get 
 80259bc:	7943 6c63 2065 6954 656d 4400 6c65 7961     Cycle Time.Delay
 80259cc:	5420 6d69 0065 7953 636e 2030 7943 6c63      Time.Sync0 Cycl
 80259dc:	2065 6954 656d 5300 2d4d 7645 6e65 2074     e Time.SM-Event 
 80259ec:	694d 7373 6465 4300 6379 656c 5420 6d69     Missed.Cycle Tim
 80259fc:	2065 6f54 206f 6d53 6c61 006c 6853 6669     e Too Small.Shif
 8025a0c:	2074 6954 656d 5420 6f6f 5320 6f68 7472     t Time Too Short
 8025a1c:	4320 756f 746e 7265 0000 0000 0000 0000      Counter........
	...
 8025a34:	0000 5300 6e79 2063 7245 6f72 0072 00ff     ...Sync Error...

08025a44 <aName0x1C33>:
 8025a44:	4d53 6920 706e 7475 7020 7261 6d61 7465     SM input paramet
 8025a54:	7265 5300 6e79 6863 6f72 696e 617a 6974     er.Synchronizati
 8025a64:	6e6f 5420 7079 0065 7943 6c63 2065 6954     on Type.Cycle Ti
 8025a74:	656d 0000 7953 636e 7268 6e6f 7a69 7461     me..Synchronizat
 8025a84:	6f69 206e 7954 6570 2073 7573 7070 726f     ion Types suppor
 8025a94:	6574 0064 694d 696e 756d 206d 7943 6c63     ted.Minimum Cycl
 8025aa4:	2065 6954 656d 4300 6c61 2063 6e61 2064     e Time.Calc and 
 8025ab4:	6f43 7970 5420 6d69 0065 4700 7465 4320     Copy Time..Get C
 8025ac4:	6379 656c 5420 6d69 0065 6544 616c 2079     ycle Time.Delay 
 8025ad4:	6954 656d 5300 6e79 3063 4320 6379 656c     Time.Sync0 Cycle
 8025ae4:	5420 6d69 0065 4d53 452d 6576 746e 4d20      Time.SM-Event M
 8025af4:	7369 6573 0064 7943 6c63 2065 6954 656d     issed.Cycle Time
 8025b04:	5420 6f6f 5320 616d 6c6c 5300 6968 7466      Too Small.Shift
 8025b14:	5420 6d69 2065 6f54 206f 6853 726f 2074      Time Too Short 
 8025b24:	6f43 6e75 6574 0072 0000 0000 0000 0000     Counter.........
	...
 8025b3c:	0000 7953 636e 4520 7272 726f ff00 0000     ..Sync Error....

08025b4c <SPI_MASTER_0_MOSI>:
 8025b4c:	8000 4802 0005 0000                         ...H....

08025b54 <SPI_MASTER_0_MISO>:
 8025b54:	8000 4802 0004 0000                         ...H....

08025b5c <SPI_MASTER_0_SCLKOUT>:
 8025b5c:	8000 4802 000b 0000                         ...H....

08025b64 <SPI_MASTER_0_SCLKOUT_Config>:
 8025b64:	0090 0000 0001 0000 0001 0000 0000 0000     ................
 8025b74:	0000 0000                                   ....

08025b78 <SPI_MASTER_0_Config>:
 8025b78:	1718 1fff 3abd 0802 5b4c 0802 16f0 1fff     .....:..L[......
 8025b88:	5b54 0802 1704 1fff 0000 0000 0000 0000     T[..............
	...
 8025ba0:	5b5c 0802 5b64 0802 0000 0000 0000 0000     \[..d[..........
	...
 8025bfc:	0101 0000 0002 0001                         ........

08025c04 <INTERRUPT_0>:
 8025c04:	3f31 0100                                   1?..

08025c08 <e_eeprom_xmc4_fce>:
 8025c08:	0020 5002 0700 0000 0000 0000                ..P........

08025c14 <ECAT_SSC_0>:
 8025c14:	2814 1fff 16c8 1fff 5c04 0802               .(.......\..

08025c20 <LED>:
 8025c20:	8000 4802 0080 0000 0001 0000 0007 0000     ...H............
 8025c30:	0002 0000                                   ....

08025c34 <SLEEPN5>:
 8025c34:	8100 4802 0080 0000 0001 0000 0000 0000     ...H............
 8025c44:	000b 0000                                   ....

08025c48 <CS_5>:
 8025c48:	8400 4802 0080 0000 0001 0000 0000 0000     ...H............
 8025c58:	0000 0000 0218 0101 0000 0001 0000 0000     ................
 8025c68:	0000 0001 0102 0101                         ........
